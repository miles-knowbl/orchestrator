{
  "id": "blocker-analyzer",
  "name": "blocker-analyzer",
  "version": "1.0.0",
  "description": "Analyzes blockers preventing module progress. Identifies blocked modules, their dependencies, and potential unblocking strategies.",
  "phase": "SCORE",
  "category": "async",
  "content": "# Blocker Analyzer\n\nAnalyzes what's blocking modules and identifies potential unblocking strategies.\n\n## When to Use\n\n- During async-loop SCORE phase\n- To understand why certain modules aren't available\n- To identify unblocking opportunities\n\n## What It Analyzes\n\n### Blocker Types\n\n| Type | Description | Example |\n|------|-------------|---------|\n| Dependency | Waiting on another module | \"Needs auth-service complete\" |\n| External | Waiting on external factor | \"Needs API key from vendor\" |\n| Technical | Technical obstacle | \"Requires library upgrade\" |\n| Resource | Needs unavailable resource | \"Needs design review\" |\n| Decision | Waiting on decision | \"Architecture choice pending\" |\n\n### Analysis Outputs\n\n- Which modules are blocked\n- What's blocking them\n- Potential workarounds\n- Unblocking priorities\n\n## Workflow\n\n### Step 1: Identify Blocked Modules\n\n```typescript\nconst blocked = roadmap.modules.filter(m =>\n  m.status !== 'complete' &&\n  m.status !== 'deferred' &&\n  (m.blockedBy?.length > 0 || m.status === 'blocked')\n);\n```\n\n### Step 2: Classify Blockers\n\nFor each blocked module:\n\n```typescript\nconst blockers = module.blockedBy.map(dep => ({\n  dependency: dep,\n  type: classifyBlockerType(dep, roadmap),\n  severity: calculateSeverity(dep),\n  unblockPath: findUnblockPath(dep, roadmap)\n}));\n```\n\n### Step 3: Find Unblock Paths\n\n```typescript\nfunction findUnblockPath(blocker, roadmap) {\n  // Is blocker itself unblocked?\n  const blockerModule = roadmap.find(m => m.name === blocker);\n  if (blockerModule?.blockedBy?.length === 0) {\n    return {\n      strategy: 'complete_dependency',\n      target: blocker,\n      effort: 'direct'\n    };\n  }\n\n  // Can we work around?\n  if (hasWorkaround(blocker)) {\n    return {\n      strategy: 'workaround',\n      description: getWorkaround(blocker),\n      effort: 'moderate'\n    };\n  }\n\n  // Need to unblock chain\n  return {\n    strategy: 'chain_unblock',\n    chain: getBlockerChain(blocker, roadmap),\n    effort: 'significant'\n  };\n}\n```\n\n### Step 4: Prioritize Unblocking\n\n```typescript\nconst unblockPriorities = blocked\n  .flatMap(m => m.blockers)\n  .reduce((acc, blocker) => {\n    // Count how many modules each blocker blocks\n    acc[blocker.dependency] = (acc[blocker.dependency] || 0) + 1;\n    return acc;\n  }, {});\n\nconst prioritized = Object.entries(unblockPriorities)\n  .sort(([, a], [, b]) => b - a)\n  .map(([blocker, count]) => ({ blocker, blocksCount: count }));\n```\n\n## Output\n\nUpdates `memory/module-scores.json` with blocker analysis:\n\n```json\n{\n  \"blocker_analysis\": {\n    \"analyzed_at\": \"ISO-timestamp\",\n    \"blocked_modules\": 3,\n    \"blockers\": [\n      {\n        \"module\": \"api-endpoints\",\n        \"blocked_by\": [\"auth-service\"],\n        \"blocker_type\": \"dependency\",\n        \"unblock_path\": {\n          \"strategy\": \"complete_dependency\",\n          \"target\": \"auth-service\",\n          \"effort\": \"direct\"\n        }\n      }\n    ],\n    \"unblock_priorities\": [\n      {\n        \"blocker\": \"auth-service\",\n        \"blocks_count\": 3,\n        \"recommendation\": \"Complete auth-service to unblock 3 modules\"\n      }\n    ],\n    \"cascading_unlocks\": [\n      {\n        \"if_complete\": \"auth-service\",\n        \"unlocks\": [\"api-endpoints\", \"user-dashboard\", \"admin-panel\"]\n      }\n    ]\n  }\n}\n```\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Updated module scores | `memory/module-scores.json` | Always |\n\n## Cascading Unlock Analysis\n\nIdentifies high-leverage unblocking opportunities:\n\n```typescript\nfunction findCascadingUnlocks(roadmap) {\n  return roadmap.modules\n    .filter(m => m.blockedBy?.length === 0 && m.status !== 'complete')\n    .map(m => ({\n      module: m.name,\n      directlyUnlocks: countDirectDependents(m, roadmap),\n      transitivelyUnlocks: countTransitiveDependents(m, roadmap)\n    }))\n    .filter(m => m.directlyUnlocks > 0)\n    .sort((a, b) => b.transitivelyUnlocks - a.transitivelyUnlocks);\n}\n```\n\n## References\n\n- [blocker-types.md](references/blocker-types.md) â€” Blocker classification guide",
  "references": [
    {
      "name": "blocker-types.md",
      "path": "references/blocker-types.md",
      "content": "# Blocker Types\n\nClassification guide for blockers.\n\n## Type Definitions\n\n### Dependency Blocker\n\n**Description:** Module waiting on another module to complete.\n\n**Identification:**\n- Listed in `blockedBy` array\n- Blocker is another module in roadmap\n- Blocker has known status\n\n**Resolution:** Complete the dependency.\n\n**Example:**\n```\nModule: api-endpoints\nBlocked by: auth-service (dependency)\nResolution: Complete auth-service first\n```\n\n### External Blocker\n\n**Description:** Waiting on something outside the system.\n\n**Identification:**\n- Blocker not in roadmap\n- Requires external action\n- Outside development control\n\n**Resolution:** External action or workaround.\n\n**Examples:**\n- Waiting for API credentials\n- Waiting for vendor response\n- Waiting for infrastructure provisioning\n\n### Technical Blocker\n\n**Description:** Technical obstacle preventing progress.\n\n**Identification:**\n- Bug or incompatibility\n- Requires investigation\n- Known technical debt\n\n**Resolution:** Technical solution or workaround.\n\n**Examples:**\n- Library version conflict\n- Performance issue\n- Breaking API change\n\n### Resource Blocker\n\n**Description:** Needs resource not currently available.\n\n**Identification:**\n- Human review needed\n- Specific expertise required\n- Access permission needed\n\n**Resolution:** Obtain resource or find alternative.\n\n**Examples:**\n- Needs design review\n- Needs security audit\n- Needs database admin access\n\n### Decision Blocker\n\n**Description:** Waiting on decision before proceeding.\n\n**Identification:**\n- Multiple valid approaches\n- Needs stakeholder input\n- Architecture choice pending\n\n**Resolution:** Make decision or escalate.\n\n**Examples:**\n- Which framework to use?\n- Build vs buy decision\n- API design approval\n\n## Severity Levels\n\n| Severity | Description | Criteria |\n|----------|-------------|----------|\n| Critical | Blocks multiple important modules | >3 dependents, high DSA |\n| High | Blocks single important module | 1-3 dependents, high DSA |\n| Medium | Blocks lower-priority work | Any dependents, medium DSA |\n| Low | Self-contained blockage | No dependents |\n\n## Unblock Strategies\n\n### Direct Completion\n\nWhen blocker is unblocked itself:\n1. Add blocker to queue\n2. Complete blocker\n3. Blocked modules auto-unblock\n\n### Workaround\n\nWhen blocker can be bypassed:\n1. Identify minimal interface needed\n2. Create stub/mock\n3. Proceed with dependent work\n4. Replace stub when blocker completes\n\n### Chain Unblock\n\nWhen blocker has its own blockers:\n1. Trace full dependency chain\n2. Find first unblocked item\n3. Plan sequential completion\n4. Consider parallel work where possible\n\n### Defer\n\nWhen unblocking is too costly:\n1. Mark dependent as deferred\n2. Document reason\n3. Set revisit criteria\n4. Move to other work\n"
    }
  ],
  "tags": [
    "async",
    "blockers",
    "dependencies",
    "analysis"
  ],
  "dependsOn": [
    "dream-sync"
  ]
}