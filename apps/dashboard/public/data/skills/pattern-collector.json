{
  "id": "pattern-collector",
  "name": "pattern-collector",
  "version": "1.0.0",
  "description": "Collects and organizes patterns from memory for async context. Gathers relevant patterns that inform autonomous decision-making.",
  "phase": "GATHER",
  "category": "async",
  "content": "# Pattern Collector\n\nGathers patterns from memory service to inform async operation decisions.\n\n## When to Use\n\n- During async-loop GATHER phase\n- To provide decision-making context for autonomous operation\n- To surface relevant learnings for the work ahead\n\n## What It Collects\n\n### Pattern Types\n\n| Type | Source | Relevance |\n|------|--------|-----------|\n| Behavioral | Run archives | How loops typically execute |\n| Codebase | Skill documentation | Implementation patterns |\n| Strategic | Memory ADRs | Decision-making patterns |\n| Anti-patterns | Retrospectives | What to avoid |\n\n### Filtering Criteria\n\nPatterns are filtered by relevance to:\n- Available modules (from roadmap)\n- Loop types likely to be executed\n- Recent execution history\n\n## Workflow\n\n### Step 1: Query Patterns\n\n```typescript\nconst patterns = await patternsService.queryPatterns({\n  level: 'all',\n  recent: true,\n  limit: 50\n});\n```\n\n### Step 2: Score Relevance\n\nFor each pattern, calculate relevance score:\n\n```typescript\nconst relevanceScore = (pattern) => {\n  let score = 0;\n\n  // Recency bonus\n  if (isRecent(pattern.detectedAt, 7)) score += 2;\n\n  // Category match\n  if (matchesAvailableWork(pattern.categories)) score += 3;\n\n  // Frequency bonus\n  if (pattern.frequency > 3) score += 1;\n\n  return score;\n};\n```\n\n### Step 3: Categorize\n\nGroup patterns by utility:\n\n```json\n{\n  \"patterns\": {\n    \"execution\": [...],  // How to run loops\n    \"technical\": [...],  // Implementation guidance\n    \"strategic\": [...],  // Decision frameworks\n    \"avoid\": [...]       // Anti-patterns\n  }\n}\n```\n\n### Step 4: Summarize\n\nCreate actionable summary:\n\n```json\n{\n  \"pattern_summary\": {\n    \"total_collected\": 25,\n    \"high_relevance\": 8,\n    \"key_insights\": [\n      \"Engineering loops typically take 2-4 hours\",\n      \"Always run tests before distribution\",\n      \"Gate rejections usually require code changes\"\n    ],\n    \"warnings\": [\n      \"Avoid: Skipping VALIDATE phase\",\n      \"Avoid: Large commits without incremental testing\"\n    ]\n  }\n}\n```\n\n## Output\n\nUpdates `memory/async-context.json`:\n\n```json\n{\n  \"patterns\": {\n    \"collected_at\": \"ISO-timestamp\",\n    \"total\": 25,\n    \"by_type\": {\n      \"execution\": 10,\n      \"technical\": 8,\n      \"strategic\": 5,\n      \"avoid\": 2\n    },\n    \"high_relevance\": [...],\n    \"key_insights\": [...],\n    \"warnings\": [...]\n  }\n}\n```\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Updated async context | `memory/async-context.json` | Always |\n\n## References\n\n- [pattern-categories.md](references/pattern-categories.md) — Pattern categorization taxonomy",
  "references": [
    {
      "name": "pattern-categories.md",
      "path": "references/pattern-categories.md",
      "content": "# Pattern Categories\n\nTaxonomy for categorizing patterns during collection.\n\n## Primary Categories\n\n### Execution Patterns\n\nPatterns about how loops execute.\n\n| Pattern | Description | Example |\n|---------|-------------|---------|\n| `phase-duration` | Typical time per phase | \"IMPLEMENT averages 45 min\" |\n| `gate-behavior` | How gates are handled | \"code-review-gate usually passes first try\" |\n| `skill-sequence` | Common skill orderings | \"scaffold always before implement\" |\n| `error-recovery` | How errors are handled | \"test failures → fix → retry\" |\n\n### Technical Patterns\n\nImplementation guidance.\n\n| Pattern | Description | Example |\n|---------|-------------|---------|\n| `code-style` | Coding conventions | \"Use Zod for validation\" |\n| `architecture` | Structural patterns | \"Services in src/services/\" |\n| `testing` | Test patterns | \"Integration tests for API endpoints\" |\n| `documentation` | Doc patterns | \"SKILL.md with references/\" |\n\n### Strategic Patterns\n\nDecision-making frameworks.\n\n| Pattern | Description | Example |\n|---------|-------------|---------|\n| `prioritization` | How to order work | \"High leverage first\" |\n| `scoping` | How to size work | \"One module per loop\" |\n| `deferral` | When to defer | \"Defer if unclear requirements\" |\n| `escalation` | When to escalate | \"3 failures → human review\" |\n\n### Anti-Patterns (Avoid)\n\nWhat not to do.\n\n| Pattern | Description | Example |\n|---------|-------------|---------|\n| `skip-validation` | Skipping quality checks | \"Never skip VALIDATE\" |\n| `big-bang` | Large changes at once | \"Incremental commits preferred\" |\n| `assumption` | Unverified assumptions | \"Always verify requirements\" |\n\n## Relevance Scoring\n\n### Factors\n\n| Factor | Weight | Description |\n|--------|--------|-------------|\n| Recency | 2 | Pattern detected in last 7 days |\n| Frequency | 1 | Pattern occurred 3+ times |\n| Category match | 3 | Matches available work types |\n| Severity | 2 | Anti-pattern (avoid) patterns |\n\n### Thresholds\n\n| Score | Classification |\n|-------|----------------|\n| 5+ | High relevance |\n| 3-4 | Medium relevance |\n| 1-2 | Low relevance |\n| 0 | Not relevant |\n\n## Usage in Async Context\n\nHigh-relevance patterns are:\n1. Surfaced in queue planning\n2. Used to inform duration estimates\n3. Referenced in decision points\n4. Applied as constraints during execution\n"
    }
  ],
  "tags": [
    "async",
    "patterns",
    "context",
    "memory"
  ],
  "dependsOn": [
    "state-loader"
  ]
}