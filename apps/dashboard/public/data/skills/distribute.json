{
  "id": "distribute",
  "name": "distribute",
  "version": "1.0.0",
  "description": "Set up CI/CD distribution pipelines for automated releases. Creates GitHub Actions workflows, configures platform deployment (Vercel or Railway), produces tarball releases with SHA256 checksums, and optionally publishes Docker images to GHCR.",
  "phase": "SHIP",
  "category": "core",
  "content": "# Distribute\n\nSet up automated distribution pipelines.\n\n## When to Use\n\n- **New project ready to ship** — Set up the CI/CD pipeline from scratch\n- **Adding platform deployment** — Connect Vercel or Railway to an existing repo\n- **Release automation** — Create tarball releases with checksums\n- **Docker publishing** — Publish container images to GHCR\n- When you say: \"set up distribution\", \"create release pipeline\", \"deploy to Vercel\", \"automate releases\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `github-actions-workflow.md` | Complete workflow template with all four pipeline stages |\n| `platform-selection.md` | Decision tree for choosing Vercel vs Railway |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `tarball-release.md` | When customizing release artifacts or adding tagged releases |\n\n**Verification:** Ensure `.github/workflows/distribute.yml` exists and is valid YAML.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `.github/workflows/distribute.yml` | Project root | Always |\n| GitHub Release (rolling \"latest\") | GitHub | Always |\n| Platform configuration | `.vercel/` or `railway.toml` | When platform selected |\n\n## Core Concept\n\nDistribution answers: **\"How does code automatically get from main branch to users?\"**\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                     DISTRIBUTION PIPELINE                                    │\n│                                                                             │\n│  Push to Main                                                               │\n│       │                                                                     │\n│       ▼                                                                     │\n│  GitHub Actions (distribute.yml)                                            │\n│       │                                                                     │\n│       ├──► Test Gate                                                        │\n│       │      └─ npm test (must pass to continue)                            │\n│       │                                                                     │\n│       ├──► Platform Deploy                                                  │\n│       │      ├─ Vercel (web apps: Next.js, static, SSR)                     │\n│       │      └─ Railway (persistent: MCP, SSE, WebSocket)                   │\n│       │                                                                     │\n│       ├──► Tarball Release                                                  │\n│       │      └─ Rolling \"latest\" + SHA256 checksum                          │\n│       │                                                                     │\n│       └──► Docker Image (if Dockerfile exists)                              │\n│              └─ ghcr.io/{org}/{repo}:latest                                 │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\nDistribution is **not** production deployment strategy — that's the `deploy` skill. Distribution automates the pipeline that triggers deployment. Deploy defines *what* happens; distribute defines *how* it gets triggered.\n\n## Platform Selection\n\n| Workload | Platform | Why |\n|----------|----------|-----|\n| Static site, Next.js, SSR | **Vercel** | Edge-optimized, zero config |\n| Full-stack with Postgres | **Vercel + Neon** | Serverless DB, preview branches |\n| MCP server, SSE, WebSocket | **Railway** | Persistent connections |\n| Long-running process (>60s) | **Railway** | No serverless timeout |\n| API with Dockerfile | **Railway** | Container-native |\n\n> See `references/platform-selection.md`\n\n## The Distribution Process\n\n### Step 1: Detect Workload Type\n\nAnalyze the project to determine the right platform:\n\n```\npackage.json → \"next\" in dependencies?     → Vercel\npackage.json → SSE or WebSocket server?     → Railway\nDockerfile exists?                          → Railway (or GHCR-only)\nStatic HTML/CSS?                            → Vercel\npyproject.toml / Cargo.toml?                → Railway\n```\n\n### Step 2: Create GitHub Repository\n\nIf the project doesn't have a remote yet:\n\n```bash\n# Create repo (public or private)\ngh repo create {name} --source=. --push\n\n# Or if repo exists but no remote\ngit remote add origin https://github.com/{org}/{name}.git\ngit push -u origin main\n```\n\n### Step 3: Generate Workflow\n\nCreate `.github/workflows/distribute.yml` using the template from `references/github-actions-workflow.md`. The workflow includes four jobs:\n\n1. **test** — Runs test suite as a quality gate\n2. **deploy-vercel** or **deploy-railway** — Platform deployment (conditional)\n3. **release** — Tarball with SHA256 checksum (always)\n4. **docker** — GHCR image (conditional on Dockerfile)\n\n### Step 4: Configure Platform\n\n**For Vercel:**\n\n```bash\nvercel link\ngh secret set VERCEL_TOKEN --body \"$(vercel whoami --token)\"\ngh secret set VERCEL_ORG_ID --body \"team_xxx\"   # from .vercel/project.json\ngh secret set VERCEL_PROJECT_ID --body \"prj_xxx\" # from .vercel/project.json\n```\n\n**For Railway:**\n\n```bash\nrailway link\ngh secret set RAILWAY_TOKEN --body \"your-token\"\n```\n\n### Step 5: Create Initial Release\n\nPush to main to trigger the first automated release:\n\n```bash\ngit add .github/workflows/distribute.yml\ngit commit -m \"Add distribution pipeline\"\ngit push origin main\n```\n\nThe workflow creates a rolling \"latest\" release with:\n- Tarball (`{repo}-v{version}.tar.gz`)\n- Checksum (`checksums.txt`)\n\n### Step 6: Verify Pipeline\n\n```bash\n# Check workflow ran\ngh run list --limit 1\n\n# Check release exists\ngh release view latest\n\n# Check platform deployment (Vercel)\nvercel ls --prod\n\n# Check platform deployment (Railway)\nrailway status\n```\n\n## Tarball Release Pattern\n\nThe distribution pipeline uses a **rolling \"latest\" release** — a single GitHub release that gets updated on every push to main.\n\n| Pattern | Behavior |\n|---------|----------|\n| Rolling \"latest\" | Single release, always current, no clutter |\n| Stack-agnostic versioning | Detects from package.json, Cargo.toml, pyproject.toml, or VERSION |\n| SHA256 checksum | Always included for verification |\n| Graceful skip | Platform deploy skips if secrets not configured |\n| Docker to GHCR | If Dockerfile exists, publishes `ghcr.io/{org}/{repo}:latest` |\n\n> See `references/tarball-release.md`\n\n## Distribution Verification Checklist\n\n```markdown\n## Distribution Verification\n\n### Pipeline\n- [ ] `.github/workflows/distribute.yml` exists\n- [ ] Workflow YAML is valid\n- [ ] Test job runs project test suite\n- [ ] Workflow triggers on push to main\n\n### Platform\n- [ ] Platform selected (Vercel or Railway)\n- [ ] Platform linked to project\n- [ ] GitHub secrets configured\n- [ ] Platform deployment succeeds\n\n### Release\n- [ ] Tarball created with correct version\n- [ ] SHA256 checksum generated\n- [ ] Rolling \"latest\" release created on GitHub\n- [ ] Previous \"latest\" release replaced (not accumulated)\n\n### Docker (if applicable)\n- [ ] Dockerfile exists and builds\n- [ ] Image pushed to ghcr.io\n- [ ] Image tagged as latest\n```\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `deploy` | Deploy handles production strategy (blue-green, canary, rollback); distribute handles CI/CD pipeline automation |\n| `git-workflow` | Merge to main triggers the distribute pipeline |\n| `code-review` | PR approval precedes distribution setup |\n| `scaffold` | Scaffold may create initial project structure; distribute adds CI/CD on top |\n| `security-audit` | Audit may flag secrets management or pipeline security |\n\n## Key Principles\n\n**Automate the path from merge to production.** No manual steps between PR merge and deployment.\n\n**Rolling releases avoid clutter.** A single \"latest\" release stays current without accumulating stale versions.\n\n**Stack-agnostic versioning.** Detect version from whatever config file the project uses.\n\n**Graceful degradation.** Pipeline steps skip when their secrets or prerequisites are missing — no failures for optional features.\n\n**Every project deserves a release pipeline.** Even internal tools benefit from automated distribution.\n\n## Mode-Specific Behavior\n\n### Greenfield Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Full pipeline setup from scratch |\n| **Approach** | Create repo, workflow, platform config, initial release |\n| **Platform** | Free choice based on workload detection |\n| **Deliverables** | `.github/workflows/distribute.yml`, platform config, initial release |\n| **Verification** | Full pipeline runs end-to-end |\n\n### Brownfield-Polish Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Add distribution to existing project |\n| **Approach** | Extend existing CI/CD if present, don't replace |\n| **Platform** | Match existing deployment patterns |\n| **Deliverables** | New or updated workflow, platform config |\n| **Verification** | Existing CI/CD still works, new pipeline runs |\n\n**Polish considerations:**\n- [ ] Existing CI/CD workflows preserved\n- [ ] New workflow doesn't conflict with existing ones\n- [ ] Platform choice matches existing deployment\n- [ ] Secrets don't collide with existing ones\n\n### Brownfield-Enterprise Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Minimal additions conforming to existing standards |\n| **Approach** | Follow existing CI/CD patterns exactly |\n| **Platform** | Must use organization-approved platforms |\n| **Deliverables** | Workflow conforming to org standards |\n| **Verification** | Passes org CI/CD policy checks |\n\n**Enterprise requirements:**\n- Workflow must follow organization template\n- Platform must be on approved list\n- Secrets must go through org secret management\n- Docker images must use org-approved base images\n\n---\n\n## References\n\n- `references/github-actions-workflow.md`: Complete workflow template\n- `references/platform-selection.md`: Platform decision guide and setup commands\n- `references/tarball-release.md`: Tarball creation and rolling release pattern",
  "references": [
    {
      "name": "github-actions-workflow.md",
      "path": "references/github-actions-workflow.md",
      "content": "# GitHub Actions Workflow Template\n\nThe `distribute.yml` workflow automates the full distribution pipeline on push to main.\n\n## Complete Workflow\n\n```yaml\nname: Distribute\n\non:\n  push:\n    branches: [main]\n\npermissions:\n  contents: write\n  packages: write\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: npm\n      - run: npm ci\n      - run: npm test\n\n  deploy-vercel:\n    needs: test\n    runs-on: ubuntu-latest\n    if: ${{ vars.DEPLOY_PLATFORM == 'vercel' }}\n    env:\n      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}\n      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}\n      VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install Vercel CLI\n        run: npm i -g vercel@latest\n      - name: Pull Vercel Environment\n        run: vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}\n      - name: Build\n        run: vercel build --prod --token=${{ secrets.VERCEL_TOKEN }}\n      - name: Deploy\n        run: vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }}\n\n  deploy-railway:\n    needs: test\n    runs-on: ubuntu-latest\n    if: ${{ vars.DEPLOY_PLATFORM == 'railway' }}\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install Railway CLI\n        run: npm i -g @railway/cli\n      - name: Deploy\n        run: railway up --service ${{ secrets.RAILWAY_SERVICE || '' }}\n        env:\n          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}\n\n  release:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Detect version\n        id: version\n        run: |\n          if [ -f package.json ]; then\n            VERSION=$(node -p \"require('./package.json').version\")\n          elif [ -f Cargo.toml ]; then\n            VERSION=$(grep '^version' Cargo.toml | head -1 | sed 's/.*\"\\(.*\\)\".*/\\1/')\n          elif [ -f pyproject.toml ]; then\n            VERSION=$(grep '^version' pyproject.toml | head -1 | sed 's/.*\"\\(.*\\)\".*/\\1/')\n          elif [ -f VERSION ]; then\n            VERSION=$(cat VERSION)\n          else\n            VERSION=\"0.0.0\"\n          fi\n          echo \"version=$VERSION\" >> \"$GITHUB_OUTPUT\"\n          echo \"Detected version: $VERSION\"\n\n      - name: Create tarball\n        run: |\n          REPO_NAME=$(basename \"$GITHUB_REPOSITORY\")\n          tar czf \"$REPO_NAME-v${{ steps.version.outputs.version }}.tar.gz\" \\\n            --exclude='.git' \\\n            --exclude='node_modules' \\\n            --exclude='.env*' \\\n            .\n          shasum -a 256 \"$REPO_NAME-v${{ steps.version.outputs.version }}.tar.gz\" > checksums.txt\n\n      - name: Create or update rolling release\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        run: |\n          REPO_NAME=$(basename \"$GITHUB_REPOSITORY\")\n          TARBALL=\"$REPO_NAME-v${{ steps.version.outputs.version }}.tar.gz\"\n\n          # Delete existing \"latest\" release if it exists\n          gh release delete latest --yes 2>/dev/null || true\n          git push origin :refs/tags/latest 2>/dev/null || true\n\n          # Create new \"latest\" release\n          gh release create latest \\\n            --title \"Latest (v${{ steps.version.outputs.version }})\" \\\n            --notes \"Rolling release — updated on every push to main.\n\n          **Version:** ${{ steps.version.outputs.version }}\n          **Commit:** ${{ github.sha }}\n          **Date:** $(date -u +%Y-%m-%dT%H:%M:%SZ)\" \\\n            \"$TARBALL\" checksums.txt\n\n  docker:\n    needs: test\n    runs-on: ubuntu-latest\n    if: ${{ hashFiles('Dockerfile') != '' }}\n    steps:\n      - uses: actions/checkout@v4\n      - name: Log in to GHCR\n        uses: docker/login-action@v3\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n      - name: Build and push\n        uses: docker/build-push-action@v5\n        with:\n          context: .\n          push: true\n          tags: ghcr.io/${{ github.repository }}:latest\n```\n\n## Workflow Structure\n\n| Job | Depends On | Condition | Purpose |\n|-----|-----------|-----------|---------|\n| `test` | — | Always | Run test suite as gate |\n| `deploy-vercel` | test | `DEPLOY_PLATFORM == 'vercel'` | Deploy to Vercel |\n| `deploy-railway` | test | `DEPLOY_PLATFORM == 'railway'` | Deploy to Railway |\n| `release` | test | Always | Create tarball + rolling release |\n| `docker` | test | Dockerfile exists | Build and push to GHCR |\n\n## Required Secrets\n\n| Secret | Platform | How to Set |\n|--------|----------|------------|\n| `VERCEL_TOKEN` | Vercel | `gh secret set VERCEL_TOKEN` |\n| `VERCEL_ORG_ID` | Vercel | `gh secret set VERCEL_ORG_ID` |\n| `VERCEL_PROJECT_ID` | Vercel | `gh secret set VERCEL_PROJECT_ID` |\n| `RAILWAY_TOKEN` | Railway | `gh secret set RAILWAY_TOKEN` |\n| `GITHUB_TOKEN` | GitHub | Automatic (provided by Actions) |\n\n## Repository Variables\n\n| Variable | Values | Purpose |\n|----------|--------|---------|\n| `DEPLOY_PLATFORM` | `vercel` or `railway` | Required for platform deploy jobs to run |\n\n## Customization Points\n\n- **Test command**: Replace `npm test` with your project's test runner\n- **Node version**: Update `node-version` to match your project\n- **Tarball excludes**: Add project-specific excludes to the `tar` command\n- **Docker tags**: Add version-specific tags alongside `latest`\n"
    },
    {
      "name": "platform-selection.md",
      "path": "references/platform-selection.md",
      "content": "# Platform Selection Guide\n\nChoose the right deployment platform based on your workload characteristics.\n\n## Decision Matrix\n\n| Workload | Platform | Why |\n|----------|----------|-----|\n| Static site, Next.js, SSR | **Vercel** | Edge-optimized, zero config |\n| Full-stack with Postgres | **Vercel + Neon** | Serverless DB, preview branches |\n| MCP server, SSE, WebSocket | **Railway** | Persistent connections |\n| Long-running process (>60s) | **Railway** | No serverless timeout |\n| API with Dockerfile | **Railway** | Container-native |\n\n## Decision Tree\n\n```\nIs it a web app (Next.js, static, SSR)?\n  ├─ Yes → Does it need a database?\n  │    ├─ Yes → Vercel + Neon\n  │    └─ No  → Vercel\n  └─ No → Does it need persistent connections (WebSocket, SSE)?\n       ├─ Yes → Railway\n       └─ No  → Does it run longer than 60 seconds?\n            ├─ Yes → Railway\n            └─ No  → Either works; default to Vercel\n```\n\n## Vercel Setup\n\n### Initial Configuration\n\n```bash\n# Link project to Vercel\nvercel link\n\n# This creates .vercel/project.json with org and project IDs\n```\n\n### GitHub Secrets\n\n```bash\n# Get token from https://vercel.com/account/tokens\ngh secret set VERCEL_TOKEN --body \"your-token\"\n\n# Get IDs from .vercel/project.json after linking\ngh secret set VERCEL_ORG_ID --body \"team_xxx\"\ngh secret set VERCEL_PROJECT_ID --body \"prj_xxx\"\n```\n\n### With Neon Database\n\n```bash\n# Standard Vercel setup (above) plus:\n# Add DATABASE_URL to Vercel env vars (NOT GitHub secrets)\nvercel env add DATABASE_URL production\n\n# Install Neon Vercel Integration for automatic preview branch databases\n# https://vercel.com/integrations/neon\n```\n\n### Vercel Configuration (vercel.json)\n\n```json\n{\n  \"buildCommand\": \"npm run build\",\n  \"outputDirectory\": \"dist\",\n  \"framework\": null\n}\n```\n\nFor Next.js projects, Vercel auto-detects — no `vercel.json` needed.\n\n## Railway Setup\n\n### Initial Configuration\n\n```bash\n# Link project to Railway\nrailway link\n\n# This connects your local directory to a Railway project\n```\n\n### GitHub Secrets\n\n```bash\n# Get token from https://railway.app/account/tokens\ngh secret set RAILWAY_TOKEN --body \"your-token\"\n\n# Optional: specify service name for multi-service projects\ngh secret set RAILWAY_SERVICE --body \"service-name\"\n```\n\n### Railway Configuration\n\nRailway auto-detects most project types. For explicit configuration, use a `railway.toml`:\n\n```toml\n[build]\nbuilder = \"nixpacks\"\n\n[deploy]\nstartCommand = \"node dist/index.js\"\nhealthcheckPath = \"/health\"\nrestartPolicyType = \"on_failure\"\n```\n\n## Dual Platform Setup\n\nSome projects deploy to both platforms:\n\n| Component | Platform | Example |\n|-----------|----------|---------|\n| Documentation site | Vercel | `docs.myproject.com` |\n| API server | Railway | `api.myproject.com` |\n| MCP server | Railway | `mcp.myproject.com` |\n\nIn this case, configure both sets of secrets and set `DEPLOY_PLATFORM` to `railway` (the primary), then add a separate Vercel project for the docs site.\n\n## Environment Variables\n\n### Vercel\n\n```bash\n# Add production env var\nvercel env add VAR_NAME production\n\n# Add to all environments\nvercel env add VAR_NAME production preview development\n```\n\n### Railway\n\n```bash\n# Set via CLI\nrailway variables set VAR_NAME=value\n\n# Or via dashboard: railway.app → Project → Variables\n```\n\n## Graceful Degradation\n\nThe `distribute.yml` workflow skips platform deployment if secrets are not configured. This means:\n\n- New repos get tarball releases immediately (no secrets needed)\n- Platform deployment activates when secrets are added\n- Docker publishing activates when a Dockerfile is added\n- No workflow failures for missing optional configuration\n"
    },
    {
      "name": "tarball-release.md",
      "path": "references/tarball-release.md",
      "content": "# Tarball Release Guide\n\nCreate reproducible release artifacts with checksums using the rolling \"latest\" release pattern.\n\n## Version Detection\n\nThe workflow auto-detects the project version from these sources (in priority order):\n\n| Source | Detection |\n|--------|-----------|\n| `package.json` | `node -p \"require('./package.json').version\"` |\n| `Cargo.toml` | `grep '^version' Cargo.toml` |\n| `pyproject.toml` | `grep '^version' pyproject.toml` |\n| `VERSION` file | `cat VERSION` |\n| Fallback | `0.0.0` |\n\n## Tarball Creation\n\n```bash\n# Standard tarball excluding common non-distributable files\nREPO_NAME=$(basename \"$PWD\")\nVERSION=$(node -p \"require('./package.json').version\")\n\ntar czf \"$REPO_NAME-v$VERSION.tar.gz\" \\\n  --exclude='.git' \\\n  --exclude='node_modules' \\\n  --exclude='.env*' \\\n  --exclude='.vercel' \\\n  --exclude='.railway' \\\n  .\n```\n\n### SHA256 Checksum\n\n```bash\n# Generate checksum\nshasum -a 256 \"$REPO_NAME-v$VERSION.tar.gz\" > checksums.txt\n\n# Verify (consumer side)\nshasum -a 256 -c checksums.txt\n```\n\n## Rolling \"Latest\" Release Pattern\n\nInstead of creating a new GitHub release for every push, maintain a single rolling \"latest\" release that gets updated:\n\n```bash\n# Delete existing release and tag\ngh release delete latest --yes 2>/dev/null || true\ngit push origin :refs/tags/latest 2>/dev/null || true\n\n# Create fresh release with current artifacts\ngh release create latest \\\n  --title \"Latest (v$VERSION)\" \\\n  --notes \"Rolling release — updated on every push to main.\" \\\n  \"$TARBALL\" checksums.txt\n```\n\n### Why Rolling Releases\n\n| Approach | Pros | Cons |\n|----------|------|------|\n| **Rolling \"latest\"** | Clean releases page, always current | No version history in releases |\n| **Per-push releases** | Full history | Cluttered releases page |\n| **Tagged releases** | Semantic versions | Requires manual tagging |\n\nThe rolling pattern is the default. For libraries or tools that need semantic version releases, add tagged releases alongside the rolling one.\n\n## Tagged Releases (Optional)\n\nWhen you want to cut a versioned release in addition to the rolling one:\n\n```bash\n# Tag the commit\ngit tag \"v$VERSION\"\ngit push origin \"v$VERSION\"\n\n# Create a versioned release\ngh release create \"v$VERSION\" \\\n  --title \"v$VERSION\" \\\n  --generate-notes \\\n  \"$TARBALL\" checksums.txt\n```\n\n## Docker Images\n\nWhen a `Dockerfile` exists, the workflow also publishes to GHCR:\n\n```bash\n# Build and tag\ndocker build -t ghcr.io/$GITHUB_REPOSITORY:latest .\n\n# Push\ndocker push ghcr.io/$GITHUB_REPOSITORY:latest\n```\n\n### Consumer Usage\n\n```bash\n# Pull the image\ndocker pull ghcr.io/org/repo:latest\n\n# Or reference in docker-compose.yml\nservices:\n  app:\n    image: ghcr.io/org/repo:latest\n```\n\n## Installation From Release\n\nConsumers can install from the tarball:\n\n```bash\n# Download latest\ngh release download latest --repo org/repo --pattern '*.tar.gz'\n\n# Verify checksum\ngh release download latest --repo org/repo --pattern 'checksums.txt'\nshasum -a 256 -c checksums.txt\n\n# Extract\ntar xzf repo-v*.tar.gz\n```\n"
    }
  ],
  "tags": [
    "shipping",
    "ci-cd",
    "release",
    "distribution",
    "core-workflow"
  ],
  "dependsOn": [
    "code-review"
  ]
}