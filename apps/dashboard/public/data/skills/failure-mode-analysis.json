{
  "id": "failure-mode-analysis",
  "name": "failure-mode-analysis",
  "version": "1.0.0",
  "description": "Apply MECE failure mode taxonomy to backend pipelines. Classifies failures by Location (L1-L4), Type (T1-T5), and Severity (S1-S4). Produces comprehensive failure mode inventory with validation status and coverage calculation.",
  "phase": "REVIEW",
  "category": "core",
  "content": "# Failure Mode Analysis\n\nApply MECE failure mode taxonomy to backend pipelines.\n\n## When to Use\n\n- **After pipeline discovery** — Runs in REVIEW phase on identified P-series\n- **Systematic failure identification** — Find all ways each pipeline can fail\n- **Coverage assessment** — Calculate what percentage of failures are validated\n- When you say: \"analyze failure modes\", \"what can break?\", \"find the risks\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `mece-taxonomy.md` | The three classification dimensions |\n| `failure-mode-template.md` | How to document each failure mode |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `validation-checking.md` | How to verify if mode is validated |\n\n**Verification:** Every pipeline step has been analyzed for failure modes.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `PIPELINE-FAILURE-MODES.md` | Project root | Always |\n| Coverage update | `audit-state.json` | Always |\n\n## Core Concept\n\nFailure Mode Analysis answers: **\"What are all the ways this pipeline can fail?\"**\n\nMECE = Mutually Exclusive, Collectively Exhaustive\n- Every failure belongs to exactly one category\n- All possible failures are covered\n\nThe three dimensions:\n1. **Location (WHERE)** — Where in the pipeline does it fail?\n2. **Type (WHAT)** — What kind of failure is it?\n3. **Severity (HOW BAD)** — How serious is the impact?\n\n## The MECE Taxonomy\n\n### Dimension 1: Location (WHERE)\n\n| Code | Location | Description | Examples |\n|------|----------|-------------|----------|\n| L1 | **Input** | Data entering pipeline is invalid/missing | Bad request, missing field |\n| L2 | **Processing** | Transformation logic fails | Algorithm error, edge case |\n| L3 | **Output** | Storage or delivery fails | DB write error, API failure |\n| L4 | **Integration** | Cross-pipeline handoff fails | Missing dependency, format mismatch |\n\n### Dimension 2: Type (WHAT)\n\n| Code | Type | Description | Examples |\n|------|------|-------------|----------|\n| T1 | **Data** | Missing, malformed, stale data | Null field, wrong format |\n| T2 | **Logic** | Algorithm error, wrong branch | Edge case, off-by-one |\n| T3 | **Infrastructure** | Auth, network, timeout | Rate limit, connection lost |\n| T4 | **Quality** | Succeeds but output is bad | Low quality, wrong tone |\n| T5 | **UX** | Works but experience is broken | Confusing, no feedback |\n\n### Dimension 3: Severity (HOW BAD)\n\n| Code | Severity | Description | User Impact |\n|------|----------|-------------|-------------|\n| S1 | **Silent** | Fails without error | Bad data persists, user unaware |\n| S2 | **Partial** | Some data correct, some wrong | Partial results, confusing |\n| S3 | **Visible** | Error surfaced but unclear | User sees error, doesn't understand |\n| S4 | **Blocking** | Cannot complete | User stuck, needs help |\n\n## Analysis Process\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│              FAILURE MODE ANALYSIS PROCESS                  │\n│                                                             │\n│  FOR EACH PIPELINE:                                         │\n│                                                             │\n│  1. WALK THROUGH EACH STEP                                  │\n│     └─→ What can go wrong at this step?                    │\n│                                                             │\n│  2. FOR EACH POTENTIAL FAILURE                              │\n│     ├─→ Assign Location (L1-L4)                            │\n│     ├─→ Assign Type (T1-T5)                                │\n│     ├─→ Assign Severity (S1-S4)                            │\n│     └─→ Generate ID: P{N}-{NNN}                            │\n│                                                             │\n│  3. CHECK VALIDATION STATUS                                 │\n│     ├─→ Is there explicit error handling?                  │\n│     ├─→ Is there test coverage?                            │\n│     └─→ Mark VALIDATED or UNVALIDATED                      │\n│                                                             │\n│  4. CALCULATE COVERAGE                                      │\n│     └─→ (Validated / Total) × 100%                         │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Failure Mode Documentation\n\n```markdown\n### P2-007: Template selection too narrow\n\n| Attribute | Value |\n|-----------|-------|\n| **ID** | P2-007 |\n| **Pipeline** | P2: Content Generation |\n| **Step** | 4. Template selection |\n| **Location** | L2-Processing |\n| **Type** | T4-Quality |\n| **Severity** | S1-Silent |\n| **Description** | Only 3 templates available, causing repetitive output |\n| **Impact** | Generated content lacks variety |\n| **Detection** | None (silent) |\n| **Status** | UNVALIDATED |\n| **Test Spec** | TEST-P2-007 |\n| **Fix** | Expand template pool to 10+ variations |\n| **Effort** | M |\n```\n\n## Output Format\n\n### PIPELINE-FAILURE-MODES.md\n\n```markdown\n# Pipeline Failure Modes\n\n## Summary\n\n| Pipeline | Failure Modes | Validated | Coverage |\n|----------|---------------|-----------|----------|\n| P1: Source Ingestion | 9 | 4 | 44% |\n| P2: Content Generation | 12 | 3 | 25% |\n| P3: Publishing | 8 | 5 | 63% |\n| **Total** | **29** | **12** | **41%** |\n\n## Risk Distribution\n\n| Severity | Count | Validated | Risk Level |\n|----------|-------|-----------|------------|\n| S1-Silent | 8 | 2 | HIGHEST |\n| S2-Partial | 7 | 3 | HIGH |\n| S3-Visible | 9 | 5 | MEDIUM |\n| S4-Blocking | 5 | 2 | LOW |\n\n## P1: Source Ingestion\n\n### P1-001: File type not supported\n\n| Attribute | Value |\n|-----------|-------|\n| **Location** | L1-Input |\n| **Type** | T1-Data |\n| **Severity** | S3-Visible |\n| **Description** | User uploads unsupported file type |\n| **Status** | VALIDATED (try-catch in upload handler) |\n\n[... more failure modes ...]\n```\n\n## Coverage Calculation\n\nA failure mode is **Validated** only if:\n\n1. **Explicit handling exists:**\n   ```typescript\n   try {\n     await processFile(file);\n   } catch (error) {\n     // Specific handling for this failure\n   }\n   ```\n\n2. **Test coverage exists:**\n   ```typescript\n   test('handles unsupported file type', () => {\n     expect(() => upload(badFile)).toThrow();\n   });\n   ```\n\nCoverage formula:\n```\nCoverage = (Validated Modes / Total Modes) × 100%\n```\n\n## Priority Order for Fixes\n\n1. **S1 (Silent)** — Highest risk: fail without anyone knowing\n2. **L4 (Integration)** — High risk: cross-pipeline, often 0% validated\n3. **S2 (Partial)** — Medium risk: data corruption possible\n4. **S3 (Visible)** — Lower risk: at least user knows\n5. **S4 (Blocking)** — Usually already handled (obvious failures)\n\n## Validation Checklist\n\n- [ ] Every pipeline step analyzed\n- [ ] Each failure mode has L/T/S codes\n- [ ] Unique ID assigned (P{N}-{NNN})\n- [ ] Validation status checked against code\n- [ ] Coverage percentages calculated\n- [ ] Summary table generated",
  "references": [
    {
      "name": "failure-mode-template.md",
      "path": "references/failure-mode-template.md",
      "content": "# Failure Mode Template\n\nStandard format for documenting a failure mode.\n\n## Full Template\n\n```markdown\n### P{N}-{NNN}: {Short description}\n\n| Attribute | Value |\n|-----------|-------|\n| **ID** | P{N}-{NNN} |\n| **Pipeline** | P{N}: {Pipeline Name} |\n| **Step** | {Step number}. {Step description} |\n| **Location** | L{N}-{Name} |\n| **Type** | T{N}-{Name} |\n| **Severity** | S{N}-{Name} |\n| **Description** | {What goes wrong} |\n| **Impact** | {What happens to user/data} |\n| **Detection** | {How is it detected, or \"None\"} |\n| **Status** | VALIDATED | UNVALIDATED |\n| **Handling** | {Code location if validated} |\n| **Test Spec** | TEST-P{N}-{NNN} |\n| **Fix** | {What would fix it} |\n| **Effort** | S | M | L |\n```\n\n## Example: Input Validation\n\n```markdown\n### P1-003: Source file exceeds size limit\n\n| Attribute | Value |\n|-----------|-------|\n| **ID** | P1-003 |\n| **Pipeline** | P1: Source Ingestion |\n| **Step** | 1. File received at upload endpoint |\n| **Location** | L1-Input |\n| **Type** | T1-Data |\n| **Severity** | S3-Visible |\n| **Description** | Uploaded file exceeds 10MB limit |\n| **Impact** | Upload rejected, user sees error |\n| **Detection** | Size check before processing |\n| **Status** | VALIDATED |\n| **Handling** | `api/upload/route.ts:34` |\n| **Test Spec** | - |\n| **Fix** | - (already handled) |\n| **Effort** | - |\n```\n\n## Example: Silent Failure\n\n```markdown\n### P2-007: Template selection too narrow\n\n| Attribute | Value |\n|-----------|-------|\n| **ID** | P2-007 |\n| **Pipeline** | P2: Content Generation |\n| **Step** | 4. Template selection |\n| **Location** | L2-Processing |\n| **Type** | T4-Quality |\n| **Severity** | S1-Silent |\n| **Description** | Only 3 templates in pool, causing repetitive output |\n| **Impact** | Users see repetitive content after several generations |\n| **Detection** | None (no error, just lower quality) |\n| **Status** | UNVALIDATED |\n| **Handling** | - |\n| **Test Spec** | TEST-P2-007 |\n| **Fix** | Expand template pool to 10+ variations |\n| **Effort** | M |\n```\n\n## Minimal Template\n\nFor quick documentation:\n\n```markdown\n### P{N}-{NNN}: {Description}\n\n**Location:** L{N} | **Type:** T{N} | **Severity:** S{N}\n**Status:** VALIDATED | UNVALIDATED\n```\n\n## ID Convention\n\n```\nP{pipeline_number}-{sequence_number}\n\nP1-001  First failure mode in P1\nP1-002  Second failure mode in P1\nP2-001  First failure mode in P2\n```\n\nKeep sequence numbers contiguous within each pipeline.\n\n## Status Determination\n\n### VALIDATED\n- Explicit try-catch with specific handling\n- Input validation that rejects bad data\n- Test that covers this scenario\n- Retry/fallback logic that handles it\n\n### UNVALIDATED\n- No explicit handling\n- Generic error catch only\n- No test coverage\n- Silent failure path\n"
    },
    {
      "name": "mece-taxonomy.md",
      "path": "references/mece-taxonomy.md",
      "content": "# MECE Taxonomy\n\nThe three dimensions for classifying failure modes.\n\n## What is MECE?\n\n**M**utually **E**xclusive, **C**ollectively **E**xhaustive\n\n- **Mutually Exclusive:** Each failure belongs to exactly one category\n- **Collectively Exhaustive:** All possible failures are covered\n\n## Dimension 1: Location (WHERE)\n\nWhere in the data flow does the failure occur?\n\n### L1: Input\nFailure when data enters the pipeline.\n\n**Examples:**\n- Missing required field in request\n- Invalid data format\n- Authentication failure\n- File too large\n\n**Code patterns:**\n```typescript\nif (!request.body.name) throw new Error('Missing name');\n```\n\n### L2: Processing\nFailure during data transformation.\n\n**Examples:**\n- Algorithm produces wrong result\n- Edge case not handled\n- Type conversion fails\n- Business rule violated\n\n**Code patterns:**\n```typescript\nconst result = transform(data);  // Logic error here\n```\n\n### L3: Output\nFailure when storing or delivering result.\n\n**Examples:**\n- Database write fails\n- External API returns error\n- Response serialization fails\n- File write permission denied\n\n**Code patterns:**\n```typescript\nawait db.insert(record);  // DB error here\n```\n\n### L4: Integration\nFailure at pipeline boundaries.\n\n**Examples:**\n- Upstream pipeline didn't run\n- Data format changed incompatibly\n- Event lost between systems\n- Timing dependency violated\n\n**Code patterns:**\n```typescript\nconst schema = await getSourceSchema(id);  // Depends on P1\n```\n\n## Dimension 2: Type (WHAT)\n\nWhat category of failure is it?\n\n### T1: Data\nProblem with the data itself.\n\n**Examples:**\n- Null/undefined value\n- Wrong data type\n- Stale/outdated data\n- Malformed structure\n\n### T2: Logic\nProblem with the code logic.\n\n**Examples:**\n- Algorithm bug\n- Wrong conditional branch\n- Off-by-one error\n- Race condition\n\n### T3: Infrastructure\nProblem with systems/services.\n\n**Examples:**\n- Network timeout\n- Rate limit exceeded\n- Service unavailable\n- Resource exhausted\n\n### T4: Quality\nTechnically succeeds but output is bad.\n\n**Examples:**\n- Generated text is generic\n- Image is low resolution\n- Response time too slow\n- Results not relevant\n\n### T5: UX\nTechnically works but experience is broken.\n\n**Examples:**\n- No loading indicator\n- Error message is confusing\n- Success not confirmed\n- State not updated\n\n## Dimension 3: Severity (HOW BAD)\n\nHow serious is the impact?\n\n### S1: Silent\nFailure happens but no one knows.\n\n**Characteristics:**\n- No error thrown\n- Bad data persists\n- User proceeds unaware\n- Discovered much later\n\n**Risk:** HIGHEST — problems accumulate\n\n### S2: Partial\nSome data correct, some wrong.\n\n**Characteristics:**\n- Mixed results\n- Partial success\n- Inconsistent state\n- Confusing situation\n\n**Risk:** HIGH — data corruption possible\n\n### S3: Visible\nError is shown but unclear.\n\n**Characteristics:**\n- Error message displayed\n- User knows something's wrong\n- May not know what to do\n- Operation didn't complete\n\n**Risk:** MEDIUM — user aware but stuck\n\n### S4: Blocking\nCannot proceed at all.\n\n**Characteristics:**\n- Operation fails completely\n- Clear error state\n- User cannot continue\n- Must seek help or retry\n\n**Risk:** LOW — obvious, usually handled\n\n## Classification Examples\n\n| Failure | Location | Type | Severity |\n|---------|----------|------|----------|\n| Missing required field | L1-Input | T1-Data | S3-Visible |\n| Off-by-one in loop | L2-Processing | T2-Logic | S1-Silent |\n| DB connection timeout | L3-Output | T3-Infra | S4-Blocking |\n| Generic AI output | L2-Processing | T4-Quality | S1-Silent |\n| No loading spinner | L3-Output | T5-UX | S3-Visible |\n| Upstream data stale | L4-Integration | T1-Data | S1-Silent |\n"
    },
    {
      "name": "validation-checking.md",
      "path": "references/validation-checking.md",
      "content": "# Validation Checking\n\nHow to determine if a failure mode is validated.\n\n## Definition of Validated\n\nA failure mode is **validated** when the system explicitly handles it, either through:\n1. Code that catches and handles the failure\n2. Tests that verify the failure is handled\n\n## Code Validation Patterns\n\n### Explicit Error Handling\n```typescript\n// VALIDATED: Specific catch for this failure\ntry {\n  await uploadFile(file);\n} catch (error) {\n  if (error.code === 'FILE_TOO_LARGE') {\n    return { error: 'File exceeds 10MB limit' };\n  }\n  throw error;  // Re-throw unknown errors\n}\n```\n\n### Input Validation\n```typescript\n// VALIDATED: Rejects bad input before processing\nif (!file.type.startsWith('text/')) {\n  throw new ValidationError('Only text files supported');\n}\n```\n\n### Retry Logic\n```typescript\n// VALIDATED: Handles transient failures\nconst result = await retry(\n  () => callExternalAPI(data),\n  { retries: 3, delay: 1000 }\n);\n```\n\n### Fallback Behavior\n```typescript\n// VALIDATED: Graceful degradation\nconst schema = await getSchema(id).catch(() => DEFAULT_SCHEMA);\n```\n\n## Test Validation Patterns\n\n### Direct Test Coverage\n```typescript\n// VALIDATED: Test specifically covers this failure\ntest('rejects files over 10MB', async () => {\n  const largeFile = createLargeFile(15_000_000);\n  await expect(upload(largeFile)).rejects.toThrow('exceeds limit');\n});\n```\n\n### Edge Case Test\n```typescript\n// VALIDATED: Test covers edge case\ntest('handles empty source schema', async () => {\n  const result = await generate({ sourceId: emptySourceId });\n  expect(result.content).toBeDefined();  // Uses fallback\n});\n```\n\n## NOT Validated\n\n### Generic Catch\n```typescript\n// NOT VALIDATED: Generic, doesn't handle specific failure\ntry {\n  await process(data);\n} catch (error) {\n  console.error(error);\n  throw error;\n}\n```\n\n### Silent Ignore\n```typescript\n// NOT VALIDATED: Swallows error without handling\ntry {\n  await optional();\n} catch {\n  // Ignore\n}\n```\n\n### No Handling\n```typescript\n// NOT VALIDATED: No try-catch, failure crashes\nconst result = await riskyOperation();\n```\n\n### Happy Path Only\n```typescript\n// NOT VALIDATED: Test only covers success\ntest('generates content', async () => {\n  const result = await generate(validInput);\n  expect(result).toBeDefined();\n});\n// No test for invalid input!\n```\n\n## Validation Checklist\n\nFor each failure mode, check:\n\n- [ ] Is there a try-catch that specifically handles this case?\n- [ ] Is there input validation that prevents this case?\n- [ ] Is there a test that exercises this failure?\n- [ ] Does retry/fallback logic cover this case?\n\nIf ANY of these is true, mark as **VALIDATED**.\nIf NONE of these is true, mark as **UNVALIDATED**.\n\n## Partial Validation\n\nSometimes a failure is partially handled:\n\n```typescript\n// PARTIALLY VALIDATED: Catches but doesn't fully handle\ntry {\n  await process(data);\n} catch (error) {\n  logger.error(error);  // Logged but not recovered\n  throw error;\n}\n```\n\nMark as **UNVALIDATED** with note: \"Logged but not handled\"\n"
    }
  ],
  "tags": [
    "audit",
    "failure-modes",
    "mece",
    "backend",
    "analysis"
  ],
  "dependsOn": [
    "pipeline-discovery"
  ]
}