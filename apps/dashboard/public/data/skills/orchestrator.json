{
  "id": "orchestrator",
  "name": "orchestrator",
  "version": "1.0.0",
  "description": "Unified development orchestration across greenfield and brownfield modes. Detects project mode, performs pre-loop scope discovery, spawns parallel sub-agents, and coordinates execution to minimize loops needed to reach production-quality.",
  "phase": "META",
  "category": "meta",
  "content": "# Orchestrator\n\nThe unified entry point for autonomous development.\n\n## When to Use\n\n- **Any development work** — Orchestrator detects the right mode automatically\n- **Fresh directory** — Greenfield mode: get 80% of the way to working app\n- **Near-complete app** — Brownfield-polish mode: deploy, UI/UX, data integrity\n- **Enterprise codebase** — Brownfield-enterprise mode: surgical, pattern-conforming\n- **Parallel systems** — Spawn 6-7 sub-agents on independent work\n- **Slash command** — User invokes `/orchestrator` to start\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `mode-detection.md` | Signal taxonomy for mode classification |\n| `scope-discovery.md` | Pre-loop gap analysis |\n| `parallel-agents.md` | Sub-agent coordination patterns |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `../engineering-harness/references/loop-phases.md` | When executing engineering loop phases |\n| `loop-state-template.md` | When initializing or resuming orchestration |\n| `failure-taxonomy.md` | When handling failures systematically |\n| `ui-ux-verification.md` | When in brownfield-polish mode |\n| `data-verification.md` | When verifying data integrity |\n\n**Verification:** Ensure mode is detected and confirmed before execution.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Mode detection | `loop-state.json` | Always |\n| Scope discovery | `SCOPE-DISCOVERY.md` | Always |\n| Estimate | `ESTIMATE.md` | Always |\n| Codebase analysis | `CODEBASE-ANALYSIS.md` | Brownfield modes |\n| Feature spec | `FEATURESPEC.md` | If creating new system |\n\n## Core Concept\n\nOrchestrator answers: **\"What mode should I use, what needs to be done, and how do I minimize loops to get there?\"**\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                         ORCHESTRATOR FLOW                                    │\n│                                                                             │\n│  User invokes /orchestrator                                                 │\n│       │                                                                     │\n│       ▼                                                                     │\n│  ┌──────────────────┐                                                       │\n│  │ 1. DETECT MODE   │  Analyze signals, classify project                    │\n│  │                  │  → greenfield | brownfield-polish | brownfield-enterprise\n│  └────────┬─────────┘  → confirm with user                                  │\n│           │                                                                 │\n│           ▼                                                                 │\n│  ┌──────────────────┐                                                       │\n│  │ 2. DISCOVER      │  Pre-loop scope analysis                              │\n│  │    SCOPE         │  → gaps, systems, estimated loops                     │\n│  └────────┬─────────┘  → \"everything that needs to be done\"                 │\n│           │                                                                 │\n│           ▼                                                                 │\n│  ┌──────────────────┐                                                       │\n│  │ 3. PLAN          │  Decompose into independent systems                   │\n│  │    EXECUTION     │  → identify parallelizable work                       │\n│  └────────┬─────────┘  → sequence dependent work                            │\n│           │                                                                 │\n│           ▼                                                                 │\n│  ┌──────────────────┐                                                       │\n│  │ 4. SPAWN         │  Create sub-agents for parallel work                  │\n│  │    SUB-AGENTS    │  → each in own worktree                               │\n│  └────────┬─────────┘  → coordinate via shared state                        │\n│           │                                                                 │\n│           ▼                                                                 │\n│  ┌──────────────────┐                                                       │\n│  │ 5. EXECUTE       │  Run loop with mode-aware skills                      │\n│  │    LOOP          │  → stage gates queue for human                        │\n│  └────────┬─────────┘  → calibration feeds future loops                     │\n│           │                                                                 │\n│           ▼                                                                 │\n│  ┌──────────────────┐                                                       │\n│  │ 6. RETROSPECT    │  Learn from this loop                                 │\n│  │    & ITERATE     │  → update scope if more loops needed                  │\n│  └────────┬─────────┘  → fewer loops = more success                         │\n│           │                                                                 │\n│           ▼                                                                 │\n│  Done: Production-quality result                                            │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n## Quick Start: Execution Checklist\n\nWhen `/orchestrator` is invoked, execute these steps in order:\n\n### Phase 1: Detect Mode\n- [ ] Gather signals (files, git, CI/CD, tests, docs, process artifacts)\n- [ ] Weight and score each mode\n- [ ] Present detection to user with confidence %\n- [ ] Get user confirmation or override\n- [ ] Write mode to `loop-state.json`\n\n### Phase 2: Discover Scope\n- [ ] Run mode-specific gap analysis\n- [ ] Create `SCOPE-DISCOVERY.md` with gaps by severity\n- [ ] Identify parallelizable work\n- [ ] Estimate loops to completion\n- [ ] Get user approval on scope\n\n### Phase 3: Plan Execution\n- [ ] Decompose into independent systems\n- [ ] Identify sequential dependencies\n- [ ] Plan worktree strategy for parallel work\n- [ ] Document execution plan\n\n### Phase 4: Execute Loop\n- [ ] For each system (parallel or sequential):\n  - [ ] Create worktree if parallel\n  - [ ] Run: SCAFFOLD → IMPLEMENT → TEST → VERIFY → VALIDATE → DOCUMENT → REVIEW\n  - [ ] Request stage gates at checkpoints\n  - [ ] Update coordination files\n- [ ] Merge completed work\n- [ ] Run full test suite\n\n### Phase 5: Ship & Retrospect\n- [ ] Final validation\n- [ ] Deploy (if polish/enterprise mode)\n- [ ] Run retrospective\n- [ ] Update calibration data\n- [ ] Decide if another loop needed\n\n→ See `references/loop-state-template.md` for initial loop-state.json structure\n\n## The Three Modes\n\n### Greenfield Mode\n\n**Trigger:** Fresh directory, no existing code\n\n**Goal:** Get 80% of the way to a working app in one loop\n\n**Behavior:**\n- Full system creation from scratch\n- Uses entry-portal for vision capture\n- Generates complete feature spec\n- Scaffolds entire project structure\n- Implements core capabilities\n- Defers deployment (user can skip)\n- Produces working app skeleton\n\n**Success criteria:**\n- App runs locally\n- Core features work\n- Tests pass\n- Ready for polish loop\n\n### Brownfield-Polish Mode\n\n**Trigger:** Small/medium codebase, near completion signals\n\n**Goal:** Ship a production-ready, polished app\n\n**Behavior:**\n- Auto-discovers what's missing\n- Focuses on deployment setup\n- Ensures UI/UX is beautiful (dark mode, responsive)\n- Validates all data flows correctly\n- Fills documentation gaps\n- Runs security/perf checks\n\n**Success criteria:**\n- Deployed to production\n- UI/UX is polished\n- All data flows verified\n- Documentation complete\n- Security audit passed\n\n### Brownfield-Enterprise Mode\n\n**Trigger:** Large codebase, team signals, process artifacts\n\n**Goal:** Surgical integration matching existing quality\n\n**Behavior:**\n- Thorough codebase analysis first\n- Follows existing patterns exactly\n- Coordinates with other engineers/agents\n- Highest-leverage work prioritized\n- Surgical changes, no collateral impact\n- Full quality gauntlet\n\n**Success criteria:**\n- PR matches codebase quality\n- No pattern violations\n- No regressions\n- Coordinated merge\n\n## Step 1: Mode Detection\n\nInvoke the `mode-detector` skill to classify the project.\n\n### Detection Algorithm\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                       MODE DETECTION ALGORITHM                               │\n│                                                                             │\n│  1. GATHER SIGNALS                                                          │\n│     • File count, LOC                                                       │\n│     • Git history depth, contributors                                       │\n│     • CI/CD presence                                                        │\n│     • Test coverage                                                         │\n│     • Documentation state                                                   │\n│     • Process artifacts (CODEOWNERS, PR templates, ADRs)                    │\n│                                                                             │\n│  2. WEIGHT SIGNALS                                                          │\n│     • Each signal has a weight and mode indicator                           │\n│     • Sum weights per mode                                                  │\n│                                                                             │\n│  3. CLASSIFY                                                                │\n│     • Highest weighted mode wins                                            │\n│     • Calculate confidence (margin between top two)                         │\n│                                                                             │\n│  4. CONFIRM                                                                 │\n│     • Present detection to user                                             │\n│     • Allow override                                                        │\n│     • Store in loop-state.json                                              │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Output Format\n\n```\nMode Detection Results:\n\n  Detected: brownfield-polish\n  Confidence: 87%\n\n  Signals:\n    [greenfield]  (0 points)\n    [polish]      47 files, <10k LOC         (+0.3)\n                  23 commits, 1 contributor  (+0.4)\n                  No CI/CD configuration     (+0.5)\n                  No deployment scripts      (+0.5)\n                  Basic tests present        (+0.3)\n                  ─────────────────────────\n                  Total: 2.0\n\n    [enterprise]  (0.4 points)\n                  Has README                 (+0.2)\n                  Has package.json           (+0.2)\n\n  Confirm mode? [Y/n/change]:\n```\n\n→ See `references/mode-detection.md` for full signal taxonomy\n\n## Step 2: Scope Discovery\n\nAnalyze the codebase to identify everything that needs to be done.\n\n### Discovery Process\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                       SCOPE DISCOVERY PROCESS                                │\n│                                                                             │\n│  GREENFIELD:                                                                │\n│  • Capture vision (entry-portal)                                            │\n│  • Generate system list                                                     │\n│  • Create feature specs                                                     │\n│  • Estimate scope                                                           │\n│                                                                             │\n│  BROWNFIELD-POLISH:                                                         │\n│  • Scan for deployment gaps                                                 │\n│  • Analyze UI/UX state                                                      │\n│  • Check data flow completeness                                             │\n│  • Find documentation gaps                                                  │\n│  • Identify security/perf issues                                            │\n│                                                                             │\n│  BROWNFIELD-ENTERPRISE:                                                     │\n│  • Deep codebase analysis                                                   │\n│  • Pattern extraction                                                       │\n│  • Dependency mapping                                                       │\n│  • Integration point identification                                         │\n│  • Roadmap generation                                                       │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Gap Categories (MECE)\n\n| Category | What to Check |\n|----------|---------------|\n| **Deployment** | CI/CD, hosting, env vars, secrets |\n| **UI/UX** | Dark mode, responsive, accessibility, polish |\n| **Data** | Schema complete, CRUD works, validation |\n| **Testing** | Unit, integration, E2E coverage |\n| **Documentation** | README, API docs, architecture |\n| **Security** | Auth, input validation, secrets handling |\n\n### Output: SCOPE-DISCOVERY.md\n\n```markdown\n# Scope Discovery: {project}\n\n## Mode\nbrownfield-polish (confirmed)\n\n## Gaps Found\n\n### Critical\n- [ ] No deployment configuration\n- [ ] Database not initialized in production\n\n### High\n- [ ] UI needs dark mode styling\n- [ ] Data validation incomplete on 3 forms\n\n### Medium\n- [ ] Missing integration tests for API\n- [ ] README needs usage examples\n\n### Low\n- [ ] No API documentation\n- [ ] Console warnings in dev mode\n\n## Systems to Build/Fix\n\n| System | Type | Priority | Parallelizable |\n|--------|------|----------|----------------|\n| Deployment | Gap-fill | Critical | No (sequential) |\n| UI Polish | Gap-fill | High | Yes |\n| Data Validation | Gap-fill | High | Yes |\n| Testing | Gap-fill | Medium | Yes |\n| Documentation | Gap-fill | Low | Yes |\n\n## Estimated Loops\n2 loops to completion\n\n## Recommended Approach\n1. Loop 1: Deployment + UI + Data (parallel where possible)\n2. Loop 2: Testing + Documentation + Final polish\n```\n\n→ See `references/scope-discovery.md` for detailed analysis patterns\n\n## Step 3: Plan Execution\n\nDecompose work into parallelizable units.\n\n### Parallelization Rules\n\n1. **Independent systems** can run in parallel\n2. **Dependent systems** must be sequenced\n3. **Shared resources** require locking\n4. **Max 7 sub-agents** recommended (resource limit)\n\n### Execution Plan Format\n\n```\nExecution Plan:\n\n  Loop 1:\n    Sequential:\n      [1] Deployment setup (blocks everything else in prod)\n\n    Parallel (after deployment):\n      [2a] UI Polish        → Agent 1, worktree: .worktrees/ui-polish\n      [2b] Data Validation  → Agent 2, worktree: .worktrees/data-validation\n      [2c] API Tests        → Agent 3, worktree: .worktrees/api-tests\n\n  Loop 2 (if needed):\n    Parallel:\n      [3a] Documentation    → Agent 1\n      [3b] Final polish     → Agent 2\n\n  Stage Gates:\n    • After deployment: verify prod access\n    • After UI: visual review\n    • After each agent: merge coordination\n```\n\n## Step 4: Spawn Sub-Agents\n\nFor parallel work, spawn sub-agents via the Task tool.\n\n### Sub-Agent Spawn Protocol\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                       SUB-AGENT SPAWN PROTOCOL                               │\n│                                                                             │\n│  1. CREATE WORKTREE                                                         │\n│     git worktree add .worktrees/{system-name} -b feature/{system-name}      │\n│                                                                             │\n│  2. PREPARE CONTEXT                                                         │\n│     • System-specific feature spec                                          │\n│     • Mode context (from orchestrator)                                      │\n│     • Coordination file paths                                               │\n│                                                                             │\n│  3. SPAWN VIA TASK TOOL                                                     │\n│     Task(                                                                   │\n│       subagent_type: \"general-purpose\",                                     │\n│       run_in_background: true,                                              │\n│       prompt: [system spec + coordination instructions]                     │\n│     )                                                                       │\n│                                                                             │\n│  4. TRACK IN LOOP-STATE                                                     │\n│     • Agent ID                                                              │\n│     • Output file path                                                      │\n│     • Status: spawning → running → waiting-gate → completed                 │\n│                                                                             │\n│  5. MONITOR                                                                 │\n│     • Check output files periodically                                       │\n│     • Watch for gate requests                                               │\n│     • Coordinate merges                                                     │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Sub-Agent Prompt Template\n\n```markdown\nYou are a sub-agent of the orchestrator working on: {system-name}\n\n## Mode\n{mode} (inherited from orchestrator)\n\n## Your Worktree\n{worktree-path}\n\n## Your Task\n{system-specific-feature-spec}\n\n## Coordination\n- Update progress in: {coordination-path}/agents/{agent-id}.json\n- Request gates by writing to: {coordination-path}/gates-pending.json\n- Check locks before modifying shared files: {coordination-path}/locks.json\n\n## Rules\n1. Stay in your worktree\n2. Follow mode-specific patterns\n3. Request gate approval at checkpoints\n4. Update your status file on completion\n\nBegin execution.\n```\n\n→ See `references/parallel-agents.md` for detailed coordination patterns\n\n## Step 5: Execute Loop\n\nRun the engineering loop with mode-aware behavior.\n\n→ See `../engineering-harness/references/loop-phases.md` for detailed phase guidance (SCAFFOLD → IMPLEMENT → TEST → VERIFY → VALIDATE → DOCUMENT → REVIEW → SHIP), including rework patterns, phase checklists, and brownfield adaptations.\n\n### Mode-Aware Skill Invocation\n\n| Skill | Greenfield | Polish | Enterprise |\n|-------|------------|--------|------------|\n| `entry-portal` | Full vision capture | Skip | Skip |\n| `spec` | Full 18-section | Gap-focused | Surgical scope |\n| `scaffold` | Full structure | Extend only | Minimal touch |\n| `implement` | Build everything | Fix gaps | Pattern-match |\n| `frontend-design` | Basic styling | Dark mode + polish | Match existing |\n| `test-generation` | Core tests | Gap coverage | Match existing |\n| `code-verification` | Standard | Standard | Strict pattern check |\n| `security-audit` | Basic | Full | Full + compliance |\n| `deploy` | Optional/skip | Required | Use existing |\n\n### Stage Gates\n\nAt each gate, sub-agents pause and queue for human review:\n\n```json\n// coordination/gates-pending.json\n{\n  \"gates\": [\n    {\n      \"id\": \"gate-001\",\n      \"agent\": \"agent-ui-polish\",\n      \"type\": \"visual-review\",\n      \"description\": \"UI styling complete, ready for visual review\",\n      \"artifacts\": [\"screenshots/home.png\", \"screenshots/dashboard.png\"],\n      \"requestedAt\": \"2026-01-20T15:30:00Z\",\n      \"status\": \"pending\"\n    }\n  ]\n}\n```\n\nHuman reviews and approves:\n```bash\n# Orchestrator prompts user with queued gates\nGate pending: UI visual review (agent-ui-polish)\n  Artifacts: screenshots/home.png, screenshots/dashboard.png\n\n  Approve? [Y/n/feedback]:\n```\n\n## Step 6: Retrospect & Iterate\n\nAfter each loop, run retrospective and calibration.\n\n### Post-Loop Actions\n\n1. **Retrospective** — What worked, what didn't\n2. **Calibration** — Record actual vs estimated\n3. **Scope update** — What remains for next loop\n4. **Decision** — Another loop needed?\n\n### Loop Completion Check\n\n```\nLoop 1 Complete:\n\n  Completed:\n    [x] Deployment configuration\n    [x] UI dark mode styling\n    [x] Data validation\n\n  Remaining:\n    [ ] Integration tests (medium priority)\n    [ ] Documentation (low priority)\n\n  Metrics:\n    • Estimated: 4 hours\n    • Actual: 3.5 hours\n    • Calibration: 0.875x (slightly overestimated)\n\n  Recommendation: Run Loop 2 for remaining items\n\n  Proceed with Loop 2? [Y/n/done]:\n```\n\n## Skills Invoked\n\nThe orchestrator coordinates these skills based on mode:\n\n```\norchestrator\n├── mode-detector (always first)\n├── entry-portal (greenfield only)\n├── spec\n├── estimation\n├── architect (if needed)\n├── scaffold\n├── implement\n├── frontend-design (polish mode)\n├── test-generation\n├── code-verification\n├── code-validation\n├── integration-test\n├── security-audit\n├── perf-analysis\n├── document\n├── code-review\n├── deploy (required for polish)\n├── retrospective\n└── calibration-tracker\n```\n\n## Invoking the Orchestrator\n\n### Basic Invocation\n\n```\nUser: /orchestrator\n\nOrchestrator: Analyzing project...\n\nMode Detection:\n  Detected: brownfield-polish (87% confidence)\n  Confirm? [Y/n/change]: y\n\nScope Discovery:\n  Found 6 gaps across 4 categories\n  Estimated: 2 loops\n\nExecution Plan:\n  Loop 1: Deployment + UI + Data (3 parallel agents)\n  Loop 2: Testing + Docs\n\nProceed? [Y/n]: y\n\nSpawning agents...\n  [1/3] agent-deployment started\n  [2/3] agent-ui-polish started\n  [3/3] agent-data-validation started\n\nMonitoring... (Ctrl+C to pause)\n```\n\n### With Mode Override\n\n```\nUser: /orchestrator --mode=greenfield\n\nOrchestrator: Mode override: greenfield\n  Skipping detection, proceeding with greenfield flow...\n```\n\n### Resume After Interruption\n\n```\nUser: /orchestrator --resume\n\nOrchestrator: Resuming from loop-state.json...\n  Mode: brownfield-polish\n  Loop: 1\n  Progress: 2/3 agents complete\n\n  Continuing...\n```\n\n## Key Principles\n\n**Detect before assuming.** Let signals guide mode selection, but always confirm.\n\n**Discover before executing.** Pre-loop scope discovery minimizes surprises.\n\n**Parallelize when safe.** Independent work should run concurrently.\n\n**Gate for quality.** Human checkpoints ensure nothing slips through.\n\n**Learn from each loop.** Calibration and retrospectives improve future runs.\n\n**Minimize loops.** The fewer loops to \"done\", the better the orchestrator is working.\n\n## Design Note: No Mode-Specific Behavior Section\n\nThis skill intentionally does not have a \"Mode-Specific Behavior\" section like other skills in the library. The orchestrator is the **source** of mode-awareness—it detects the mode and then instructs other skills how to behave. The orchestrator's behavior is the same regardless of mode: detect → configure → execute → verify → complete.\n\nThe mode-specific behavior logic is contained in this skill's core documentation and references, which define how other skills should adapt based on the detected mode. See `references/mode-detection.md` for the mode detection algorithm and `references/scope-discovery.md` for mode-specific scope handling.\n\n## References\n\n- `references/mode-detection.md`: Signal taxonomy and detection algorithm\n- `references/scope-discovery.md`: Gap analysis by mode\n- `references/parallel-agents.md`: Sub-agent coordination patterns\n- `references/failure-taxonomy.md`: MECE failure classification\n- `references/ui-ux-verification.md`: UI/UX quality checks\n- `references/data-verification.md`: Data integrity verification\n- `references/mode-behavior-standard.md`: Standardized 6-aspect mode behavior template",
  "references": [
    {
      "name": "data-verification.md",
      "path": "references/data-verification.md",
      "content": "# Data Verification Reference\n\nEnsuring data integrity across the application.\n\n---\n\n## Purpose\n\nData verification ensures:\n1. **Schema completeness** — All required fields/tables exist\n2. **CRUD operations work** — Create, Read, Update, Delete functional\n3. **Validation enforced** — Bad data rejected at boundaries\n4. **Data flows correctly** — Static and dynamic data populate properly\n\n---\n\n## Verification Categories (MECE)\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                    DATA VERIFICATION CATEGORIES                              │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                             │\n│  1. SCHEMA VERIFICATION                                                     │\n│     └── Tables, columns, types, constraints                                 │\n│                                                                             │\n│  2. SEED DATA VERIFICATION                                                  │\n│     └── Initial data, test fixtures, demo data                              │\n│                                                                             │\n│  3. CRUD VERIFICATION                                                       │\n│     └── Create, Read, Update, Delete operations                             │\n│                                                                             │\n│  4. VALIDATION VERIFICATION                                                 │\n│     └── Input validation, type coercion, constraints                        │\n│                                                                             │\n│  5. RELATIONSHIP VERIFICATION                                               │\n│     └── Foreign keys, joins, cascades                                       │\n│                                                                             │\n│  6. FLOW VERIFICATION                                                       │\n│     └── Data through the system, state transitions                          │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 1. Schema Verification\n\n### Checks\n\n| Check | How to Verify | Expected |\n|-------|---------------|----------|\n| Schema file exists | `ls prisma/schema.prisma` | File present |\n| Schema valid | `npx prisma validate` | No errors |\n| Migrations exist | `ls prisma/migrations/` | Migration folders |\n| DB in sync | `npx prisma migrate status` | All applied |\n| Types generated | `ls node_modules/.prisma/client` | Generated client |\n\n### Schema Completeness Checklist\n\n```\nSchema Verification\n═══════════════════\n\nModels\n  [ ] All required models defined\n  [ ] Primary keys on all models\n  [ ] Created/updated timestamps\n  [ ] Soft delete if needed\n\nFields\n  [ ] All required fields present\n  [ ] Correct types (String, Int, etc.)\n  [ ] Nullable fields marked optional\n  [ ] Default values where appropriate\n\nRelationships\n  [ ] Foreign keys defined\n  [ ] Relation fields present\n  [ ] Cascade behavior specified\n\nIndexes\n  [ ] Primary key indexes (automatic)\n  [ ] Foreign key indexes\n  [ ] Query-specific indexes\n  [ ] Unique constraints\n\nEnums\n  [ ] Status fields use enums\n  [ ] Enum values comprehensive\n```\n\n### Schema Verification Script\n\n```bash\n#!/bin/bash\n# verify-schema.sh\n\necho \"Schema Verification\"\necho \"===================\"\n\n# Check schema exists\nif [ -f \"prisma/schema.prisma\" ]; then\n  echo \"✓ Schema file exists\"\nelse\n  echo \"✗ Schema file missing\"\n  exit 1\nfi\n\n# Validate schema\nif npx prisma validate 2>/dev/null; then\n  echo \"✓ Schema is valid\"\nelse\n  echo \"✗ Schema has errors\"\n  exit 1\nfi\n\n# Check migration status\nif npx prisma migrate status 2>/dev/null | grep -q \"applied\"; then\n  echo \"✓ Migrations applied\"\nelse\n  echo \"⚠ Check migration status\"\nfi\n\n# Check generated client\nif [ -d \"node_modules/.prisma/client\" ]; then\n  echo \"✓ Client generated\"\nelse\n  echo \"⚠ Run prisma generate\"\nfi\n\necho \"Done\"\n```\n\n---\n\n## 2. Seed Data Verification\n\n### Checks\n\n| Check | How to Verify | Expected |\n|-------|---------------|----------|\n| Seed script exists | `grep seed package.json` | Script defined |\n| Seed runs | `npm run seed` | No errors |\n| Data created | Query database | Expected rows |\n| Idempotent | Run seed twice | No duplicates/errors |\n\n### Seed Data Requirements\n\n```javascript\n// prisma/seed.ts - Example structure\n\nasync function main() {\n  // 1. Clear existing data (dev only)\n  await prisma.item.deleteMany();\n  await prisma.user.deleteMany();\n\n  // 2. Create reference data\n  const adminRole = await prisma.role.upsert({\n    where: { name: 'admin' },\n    update: {},\n    create: { name: 'admin', permissions: ['all'] }\n  });\n\n  // 3. Create test users\n  const testUser = await prisma.user.create({\n    data: {\n      email: 'test@example.com',\n      name: 'Test User',\n      roleId: adminRole.id\n    }\n  });\n\n  // 4. Create sample data\n  await prisma.item.createMany({\n    data: [\n      { name: 'Item 1', userId: testUser.id },\n      { name: 'Item 2', userId: testUser.id },\n      { name: 'Item 3', userId: testUser.id },\n    ]\n  });\n\n  console.log('Seed complete');\n}\n```\n\n### Seed Verification Script\n\n```bash\n#!/bin/bash\n# verify-seed.sh\n\necho \"Seed Data Verification\"\necho \"======================\"\n\n# Run seed\nif npm run seed 2>&1 | grep -q \"Seed complete\"; then\n  echo \"✓ Seed ran successfully\"\nelse\n  echo \"✗ Seed failed\"\n  exit 1\nfi\n\n# Verify data exists (example queries)\nUSER_COUNT=$(npx prisma db execute --stdin <<< \"SELECT COUNT(*) FROM users\" 2>/dev/null)\nif [ \"$USER_COUNT\" -gt 0 ]; then\n  echo \"✓ Users created: $USER_COUNT\"\nelse\n  echo \"✗ No users created\"\nfi\n\n# Test idempotency\nif npm run seed 2>&1 | grep -q \"Seed complete\"; then\n  echo \"✓ Seed is idempotent\"\nelse\n  echo \"✗ Seed not idempotent\"\nfi\n\necho \"Done\"\n```\n\n---\n\n## 3. CRUD Verification\n\n### Verification Matrix\n\n| Entity | Create | Read | Update | Delete | Test |\n|--------|--------|------|--------|--------|------|\n| User | ✓/✗ | ✓/✗ | ✓/✗ | ✓/✗ | `test:user` |\n| Item | ✓/✗ | ✓/✗ | ✓/✗ | ✓/✗ | `test:item` |\n| ... | | | | | |\n\n### CRUD Test Template\n\n```typescript\n// tests/user.crud.test.ts\n\ndescribe('User CRUD', () => {\n  describe('Create', () => {\n    it('creates a user with valid data', async () => {\n      const user = await createUser({\n        email: 'new@example.com',\n        name: 'New User'\n      });\n      expect(user.id).toBeDefined();\n      expect(user.email).toBe('new@example.com');\n    });\n\n    it('rejects invalid email', async () => {\n      await expect(createUser({\n        email: 'invalid',\n        name: 'Test'\n      })).rejects.toThrow();\n    });\n  });\n\n  describe('Read', () => {\n    it('reads a user by id', async () => {\n      const user = await getUser(testUserId);\n      expect(user).not.toBeNull();\n    });\n\n    it('returns null for non-existent id', async () => {\n      const user = await getUser('non-existent');\n      expect(user).toBeNull();\n    });\n\n    it('lists all users', async () => {\n      const users = await listUsers();\n      expect(users.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Update', () => {\n    it('updates user name', async () => {\n      const updated = await updateUser(testUserId, {\n        name: 'Updated Name'\n      });\n      expect(updated.name).toBe('Updated Name');\n    });\n\n    it('rejects invalid update', async () => {\n      await expect(updateUser(testUserId, {\n        email: 'invalid'\n      })).rejects.toThrow();\n    });\n  });\n\n  describe('Delete', () => {\n    it('deletes a user', async () => {\n      await deleteUser(testUserId);\n      const user = await getUser(testUserId);\n      expect(user).toBeNull();\n    });\n\n    it('handles delete of non-existent gracefully', async () => {\n      await expect(deleteUser('non-existent')).resolves.not.toThrow();\n    });\n  });\n});\n```\n\n### API CRUD Verification\n\n```bash\n# Manual API testing\n\n# Create\ncurl -X POST http://localhost:3000/api/users \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"test@example.com\", \"name\": \"Test\"}'\n\n# Read\ncurl http://localhost:3000/api/users/1\n\n# Read all\ncurl http://localhost:3000/api/users\n\n# Update\ncurl -X PUT http://localhost:3000/api/users/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"Updated\"}'\n\n# Delete\ncurl -X DELETE http://localhost:3000/api/users/1\n```\n\n---\n\n## 4. Validation Verification\n\n### Validation Layers\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                      VALIDATION LAYERS                                       │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                             │\n│  CLIENT SIDE (UI)                                                           │\n│  └── HTML5 validation, form libraries                                       │\n│      • required, type=\"email\", min, max                                     │\n│      • Nice UX, but can be bypassed                                         │\n│                                                                             │\n│  API LAYER                                                                  │\n│  └── Schema validation (Zod, Yup, Joi)                                      │\n│      • Parse and validate all inputs                                        │\n│      • Return clear error messages                                          │\n│      • MUST validate here                                                   │\n│                                                                             │\n│  DATABASE LAYER                                                             │\n│  └── Constraints, types, foreign keys                                       │\n│      • Last line of defense                                                 │\n│      • Catch anything that slipped through                                  │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Validation Schema Example (Zod)\n\n```typescript\n// schemas/user.ts\nimport { z } from 'zod';\n\nexport const createUserSchema = z.object({\n  email: z.string().email('Invalid email format'),\n  name: z.string().min(1, 'Name required').max(100, 'Name too long'),\n  age: z.number().int().positive().optional(),\n});\n\nexport const updateUserSchema = createUserSchema.partial();\n\n// Usage in API\nexport async function POST(request: Request) {\n  const body = await request.json();\n\n  const result = createUserSchema.safeParse(body);\n  if (!result.success) {\n    return Response.json({\n      error: 'Validation failed',\n      details: result.error.issues\n    }, { status: 400 });\n  }\n\n  const user = await createUser(result.data);\n  return Response.json(user, { status: 201 });\n}\n```\n\n### Validation Test Cases\n\n```typescript\ndescribe('User Validation', () => {\n  describe('Email', () => {\n    it('accepts valid email', () => {\n      expect(createUserSchema.safeParse({\n        email: 'valid@example.com',\n        name: 'Test'\n      }).success).toBe(true);\n    });\n\n    it('rejects invalid email', () => {\n      expect(createUserSchema.safeParse({\n        email: 'invalid',\n        name: 'Test'\n      }).success).toBe(false);\n    });\n\n    it('rejects missing email', () => {\n      expect(createUserSchema.safeParse({\n        name: 'Test'\n      }).success).toBe(false);\n    });\n  });\n\n  describe('Name', () => {\n    it('accepts valid name', () => {\n      expect(createUserSchema.safeParse({\n        email: 'test@example.com',\n        name: 'Valid Name'\n      }).success).toBe(true);\n    });\n\n    it('rejects empty name', () => {\n      expect(createUserSchema.safeParse({\n        email: 'test@example.com',\n        name: ''\n      }).success).toBe(false);\n    });\n\n    it('rejects name over 100 chars', () => {\n      expect(createUserSchema.safeParse({\n        email: 'test@example.com',\n        name: 'a'.repeat(101)\n      }).success).toBe(false);\n    });\n  });\n});\n```\n\n---\n\n## 5. Relationship Verification\n\n### Checks\n\n| Relationship | Type | Cascade | Test |\n|--------------|------|---------|------|\n| User → Items | 1:many | Delete items | Delete user, check items |\n| Item → User | many:1 | Restrict | Delete user with items |\n| ... | | | |\n\n### Relationship Tests\n\n```typescript\ndescribe('Relationships', () => {\n  describe('User → Items', () => {\n    it('user has many items', async () => {\n      const user = await getUserWithItems(userId);\n      expect(user.items).toBeInstanceOf(Array);\n    });\n\n    it('deleting user cascades to items', async () => {\n      const user = await createUserWithItems();\n      const itemIds = user.items.map(i => i.id);\n\n      await deleteUser(user.id);\n\n      for (const itemId of itemIds) {\n        const item = await getItem(itemId);\n        expect(item).toBeNull();\n      }\n    });\n  });\n\n  describe('Foreign Key Integrity', () => {\n    it('cannot create item with invalid userId', async () => {\n      await expect(createItem({\n        name: 'Test',\n        userId: 'non-existent'\n      })).rejects.toThrow();\n    });\n  });\n});\n```\n\n---\n\n## 6. Flow Verification\n\n### Data Flow Checklist\n\n```\nData Flow Verification\n══════════════════════\n\nUser Registration Flow\n  [ ] Form data validated client-side\n  [ ] API validates and creates user\n  [ ] Confirmation email sent (if applicable)\n  [ ] User can log in\n  [ ] User appears in admin list\n\nItem Creation Flow\n  [ ] User authenticated\n  [ ] Form validates input\n  [ ] Item created in database\n  [ ] Item appears in user's list\n  [ ] Item editable by owner\n  [ ] Item deletable by owner\n\nData Display Flow\n  [ ] Static data loads correctly\n  [ ] Dynamic data fetches and displays\n  [ ] Loading states shown during fetch\n  [ ] Error states on failure\n  [ ] Empty states when no data\n```\n\n### E2E Flow Tests\n\n```typescript\n// tests/e2e/user-flow.spec.ts\n\ndescribe('User Registration Flow', () => {\n  it('completes full registration flow', async () => {\n    // 1. Visit registration page\n    await page.goto('/register');\n\n    // 2. Fill form\n    await page.fill('[name=\"email\"]', 'new@example.com');\n    await page.fill('[name=\"name\"]', 'New User');\n    await page.fill('[name=\"password\"]', 'securepassword');\n\n    // 3. Submit\n    await page.click('button[type=\"submit\"]');\n\n    // 4. Verify redirect to dashboard\n    await expect(page).toHaveURL('/dashboard');\n\n    // 5. Verify user data displayed\n    await expect(page.locator('text=New User')).toBeVisible();\n\n    // 6. Verify in database\n    const user = await prisma.user.findUnique({\n      where: { email: 'new@example.com' }\n    });\n    expect(user).not.toBeNull();\n  });\n});\n```\n\n---\n\n## Integration Test Suite\n\n### Complete Data Verification Suite\n\n```typescript\n// tests/data-verification.test.ts\n\ndescribe('Data Verification Suite', () => {\n  describe('1. Schema', () => {\n    it('schema is valid', () => {\n      // Run prisma validate\n    });\n\n    it('all migrations applied', () => {\n      // Check migration status\n    });\n  });\n\n  describe('2. Seed Data', () => {\n    it('seed creates expected data', async () => {\n      await seed();\n      const users = await prisma.user.count();\n      expect(users).toBeGreaterThan(0);\n    });\n  });\n\n  describe('3. CRUD Operations', () => {\n    // User CRUD\n    // Item CRUD\n    // etc.\n  });\n\n  describe('4. Validation', () => {\n    // Schema validation tests\n    // API validation tests\n  });\n\n  describe('5. Relationships', () => {\n    // Relationship integrity tests\n  });\n\n  describe('6. Data Flows', () => {\n    // End-to-end flow tests\n  });\n});\n```\n\n---\n\n## Manual Spot-Check Procedure\n\nFor human verification:\n\n```\nData Spot-Check Procedure\n═════════════════════════\n\n1. SCHEMA CHECK\n   - Open database client (Prisma Studio, pgAdmin, etc.)\n   - Verify all tables exist\n   - Check column types match schema\n   - Verify indexes present\n\n2. SEED DATA CHECK\n   - Run: npm run seed\n   - Open Prisma Studio: npx prisma studio\n   - Verify expected rows in each table\n   - Check relationships populated\n\n3. CRUD CHECK\n   - Create: Add a new record via UI\n   - Read: View the record in list and detail\n   - Update: Edit the record\n   - Delete: Remove the record\n   - Verify changes in database\n\n4. VALIDATION CHECK\n   - Try submitting invalid data\n   - Verify error messages\n   - Check database wasn't corrupted\n\n5. FLOW CHECK\n   - Complete a full user journey\n   - Verify data correct at each step\n   - Check nothing lost or corrupted\n```\n\n---\n\n## Quick Fixes\n\n### Missing Seed Script\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"seed\": \"npx prisma db seed\"\n  },\n  \"prisma\": {\n    \"seed\": \"ts-node prisma/seed.ts\"\n  }\n}\n```\n\n### Missing Validation\n\n```typescript\n// Add Zod validation to API routes\nimport { z } from 'zod';\n\nconst schema = z.object({\n  // define schema\n});\n\nexport async function POST(req: Request) {\n  const data = schema.parse(await req.json());\n  // proceed with validated data\n}\n```\n\n### Missing Tests\n\n```bash\n# Generate basic CRUD tests\nnpx hygen crud-test new --entity User\n```\n\n---\n\n*Data integrity is non-negotiable. Verify thoroughly.*\n"
    },
    {
      "name": "failure-taxonomy.md",
      "path": "references/failure-taxonomy.md",
      "content": "# Failure Taxonomy Reference\n\nMECE classification of failure states with recovery procedures.\n\n---\n\n## Purpose\n\nA failure taxonomy enables:\n1. **Systematic handling** — Known failures have known fixes\n2. **Faster recovery** — No reinventing solutions\n3. **Prevention** — Learn from past failures\n4. **Calibration** — Track failure rates by type\n\n---\n\n## Taxonomy Structure\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                      FAILURE TAXONOMY (MECE)                                 │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                             │\n│  1. ENVIRONMENT FAILURES                                                    │\n│     └── Setup, dependencies, configuration                                  │\n│                                                                             │\n│  2. BUILD FAILURES                                                          │\n│     └── Compilation, bundling, asset processing                             │\n│                                                                             │\n│  3. TEST FAILURES                                                           │\n│     └── Unit, integration, E2E test failures                                │\n│                                                                             │\n│  4. VERIFICATION FAILURES                                                   │\n│     └── Lint, type check, static analysis                                   │\n│                                                                             │\n│  5. RUNTIME FAILURES                                                        │\n│     └── Crashes, errors during execution                                    │\n│                                                                             │\n│  6. DATA FAILURES                                                           │\n│     └── Schema, migration, validation issues                                │\n│                                                                             │\n│  7. INTEGRATION FAILURES                                                    │\n│     └── API, service, external dependency issues                            │\n│                                                                             │\n│  8. DEPLOYMENT FAILURES                                                     │\n│     └── CI/CD, hosting, infrastructure issues                               │\n│                                                                             │\n│  9. COORDINATION FAILURES                                                   │\n│     └── Multi-agent conflicts, locks, merges                                │\n│                                                                             │\n│  10. SCOPE FAILURES                                                         │\n│      └── Requirements, spec, estimation issues                              │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Category 1: Environment Failures\n\n### E1.1: Missing Dependencies\n\n**Symptoms:**\n- `Module not found` errors\n- `Package X is not installed`\n- Import errors at startup\n\n**Recovery:**\n```bash\n# Node.js\nnpm install\n# or\nyarn install\n\n# Python\npip install -r requirements.txt\n\n# Check for peer dependencies\nnpm ls\n```\n\n**Prevention:**\n- Lock files committed (package-lock.json)\n- CI runs fresh install\n- Document system dependencies in README\n\n### E1.2: Wrong Node/Python/Runtime Version\n\n**Symptoms:**\n- Syntax errors on valid code\n- API not available errors\n- `Unsupported engine` warnings\n\n**Recovery:**\n```bash\n# Check required version in package.json engines\n# Use nvm/pyenv to switch\nnvm use\n# or\nnvm install $(cat .nvmrc)\n```\n\n**Prevention:**\n- `.nvmrc` or `.python-version` in repo\n- CI enforces version\n- README documents requirements\n\n### E1.3: Environment Variables Missing\n\n**Symptoms:**\n- `undefined` config values\n- Connection failures\n- Auth failures\n\n**Recovery:**\n```bash\n# Check .env.example for required vars\ncp .env.example .env\n# Fill in values\n```\n\n**Prevention:**\n- `.env.example` with all required vars\n- Startup validation of required env vars\n- Clear error messages when missing\n\n### E1.4: Port Already in Use\n\n**Symptoms:**\n- `EADDRINUSE` error\n- Server won't start\n\n**Recovery:**\n```bash\n# Find process using port\nlsof -i :3000\n# Kill it\nkill -9 {PID}\n# Or use different port\nPORT=3001 npm start\n```\n\n**Prevention:**\n- Configurable ports\n- Graceful shutdown in dev\n- Check port before starting\n\n---\n\n## Category 2: Build Failures\n\n### B2.1: TypeScript Compilation Error\n\n**Symptoms:**\n- Type errors\n- `tsc` fails\n- Red squiggles in editor\n\n**Recovery:**\n1. Read error message carefully\n2. Fix type issue (add types, fix logic)\n3. If stuck, check tsconfig.json settings\n4. As last resort, use `// @ts-ignore` (document why)\n\n**Prevention:**\n- Strict mode from start\n- Type tests on commit\n- Good IDE integration\n\n### B2.2: Module Resolution Failure\n\n**Symptoms:**\n- `Cannot find module`\n- Path alias not working\n\n**Recovery:**\n```bash\n# Check tsconfig paths\n# Check bundler config (vite, webpack)\n# Verify file exists at path\n```\n\n**Prevention:**\n- Consistent path strategy\n- Test path aliases in CI\n- Document path configuration\n\n### B2.3: Asset Processing Failure\n\n**Symptoms:**\n- CSS/SCSS build fails\n- Image optimization fails\n- Bundle too large\n\n**Recovery:**\n- Check asset source files\n- Verify preprocessor config\n- Check for corrupt files\n\n**Prevention:**\n- Asset validation in CI\n- Size budgets\n- Consistent asset pipeline\n\n---\n\n## Category 3: Test Failures\n\n### T3.1: Unit Test Failure\n\n**Symptoms:**\n- Test assertion fails\n- Expected vs actual mismatch\n\n**Recovery:**\n1. Read test failure output\n2. Determine if test or code is wrong\n3. Fix the bug or update the test\n4. Run test in isolation to verify\n\n**Prevention:**\n- TDD where appropriate\n- Clear test descriptions\n- Test one thing per test\n\n### T3.2: Integration Test Failure\n\n**Symptoms:**\n- API test fails\n- Database test fails\n- Service interaction fails\n\n**Recovery:**\n1. Check if dependencies are running\n2. Check if test database is seeded\n3. Look for race conditions\n4. Check for environment differences\n\n**Prevention:**\n- Isolated test databases\n- Proper test fixtures\n- Retry flaky tests (with caution)\n\n### T3.3: E2E Test Failure\n\n**Symptoms:**\n- Browser test fails\n- Element not found\n- Timeout\n\n**Recovery:**\n1. Run test with headed browser\n2. Add wait conditions\n3. Check for UI changes\n4. Verify test environment matches prod\n\n**Prevention:**\n- Stable selectors (data-testid)\n- Explicit waits over implicit\n- Test in CI with same env as local\n\n### T3.4: Flaky Test\n\n**Symptoms:**\n- Test passes sometimes, fails sometimes\n- Different results in CI vs local\n\n**Recovery:**\n1. Identify source of flakiness (timing, order, state)\n2. Add proper synchronization\n3. Isolate test state\n4. Consider quarantine while fixing\n\n**Prevention:**\n- Avoid shared state\n- Explicit waits\n- Deterministic test data\n- Run tests multiple times in CI\n\n---\n\n## Category 4: Verification Failures\n\n### V4.1: Lint Error\n\n**Symptoms:**\n- ESLint/Prettier errors\n- Style violations\n\n**Recovery:**\n```bash\n# Auto-fix what's possible\nnpm run lint -- --fix\n# Manual fix remaining\n```\n\n**Prevention:**\n- Pre-commit hooks\n- Editor integration\n- CI lint check\n\n### V4.2: Type Error\n\n**Symptoms:**\n- TypeScript errors\n- Type mismatch\n\n**Recovery:**\n1. Understand what type is expected\n2. Fix code to match type\n3. Or update type if code is correct\n4. Avoid `any` escape hatch\n\n**Prevention:**\n- Strict TypeScript config\n- Good type definitions\n- Type tests\n\n### V4.3: Security Vulnerability\n\n**Symptoms:**\n- `npm audit` findings\n- Dependency vulnerabilities\n\n**Recovery:**\n```bash\n# Check what's vulnerable\nnpm audit\n# Update if possible\nnpm update {package}\n# Or use resolution/override\n```\n\n**Prevention:**\n- Regular dependency updates\n- Automated security scanning\n- Minimal dependencies\n\n---\n\n## Category 5: Runtime Failures\n\n### R5.1: Unhandled Exception\n\n**Symptoms:**\n- App crashes\n- Stack trace in logs\n- 500 errors\n\n**Recovery:**\n1. Read stack trace\n2. Identify root cause\n3. Add error handling\n4. Fix underlying bug\n\n**Prevention:**\n- Global error handlers\n- Try-catch at boundaries\n- Error monitoring (Sentry)\n\n### R5.2: Memory Leak\n\n**Symptoms:**\n- Growing memory usage\n- Eventually crashes\n- Slow performance\n\n**Recovery:**\n1. Profile with heap snapshots\n2. Identify retained objects\n3. Fix cleanup/disposal\n\n**Prevention:**\n- Cleanup in useEffect/componentWillUnmount\n- Weak references where appropriate\n- Memory tests for long-running processes\n\n### R5.3: Performance Degradation\n\n**Symptoms:**\n- Slow responses\n- High CPU usage\n- Timeouts\n\n**Recovery:**\n1. Profile to find bottleneck\n2. Optimize hot paths\n3. Add caching\n4. Consider scaling\n\n**Prevention:**\n- Performance budgets\n- Regular profiling\n- Load testing\n\n---\n\n## Category 6: Data Failures\n\n### D6.1: Schema Mismatch\n\n**Symptoms:**\n- Database errors\n- Missing columns\n- Type mismatches\n\n**Recovery:**\n1. Check current schema vs expected\n2. Generate/apply migration\n3. Verify data integrity\n\n**Prevention:**\n- Always use migrations\n- Test migrations up and down\n- Schema validation at startup\n\n### D6.2: Migration Failure\n\n**Symptoms:**\n- Migration won't apply\n- Partial migration state\n- Data corruption\n\n**Recovery:**\n1. Check migration status\n2. Rollback if possible\n3. Fix migration and reapply\n4. May need manual DB fix\n\n**Prevention:**\n- Test migrations on copy of prod data\n- Reversible migrations\n- Backup before migrate\n\n### D6.3: Validation Failure\n\n**Symptoms:**\n- Invalid data accepted\n- Constraint violations\n- Data integrity issues\n\n**Recovery:**\n1. Add missing validation\n2. Fix existing bad data\n3. Prevent future bad data\n\n**Prevention:**\n- Validation at all boundaries\n- Database constraints\n- Type-safe schemas (Zod)\n\n---\n\n## Category 7: Integration Failures\n\n### I7.1: API Contract Violation\n\n**Symptoms:**\n- Unexpected response format\n- Missing fields\n- Type errors from API\n\n**Recovery:**\n1. Check API documentation\n2. Update client expectations\n3. Add defensive parsing\n4. Contact API owner if their bug\n\n**Prevention:**\n- Contract testing\n- API versioning\n- Response validation\n\n### I7.2: External Service Unavailable\n\n**Symptoms:**\n- Timeouts\n- Connection refused\n- 503 errors\n\n**Recovery:**\n1. Check service status\n2. Implement retry with backoff\n3. Fall back to cached data\n4. Graceful degradation\n\n**Prevention:**\n- Circuit breakers\n- Fallback strategies\n- Health checks\n- Timeout configuration\n\n### I7.3: Rate Limiting\n\n**Symptoms:**\n- 429 errors\n- Requests rejected\n- Quota exceeded\n\n**Recovery:**\n1. Implement backoff\n2. Queue requests\n3. Request quota increase\n4. Cache responses\n\n**Prevention:**\n- Rate limit awareness\n- Request batching\n- Caching layer\n- Monitor usage\n\n---\n\n## Category 8: Deployment Failures\n\n### D8.1: CI Pipeline Failure\n\n**Symptoms:**\n- Build fails in CI\n- Tests pass local, fail CI\n- Deployment blocked\n\n**Recovery:**\n1. Check CI logs\n2. Identify difference from local\n3. Fix environment/config\n4. Retry\n\n**Prevention:**\n- Local CI simulation (act)\n- Same versions local/CI\n- Cached dependencies\n\n### D8.2: Container Build Failure\n\n**Symptoms:**\n- Docker build fails\n- Image too large\n- Missing dependencies in container\n\n**Recovery:**\n1. Check Dockerfile\n2. Multi-stage builds for size\n3. Verify all deps copied\n\n**Prevention:**\n- .dockerignore\n- Multi-stage builds\n- Regular image updates\n\n### D8.3: Production Deploy Failure\n\n**Symptoms:**\n- Deploy fails\n- App won't start in prod\n- Health check fails\n\n**Recovery:**\n1. Check deploy logs\n2. Verify env vars in prod\n3. Rollback if needed\n4. Fix and redeploy\n\n**Prevention:**\n- Staging environment\n- Health checks\n- Rollback automation\n- Blue-green deploys\n\n---\n\n## Category 9: Coordination Failures\n\n### C9.1: Merge Conflict\n\n**Symptoms:**\n- Git conflict markers\n- Can't merge branches\n- CI fails on merge\n\n**Recovery:**\n1. Identify conflicting changes\n2. Determine correct resolution\n3. Resolve conflicts\n4. Test merged result\n\n**Prevention:**\n- Smaller, more frequent merges\n- Clear system boundaries\n- Communication between agents\n\n### C9.2: Lock Contention\n\n**Symptoms:**\n- Agent waiting on lock\n- Timeout acquiring lock\n- Deadlock\n\n**Recovery:**\n1. Check lock holder\n2. Wait or request release\n3. Force release if expired\n4. Retry operation\n\n**Prevention:**\n- Short lock durations\n- Lock ordering (prevent deadlock)\n- Timeout + retry\n\n### C9.3: State Inconsistency\n\n**Symptoms:**\n- Agents have different view of state\n- Actions based on stale data\n- Conflicting operations\n\n**Recovery:**\n1. Identify source of truth\n2. Sync all agents to truth\n3. Replay if needed\n\n**Prevention:**\n- Single source of truth\n- Atomic updates\n- Event-driven state changes\n\n---\n\n## Category 10: Scope Failures\n\n### S10.1: Missing Requirement\n\n**Symptoms:**\n- Feature incomplete\n- User reports missing functionality\n- Gap discovered late\n\n**Recovery:**\n1. Document the requirement\n2. Estimate impact\n3. Add to current or next loop\n4. Implement\n\n**Prevention:**\n- Thorough scope discovery\n- User feedback early\n- Comprehensive specs\n\n### S10.2: Spec Ambiguity\n\n**Symptoms:**\n- Implementation doesn't match intent\n- Multiple interpretations possible\n- Rework needed\n\n**Recovery:**\n1. Clarify with user/stakeholder\n2. Document clarification\n3. Adjust implementation\n\n**Prevention:**\n- Concrete examples in specs\n- Review specs before implementing\n- Ask clarifying questions\n\n### S10.3: Underestimation\n\n**Symptoms:**\n- Taking longer than expected\n- Scope larger than thought\n- More loops needed\n\n**Recovery:**\n1. Re-estimate remaining work\n2. Adjust expectations\n3. Consider scope reduction\n4. Learn for calibration\n\n**Prevention:**\n- Conservative estimates\n- Buffer for unknowns\n- Calibration from history\n- Break down large items\n\n---\n\n## Failure Handling Protocol\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                      FAILURE HANDLING PROTOCOL                               │\n│                                                                             │\n│  1. DETECT                                                                  │\n│     • Automated (test failure, build error)                                 │\n│     • Manual (review, user report)                                          │\n│                                                                             │\n│  2. CLASSIFY                                                                │\n│     • Identify category from taxonomy                                       │\n│     • Determine severity                                                    │\n│                                                                             │\n│  3. RECOVER                                                                 │\n│     • Follow category-specific recovery procedure                           │\n│     • Escalate if recovery fails                                            │\n│                                                                             │\n│  4. VERIFY                                                                  │\n│     • Confirm issue is resolved                                             │\n│     • Run relevant tests                                                    │\n│                                                                             │\n│  5. PREVENT                                                                 │\n│     • Add test/check to catch this in future                                │\n│     • Update documentation                                                  │\n│     • Consider systemic fix                                                 │\n│                                                                             │\n│  6. RECORD                                                                  │\n│     • Log failure in journey                                                │\n│     • Update calibration                                                    │\n│     • Feed into retrospective                                               │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Generating Codebase-Specific Taxonomy\n\nEach codebase may have specific failure patterns. To generate:\n\n1. **Analyze history** — What has failed before?\n2. **Identify tech-specific failures** — Framework, language quirks\n3. **Add custom categories** — Domain-specific issues\n4. **Document recovery** — What worked to fix it\n\n### Template for Custom Failure\n\n```markdown\n### {CATEGORY}.{NUMBER}: {Failure Name}\n\n**Symptoms:**\n- {symptom-1}\n- {symptom-2}\n\n**Recovery:**\n1. {step-1}\n2. {step-2}\n3. {step-3}\n\n**Prevention:**\n- {prevention-1}\n- {prevention-2}\n```\n\n---\n\n*A comprehensive failure taxonomy turns surprises into procedures.*\n"
    },
    {
      "name": "loop-state-template.md",
      "path": "references/loop-state-template.md",
      "content": "# loop-state.json Template\n\nThis document defines the structure for `loop-state.json`, which tracks orchestrator state across sessions.\n\n---\n\n## Initial Structure\n\nWhen starting orchestrator, create `loop-state.json` in the project root:\n\n```json\n{\n  \"orchestratorId\": \"orch-{timestamp}\",\n  \"startedAt\": \"2026-01-21T10:00:00Z\",\n  \"mode\": null,\n  \"modeDetection\": {\n    \"detected\": null,\n    \"confidence\": 0,\n    \"signals\": [],\n    \"confirmedByUser\": false,\n    \"overridden\": false\n  },\n  \"scopeDiscovery\": {\n    \"completedAt\": null,\n    \"gaps\": [],\n    \"systems\": [],\n    \"estimatedLoops\": 0,\n    \"parallelizationFactor\": 1\n  },\n  \"currentLoop\": 1,\n  \"currentPhase\": \"DETECT\",\n  \"subAgents\": [],\n  \"completedSystems\": [],\n  \"gates\": {\n    \"pending\": [],\n    \"approved\": [],\n    \"rejected\": []\n  },\n  \"metrics\": {\n    \"loopsCompleted\": 0,\n    \"estimatedHours\": 0,\n    \"actualHours\": 0,\n    \"calibrationFactor\": 1.0\n  }\n}\n```\n\n---\n\n## Phase Progression\n\nUpdate `currentPhase` as you progress through the orchestrator flow:\n\n```\nDETECT → DISCOVER → PLAN → EXECUTE → RETROSPECT → (COMPLETE or next loop)\n```\n\n| Phase | Description | Next Phase |\n|-------|-------------|------------|\n| `DETECT` | Gathering signals, classifying mode | `DISCOVER` |\n| `DISCOVER` | Running gap analysis, creating SCOPE-DISCOVERY.md | `PLAN` |\n| `PLAN` | Decomposing work, identifying parallelization | `EXECUTE` |\n| `EXECUTE` | Running engineering loop, spawning agents | `RETROSPECT` |\n| `RETROSPECT` | Learning from loop, updating calibration | `COMPLETE` or back to `EXECUTE` |\n| `COMPLETE` | All work done, production-quality achieved | — |\n\n---\n\n## Mode Detection\n\nAfter detecting and confirming mode:\n\n```json\n{\n  \"mode\": \"brownfield-polish\",\n  \"modeDetection\": {\n    \"detected\": \"brownfield-polish\",\n    \"confidence\": 0.87,\n    \"signals\": [\n      { \"category\": \"codebase\", \"signal\": \"47 files\", \"weight\": 0.3, \"mode\": \"polish\" },\n      { \"category\": \"git\", \"signal\": \"23 commits\", \"weight\": 0.4, \"mode\": \"polish\" },\n      { \"category\": \"cicd\", \"signal\": \"no CI/CD\", \"weight\": 0.5, \"mode\": \"polish\" },\n      { \"category\": \"deploy\", \"signal\": \"no deploy config\", \"weight\": 0.5, \"mode\": \"polish\" }\n    ],\n    \"confirmedByUser\": true,\n    \"overridden\": false\n  }\n}\n```\n\n---\n\n## Scope Discovery\n\nAfter running gap analysis:\n\n```json\n{\n  \"scopeDiscovery\": {\n    \"completedAt\": \"2026-01-21T10:15:00Z\",\n    \"gaps\": [\n      { \"category\": \"deployment\", \"severity\": \"critical\", \"description\": \"No CI/CD pipeline\" },\n      { \"category\": \"ui\", \"severity\": \"high\", \"description\": \"No dark mode\" },\n      { \"category\": \"testing\", \"severity\": \"medium\", \"description\": \"Missing integration tests\" }\n    ],\n    \"systems\": [\n      { \"name\": \"deployment\", \"type\": \"gap-fill\", \"priority\": \"critical\", \"parallelizable\": false },\n      { \"name\": \"ui-polish\", \"type\": \"gap-fill\", \"priority\": \"high\", \"parallelizable\": true },\n      { \"name\": \"testing\", \"type\": \"gap-fill\", \"priority\": \"medium\", \"parallelizable\": true }\n    ],\n    \"estimatedLoops\": 2,\n    \"parallelizationFactor\": 3\n  }\n}\n```\n\n---\n\n## Sub-Agent Tracking\n\nWhen spawning agents for parallel work, add to `subAgents`:\n\n```json\n{\n  \"subAgents\": [\n    {\n      \"id\": \"agent-ui-polish\",\n      \"system\": \"ui-polish\",\n      \"worktree\": \".worktrees/ui-polish\",\n      \"branch\": \"feature/ui-polish\",\n      \"status\": \"running\",\n      \"currentStage\": \"IMPLEMENT\",\n      \"progress\": \"Adding dark mode toggle component\",\n      \"outputFile\": \"/tmp/agent-ui-polish-output.txt\",\n      \"spawnedAt\": \"2026-01-21T10:30:00Z\",\n      \"lastHeartbeat\": \"2026-01-21T10:45:00Z\",\n      \"completedAt\": null,\n      \"metrics\": {\n        \"filesModified\": 8,\n        \"testsAdded\": 3,\n        \"commitsCreated\": 2\n      }\n    }\n  ]\n}\n```\n\n### Agent Status Values\n\n| Status | Description |\n|--------|-------------|\n| `spawning` | Agent is being initialized |\n| `running` | Agent is actively working |\n| `waiting-gate` | Agent is paused, waiting for human approval |\n| `completed` | Agent finished successfully |\n| `failed` | Agent encountered an error |\n\n---\n\n## Stage Gates\n\nWhen agents request human approval:\n\n```json\n{\n  \"gates\": {\n    \"pending\": [\n      {\n        \"id\": \"gate-001\",\n        \"agent\": \"agent-ui-polish\",\n        \"type\": \"visual-review\",\n        \"description\": \"UI dark mode styling complete\",\n        \"artifacts\": [\"screenshots/dark-home.png\", \"screenshots/dark-dashboard.png\"],\n        \"requestedAt\": \"2026-01-21T11:00:00Z\"\n      }\n    ],\n    \"approved\": [],\n    \"rejected\": []\n  }\n}\n```\n\nAfter approval:\n```json\n{\n  \"gates\": {\n    \"pending\": [],\n    \"approved\": [\n      {\n        \"id\": \"gate-001\",\n        \"agent\": \"agent-ui-polish\",\n        \"type\": \"visual-review\",\n        \"approvedAt\": \"2026-01-21T11:05:00Z\",\n        \"feedback\": null\n      }\n    ],\n    \"rejected\": []\n  }\n}\n```\n\n---\n\n## Metrics & Calibration\n\nTrack actual vs estimated for future calibration:\n\n```json\n{\n  \"metrics\": {\n    \"loopsCompleted\": 1,\n    \"estimatedHours\": 4,\n    \"actualHours\": 3.5,\n    \"calibrationFactor\": 0.875\n  }\n}\n```\n\nThe `calibrationFactor` is `actualHours / estimatedHours`. Use this to adjust future estimates:\n- Factor < 1.0 = You're overestimating (work is faster than expected)\n- Factor > 1.0 = You're underestimating (work takes longer than expected)\n\n---\n\n## Session Handoff\n\nWhen ending a session mid-orchestration, update loop-state.json to enable resume:\n\n```json\n{\n  \"currentPhase\": \"EXECUTE\",\n  \"sessionHandoff\": {\n    \"pausedAt\": \"2026-01-21T12:00:00Z\",\n    \"reason\": \"session-end\",\n    \"resumeInstructions\": \"Continue with agent-testing completion, then merge all worktrees\",\n    \"pendingActions\": [\n      \"Wait for agent-testing to complete\",\n      \"Merge ui-polish branch\",\n      \"Run full test suite\"\n    ]\n  }\n}\n```\n\nResume with `/orchestrator --resume` to continue from this state.\n\n---\n\n## Complete Example\n\nFull loop-state.json after one loop completion:\n\n```json\n{\n  \"orchestratorId\": \"orch-1705834800000\",\n  \"startedAt\": \"2026-01-21T10:00:00Z\",\n  \"mode\": \"brownfield-polish\",\n  \"modeDetection\": {\n    \"detected\": \"brownfield-polish\",\n    \"confidence\": 0.87,\n    \"signals\": [\n      { \"category\": \"codebase\", \"signal\": \"47 files\", \"weight\": 0.3, \"mode\": \"polish\" }\n    ],\n    \"confirmedByUser\": true,\n    \"overridden\": false\n  },\n  \"scopeDiscovery\": {\n    \"completedAt\": \"2026-01-21T10:15:00Z\",\n    \"gaps\": [\n      { \"category\": \"deployment\", \"severity\": \"critical\", \"description\": \"No CI/CD\" }\n    ],\n    \"systems\": [\n      { \"name\": \"deployment\", \"type\": \"gap-fill\", \"priority\": \"critical\", \"parallelizable\": false }\n    ],\n    \"estimatedLoops\": 2,\n    \"parallelizationFactor\": 1\n  },\n  \"currentLoop\": 2,\n  \"currentPhase\": \"EXECUTE\",\n  \"subAgents\": [],\n  \"completedSystems\": [\"deployment\", \"ui-polish\", \"data-validation\"],\n  \"gates\": {\n    \"pending\": [],\n    \"approved\": [\n      { \"id\": \"gate-001\", \"agent\": \"agent-ui-polish\", \"type\": \"visual-review\", \"approvedAt\": \"2026-01-21T11:05:00Z\" }\n    ],\n    \"rejected\": []\n  },\n  \"metrics\": {\n    \"loopsCompleted\": 1,\n    \"estimatedHours\": 4,\n    \"actualHours\": 3.5,\n    \"calibrationFactor\": 0.875\n  }\n}\n```\n"
    },
    {
      "name": "mode-behavior-standard.md",
      "path": "references/mode-behavior-standard.md",
      "content": "# Mode-Specific Behavior Standard\n\nThis document defines the standard structure for mode-specific behavior sections across all skills.\n\n## Standard Template\n\nEvery skill with mode-specific behavior MUST use this structure:\n\n```markdown\n## Mode-Specific Behavior\n\n[Skill name] behavior differs by orchestrator mode:\n\n### Greenfield Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | [What this skill operates on] |\n| **Approach** | [Full/comprehensive/from-scratch] |\n| **Patterns** | [Free choice / establish new] |\n| **Deliverables** | [Full artifacts] |\n| **Validation** | [Standard validation] |\n| **Constraints** | [Minimal constraints] |\n\n### Brownfield-Polish Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | [Gap-specific + integration points] |\n| **Approach** | [Gap-focused / extend existing] |\n| **Patterns** | [Should match existing patterns] |\n| **Deliverables** | [Delta / extension artifacts] |\n| **Validation** | [Existing + gap validation] |\n| **Constraints** | [Must not break existing] |\n\n**Polish considerations:**\n- [Bullet point guidance specific to this skill in polish mode]\n\n### Brownfield-Enterprise Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | [Change-specific only] |\n| **Approach** | [Surgical / minimal / change-only] |\n| **Patterns** | [Must conform exactly to existing] |\n| **Deliverables** | [Change documentation only] |\n| **Validation** | [Full regression + change validation] |\n| **Constraints** | [Requires approval / audit trail] |\n\n**Enterprise constraints:**\n- [Bullet point constraints specific to this skill in enterprise mode]\n```\n\n## Standard Aspects (Required)\n\n| Aspect | Definition | Greenfield Default | Polish Default | Enterprise Default |\n|--------|------------|-------------------|----------------|-------------------|\n| **Scope** | What the skill operates on | Full system | Gap-specific | Change-specific |\n| **Approach** | How to execute | Comprehensive | Extend existing | Surgical/minimal |\n| **Patterns** | Pattern conformance level | Free choice | Should match existing | Must conform exactly |\n| **Deliverables** | What artifacts to produce | Full artifacts | Delta artifacts | Change record |\n| **Validation** | How to verify correctness | Standard | Existing + new | Full regression |\n| **Constraints** | Mode-specific restrictions | Minimal | Don't break existing | Requires approval |\n\n## Terminology Standards\n\n### Pattern Conformance\n- **Greenfield:** \"Free choice based on requirements\"\n- **Polish:** \"Should match existing patterns\"\n- **Enterprise:** \"Must conform exactly to existing\"\n\n### Risk/Tolerance\n- **Greenfield:** \"Standard\"\n- **Polish:** \"Moderate—existing functionality at risk\"\n- **Enterprise:** \"Minimal—production critical\"\n\n### Validation vs Verification\n- **Validation:** Semantic correctness (did we build the right thing?)\n- **Verification:** Structural correctness (did we build it right?)\n- Use \"Validation\" in mode-specific tables for consistency\n\n### Approval Language\n- **Greenfield:** \"Standard review\"\n- **Polish:** \"Review required\"\n- **Enterprise:** \"Requires explicit approval\"\n\n## Section Structure\n\n### After Tables\n- **Greenfield:** No additional section needed (or brief note)\n- **Polish:** \"**Polish considerations:**\" with 3-5 bullet points\n- **Enterprise:** \"**Enterprise constraints:**\" with 3-5 bullet points\n\n### Depth Balance\nEach mode section should have approximately equal depth:\n- Table: 6 rows (standard aspects)\n- Post-table content: 3-5 bullet points or equivalent\n\n## Skills Without Mode-Specific Behavior\n\nThe following skills intentionally omit mode-specific behavior:\n\n| Skill | Reason |\n|-------|--------|\n| `orchestrator` | Determines the mode; runs before mode is known |\n| `mode-detector` | Detects the mode; runs before mode is known |\n\nThese skills should include this note:\n```markdown\n> **Note:** This skill does not have mode-specific behavior because it operates before or during mode detection.\n```\n"
    },
    {
      "name": "mode-detection.md",
      "path": "references/mode-detection.md",
      "content": "# Mode Detection Reference\n\nComplete signal taxonomy and detection algorithm for project mode classification.\n\n---\n\n## Signal Taxonomy (MECE)\n\n### 1. Codebase Metrics\n\n| Signal | How to Measure | Greenfield | Polish | Enterprise |\n|--------|----------------|------------|--------|------------|\n| File count | `find . -type f \\| wc -l` | 0: +1.0 | 1-100: +0.3 | 500+: +0.4 |\n| Lines of code | `cloc` or `wc -l` | 0: +1.0 | <10k: +0.3 | 100k+: +0.4 |\n| Directory depth | `find . -type d \\| wc -l` | 0-1: +0.5 | 2-10: +0.2 | 20+: +0.3 |\n\n### 2. Version Control\n\n| Signal | How to Measure | Greenfield | Polish | Enterprise |\n|--------|----------------|------------|--------|------------|\n| No .git directory | `test -d .git` | +0.8 | - | - |\n| Commit count | `git rev-list --count HEAD` | <5: +0.3 | 10-200: +0.3 | 1000+: +0.3 |\n| Contributor count | `git shortlog -sn \\| wc -l` | 1: +0.2 | 1-3: +0.4 | 5+: +0.4 |\n| Branch count | `git branch -a \\| wc -l` | <3: +0.2 | 3-10: +0.2 | 20+: +0.3 |\n| Tag count | `git tag \\| wc -l` | 0: +0.2 | 1-5: +0.2 | 10+: +0.3 |\n| Repo age (days) | First commit date | <7: +0.3 | 7-180: +0.3 | 365+: +0.3 |\n\n### 3. Dependency Management\n\n| Signal | How to Measure | Greenfield | Polish | Enterprise |\n|--------|----------------|------------|--------|------------|\n| No package file | Missing package.json/go.mod/etc | +0.7 | - | - |\n| Has package file | Present | - | +0.1 | +0.1 |\n| Dependency count | Parse package.json | 0: +0.3 | 1-20: +0.2 | 50+: +0.3 |\n| Lock file present | package-lock.json, yarn.lock | - | +0.1 | +0.2 |\n| Monorepo structure | Multiple package.json | - | - | +0.4 |\n\n### 4. CI/CD & Deployment\n\n| Signal | How to Measure | Greenfield | Polish | Enterprise |\n|--------|----------------|------------|--------|------------|\n| No CI config | Missing .github/workflows, etc | +0.2 | +0.5 | - |\n| Has CI config | Present | - | - | +0.4 |\n| No deployment config | Missing Dockerfile, vercel.json | +0.2 | +0.5 | - |\n| Has deployment config | Present | - | - | +0.4 |\n| Multiple environments | staging + prod configs | - | - | +0.5 |\n| Infrastructure as code | Terraform, Pulumi, CDK | - | - | +0.4 |\n\n### 5. Testing & Quality\n\n| Signal | How to Measure | Greenfield | Polish | Enterprise |\n|--------|----------------|------------|--------|------------|\n| No test files | Missing *.test.*, *.spec.* | +0.3 | +0.2 | - |\n| Basic tests | < 20 test files | - | +0.3 | - |\n| Comprehensive tests | 50+ test files | - | - | +0.4 |\n| No test config | Missing jest.config, vitest.config | +0.2 | +0.2 | - |\n| Coverage config | Has coverage thresholds | - | - | +0.3 |\n| No linting | Missing eslint, prettier config | +0.2 | +0.2 | - |\n| Has linting | Config present | - | +0.1 | +0.2 |\n\n### 6. Documentation\n\n| Signal | How to Measure | Greenfield | Polish | Enterprise |\n|--------|----------------|------------|--------|------------|\n| No README | Missing README.md | +0.3 | +0.2 | - |\n| Basic README | < 100 lines | - | +0.2 | - |\n| Detailed README | 100+ lines | - | - | +0.2 |\n| No docs directory | Missing /docs | +0.2 | +0.2 | - |\n| Has docs directory | Present | - | - | +0.3 |\n| API documentation | OpenAPI, JSDoc | - | - | +0.3 |\n| Architecture docs | ADRs, diagrams | - | - | +0.4 |\n\n### 7. Process Artifacts (Enterprise Markers)\n\n| Signal | How to Measure | Greenfield | Polish | Enterprise |\n|--------|----------------|------------|--------|------------|\n| CODEOWNERS | Present | - | - | +0.5 |\n| PR template | .github/pull_request_template.md | - | - | +0.3 |\n| Issue templates | .github/ISSUE_TEMPLATE/ | - | - | +0.3 |\n| Contributing guide | CONTRIBUTING.md | - | - | +0.3 |\n| Code of conduct | CODE_OF_CONDUCT.md | - | - | +0.2 |\n| Security policy | SECURITY.md | - | - | +0.3 |\n| Changelog | CHANGELOG.md | - | - | +0.3 |\n\n### 8. Compliance & Governance\n\n| Signal | How to Measure | Greenfield | Polish | Enterprise |\n|--------|----------------|------------|--------|------------|\n| License file | LICENSE, LICENSE.md | - | +0.1 | +0.2 |\n| Compliance markers | SOC2, HIPAA, GDPR mentions | - | - | +0.5 |\n| Audit logs | Audit trail code | - | - | +0.4 |\n| Feature flags | LaunchDarkly, env-based flags | - | - | +0.3 |\n| Secrets management | Vault, AWS Secrets Manager | - | - | +0.4 |\n\n---\n\n## Scoring Algorithm\n\n### Step 1: Gather All Signals\n\n```javascript\nfunction gatherSignals(codebasePath) {\n  const signals = [];\n\n  // Filesystem signals\n  signals.push(measureFileCount(codebasePath));\n  signals.push(measureLOC(codebasePath));\n  signals.push(measureDirectoryDepth(codebasePath));\n\n  // Git signals\n  if (hasGit(codebasePath)) {\n    signals.push(measureCommitCount(codebasePath));\n    signals.push(measureContributorCount(codebasePath));\n    signals.push(measureBranchCount(codebasePath));\n    signals.push(measureRepoAge(codebasePath));\n  } else {\n    signals.push({ name: 'no_git', weights: { greenfield: 0.8 } });\n  }\n\n  // Infrastructure signals\n  signals.push(measurePackageFile(codebasePath));\n  signals.push(measureCICD(codebasePath));\n  signals.push(measureDeployment(codebasePath));\n\n  // Quality signals\n  signals.push(measureTests(codebasePath));\n  signals.push(measureLinting(codebasePath));\n  signals.push(measureDocumentation(codebasePath));\n\n  // Process signals\n  signals.push(measureProcessArtifacts(codebasePath));\n\n  return signals;\n}\n```\n\n### Step 2: Calculate Scores\n\n```javascript\nfunction calculateScores(signals) {\n  const scores = {\n    greenfield: 0,\n    polish: 0,\n    enterprise: 0\n  };\n\n  for (const signal of signals) {\n    if (signal.weights.greenfield) {\n      scores.greenfield += signal.weights.greenfield;\n    }\n    if (signal.weights.polish) {\n      scores.polish += signal.weights.polish;\n    }\n    if (signal.weights.enterprise) {\n      scores.enterprise += signal.weights.enterprise;\n    }\n  }\n\n  return scores;\n}\n```\n\n### Step 3: Normalize and Classify\n\n```javascript\nfunction classify(scores) {\n  const total = scores.greenfield + scores.polish + scores.enterprise;\n\n  if (total === 0) {\n    // No signals = assume greenfield\n    return {\n      mode: 'greenfield',\n      confidence: 1.0,\n      margin: 1.0\n    };\n  }\n\n  // Normalize to percentages\n  const normalized = {\n    greenfield: scores.greenfield / total,\n    polish: scores.polish / total,\n    enterprise: scores.enterprise / total\n  };\n\n  // Find winner\n  const sorted = Object.entries(normalized)\n    .sort(([, a], [, b]) => b - a);\n\n  const winner = sorted[0][0];\n  const confidence = sorted[0][1];\n  const runnerUp = sorted[1] ? sorted[1][1] : 0;\n  const margin = confidence - runnerUp;\n\n  return {\n    mode: winner,\n    confidence: confidence,\n    margin: margin,\n    scores: normalized\n  };\n}\n```\n\n---\n\n## Confidence Interpretation\n\n| Confidence | Margin | Interpretation |\n|------------|--------|----------------|\n| > 70% | > 30% | High confidence, clear winner |\n| 50-70% | 15-30% | Medium confidence, likely correct |\n| 40-50% | 5-15% | Low confidence, needs user attention |\n| < 40% | < 5% | Ambiguous, require user selection |\n\n---\n\n## Mode Behavior Summary\n\n| Aspect | Greenfield | Polish | Enterprise |\n|--------|------------|--------|------------|\n| **Entry point** | entry-portal (vision) | scope discovery | codebase analysis |\n| **Spec detail** | Full 18 sections | Gap-focused | Pattern-matching |\n| **Scaffolding** | Create everything | Extend only | Minimal touch |\n| **Patterns** | Establish new | Polish existing | Match exactly |\n| **Testing** | Create suite | Fill gaps | Match style |\n| **Deployment** | Optional | Required | Use existing |\n| **Coordination** | N/A | Solo or small team | Multi-agent |\n\n---\n\n## Override Guidelines\n\n### When to Override to Greenfield\n- Starting a new module in an existing repo\n- Repo exists but current code should be replaced\n- User explicitly wants fresh start\n\n### When to Override to Polish\n- Enterprise codebase but feature is small\n- Just want to finish and ship quickly\n- Team size doesn't match codebase age\n\n### When to Override to Enterprise\n- Small codebase but high quality standards needed\n- Part of a larger ecosystem\n- Compliance requirements exist\n\n---\n\n*Use this taxonomy to ensure consistent mode detection across codebases.*\n"
    },
    {
      "name": "parallel-agents.md",
      "path": "references/parallel-agents.md",
      "content": "# Parallel Agents Reference\n\nPatterns for spawning and coordinating multiple sub-agents.\n\n---\n\n## Overview\n\nThe orchestrator can spawn up to 6-7 sub-agents working on independent systems simultaneously. Each agent operates in its own git worktree with coordination via shared state files.\n\n---\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                       PARALLEL AGENT ARCHITECTURE                            │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                        ORCHESTRATOR                                  │   │\n│  │  • Mode detection                                                    │   │\n│  │  • Scope discovery                                                   │   │\n│  │  • Agent spawning                                                    │   │\n│  │  • Progress monitoring                                               │   │\n│  │  • Gate queue management                                             │   │\n│  │  • Merge coordination                                                │   │\n│  └──────────────────────────────┬──────────────────────────────────────┘   │\n│                                 │                                           │\n│            ┌────────────────────┼────────────────────┐                      │\n│            │                    │                    │                      │\n│            ▼                    ▼                    ▼                      │\n│  ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐            │\n│  │    Sub-Agent 1   │ │    Sub-Agent 2   │ │    Sub-Agent 3   │            │\n│  │                  │ │                  │ │                  │            │\n│  │  Worktree:       │ │  Worktree:       │ │  Worktree:       │            │\n│  │  .worktrees/     │ │  .worktrees/     │ │  .worktrees/     │            │\n│  │  feature-auth/   │ │  feature-api/    │ │  feature-ui/     │            │\n│  │                  │ │                  │ │                  │            │\n│  │  Branch:         │ │  Branch:         │ │  Branch:         │            │\n│  │  feature/auth    │ │  feature/api     │ │  feature/ui      │            │\n│  └────────┬─────────┘ └────────┬─────────┘ └────────┬─────────┘            │\n│           │                    │                    │                      │\n│           └────────────────────┼────────────────────┘                      │\n│                                │                                           │\n│                                ▼                                           │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                     SHARED COORDINATION                              │   │\n│  │                                                                      │   │\n│  │  coordination/                                                       │   │\n│  │  ├── agents/                                                         │   │\n│  │  │   ├── agent-1.json    (status, progress, heartbeat)              │   │\n│  │  │   ├── agent-2.json                                               │   │\n│  │  │   └── agent-3.json                                               │   │\n│  │  ├── gates-pending.json  (stage gates awaiting human)               │   │\n│  │  ├── locks.json          (resource locks)                           │   │\n│  │  └── events.json         (coordination events)                      │   │\n│  │                                                                      │   │\n│  │  loop-state.json         (orchestrator state + agent registry)      │   │\n│  │                                                                      │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Spawning Sub-Agents\n\n### Prerequisites\n\nBefore spawning:\n1. Mode detected and confirmed\n2. Scope discovery complete\n3. Systems identified as parallelizable\n4. Worktree paths planned\n\n### Spawn Procedure\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                       SPAWN PROCEDURE                                        │\n│                                                                             │\n│  1. CREATE WORKTREE                                                         │\n│     ┌─────────────────────────────────────────────────────────────────┐    │\n│     │ git worktree add .worktrees/{system-name} -b feature/{system}   │    │\n│     └─────────────────────────────────────────────────────────────────┘    │\n│                                                                             │\n│  2. CREATE AGENT STATE FILE                                                 │\n│     ┌─────────────────────────────────────────────────────────────────┐    │\n│     │ Write coordination/agents/{agent-id}.json                        │    │\n│     │ {                                                                │    │\n│     │   \"id\": \"agent-{system-name}\",                                   │    │\n│     │   \"system\": \"{system-name}\",                                     │    │\n│     │   \"worktree\": \".worktrees/{system-name}\",                        │    │\n│     │   \"branch\": \"feature/{system-name}\",                             │    │\n│     │   \"status\": \"spawning\",                                          │    │\n│     │   \"startedAt\": \"{timestamp}\"                                     │    │\n│     │ }                                                                │    │\n│     └─────────────────────────────────────────────────────────────────┘    │\n│                                                                             │\n│  3. SPAWN VIA TASK TOOL                                                     │\n│     ┌─────────────────────────────────────────────────────────────────┐    │\n│     │ Task(                                                            │    │\n│     │   description: \"Sub-agent for {system-name}\",                    │    │\n│     │   subagent_type: \"general-purpose\",                              │    │\n│     │   run_in_background: true,                                       │    │\n│     │   prompt: \"{agent-prompt}\"                                       │    │\n│     │ )                                                                │    │\n│     └─────────────────────────────────────────────────────────────────┘    │\n│                                                                             │\n│  4. RECORD IN LOOP-STATE                                                    │\n│     ┌─────────────────────────────────────────────────────────────────┐    │\n│     │ Update loop-state.json subAgents array                           │    │\n│     │ Record outputFile from Task tool result                          │    │\n│     └─────────────────────────────────────────────────────────────────┘    │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Agent Prompt Template\n\n```markdown\n# Sub-Agent Assignment: {system-name}\n\nYou are a sub-agent spawned by the orchestrator to work on a specific system.\n\n## Context\n\n**Mode:** {mode} (inherited from orchestrator)\n**Orchestrator ID:** {orchestrator-id}\n\n## Your Assignment\n\n**System:** {system-name}\n**Description:** {system-description}\n\n## Your Workspace\n\n**Worktree:** {worktree-path}\n**Branch:** feature/{system-name}\n\n**IMPORTANT:**\n- All your work MUST be done in this worktree\n- Do NOT modify files outside your worktree\n- Start by navigating: `cd {worktree-path}`\n\n## Your Task\n\n{system-specific-feature-spec-or-gap-description}\n\n## Coordination Protocol\n\n### Status Updates\n\nUpdate your status file regularly:\n- Path: coordination/agents/{agent-id}.json\n- Update on: stage transitions, completion, blocking issues\n\n```json\n{\n  \"id\": \"{agent-id}\",\n  \"status\": \"running|waiting-gate|completed|failed\",\n  \"currentStage\": \"SCAFFOLD|IMPLEMENT|TEST|...\",\n  \"progress\": \"description of current work\",\n  \"lastHeartbeat\": \"{timestamp}\"\n}\n```\n\n### Stage Gates\n\nWhen you reach a checkpoint requiring human review:\n\n1. Update your status to \"waiting-gate\"\n2. Add entry to coordination/gates-pending.json:\n\n```json\n{\n  \"id\": \"gate-{uuid}\",\n  \"agent\": \"{agent-id}\",\n  \"type\": \"{gate-type}\",\n  \"description\": \"{what needs review}\",\n  \"artifacts\": [\"{paths to review}\"],\n  \"requestedAt\": \"{timestamp}\",\n  \"status\": \"pending\"\n}\n```\n\n3. Wait for approval (check gates-pending.json for status: \"approved\")\n\n### Resource Locks\n\nBefore modifying shared files (outside your worktree):\n\n1. Check coordination/locks.json\n2. If unlocked, acquire lock:\n```json\n{\n  \"resource\": \"{file-path}\",\n  \"lockedBy\": \"{agent-id}\",\n  \"lockedAt\": \"{timestamp}\",\n  \"expiresAt\": \"{timestamp + 5min}\",\n  \"reason\": \"{why}\"\n}\n```\n3. Make changes\n4. Release lock (remove entry)\n\n### Completion\n\nWhen done:\n1. Commit all changes to your branch\n2. Update status to \"completed\"\n3. Add completion event to coordination/events.json:\n```json\n{\n  \"type\": \"agent.completed\",\n  \"agent\": \"{agent-id}\",\n  \"system\": \"{system-name}\",\n  \"timestamp\": \"{timestamp}\",\n  \"branch\": \"feature/{system-name}\",\n  \"commits\": [\"{commit-hashes}\"]\n}\n```\n\n## Mode-Specific Behavior\n\n{mode-specific-instructions}\n\n## Begin\n\nNavigate to your worktree and begin execution:\n\n```bash\ncd {worktree-path}\ngit status\n```\n\nExecute the loop for your system. Good luck!\n```\n\n---\n\n## State Files\n\n### Agent State (coordination/agents/{agent-id}.json)\n\n```json\n{\n  \"id\": \"agent-ui-polish\",\n  \"system\": \"ui-polish\",\n  \"worktree\": \".worktrees/ui-polish\",\n  \"branch\": \"feature/ui-polish\",\n  \"status\": \"running\",\n  \"currentStage\": \"IMPLEMENT\",\n  \"progress\": \"Adding dark mode styles to components\",\n  \"startedAt\": \"2026-01-20T15:00:00Z\",\n  \"lastHeartbeat\": \"2026-01-20T15:45:00Z\",\n  \"outputFile\": \"/path/to/task-output.txt\",\n  \"metrics\": {\n    \"filesModified\": 12,\n    \"testsAdded\": 5,\n    \"commitsCreated\": 3\n  }\n}\n```\n\n### Gates Pending (coordination/gates-pending.json)\n\n```json\n{\n  \"gates\": [\n    {\n      \"id\": \"gate-abc123\",\n      \"agent\": \"agent-ui-polish\",\n      \"type\": \"visual-review\",\n      \"description\": \"Dark mode styling complete, ready for visual review\",\n      \"artifacts\": [\n        \"screenshots/home-dark.png\",\n        \"screenshots/dashboard-dark.png\"\n      ],\n      \"requestedAt\": \"2026-01-20T16:00:00Z\",\n      \"status\": \"pending\",\n      \"priority\": \"normal\"\n    },\n    {\n      \"id\": \"gate-def456\",\n      \"agent\": \"agent-data-validation\",\n      \"type\": \"schema-review\",\n      \"description\": \"Database schema changes ready for review\",\n      \"artifacts\": [\n        \"prisma/schema.prisma\",\n        \"prisma/migrations/20260120_add_validation/\"\n      ],\n      \"requestedAt\": \"2026-01-20T16:05:00Z\",\n      \"status\": \"pending\",\n      \"priority\": \"high\"\n    }\n  ]\n}\n```\n\n### Locks (coordination/locks.json)\n\n```json\n{\n  \"locks\": [\n    {\n      \"resource\": \"shared/types/index.ts\",\n      \"lockedBy\": \"agent-api\",\n      \"lockedAt\": \"2026-01-20T15:30:00Z\",\n      \"expiresAt\": \"2026-01-20T15:35:00Z\",\n      \"reason\": \"Adding new API types\"\n    }\n  ]\n}\n```\n\n### Events (coordination/events.json)\n\n```json\n{\n  \"events\": [\n    {\n      \"id\": \"evt-001\",\n      \"type\": \"agent.spawned\",\n      \"agent\": \"agent-ui-polish\",\n      \"timestamp\": \"2026-01-20T15:00:00Z\"\n    },\n    {\n      \"id\": \"evt-002\",\n      \"type\": \"agent.stage_changed\",\n      \"agent\": \"agent-ui-polish\",\n      \"fromStage\": \"SCAFFOLD\",\n      \"toStage\": \"IMPLEMENT\",\n      \"timestamp\": \"2026-01-20T15:15:00Z\"\n    },\n    {\n      \"id\": \"evt-003\",\n      \"type\": \"agent.completed\",\n      \"agent\": \"agent-data-validation\",\n      \"timestamp\": \"2026-01-20T16:30:00Z\",\n      \"branch\": \"feature/data-validation\"\n    }\n  ]\n}\n```\n\n---\n\n## Orchestrator Monitoring\n\n### Progress Check Loop\n\n```javascript\nasync function monitorAgents(agents) {\n  while (agents.some(a => a.status !== 'completed' && a.status !== 'failed')) {\n    // Check each agent\n    for (const agent of agents) {\n      const state = await readAgentState(agent.id);\n\n      // Update heartbeat check\n      if (isHeartbeatStale(state.lastHeartbeat)) {\n        console.warn(`Agent ${agent.id} heartbeat stale`);\n        // Consider intervention\n      }\n\n      // Check for gate requests\n      if (state.status === 'waiting-gate') {\n        await queueGateForHuman(agent.id);\n      }\n\n      // Check for completion\n      if (state.status === 'completed') {\n        await handleAgentCompletion(agent.id);\n      }\n\n      // Check for failure\n      if (state.status === 'failed') {\n        await handleAgentFailure(agent.id);\n      }\n    }\n\n    // Check pending gates\n    await processGateQueue();\n\n    // Sleep before next check\n    await sleep(30000); // 30 seconds\n  }\n}\n```\n\n### Gate Queue Processing\n\n```\nOrchestrator displays pending gates to user:\n\n═══════════════════════════════════════════════════════════\nSTAGE GATES PENDING (3)\n═══════════════════════════════════════════════════════════\n\n[1] agent-ui-polish: Visual Review (normal priority)\n    Dark mode styling complete, ready for visual review\n    Artifacts: screenshots/home-dark.png, screenshots/dashboard-dark.png\n    Waiting: 5 minutes\n\n[2] agent-data-validation: Schema Review (HIGH priority)\n    Database schema changes ready for review\n    Artifacts: prisma/schema.prisma\n    Waiting: 3 minutes\n\n[3] agent-api: Security Review (normal priority)\n    New API endpoints ready for security check\n    Artifacts: src/routes/api/users.ts\n    Waiting: 1 minute\n\n═══════════════════════════════════════════════════════════\n\nSelect gate to review [1-3] or 'all' for batch:\n```\n\n---\n\n## Merge Coordination\n\n### When All Agents Complete\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                       MERGE PROCEDURE                                        │\n│                                                                             │\n│  1. VERIFY ALL AGENTS COMPLETE                                              │\n│     • All status = \"completed\"                                              │\n│     • No pending gates                                                      │\n│                                                                             │\n│  2. MERGE SEQUENTIALLY (safest)                                             │\n│     For each agent branch:                                                  │\n│     a. git checkout main                                                    │\n│     b. git merge feature/{system} --no-ff                                   │\n│     c. Resolve conflicts if any                                             │\n│     d. Run tests                                                            │\n│     e. If tests pass, continue; else stop                                   │\n│                                                                             │\n│  3. ALTERNATIVE: MERGE TO INTEGRATION BRANCH                                │\n│     a. Create integration branch                                            │\n│     b. Merge all feature branches                                           │\n│     c. Test integration branch                                              │\n│     d. PR integration → main                                                │\n│                                                                             │\n│  4. CLEANUP                                                                 │\n│     • Remove worktrees: git worktree remove .worktrees/{name}               │\n│     • Delete branches if merged                                             │\n│     • Archive coordination files                                            │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Limits and Guidelines\n\n### Resource Limits\n\n| Resource | Recommended Limit | Reason |\n|----------|------------------|--------|\n| Max sub-agents | 7 | System resources, coordination overhead |\n| Heartbeat timeout | 5 minutes | Detect stale agents |\n| Lock TTL | 5 minutes | Prevent deadlocks |\n| Gate timeout | 30 minutes | Don't block indefinitely |\n\n### When to Use Parallel Agents\n\n**Use parallel agents when:**\n- Systems are truly independent\n- No shared file modifications\n- Each system has clear boundaries\n- Speedup justifies coordination overhead\n\n**Don't use parallel agents when:**\n- Systems have tight dependencies\n- Shared state requires coordination\n- Single system with sequential steps\n- User prefers to review sequentially\n\n---\n\n## Troubleshooting\n\n### Agent Not Responding\n\n1. Check output file via `Read` tool\n2. Check agent state file\n3. If stale, consider:\n   - Resume agent with Task tool (using agent ID)\n   - Kill and restart\n   - Absorb work into another agent\n\n### Merge Conflicts\n\n1. Identify conflicting files\n2. Determine which agent's changes take precedence\n3. Manual resolution in integration branch\n4. Re-run tests\n\n### Gate Queue Backup\n\n1. Prioritize critical gates\n2. Batch review similar gates\n3. Consider auto-approve for low-risk gates\n4. Communicate delays to agents (via events)\n\n---\n\n*Parallel agents multiply throughput when used correctly. Coordinate carefully.*\n"
    },
    {
      "name": "scope-discovery.md",
      "path": "references/scope-discovery.md",
      "content": "# Scope Discovery Reference\n\nPre-loop analysis to identify everything that needs to be done.\n\n---\n\n## Purpose\n\nScope discovery minimizes loops by catching all work upfront. The goal is to answer: **\"What does 'done' look like, and what's missing?\"**\n\n---\n\n## Discovery by Mode\n\n### Greenfield Discovery\n\nFor new projects, scope discovery means:\n\n1. **Capture vision** (via entry-portal)\n   - What is this project?\n   - What problem does it solve?\n   - Who are the users?\n\n2. **Identify systems**\n   - Core functionality\n   - Supporting systems\n   - Infrastructure needs\n\n3. **Generate feature specs**\n   - 18-section specs per system\n   - Capability breakdown\n   - Integration points\n\n4. **Estimate scope**\n   - Complexity per system\n   - Dependencies between systems\n   - Parallelization opportunities\n\n### Brownfield-Polish Discovery\n\nFor near-complete apps, scope discovery means finding gaps:\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                    POLISH GAP CATEGORIES (MECE)                              │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                             │\n│  1. DEPLOYMENT GAPS                                                         │\n│     • CI/CD pipeline missing or incomplete                                  │\n│     • Hosting not configured                                                │\n│     • Environment variables not set                                         │\n│     • Secrets not managed                                                   │\n│     • Domain/DNS not configured                                             │\n│     • SSL not set up                                                        │\n│                                                                             │\n│  2. UI/UX GAPS                                                              │\n│     • Not dark mode                                                         │\n│     • Not responsive                                                        │\n│     • Inconsistent styling                                                  │\n│     • Missing loading states                                                │\n│     • Missing error states                                                  │\n│     • Accessibility issues                                                  │\n│     • No favicon/meta tags                                                  │\n│                                                                             │\n│  3. DATA GAPS                                                               │\n│     • Schema incomplete                                                     │\n│     • Validation missing                                                    │\n│     • CRUD operations incomplete                                            │\n│     • Seed data missing                                                     │\n│     • Migrations not set up                                                 │\n│                                                                             │\n│  4. TESTING GAPS                                                            │\n│     • No unit tests                                                         │\n│     • No integration tests                                                  │\n│     • No E2E tests                                                          │\n│     • Coverage below target                                                 │\n│                                                                             │\n│  5. DOCUMENTATION GAPS                                                      │\n│     • README incomplete                                                     │\n│     • API not documented                                                    │\n│     • No setup instructions                                                 │\n│     • No architecture overview                                              │\n│                                                                             │\n│  6. SECURITY GAPS                                                           │\n│     • Auth incomplete                                                       │\n│     • Input not validated                                                   │\n│     • Secrets exposed                                                       │\n│     • Dependencies vulnerable                                               │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Brownfield-Enterprise Discovery\n\nFor enterprise codebases, scope discovery means:\n\n1. **Deep codebase analysis**\n   - Architecture patterns\n   - Code conventions\n   - Testing patterns\n   - Existing abstractions\n\n2. **Dependency mapping**\n   - What depends on what\n   - Integration points\n   - Shared resources\n\n3. **Roadmap review**\n   - Existing plans\n   - Team priorities\n   - Blocked items\n\n4. **Highest-leverage identification**\n   - What has most impact\n   - What unblocks others\n   - What aligns with team\n\n---\n\n## Gap Detection Procedures\n\n### Deployment Gap Detection\n\n```bash\n# Check CI/CD\nls .github/workflows/*.yml 2>/dev/null || echo \"GAP: No GitHub Actions\"\nls .gitlab-ci.yml 2>/dev/null || echo \"GAP: No GitLab CI\"\nls Jenkinsfile 2>/dev/null || echo \"GAP: No Jenkins\"\n\n# Check deployment config\nls Dockerfile 2>/dev/null || echo \"GAP: No Dockerfile\"\nls docker-compose.yml 2>/dev/null || echo \"GAP: No docker-compose\"\nls vercel.json 2>/dev/null || echo \"GAP: No Vercel config\"\nls netlify.toml 2>/dev/null || echo \"GAP: No Netlify config\"\nls fly.toml 2>/dev/null || echo \"GAP: No Fly.io config\"\n\n# Check environment\nls .env.example 2>/dev/null || echo \"GAP: No .env.example\"\ngrep -r \"process.env\" src/ 2>/dev/null | head -5 || echo \"INFO: No env vars used\"\n```\n\n### UI/UX Gap Detection\n\n```bash\n# Check for dark mode\ngrep -r \"dark\" --include=\"*.css\" --include=\"*.scss\" --include=\"*.tailwind\" . 2>/dev/null || echo \"GAP: No dark mode styles\"\ngrep -r \"prefers-color-scheme\" . 2>/dev/null || echo \"GAP: No system theme detection\"\n\n# Check for responsive\ngrep -r \"@media\" --include=\"*.css\" . 2>/dev/null || echo \"GAP: No media queries\"\ngrep -r \"sm:|md:|lg:|xl:\" . 2>/dev/null || echo \"INFO: Check Tailwind breakpoints\"\n\n# Check meta tags\ngrep -r \"viewport\" --include=\"*.html\" --include=\"*.tsx\" --include=\"*.jsx\" . 2>/dev/null || echo \"GAP: No viewport meta\"\ngrep -r \"favicon\" . 2>/dev/null || echo \"GAP: No favicon\"\n```\n\n### Data Gap Detection\n\n```bash\n# Check schema\nls prisma/schema.prisma 2>/dev/null || ls drizzle/ 2>/dev/null || echo \"GAP: No schema definition\"\n\n# Check migrations\nls prisma/migrations/ 2>/dev/null || ls drizzle/migrations/ 2>/dev/null || echo \"GAP: No migrations\"\n\n# Check validation\ngrep -r \"zod\\|yup\\|joi\\|validator\" package.json 2>/dev/null || echo \"GAP: No validation library\"\n\n# Check seed data\ngrep -r \"seed\" package.json 2>/dev/null || echo \"GAP: No seed script\"\n```\n\n### Testing Gap Detection\n\n```bash\n# Check test files\nfind . -name \"*.test.*\" -o -name \"*.spec.*\" | grep -v node_modules | wc -l\n# If 0, GAP: No tests\n\n# Check test config\nls jest.config.* vitest.config.* 2>/dev/null || echo \"GAP: No test config\"\n\n# Check coverage config\ngrep -r \"coverage\" jest.config.* vitest.config.* 2>/dev/null || echo \"GAP: No coverage config\"\n\n# Check E2E\nls cypress/ playwright/ 2>/dev/null || echo \"GAP: No E2E framework\"\n```\n\n### Documentation Gap Detection\n\n```bash\n# Check README\nwc -l README.md 2>/dev/null || echo \"GAP: No README\"\n# If < 20 lines, GAP: README too short\n\n# Check docs\nls docs/ 2>/dev/null || echo \"GAP: No docs directory\"\n\n# Check API docs\ngrep -r \"openapi\\|swagger\" . 2>/dev/null || echo \"GAP: No API documentation\"\n\n# Check code comments\ngrep -r \"@param\\|@returns\\|@example\" src/ 2>/dev/null | wc -l\n# If low, GAP: Sparse documentation\n```\n\n### Security Gap Detection\n\n```bash\n# Check auth\ngrep -r \"auth\\|login\\|session\\|jwt\" src/ 2>/dev/null || echo \"INFO: Check if auth needed\"\n\n# Check input validation\ngrep -r \"sanitize\\|escape\\|validate\" src/ 2>/dev/null || echo \"GAP: No input sanitization\"\n\n# Check for secrets in code\ngrep -r \"password\\|secret\\|api_key\" --include=\"*.ts\" --include=\"*.js\" . 2>/dev/null | grep -v \".env\" && echo \"GAP: Possible hardcoded secrets\"\n\n# Check dependencies\nnpm audit 2>/dev/null || yarn audit 2>/dev/null || echo \"INFO: Run dependency audit\"\n```\n\n---\n\n## Gap Severity Classification\n\n| Severity | Definition | Examples |\n|----------|------------|----------|\n| **Critical** | Blocks production deployment | No deployment config, broken build |\n| **High** | Significantly impacts quality | No auth, major UI issues, no validation |\n| **Medium** | Reduces polish | Missing tests, incomplete docs |\n| **Low** | Nice to have | Minor style issues, extra features |\n\n---\n\n## SCOPE-DISCOVERY.md Template\n\n```markdown\n# Scope Discovery: {project-name}\n\n**Date:** {date}\n**Mode:** {detected-mode}\n**Analyst:** {orchestrator/agent}\n\n## Executive Summary\n\n{2-3 sentences: current state, main gaps, estimated effort}\n\n## Mode Confirmation\n\n- **Detected:** {mode}\n- **Confidence:** {X}%\n- **Confirmed:** {yes/no/overridden}\n\n## Gap Analysis\n\n### Critical Gaps (blocks deployment)\n\n| Gap | Category | Description | Effort |\n|-----|----------|-------------|--------|\n| {gap-1} | Deployment | {description} | {S/M/L} |\n\n### High Priority Gaps (quality impact)\n\n| Gap | Category | Description | Effort |\n|-----|----------|-------------|--------|\n| {gap-2} | UI/UX | {description} | {S/M/L} |\n| {gap-3} | Data | {description} | {S/M/L} |\n\n### Medium Priority Gaps (polish)\n\n| Gap | Category | Description | Effort |\n|-----|----------|-------------|--------|\n| {gap-4} | Testing | {description} | {S/M/L} |\n| {gap-5} | Documentation | {description} | {S/M/L} |\n\n### Low Priority Gaps (nice to have)\n\n| Gap | Category | Description | Effort |\n|-----|----------|-------------|--------|\n| {gap-6} | {category} | {description} | {S/M/L} |\n\n## Systems/Tasks to Build\n\n| ID | System | Type | Priority | Parallelizable | Dependencies |\n|----|--------|------|----------|----------------|--------------|\n| S1 | {system-1} | {gap-fill/new} | Critical | No | - |\n| S2 | {system-2} | {gap-fill/new} | High | Yes | - |\n| S3 | {system-3} | {gap-fill/new} | High | Yes | - |\n| S4 | {system-4} | {gap-fill/new} | Medium | Yes | S1 |\n\n## Execution Plan\n\n### Loop 1 (Critical + High)\n\n**Sequential:**\n1. S1: {system-1} — {reason for sequential}\n\n**Parallel (after S1):**\n- S2: {system-2} → Agent 1\n- S3: {system-3} → Agent 2\n\n**Exit Criteria:**\n- [ ] {criterion-1}\n- [ ] {criterion-2}\n\n### Loop 2 (Medium + Low, if needed)\n\n**Parallel:**\n- S4: {system-4} → Agent 1\n- S5: {system-5} → Agent 2\n\n**Exit Criteria:**\n- [ ] {criterion-3}\n- [ ] {criterion-4}\n\n## Estimates\n\n| Dimension | Value |\n|-----------|-------|\n| Total gaps | {N} |\n| Estimated loops | {1-3} |\n| Estimated hours (agentic) | {X-Y hours} |\n| Parallelization factor | {N agents} |\n\n## Risks\n\n| Risk | Likelihood | Impact | Mitigation |\n|------|------------|--------|------------|\n| {risk-1} | {L/M/H} | {L/M/H} | {mitigation} |\n\n## Open Questions\n\n- [ ] {question-1}\n- [ ] {question-2}\n```\n\n---\n\n## Discovery Best Practices\n\n1. **Be thorough upfront** — Missing a gap means an extra loop later\n2. **Classify severity honestly** — Not everything is critical\n3. **Identify parallelization** — More parallel = faster completion\n4. **Consider dependencies** — Order matters\n5. **Estimate conservatively** — Surprises are usually bad\n\n---\n\n*Comprehensive scope discovery is the key to minimizing loops.*\n"
    },
    {
      "name": "ui-ux-verification.md",
      "path": "references/ui-ux-verification.md",
      "content": "# UI/UX Verification Reference\n\nEnsuring beautiful, functional interfaces in brownfield-polish mode.\n\n---\n\n## Purpose\n\nUI/UX verification ensures:\n1. **Dark mode by default** — Clean, modern aesthetic\n2. **Responsive design** — Works on all screen sizes\n3. **Consistent styling** — Design system conformance\n4. **Good UX patterns** — Loading, errors, empty states\n\n---\n\n## Verification Checklist\n\n### 1. Dark Mode\n\n| Check | How to Verify | Fix If Missing |\n|-------|---------------|----------------|\n| Background is dark | Visual inspection | Set `bg-gray-900` or `bg-slate-900` |\n| Text is light | Visual inspection | Set `text-gray-100` or `text-white` |\n| No white flash | Load page fresh | Add `dark` class to `<html>` before render |\n| System preference respected | Toggle OS theme | Use `prefers-color-scheme` media query |\n| Consistent palette | Compare all pages | Use design tokens |\n| Sufficient contrast | Use contrast checker | WCAG AA minimum (4.5:1 for text) |\n\n**Dark Mode Implementation:**\n\n```css\n/* Tailwind - in tailwind.config.js */\nmodule.exports = {\n  darkMode: 'class', // or 'media'\n}\n\n/* Apply dark mode globally */\n<html class=\"dark\">\n\n/* Styles */\n.dark body {\n  @apply bg-gray-900 text-gray-100;\n}\n```\n\n```javascript\n// Detect system preference\nif (window.matchMedia('(prefers-color-scheme: dark)').matches) {\n  document.documentElement.classList.add('dark');\n}\n\n// Always dark (default)\ndocument.documentElement.classList.add('dark');\n```\n\n### 2. Responsive Design\n\n| Breakpoint | Width | What to Check |\n|------------|-------|---------------|\n| Mobile | < 640px | Single column, touch targets |\n| Tablet | 640-1024px | Adjusted layout |\n| Desktop | > 1024px | Full layout |\n\n**Verification Commands:**\n\n```bash\n# Check for responsive classes (Tailwind)\ngrep -r \"sm:\\|md:\\|lg:\\|xl:\" src/ | wc -l\n# Should be > 0 for responsive sites\n\n# Check for media queries (CSS)\ngrep -r \"@media\" src/ | wc -l\n```\n\n**Common Responsive Patterns:**\n\n```html\n<!-- Navigation: hamburger on mobile -->\n<nav class=\"hidden md:flex\">...</nav>\n<button class=\"md:hidden\">Menu</button>\n\n<!-- Grid: stack on mobile -->\n<div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3\">\n\n<!-- Text: smaller on mobile -->\n<h1 class=\"text-2xl md:text-4xl\">\n```\n\n### 3. Spacing & Alignment\n\n| Check | Standard | How to Verify |\n|-------|----------|---------------|\n| Consistent padding | 4px increments | Visual inspection |\n| Aligned elements | Grid/flex | Browser dev tools |\n| Proper margins | 4/8/16/24/32px | Measure in dev tools |\n| No overflow | Elements within viewport | Scroll horizontally |\n\n**Spacing Scale (Tailwind):**\n- `p-1` = 4px\n- `p-2` = 8px\n- `p-4` = 16px\n- `p-6` = 24px\n- `p-8` = 32px\n\n### 4. Typography\n\n| Check | Standard | How to Verify |\n|-------|----------|---------------|\n| Font loaded | System or web font | Inspect computed style |\n| Hierarchy clear | Distinct heading sizes | Visual inspection |\n| Line height | 1.5 for body, 1.2 for headings | Computed style |\n| Max width | ~65 characters for prose | Measure |\n\n**Typography Defaults:**\n\n```css\nbody {\n  @apply font-sans text-base leading-relaxed;\n}\n\nh1 { @apply text-4xl font-bold leading-tight; }\nh2 { @apply text-3xl font-semibold leading-tight; }\nh3 { @apply text-2xl font-medium leading-snug; }\n\n/* Prose max width */\n.prose {\n  @apply max-w-prose; /* ~65ch */\n}\n```\n\n### 5. Interactive Elements\n\n| Element | Required States | Check |\n|---------|-----------------|-------|\n| Buttons | default, hover, active, disabled | Hover and click each |\n| Links | default, hover, visited, active | Navigate and return |\n| Inputs | default, focus, error, disabled | Tab through form |\n| Cards | default, hover (if clickable) | Hover test |\n\n**Button States:**\n\n```html\n<button class=\"\n  bg-blue-600 hover:bg-blue-700 active:bg-blue-800\n  disabled:bg-gray-400 disabled:cursor-not-allowed\n  focus:outline-none focus:ring-2 focus:ring-blue-500\n  transition-colors\n\">\n```\n\n### 6. Loading States\n\n| Location | Expected | Check |\n|----------|----------|-------|\n| Page load | Skeleton or spinner | Throttle network in dev tools |\n| Button submit | Loading indicator | Click and observe |\n| Data fetch | Loading state | Slow API response |\n| Image load | Placeholder or blur | Throttle images |\n\n**Loading Patterns:**\n\n```jsx\n// Skeleton\n{isLoading ? (\n  <div class=\"animate-pulse bg-gray-700 h-4 w-full rounded\" />\n) : (\n  <p>{content}</p>\n)}\n\n// Button loading\n<button disabled={isLoading}>\n  {isLoading ? <Spinner /> : 'Submit'}\n</button>\n```\n\n### 7. Error States\n\n| Location | Expected | Check |\n|----------|----------|-------|\n| Form validation | Inline error messages | Submit invalid form |\n| API errors | User-friendly message | Disconnect network |\n| 404 page | Helpful not found page | Visit invalid URL |\n| Crash | Error boundary | Throw error in component |\n\n**Error Patterns:**\n\n```jsx\n// Form error\n<input class={error ? 'border-red-500' : 'border-gray-600'} />\n{error && <p class=\"text-red-500 text-sm\">{error}</p>}\n\n// Error boundary fallback\n<div class=\"text-center p-8\">\n  <h2>Something went wrong</h2>\n  <button onClick={retry}>Try again</button>\n</div>\n```\n\n### 8. Empty States\n\n| Location | Expected | Check |\n|----------|----------|-------|\n| Empty list | Helpful message + CTA | Clear all data |\n| No search results | Suggestions | Search nonsense |\n| First-time user | Onboarding | New account |\n\n**Empty State Pattern:**\n\n```jsx\n{items.length === 0 ? (\n  <div class=\"text-center p-8 text-gray-400\">\n    <Icon class=\"w-12 h-12 mx-auto mb-4\" />\n    <h3>No items yet</h3>\n    <p>Get started by creating your first item.</p>\n    <button>Create Item</button>\n  </div>\n) : (\n  <ItemList items={items} />\n)}\n```\n\n### 9. Accessibility\n\n| Check | Standard | How to Verify |\n|-------|----------|---------------|\n| Keyboard navigation | Tab through all interactive | Use keyboard only |\n| Focus visible | Clear focus ring | Tab and observe |\n| Alt text | All images have alt | Inspect images |\n| ARIA labels | Interactive elements labeled | Screen reader |\n| Color contrast | 4.5:1 minimum | Contrast checker |\n\n**Accessibility Basics:**\n\n```html\n<!-- Focus visible -->\n<button class=\"focus:ring-2 focus:ring-blue-500 focus:outline-none\">\n\n<!-- Alt text -->\n<img src=\"...\" alt=\"Description of image\" />\n\n<!-- ARIA labels -->\n<button aria-label=\"Close menu\">\n  <XIcon />\n</button>\n\n<!-- Skip link -->\n<a href=\"#main\" class=\"sr-only focus:not-sr-only\">\n  Skip to content\n</a>\n```\n\n### 10. Polish Details\n\n| Detail | Standard | How to Verify |\n|--------|----------|---------------|\n| Favicon | Present and appropriate | Check browser tab |\n| Page title | Descriptive per page | Check browser tab |\n| Meta description | Present | View page source |\n| Open Graph | Social sharing works | Share link |\n| Smooth transitions | 150-300ms | Interact with UI |\n| No console errors | Clean console | Open dev tools |\n\n**Polish Checklist:**\n\n```html\n<head>\n  <link rel=\"icon\" href=\"/favicon.ico\" />\n  <title>Page Title | App Name</title>\n  <meta name=\"description\" content=\"...\" />\n  <meta property=\"og:title\" content=\"...\" />\n  <meta property=\"og:image\" content=\"...\" />\n</head>\n```\n\n---\n\n## Verification Procedure\n\n### Automated Checks\n\n```bash\n# 1. Check for dark mode classes\ngrep -r \"dark:\" src/ | wc -l\n# Expect > 0\n\n# 2. Check for responsive classes\ngrep -r \"sm:\\|md:\\|lg:\" src/ | wc -l\n# Expect > 0\n\n# 3. Check for loading states\ngrep -r \"loading\\|isLoading\\|pending\" src/ | wc -l\n# Expect > 0\n\n# 4. Run accessibility audit\nnpx lighthouse --only-categories=accessibility http://localhost:3000\n# Expect > 90\n\n# 5. Check console errors\n# Manual: Open dev tools, check console\n\n# 6. Run linter\nnpm run lint\n# Expect no errors\n```\n\n### Manual Verification\n\n```\nUI/UX Verification Checklist\n═══════════════════════════\n\nDark Mode\n  [ ] Background is dark (#1a1a1a or similar)\n  [ ] Text is light and readable\n  [ ] No white flash on load\n  [ ] Consistent color palette\n\nResponsive\n  [ ] Mobile (375px): Single column, usable\n  [ ] Tablet (768px): Appropriate layout\n  [ ] Desktop (1440px): Full experience\n\nSpacing\n  [ ] Consistent padding/margins\n  [ ] Elements properly aligned\n  [ ] No horizontal overflow\n\nTypography\n  [ ] Font loads correctly\n  [ ] Clear heading hierarchy\n  [ ] Readable line length\n\nInteractive\n  [ ] All buttons have hover states\n  [ ] Focus states visible\n  [ ] Disabled states clear\n\nStates\n  [ ] Loading indicators present\n  [ ] Error messages helpful\n  [ ] Empty states informative\n\nAccessibility\n  [ ] Keyboard navigable\n  [ ] Focus visible\n  [ ] Sufficient contrast\n\nPolish\n  [ ] Favicon present\n  [ ] Page titles set\n  [ ] No console errors\n  [ ] Smooth transitions\n```\n\n---\n\n## Integration with frontend-design Skill\n\nFor comprehensive UI/UX work, invoke the `frontend-design` skill:\n\n```\nInvoke: frontend-design\n\nContext: Brownfield-polish mode, verifying UI/UX\nInput: {\n  \"currentState\": \"Basic styling exists\",\n  \"goals\": [\n    \"Dark mode default\",\n    \"Responsive design\",\n    \"Polish and consistency\"\n  ]\n}\n```\n\nThe frontend-design skill provides:\n- Component patterns\n- Design system recommendations\n- Specific fixes for common issues\n\n---\n\n## Quick Fixes\n\n### Add Dark Mode Fast\n\n```html\n<!-- In <head> before any render -->\n<script>\n  document.documentElement.classList.add('dark');\n</script>\n\n<!-- In CSS/Tailwind -->\n<body class=\"bg-gray-900 text-gray-100\">\n```\n\n### Add Responsive Fast\n\n```html\n<!-- Container with max-width and padding -->\n<div class=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n  <!-- Content -->\n</div>\n\n<!-- Stack on mobile, row on desktop -->\n<div class=\"flex flex-col md:flex-row gap-4\">\n```\n\n### Add Loading State Fast\n\n```jsx\n// Simple loading wrapper\nfunction LoadingWrapper({ isLoading, children }) {\n  if (isLoading) {\n    return <div class=\"animate-pulse\">Loading...</div>;\n  }\n  return children;\n}\n```\n\n---\n\n*Beautiful UI/UX is a feature, not a luxury. Polish mode ensures it's not forgotten.*\n"
    }
  ],
  "tags": [
    "meta",
    "orchestration",
    "coordination",
    "modes"
  ],
  "dependsOn": []
}