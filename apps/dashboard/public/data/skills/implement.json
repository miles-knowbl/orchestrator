{
  "id": "implement",
  "name": "implement",
  "version": "1.0.0",
  "description": "Transform specifications into working, production-quality code. Takes FeatureSpecs, requirements, or design documents and produces complete implementations following established patterns. Handles data layer, service layer, API layer, and UI components with proper error handling, validation, and tests.",
  "phase": "IMPLEMENT",
  "category": "engineering",
  "content": "# Implement\n\nTransform specifications into working code.\n\n## When to Use\n\n- **After spec** — FeatureSpec ready, need implementation\n- **After scaffold** — Project structure exists, need feature code\n- **Defined task** — Clear requirements, need code\n- **Bug fix** — Issue identified, need implementation of fix\n- When you say: \"implement this\", \"build this feature\", \"write the code for\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `service-layer-patterns.md` | Core patterns for business logic |\n| `error-handling-patterns.md` | How to handle errors properly |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `data-layer-patterns.md` | When working with databases |\n| `api-layer-patterns.md` | When building APIs |\n| `testing-patterns.md` | When writing tests alongside |\n\n**Verification:** Ensure code follows patterns from references, not ad-hoc approaches.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Source code files | `src/` | Always |\n| Test files | `tests/` | Always (alongside implementation) |\n\n## Core Concept\n\nImplement answers: **\"How do I turn this spec into working code?\"**\n\nGood implementation is:\n- **Faithful** — Matches the specification exactly\n- **Complete** — All capabilities, all edge cases, all error handling\n- **Tested** — Tests written alongside code\n- **Reviewable** — Clean, well-organized, follows conventions\n\nImplementation is NOT:\n- Architecture design (that's `architect`)\n- Requirements gathering (that's `requirements`)\n- Project setup (that's `scaffold`)\n- Code improvement (that's `refactor`)\n\n## The Implementation Process\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                IMPLEMENTATION PROCESS                   │\n│                                                         │\n│  1. UNDERSTAND THE SPEC                                 │\n│     └─→ What exactly needs to be built?                 │\n│                                                         │\n│  2. PLAN IMPLEMENTATION ORDER                           │\n│     └─→ What order minimizes blocked work?              │\n│                                                         │\n│  3. IMPLEMENT DATA LAYER                                │\n│     └─→ Models, migrations, repositories                │\n│                                                         │\n│  4. IMPLEMENT SERVICE LAYER                             │\n│     └─→ Business logic, validation, orchestration       │\n│                                                         │\n│  5. IMPLEMENT API LAYER                                 │\n│     └─→ Endpoints, request/response handling            │\n│                                                         │\n│  6. IMPLEMENT UI LAYER                                  │\n│     └─→ Components, state, user interactions            │\n│                                                         │\n│  7. VERIFY & TEST                                       │\n│     └─→ Unit tests, integration tests, manual verify    │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Step 1: Understand the Spec\n\nBefore writing code, fully understand what you're building.\n\n### Reading a FeatureSpec\n\nIf working from a FeatureSpec (from `spec` skill), extract:\n\n| Section | What to Extract |\n|---------|-----------------|\n| **Feature Overview** | Business context, user stories |\n| **Entities** | Database tables, fields, relationships |\n| **Capabilities** | What the system must do (CAP-###) |\n| **Service Layer** | Business logic implementation |\n| **API Layer** | Endpoints, request/response shapes |\n| **UI Components** | Components to build, states to handle |\n| **Feedback Timing** | How fast things should respond |\n| **Test Scenarios** | What tests to write |\n\n### Capability Extraction\n\nFor each capability (CAP-###), note:\n\n```markdown\n## CAP-001: create_order\n\n**Trigger:** User clicks \"Place Order\"\n**Input:** cart_id, shipping_address, payment_method\n**Output:** order_id, confirmation_number\n**Validation:** Cart not empty, address valid, payment valid\n**Side Effects:** Inventory reserved, payment charged, email sent\n**Error Cases:** CART_EMPTY, INVALID_ADDRESS, PAYMENT_FAILED, OUT_OF_STOCK\n**Feedback:** Optimistic UI, <50ms visual, background payment\n```\n\n### Understanding Checklist\n\n```markdown\n- [ ] All entities and relationships understood\n- [ ] All capabilities listed with inputs/outputs\n- [ ] Validation rules documented\n- [ ] Error cases identified\n- [ ] Feedback requirements noted\n- [ ] Test scenarios extracted\n- [ ] Questions resolved (none remaining)\n```\n\n## Step 2: Plan Implementation Order\n\n### Dependency-Based Ordering\n\nBuild in order that minimizes blocked work:\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                 IMPLEMENTATION ORDER                    │\n│                                                         │\n│  Layer 1: DATA LAYER (no dependencies)                  │\n│  ├── Database migrations                                │\n│  ├── Entity models                                      │\n│  └── Repository interfaces                              │\n│                                                         │\n│  Layer 2: SERVICE LAYER (depends on data)               │\n│  ├── Business logic services                            │\n│  ├── Validation logic                                   │\n│  └── Cross-cutting concerns                             │\n│                                                         │\n│  Layer 3: API LAYER (depends on services)               │\n│  ├── Route definitions                                  │\n│  ├── Controllers/handlers                               │\n│  └── Request/response DTOs                              │\n│                                                         │\n│  Layer 4: UI LAYER (depends on API)                     │\n│  ├── API client hooks                                   │\n│  ├── Components                                         │\n│  └── Pages/views                                        │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### Within Each Layer\n\nOrder by dependency:\n\n```markdown\n## Service Layer Order\n\n1. **Independent services first**\n   - UserService (no service dependencies)\n   - ProductService (no service dependencies)\n\n2. **Dependent services second**\n   - CartService (depends on ProductService)\n   - OrderService (depends on CartService, UserService)\n\n3. **Orchestration services last**\n   - CheckoutService (orchestrates multiple services)\n```\n\n### Implementation Plan Template\n\n```markdown\n## Implementation Plan: [Feature Name]\n\n### Phase 1: Data Layer\n- [ ] Migration: create_orders_table\n- [ ] Migration: create_order_items_table\n- [ ] Model: Order\n- [ ] Model: OrderItem\n- [ ] Repository: OrderRepository\n\n### Phase 2: Service Layer\n- [ ] Service: OrderService.createOrder\n- [ ] Service: OrderService.getOrder\n- [ ] Service: OrderService.updateStatus\n- [ ] Validation: OrderValidation\n\n### Phase 3: API Layer\n- [ ] POST /api/orders\n- [ ] GET /api/orders/:id\n- [ ] PATCH /api/orders/:id/status\n\n### Phase 4: UI Layer\n- [ ] Hook: useCreateOrder\n- [ ] Component: OrderForm\n- [ ] Component: OrderConfirmation\n- [ ] Page: CheckoutPage\n\n### Phase 5: Testing\n- [ ] Unit: OrderService tests\n- [ ] Integration: Order API tests\n- [ ] E2E: Checkout flow test\n```\n\n## Step 3: Implement Data Layer\n\n### Database Migrations\n\n```typescript\n// migrations/20240115_create_orders.ts\nimport { Kysely, sql } from 'kysely';\n\nexport async function up(db: Kysely<unknown>): Promise<void> {\n  await db.schema\n    .createTable('orders')\n    .addColumn('id', 'uuid', (col) => \n      col.primaryKey().defaultTo(sql`gen_random_uuid()`))\n    .addColumn('user_id', 'uuid', (col) => \n      col.notNull().references('users.id'))\n    .addColumn('status', 'varchar(50)', (col) => \n      col.notNull().defaultTo('pending'))\n    .addColumn('total_cents', 'integer', (col) => col.notNull())\n    .addColumn('created_at', 'timestamptz', (col) => \n      col.notNull().defaultTo(sql`now()`))\n    .addColumn('updated_at', 'timestamptz', (col) => \n      col.notNull().defaultTo(sql`now()`))\n    .execute();\n\n  // Indexes\n  await db.schema\n    .createIndex('idx_orders_user_id')\n    .on('orders')\n    .column('user_id')\n    .execute();\n\n  await db.schema\n    .createIndex('idx_orders_status')\n    .on('orders')\n    .column('status')\n    .execute();\n}\n\nexport async function down(db: Kysely<unknown>): Promise<void> {\n  await db.schema.dropTable('orders').execute();\n}\n```\n\n### Entity Models\n\n```typescript\n// models/Order.ts\nexport interface Order {\n  id: string;\n  userId: string;\n  status: OrderStatus;\n  totalCents: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport type OrderStatus = \n  | 'pending' \n  | 'confirmed' \n  | 'processing' \n  | 'shipped' \n  | 'delivered' \n  | 'cancelled';\n\nexport interface CreateOrderInput {\n  userId: string;\n  items: OrderItemInput[];\n  shippingAddressId: string;\n}\n\nexport interface OrderItemInput {\n  productId: string;\n  quantity: number;\n}\n```\n\n### Repository Pattern\n\n```typescript\n// repositories/OrderRepository.ts\nimport { db } from '../database';\nimport type { Order, CreateOrderInput } from '../models/Order';\n\nexport class OrderRepository {\n  async create(input: CreateOrderInput): Promise<Order> {\n    const [order] = await db\n      .insertInto('orders')\n      .values({\n        user_id: input.userId,\n        status: 'pending',\n        total_cents: 0, // Calculated in service\n      })\n      .returning(['id', 'user_id', 'status', 'total_cents', 'created_at', 'updated_at'])\n      .execute();\n\n    return this.mapToOrder(order);\n  }\n\n  async findById(id: string): Promise<Order | null> {\n    const order = await db\n      .selectFrom('orders')\n      .selectAll()\n      .where('id', '=', id)\n      .executeTakeFirst();\n\n    return order ? this.mapToOrder(order) : null;\n  }\n\n  async findByUserId(userId: string): Promise<Order[]> {\n    const orders = await db\n      .selectFrom('orders')\n      .selectAll()\n      .where('user_id', '=', userId)\n      .orderBy('created_at', 'desc')\n      .execute();\n\n    return orders.map(this.mapToOrder);\n  }\n\n  private mapToOrder(row: OrderRow): Order {\n    return {\n      id: row.id,\n      userId: row.user_id,\n      status: row.status as OrderStatus,\n      totalCents: row.total_cents,\n      createdAt: row.created_at,\n      updatedAt: row.updated_at,\n    };\n  }\n}\n```\n\n→ See `references/data-layer-patterns.md`\n\n## Step 4: Implement Service Layer\n\n### Service Structure\n\n```typescript\n// services/OrderService.ts\nimport { OrderRepository } from '../repositories/OrderRepository';\nimport { ProductService } from './ProductService';\nimport { InventoryService } from './InventoryService';\nimport { PaymentService } from './PaymentService';\nimport { AppError } from '../common/errors';\nimport type { Order, CreateOrderInput } from '../models/Order';\n\nexport class OrderService {\n  constructor(\n    private orderRepo: OrderRepository,\n    private productService: ProductService,\n    private inventoryService: InventoryService,\n    private paymentService: PaymentService,\n  ) {}\n\n  /**\n   * CAP-001: create_order\n   * Creates a new order from cart items\n   */\n  async createOrder(input: CreateOrderInput): Promise<Order> {\n    // 1. Validate input\n    this.validateCreateInput(input);\n\n    // 2. Check inventory\n    await this.checkInventory(input.items);\n\n    // 3. Calculate total\n    const totalCents = await this.calculateTotal(input.items);\n\n    // 4. Reserve inventory\n    const reservationId = await this.inventoryService.reserve(input.items);\n\n    try {\n      // 5. Create order\n      const order = await this.orderRepo.create({\n        ...input,\n        totalCents,\n      });\n\n      // 6. Create order items\n      await this.createOrderItems(order.id, input.items);\n\n      return order;\n    } catch (error) {\n      // Rollback inventory reservation\n      await this.inventoryService.releaseReservation(reservationId);\n      throw error;\n    }\n  }\n\n  private validateCreateInput(input: CreateOrderInput): void {\n    if (!input.items || input.items.length === 0) {\n      throw new AppError('CART_EMPTY', 'Cannot create order with empty cart', 400);\n    }\n\n    for (const item of input.items) {\n      if (item.quantity <= 0) {\n        throw new AppError('INVALID_QUANTITY', 'Quantity must be positive', 400);\n      }\n    }\n  }\n\n  private async checkInventory(items: OrderItemInput[]): Promise<void> {\n    for (const item of items) {\n      const available = await this.inventoryService.getAvailable(item.productId);\n      if (available < item.quantity) {\n        throw new AppError(\n          'OUT_OF_STOCK',\n          `Insufficient inventory for product ${item.productId}`,\n          400,\n          { productId: item.productId, available, requested: item.quantity }\n        );\n      }\n    }\n  }\n\n  private async calculateTotal(items: OrderItemInput[]): Promise<number> {\n    let total = 0;\n    for (const item of items) {\n      const product = await this.productService.getById(item.productId);\n      if (!product) {\n        throw new AppError('PRODUCT_NOT_FOUND', `Product ${item.productId} not found`, 404);\n      }\n      total += product.priceCents * item.quantity;\n    }\n    return total;\n  }\n}\n```\n\n### Validation Layer\n\n```typescript\n// validation/orderValidation.ts\nimport { z } from 'zod';\n\nexport const createOrderSchema = z.object({\n  items: z.array(z.object({\n    productId: z.string().uuid(),\n    quantity: z.number().int().positive(),\n  })).min(1, 'At least one item required'),\n  shippingAddressId: z.string().uuid(),\n  paymentMethodId: z.string().uuid().optional(),\n});\n\nexport type CreateOrderDTO = z.infer<typeof createOrderSchema>;\n\n// Usage in controller\nconst validated = createOrderSchema.parse(req.body);\n```\n\n→ See `references/service-layer-patterns.md`\n\n## Step 5: Implement API Layer\n\n### Route Definition\n\n```typescript\n// routes/orders.ts\nimport { Router } from 'express';\nimport { OrderController } from '../controllers/OrderController';\nimport { authenticate } from '../middleware/authenticate';\nimport { validate } from '../middleware/validate';\nimport { createOrderSchema } from '../validation/orderValidation';\n\nconst router = Router();\nconst controller = new OrderController();\n\nrouter.use(authenticate);\n\nrouter.post('/', validate(createOrderSchema), controller.create);\nrouter.get('/:id', controller.getById);\nrouter.get('/', controller.listForUser);\nrouter.patch('/:id/cancel', controller.cancel);\n\nexport const orderRoutes = router;\n```\n\n### Controller Implementation\n\n```typescript\n// controllers/OrderController.ts\nimport type { Request, Response, NextFunction } from 'express';\nimport { OrderService } from '../services/OrderService';\n\nexport class OrderController {\n  private orderService: OrderService;\n\n  constructor() {\n    this.orderService = new OrderService(/* dependencies */);\n  }\n\n  create = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const order = await this.orderService.createOrder({\n        userId: req.user.id,\n        items: req.body.items,\n        shippingAddressId: req.body.shippingAddressId,\n      });\n\n      res.status(201).json({\n        data: order,\n      });\n    } catch (error) {\n      next(error);\n    }\n  };\n\n  getById = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const order = await this.orderService.getById(req.params.id);\n\n      if (!order) {\n        return res.status(404).json({\n          error: { code: 'NOT_FOUND', message: 'Order not found' },\n        });\n      }\n\n      // Authorization check\n      if (order.userId !== req.user.id && !req.user.isAdmin) {\n        return res.status(403).json({\n          error: { code: 'FORBIDDEN', message: 'Access denied' },\n        });\n      }\n\n      res.json({ data: order });\n    } catch (error) {\n      next(error);\n    }\n  };\n}\n```\n\n### Request/Response Types\n\n```typescript\n// types/api.ts\nexport interface ApiResponse<T> {\n  data: T;\n  meta?: {\n    page?: number;\n    limit?: number;\n    total?: number;\n  };\n}\n\nexport interface ApiError {\n  error: {\n    code: string;\n    message: string;\n    details?: Record<string, unknown>;\n  };\n}\n\n// Specific response types\nexport interface CreateOrderResponse {\n  data: {\n    id: string;\n    status: string;\n    totalCents: number;\n    createdAt: string;\n  };\n}\n```\n\n→ See `references/api-layer-patterns.md`\n\n## Step 6: Implement UI Layer\n\n### API Client Hooks\n\n```typescript\n// hooks/useOrders.ts\nimport { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';\nimport { api } from '../lib/api';\nimport type { Order, CreateOrderInput } from '../types';\n\nexport function useCreateOrder() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (input: CreateOrderInput) => \n      api.post<{ data: Order }>('/orders', input).then(r => r.data.data),\n    \n    onSuccess: () => {\n      // Invalidate orders list\n      queryClient.invalidateQueries({ queryKey: ['orders'] });\n      // Clear cart\n      queryClient.invalidateQueries({ queryKey: ['cart'] });\n    },\n  });\n}\n\nexport function useOrder(orderId: string) {\n  return useQuery({\n    queryKey: ['orders', orderId],\n    queryFn: () => \n      api.get<{ data: Order }>(`/orders/${orderId}`).then(r => r.data.data),\n    enabled: !!orderId,\n  });\n}\n\nexport function useOrders() {\n  return useQuery({\n    queryKey: ['orders'],\n    queryFn: () => \n      api.get<{ data: Order[] }>('/orders').then(r => r.data.data),\n  });\n}\n```\n\n### Component with Feedback\n\n```typescript\n// components/OrderForm.tsx\nimport { useState } from 'react';\nimport { useCreateOrder } from '../hooks/useOrders';\nimport { Button } from './ui/Button';\nimport { useHaptic } from '../hooks/useHaptic';\n\ninterface OrderFormProps {\n  cartId: string;\n  onSuccess: (orderId: string) => void;\n}\n\nexport function OrderForm({ cartId, onSuccess }: OrderFormProps) {\n  const createOrder = useCreateOrder();\n  const haptic = useHaptic();\n  const [optimisticState, setOptimisticState] = useState<'idle' | 'pending' | 'success'>('idle');\n\n  const handleSubmit = async () => {\n    // Immediate haptic feedback (0ms)\n    haptic.impact('medium');\n    \n    // Optimistic UI (<50ms)\n    setOptimisticState('pending');\n\n    try {\n      const order = await createOrder.mutateAsync({ cartId });\n      \n      // Success haptic\n      haptic.notification('success');\n      setOptimisticState('success');\n      \n      // Navigate after animation settles (<300ms)\n      setTimeout(() => onSuccess(order.id), 200);\n    } catch (error) {\n      // Error haptic\n      haptic.notification('error');\n      setOptimisticState('idle');\n    }\n  };\n\n  return (\n    <div>\n      <Button\n        onClick={handleSubmit}\n        loading={createOrder.isPending}\n        disabled={optimisticState !== 'idle'}\n      >\n        {optimisticState === 'pending' ? 'Placing Order...' : 'Place Order'}\n      </Button>\n\n      {createOrder.isError && (\n        <p className=\"text-red-500 mt-2\">\n          {createOrder.error.message}\n        </p>\n      )}\n    </div>\n  );\n}\n```\n\n### State Management\n\n```typescript\n// components/CheckoutPage.tsx\nimport { useState } from 'react';\nimport { OrderForm } from './OrderForm';\nimport { OrderConfirmation } from './OrderConfirmation';\nimport { useCart } from '../hooks/useCart';\n\ntype CheckoutState = \n  | { step: 'review' }\n  | { step: 'processing' }\n  | { step: 'confirmation'; orderId: string }\n  | { step: 'error'; message: string };\n\nexport function CheckoutPage() {\n  const [state, setState] = useState<CheckoutState>({ step: 'review' });\n  const { data: cart } = useCart();\n\n  if (state.step === 'confirmation') {\n    return <OrderConfirmation orderId={state.orderId} />;\n  }\n\n  if (state.step === 'error') {\n    return (\n      <div>\n        <p>Error: {state.message}</p>\n        <button onClick={() => setState({ step: 'review' })}>\n          Try Again\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <h1>Checkout</h1>\n      <CartSummary cart={cart} />\n      <OrderForm\n        cartId={cart?.id}\n        onSuccess={(orderId) => setState({ step: 'confirmation', orderId })}\n      />\n    </div>\n  );\n}\n```\n\n→ See `references/ui-layer-patterns.md`\n\n## Step 7: Verify & Test\n\n### Test Alongside Implementation\n\nWrite tests as you implement, not after:\n\n```typescript\n// services/__tests__/OrderService.test.ts\nimport { OrderService } from '../OrderService';\nimport { createMockOrderRepo, createMockProductService } from '../../test/mocks';\n\ndescribe('OrderService', () => {\n  let service: OrderService;\n  let mockOrderRepo: ReturnType<typeof createMockOrderRepo>;\n\n  beforeEach(() => {\n    mockOrderRepo = createMockOrderRepo();\n    service = new OrderService(\n      mockOrderRepo,\n      createMockProductService(),\n      createMockInventoryService(),\n      createMockPaymentService(),\n    );\n  });\n\n  describe('createOrder', () => {\n    it('creates order with valid input', async () => {\n      const input = {\n        userId: 'user-1',\n        items: [{ productId: 'prod-1', quantity: 2 }],\n        shippingAddressId: 'addr-1',\n      };\n\n      const order = await service.createOrder(input);\n\n      expect(order).toMatchObject({\n        userId: 'user-1',\n        status: 'pending',\n      });\n      expect(mockOrderRepo.create).toHaveBeenCalledWith(\n        expect.objectContaining({ userId: 'user-1' })\n      );\n    });\n\n    it('throws CART_EMPTY for empty items', async () => {\n      const input = {\n        userId: 'user-1',\n        items: [],\n        shippingAddressId: 'addr-1',\n      };\n\n      await expect(service.createOrder(input)).rejects.toThrow('CART_EMPTY');\n    });\n\n    it('throws OUT_OF_STOCK when inventory insufficient', async () => {\n      // Setup mock to return low inventory\n      mockInventoryService.getAvailable.mockResolvedValue(1);\n\n      const input = {\n        userId: 'user-1',\n        items: [{ productId: 'prod-1', quantity: 10 }],\n        shippingAddressId: 'addr-1',\n      };\n\n      await expect(service.createOrder(input)).rejects.toThrow('OUT_OF_STOCK');\n    });\n  });\n});\n```\n\n### Integration Tests\n\n```typescript\n// tests/integration/orders.test.ts\nimport request from 'supertest';\nimport app from '../../src/app';\nimport { setupTestDb, teardownTestDb, createTestUser } from '../helpers';\n\ndescribe('Orders API', () => {\n  let authToken: string;\n  let userId: string;\n\n  beforeAll(async () => {\n    await setupTestDb();\n    const user = await createTestUser();\n    userId = user.id;\n    authToken = user.token;\n  });\n\n  afterAll(async () => {\n    await teardownTestDb();\n  });\n\n  describe('POST /api/orders', () => {\n    it('creates order and returns 201', async () => {\n      const response = await request(app)\n        .post('/api/orders')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          items: [{ productId: 'prod-1', quantity: 2 }],\n          shippingAddressId: 'addr-1',\n        });\n\n      expect(response.status).toBe(201);\n      expect(response.body.data).toMatchObject({\n        status: 'pending',\n      });\n    });\n\n    it('returns 401 without auth', async () => {\n      const response = await request(app)\n        .post('/api/orders')\n        .send({ items: [] });\n\n      expect(response.status).toBe(401);\n    });\n\n    it('returns 400 for empty cart', async () => {\n      const response = await request(app)\n        .post('/api/orders')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({ items: [], shippingAddressId: 'addr-1' });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error.code).toBe('CART_EMPTY');\n    });\n  });\n});\n```\n\n→ See `references/testing-patterns.md`\n\n## Implementation Quality Standards\n\n### Code Quality Checklist\n\n```markdown\n## Before Submitting\n\n### Completeness\n- [ ] All capabilities from spec implemented\n- [ ] All error cases handled\n- [ ] All validation rules applied\n- [ ] All side effects implemented\n\n### Code Quality\n- [ ] No TypeScript errors\n- [ ] No ESLint warnings\n- [ ] Consistent naming conventions\n- [ ] Functions are small and focused\n- [ ] No magic numbers/strings\n\n### Error Handling\n- [ ] All async code has try/catch\n- [ ] Errors have appropriate codes\n- [ ] User-facing messages are helpful\n- [ ] Errors are logged appropriately\n\n### Testing\n- [ ] Unit tests for service logic\n- [ ] Integration tests for API endpoints\n- [ ] Edge cases tested\n- [ ] Error cases tested\n\n### Documentation\n- [ ] JSDoc on public functions\n- [ ] Complex logic has comments\n- [ ] API changes documented\n```\n\n### Common Implementation Mistakes\n\n| Mistake | Problem | Solution |\n|---------|---------|----------|\n| Missing error handling | Unhandled promise rejections | Always wrap async in try/catch |\n| Ignoring validation | Invalid data reaches database | Validate at API boundary |\n| N+1 queries | Performance issues | Batch/join queries |\n| Missing indexes | Slow queries | Add indexes for frequent filters |\n| Hardcoded values | Inflexible code | Use constants/config |\n| No tests | Regressions | Write tests alongside code |\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `spec` | Spec provides detailed implementation requirements |\n| `frontend-design` | (Frontend systems) DESIGN.md guides UI component implementation |\n| `scaffold` | Scaffold provides project structure to implement within |\n| `code-verification` | Verifies implementation is structurally correct |\n| `code-validation` | Validates implementation matches requirements |\n| `code-review` | Reviews implementation before merge |\n| `test-generation` | Generates additional tests for implementation |\n| `refactor` | Improves implementation after it works |\n\n## Key Principles\n\n**Spec fidelity.** The spec is the contract. Implement exactly what it says.\n\n**Layer by layer.** Build data layer before services, services before API, API before UI.\n\n**Test as you go.** Write tests alongside implementation, not after.\n\n**Handle all errors.** Every error case in the spec needs handling.\n\n**Feedback matters.** Implement the timing and haptic feedback from the spec.\n\n**Small commits.** Commit after each logical unit (one capability, one component).\n\n## References\n\n- `references/data-layer-patterns.md`: Database, models, repositories\n- `references/service-layer-patterns.md`: Business logic, validation, transactions\n- `references/api-layer-patterns.md`: Routes, controllers, middleware\n- `references/ui-layer-patterns.md`: Components, state, feedback\n- `references/testing-patterns.md`: Unit, integration, E2E tests\n- `references/error-handling-patterns.md`: Error types, handling, logging",
  "references": [
    {
      "name": "api-layer-patterns.md",
      "path": "references/api-layer-patterns.md",
      "content": "# API Layer Patterns\n\nPatterns for implementing routes, controllers, and middleware.\n\n## Route Organization\n\n### Route File Structure\n\n```typescript\n// routes/index.ts\nimport { Router } from 'express';\nimport { userRoutes } from './users';\nimport { productRoutes } from './products';\nimport { orderRoutes } from './orders';\n\nconst router = Router();\n\nrouter.use('/users', userRoutes);\nrouter.use('/products', productRoutes);\nrouter.use('/orders', orderRoutes);\n\nexport const apiRoutes = router;\n\n// app.ts\napp.use('/api/v1', apiRoutes);\n```\n\n### Module Routes\n\n```typescript\n// routes/orders.ts\nimport { Router } from 'express';\nimport { OrderController } from '../controllers/OrderController';\nimport { authenticate } from '../middleware/authenticate';\nimport { validate } from '../middleware/validate';\nimport { authorize } from '../middleware/authorize';\nimport { \n  createOrderSchema, \n  updateOrderStatusSchema \n} from '../validation/orderValidation';\n\nconst router = Router();\nconst controller = new OrderController();\n\n// All order routes require authentication\nrouter.use(authenticate);\n\n// Create order\nrouter.post(\n  '/',\n  validate(createOrderSchema),\n  controller.create\n);\n\n// List user's orders\nrouter.get('/', controller.list);\n\n// Get single order\nrouter.get('/:id', controller.getById);\n\n// Update order status (admin only)\nrouter.patch(\n  '/:id/status',\n  authorize('admin'),\n  validate(updateOrderStatusSchema),\n  controller.updateStatus\n);\n\n// Cancel order\nrouter.post('/:id/cancel', controller.cancel);\n\nexport const orderRoutes = router;\n```\n\n## Controller Patterns\n\n### Basic Controller\n\n```typescript\n// controllers/OrderController.ts\nimport type { Request, Response, NextFunction } from 'express';\nimport { OrderService } from '../services/OrderService';\nimport { container } from '../container';\n\nexport class OrderController {\n  private orderService: OrderService;\n\n  constructor() {\n    this.orderService = container.resolve(OrderService);\n  }\n\n  create = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const order = await this.orderService.createOrder({\n        userId: req.user!.id,\n        items: req.body.items,\n        shippingAddressId: req.body.shippingAddressId,\n      });\n\n      res.status(201).json({\n        data: this.formatOrder(order),\n      });\n    } catch (error) {\n      next(error);\n    }\n  };\n\n  list = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { page, limit, status } = req.query;\n      \n      const result = await this.orderService.listForUser(req.user!.id, {\n        page: page ? parseInt(page as string, 10) : undefined,\n        limit: limit ? parseInt(limit as string, 10) : undefined,\n        status: status as string | undefined,\n      });\n\n      res.json({\n        data: result.data.map(this.formatOrder),\n        meta: result.meta,\n      });\n    } catch (error) {\n      next(error);\n    }\n  };\n\n  getById = async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const order = await this.orderService.getOrder(\n        req.params.id,\n        req.user!\n      );\n\n      res.json({\n        data: this.formatOrder(order),\n      });\n    } catch (error) {\n      next(error);\n    }\n  };\n\n  private formatOrder(order: Order): OrderResponse {\n    return {\n      id: order.id,\n      status: order.status,\n      items: order.items.map(item => ({\n        productId: item.productId,\n        productName: item.productName,\n        quantity: item.quantity,\n        priceCents: item.priceCents,\n      })),\n      subtotalCents: order.subtotalCents,\n      taxCents: order.taxCents,\n      totalCents: order.totalCents,\n      createdAt: order.createdAt.toISOString(),\n      updatedAt: order.updatedAt.toISOString(),\n    };\n  }\n}\n```\n\n### Controller with Dependency Injection\n\n```typescript\n// controllers/ProductController.ts\nexport class ProductController {\n  constructor(\n    private productService: ProductService,\n    private categoryService: CategoryService,\n  ) {}\n\n  // Methods use injected services\n}\n\n// Factory function for DI\nexport function createProductController(container: Container): ProductController {\n  return new ProductController(\n    container.resolve(ProductService),\n    container.resolve(CategoryService),\n  );\n}\n```\n\n## Middleware Patterns\n\n### Authentication Middleware\n\n```typescript\n// middleware/authenticate.ts\nimport type { Request, Response, NextFunction } from 'express';\nimport { verifyToken } from '../lib/jwt';\nimport { UserService } from '../services/UserService';\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: User;\n    }\n  }\n}\n\nexport function authenticate(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  const authHeader = req.headers.authorization;\n\n  if (!authHeader?.startsWith('Bearer ')) {\n    return res.status(401).json({\n      error: {\n        code: 'UNAUTHORIZED',\n        message: 'Missing or invalid authorization header',\n      },\n    });\n  }\n\n  const token = authHeader.substring(7);\n\n  try {\n    const payload = verifyToken(token);\n    \n    // Optionally fetch full user\n    const user = await userService.getById(payload.userId);\n    \n    if (!user) {\n      return res.status(401).json({\n        error: {\n          code: 'UNAUTHORIZED',\n          message: 'User not found',\n        },\n      });\n    }\n\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.status(401).json({\n      error: {\n        code: 'UNAUTHORIZED',\n        message: 'Invalid or expired token',\n      },\n    });\n  }\n}\n```\n\n### Authorization Middleware\n\n```typescript\n// middleware/authorize.ts\nexport function authorize(...allowedRoles: string[]) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return res.status(401).json({\n        error: { code: 'UNAUTHORIZED', message: 'Not authenticated' },\n      });\n    }\n\n    const hasRole = allowedRoles.some(role => \n      req.user!.roles.includes(role)\n    );\n\n    if (!hasRole) {\n      return res.status(403).json({\n        error: { code: 'FORBIDDEN', message: 'Insufficient permissions' },\n      });\n    }\n\n    next();\n  };\n}\n\n// Usage\nrouter.delete('/:id', authorize('admin'), controller.delete);\n```\n\n### Validation Middleware\n\n```typescript\n// middleware/validate.ts\nimport type { Request, Response, NextFunction } from 'express';\nimport { ZodSchema, ZodError } from 'zod';\n\nexport function validate(schema: ZodSchema) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    try {\n      req.body = schema.parse(req.body);\n      next();\n    } catch (error) {\n      if (error instanceof ZodError) {\n        return res.status(400).json({\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: 'Invalid request data',\n            details: error.errors.map(e => ({\n              field: e.path.join('.'),\n              message: e.message,\n            })),\n          },\n        });\n      }\n      next(error);\n    }\n  };\n}\n```\n\n### Request Logging Middleware\n\n```typescript\n// middleware/requestLogger.ts\nimport { randomUUID } from 'crypto';\nimport { logger } from '../lib/logger';\n\nexport function requestLogger(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  // Generate request ID\n  const requestId = randomUUID();\n  req.headers['x-request-id'] = requestId;\n  res.setHeader('x-request-id', requestId);\n\n  const startTime = Date.now();\n\n  // Log request\n  logger.info('Request started', {\n    requestId,\n    method: req.method,\n    path: req.path,\n    query: req.query,\n    userAgent: req.headers['user-agent'],\n    ip: req.ip,\n  });\n\n  // Log response on finish\n  res.on('finish', () => {\n    const duration = Date.now() - startTime;\n    \n    logger.info('Request completed', {\n      requestId,\n      method: req.method,\n      path: req.path,\n      statusCode: res.statusCode,\n      duration,\n    });\n  });\n\n  next();\n}\n```\n\n### Rate Limiting Middleware\n\n```typescript\n// middleware/rateLimit.ts\nimport rateLimit from 'express-rate-limit';\nimport RedisStore from 'rate-limit-redis';\nimport { redis } from '../lib/redis';\n\nexport const apiRateLimiter = rateLimit({\n  store: new RedisStore({\n    sendCommand: (...args: string[]) => redis.call(...args),\n  }),\n  windowMs: 60 * 1000, // 1 minute\n  max: 100, // 100 requests per minute\n  message: {\n    error: {\n      code: 'RATE_LIMITED',\n      message: 'Too many requests, please try again later',\n    },\n  },\n  keyGenerator: (req) => {\n    // Use user ID if authenticated, otherwise IP\n    return req.user?.id ?? req.ip;\n  },\n});\n\n// Stricter limit for sensitive endpoints\nexport const authRateLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 attempts\n  message: {\n    error: {\n      code: 'RATE_LIMITED',\n      message: 'Too many attempts, please try again later',\n    },\n  },\n});\n```\n\n## Request/Response Patterns\n\n### Standard Response Format\n\n```typescript\n// types/api.ts\nexport interface ApiResponse<T> {\n  data: T;\n  meta?: {\n    page?: number;\n    limit?: number;\n    total?: number;\n    totalPages?: number;\n  };\n}\n\nexport interface ApiError {\n  error: {\n    code: string;\n    message: string;\n    details?: unknown;\n  };\n}\n\n// Response helpers\nexport function success<T>(res: Response, data: T, status = 200) {\n  res.status(status).json({ data });\n}\n\nexport function paginated<T>(\n  res: Response,\n  data: T[],\n  meta: { page: number; limit: number; total: number }\n) {\n  res.json({\n    data,\n    meta: {\n      ...meta,\n      totalPages: Math.ceil(meta.total / meta.limit),\n    },\n  });\n}\n\nexport function created<T>(res: Response, data: T) {\n  res.status(201).json({ data });\n}\n\nexport function noContent(res: Response) {\n  res.status(204).send();\n}\n```\n\n### Query Parameter Parsing\n\n```typescript\n// utils/queryParser.ts\nexport interface PaginationParams {\n  page: number;\n  limit: number;\n  offset: number;\n}\n\nexport function parsePagination(query: Record<string, unknown>): PaginationParams {\n  const page = Math.max(1, parseInt(query.page as string, 10) || 1);\n  const limit = Math.min(100, Math.max(1, parseInt(query.limit as string, 10) || 20));\n  const offset = (page - 1) * limit;\n\n  return { page, limit, offset };\n}\n\nexport interface SortParams {\n  field: string;\n  order: 'asc' | 'desc';\n}\n\nexport function parseSort(\n  query: Record<string, unknown>,\n  allowedFields: string[],\n  defaultField = 'createdAt'\n): SortParams {\n  let field = (query.sortBy as string) || defaultField;\n  let order: 'asc' | 'desc' = (query.sortOrder as string) === 'asc' ? 'asc' : 'desc';\n\n  if (!allowedFields.includes(field)) {\n    field = defaultField;\n  }\n\n  return { field, order };\n}\n\n// Usage in controller\nconst pagination = parsePagination(req.query);\nconst sort = parseSort(req.query, ['name', 'price', 'createdAt']);\n\nconst result = await productService.list({\n  ...pagination,\n  sortBy: sort.field,\n  sortOrder: sort.order,\n});\n```\n\n### File Upload Handling\n\n```typescript\n// middleware/upload.ts\nimport multer from 'multer';\nimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';\nimport { randomUUID } from 'crypto';\n\nconst upload = multer({\n  storage: multer.memoryStorage(),\n  limits: {\n    fileSize: 10 * 1024 * 1024, // 10MB\n  },\n  fileFilter: (req, file, cb) => {\n    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];\n    if (allowedTypes.includes(file.mimetype)) {\n      cb(null, true);\n    } else {\n      cb(new Error('Invalid file type'));\n    }\n  },\n});\n\nexport const uploadSingle = upload.single('file');\n\n// Controller\nasync uploadImage(req: Request, res: Response, next: NextFunction) {\n  try {\n    if (!req.file) {\n      return res.status(400).json({\n        error: { code: 'NO_FILE', message: 'No file uploaded' },\n      });\n    }\n\n    const key = `images/${randomUUID()}-${req.file.originalname}`;\n    \n    await s3Client.send(new PutObjectCommand({\n      Bucket: config.s3Bucket,\n      Key: key,\n      Body: req.file.buffer,\n      ContentType: req.file.mimetype,\n    }));\n\n    res.json({\n      data: {\n        url: `https://${config.s3Bucket}.s3.amazonaws.com/${key}`,\n      },\n    });\n  } catch (error) {\n    next(error);\n  }\n}\n```\n\n## Error Handling\n\n### Global Error Handler\n\n```typescript\n// middleware/errorHandler.ts\nimport type { ErrorRequestHandler } from 'express';\nimport { AppError } from '../common/errors';\nimport { logger } from '../lib/logger';\n\nexport const errorHandler: ErrorRequestHandler = (err, req, res, _next) => {\n  // Log error\n  const requestId = req.headers['x-request-id'];\n  \n  if (err instanceof AppError && err.isOperational) {\n    // Operational error - expected\n    logger.warn('Operational error', {\n      requestId,\n      code: err.code,\n      message: err.message,\n      statusCode: err.statusCode,\n    });\n\n    return res.status(err.statusCode).json({\n      error: {\n        code: err.code,\n        message: err.message,\n        ...(err.details && { details: err.details }),\n      },\n    });\n  }\n\n  // Programming error - unexpected\n  logger.error('Unexpected error', {\n    requestId,\n    error: err.message,\n    stack: err.stack,\n    path: req.path,\n    method: req.method,\n  });\n\n  // Don't leak error details in production\n  const message = process.env.NODE_ENV === 'production'\n    ? 'An unexpected error occurred'\n    : err.message;\n\n  return res.status(500).json({\n    error: {\n      code: 'INTERNAL_ERROR',\n      message,\n    },\n  });\n};\n```\n\n### 404 Handler\n\n```typescript\n// middleware/notFound.ts\nexport function notFoundHandler(req: Request, res: Response) {\n  res.status(404).json({\n    error: {\n      code: 'NOT_FOUND',\n      message: `Route ${req.method} ${req.path} not found`,\n    },\n  });\n}\n\n// app.ts\napp.use('/api/v1', apiRoutes);\napp.use(notFoundHandler);\napp.use(errorHandler);\n```\n\n## API Versioning\n\n### URL Versioning\n\n```typescript\n// routes/v1/index.ts\nimport { Router } from 'express';\nimport { userRoutes } from './users';\nimport { productRoutes } from './products';\n\nconst v1Router = Router();\nv1Router.use('/users', userRoutes);\nv1Router.use('/products', productRoutes);\n\nexport { v1Router };\n\n// routes/v2/index.ts\nconst v2Router = Router();\n// V2 routes with breaking changes\n\n// app.ts\napp.use('/api/v1', v1Router);\napp.use('/api/v2', v2Router);\n```\n\n### Header Versioning\n\n```typescript\n// middleware/apiVersion.ts\nexport function apiVersion(req: Request, res: Response, next: NextFunction) {\n  const version = req.headers['api-version'] || req.query.version || '1';\n  req.apiVersion = version as string;\n  next();\n}\n\n// In controller\nif (req.apiVersion === '2') {\n  // V2 response format\n} else {\n  // V1 response format\n}\n```\n"
    },
    {
      "name": "binary-data-handling.md",
      "path": "references/binary-data-handling.md",
      "content": "# Binary Data Handling\n\n## Overview\nProperly handle binary data in API responses, including encoding, decoding, and file operations.\n\n## Core Operations\n\n### 1. Data Encoding\n- Convert binary files to base64 for API transmission\n- Handle different file formats (PNG, JPEG, etc.)\n- Manage encoding errors and corruption\n\n```python\n# Example encoding\nwith open('image.png', 'rb') as f:\n    image_data = base64.b64encode(f.read()).decode('utf-8')\n```\n\n### 2. Data Decoding\n- Parse base64 strings from API responses\n- Convert back to binary format\n- Validate data integrity\n\n```python\n# Example decoding\nimage_bytes = base64.b64decode(base64_string)\nwith open('output.png', 'wb') as f:\n    f.write(image_bytes)\n```\n\n### 3. File Operations\n- Create output directories if needed\n- Handle file naming conflicts\n- Set appropriate file permissions (e.g., 0644)\n- Validate write permissions\n\n### 4. MIME Type Management\n- Specify correct MIME types for uploads\n- Validate content types in responses\n- Handle type mismatches gracefully\n\n### 5. Memory Management\n- Handle large binary files efficiently\n- Stream data when possible\n- Clean up temporary files\n- Monitor memory usage for large operations\n\n## Error Handling\n- Catch and handle base64 decode errors\n- Validate file system permissions\n- Handle disk space limitations\n- Manage network timeout issues\n"
    },
    {
      "name": "conversation-state-management.md",
      "path": "references/conversation-state-management.md",
      "content": "# Conversation State Management\n\n## Overview\nImplement flexible state management for multi-turn conversations with both server-side and client-side options.\n\n## Stateful Pattern\nServer maintains conversation context automatically:\n\n```python\n# First interaction\ninteraction1 = client.interactions.create(\n    model=\"model-name\",\n    input=\"Hi, my name is Phil.\"\n)\n\n# Continue conversation using previous interaction ID\ninteraction2 = client.interactions.create(\n    model=\"model-name\",\n    input=\"What is my name?\",\n    previous_interaction_id=interaction1.id\n)\n```\n\n## Stateless Pattern\nClient manages conversation history:\n\n```python\nconversation_history = [\n    {\"role\": \"user\", \"content\": \"Initial message\"}\n]\n\n# First turn\nresponse = client.interactions.create(\n    model=\"model-name\",\n    input=conversation_history\n)\n\n# Update history and continue\nconversation_history.append({\"role\": \"model\", \"content\": response.outputs})\nconversation_history.append({\"role\": \"user\", \"content\": \"Follow-up message\"})\n```\n\n## State Retrieval\n```python\n# Retrieve previous interactions\nprevious = client.interactions.get(\"interaction_id\")\n```\n\n## Best Practices\n- Use stateful for simple applications\n- Use stateless for custom logic or distributed systems\n- Implement proper cleanup for stored interactions\n- Consider data retention policies\n"
    },
    {
      "name": "cross-platform-sdk-consistency.md",
      "path": "references/cross-platform-sdk-consistency.md",
      "content": "# Cross-Platform SDK Consistency\n\n## Overview\nMaintain consistent developer experience across multiple programming language SDKs.\n\n## Consistency Patterns\n\n### Method Naming\n```python\n# Python (snake_case)\ninteraction = client.interactions.create(\n    model=\"model-name\",\n    input=\"prompt\"\n)\n```\n\n```javascript\n// JavaScript (camelCase)\nconst interaction = await client.interactions.create({\n    model: 'model-name',\n    input: 'prompt'\n});\n```\n\n```bash\n# REST API (kebab-case URLs)\nPOST /interactions\n```\n\n### Response Handling\nConsistent output access patterns:\n\n```python\n# Python\nprint(interaction.outputs[-1].text)\n```\n\n```javascript\n// JavaScript\nconsole.log(interaction.outputs[interaction.outputs.length - 1].text);\n```\n\n### Error Handling\nStandardized error structures:\n\n```python\ntry:\n    interaction = client.interactions.create(...)\nexcept APIError as e:\n    print(f\"Error: {e.message}\")\n```\n\n```javascript\ntry {\n    const interaction = await client.interactions.create(...);\n} catch (error) {\n    console.log(`Error: ${error.message}`);\n}\n```\n\n## Implementation Guidelines\n\n### Core Principles\n1. **Same Functionality**: All SDKs support same features\n2. **Idiomatic Patterns**: Follow language conventions\n3. **Consistent Concepts**: Same abstractions across platforms\n4. **Unified Documentation**: Cross-referenced examples\n\n### Testing Strategy\n- Cross-platform integration tests\n- Behavioral consistency validation\n- Performance benchmarking\n- Documentation accuracy verification\n\n### Maintenance\n- Synchronized releases\n- Shared test suites\n- Common specification documents\n- Regular cross-team reviews\n"
    },
    {
      "name": "data-layer-patterns.md",
      "path": "references/data-layer-patterns.md",
      "content": "# Data Layer Patterns\n\nPatterns for implementing database models, migrations, and repositories.\n\n## Migration Patterns\n\n### Migration Structure\n\n```typescript\n// migrations/YYYYMMDD_HHMMSS_description.ts\nimport { Kysely, sql } from 'kysely';\n\nexport async function up(db: Kysely<unknown>): Promise<void> {\n  // Create tables, indexes, etc.\n}\n\nexport async function down(db: Kysely<unknown>): Promise<void> {\n  // Reverse the migration\n}\n```\n\n### Creating Tables\n\n```typescript\nexport async function up(db: Kysely<unknown>): Promise<void> {\n  await db.schema\n    .createTable('products')\n    // Primary key\n    .addColumn('id', 'uuid', (col) => \n      col.primaryKey().defaultTo(sql`gen_random_uuid()`))\n    \n    // Foreign key\n    .addColumn('category_id', 'uuid', (col) => \n      col.notNull().references('categories.id').onDelete('cascade'))\n    \n    // Required string with length\n    .addColumn('name', 'varchar(255)', (col) => col.notNull())\n    \n    // Optional string\n    .addColumn('description', 'text')\n    \n    // Integer with constraint\n    .addColumn('price_cents', 'integer', (col) => \n      col.notNull().check(sql`price_cents >= 0`))\n    \n    // Enum-like column\n    .addColumn('status', 'varchar(50)', (col) => \n      col.notNull().defaultTo('draft'))\n    \n    // JSON column\n    .addColumn('metadata', 'jsonb', (col) => \n      col.notNull().defaultTo(sql`'{}'::jsonb`))\n    \n    // Boolean with default\n    .addColumn('is_active', 'boolean', (col) => \n      col.notNull().defaultTo(true))\n    \n    // Timestamps\n    .addColumn('created_at', 'timestamptz', (col) => \n      col.notNull().defaultTo(sql`now()`))\n    .addColumn('updated_at', 'timestamptz', (col) => \n      col.notNull().defaultTo(sql`now()`))\n    \n    // Soft delete\n    .addColumn('deleted_at', 'timestamptz')\n    \n    .execute();\n}\n```\n\n### Adding Indexes\n\n```typescript\n// Single column index\nawait db.schema\n  .createIndex('idx_products_category_id')\n  .on('products')\n  .column('category_id')\n  .execute();\n\n// Composite index\nawait db.schema\n  .createIndex('idx_products_category_status')\n  .on('products')\n  .columns(['category_id', 'status'])\n  .execute();\n\n// Unique index\nawait db.schema\n  .createIndex('idx_products_slug')\n  .on('products')\n  .column('slug')\n  .unique()\n  .execute();\n\n// Partial index\nawait db.schema\n  .createIndex('idx_active_products')\n  .on('products')\n  .column('name')\n  .where('is_active', '=', true)\n  .execute();\n\n// GIN index for JSONB\nawait sql`CREATE INDEX idx_products_metadata ON products USING GIN (metadata)`.execute(db);\n```\n\n### Adding Constraints\n\n```typescript\n// Check constraint\nawait sql`\n  ALTER TABLE products \n  ADD CONSTRAINT chk_products_price \n  CHECK (price_cents >= 0)\n`.execute(db);\n\n// Unique constraint\nawait sql`\n  ALTER TABLE products \n  ADD CONSTRAINT uq_products_sku \n  UNIQUE (sku)\n`.execute(db);\n```\n\n### Safe Migrations\n\n```typescript\n// Add column with default (safe)\nawait db.schema\n  .alterTable('products')\n  .addColumn('new_column', 'varchar(255)', (col) => \n    col.defaultTo('default_value'))\n  .execute();\n\n// Add NOT NULL with default (safe)\nawait db.schema\n  .alterTable('products')\n  .addColumn('required_column', 'varchar(255)', (col) => \n    col.notNull().defaultTo(''))\n  .execute();\n\n// Drop column (careful!)\nawait db.schema\n  .alterTable('products')\n  .dropColumn('old_column')\n  .execute();\n```\n\n## Entity Models\n\n### TypeScript Types\n\n```typescript\n// models/Product.ts\n\n// Database row type (matches DB schema)\nexport interface ProductRow {\n  id: string;\n  category_id: string;\n  name: string;\n  description: string | null;\n  price_cents: number;\n  status: string;\n  metadata: Record<string, unknown>;\n  is_active: boolean;\n  created_at: Date;\n  updated_at: Date;\n  deleted_at: Date | null;\n}\n\n// Domain type (camelCase, transformed)\nexport interface Product {\n  id: string;\n  categoryId: string;\n  name: string;\n  description: string | null;\n  priceCents: number;\n  status: ProductStatus;\n  metadata: ProductMetadata;\n  isActive: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Status enum\nexport type ProductStatus = 'draft' | 'active' | 'archived';\n\n// Metadata type\nexport interface ProductMetadata {\n  weight?: number;\n  dimensions?: { width: number; height: number; depth: number };\n  tags?: string[];\n}\n\n// Create input (partial, no ID or timestamps)\nexport interface CreateProductInput {\n  categoryId: string;\n  name: string;\n  description?: string;\n  priceCents: number;\n  metadata?: ProductMetadata;\n}\n\n// Update input (all optional except ID)\nexport interface UpdateProductInput {\n  id: string;\n  name?: string;\n  description?: string;\n  priceCents?: number;\n  status?: ProductStatus;\n  metadata?: ProductMetadata;\n  isActive?: boolean;\n}\n```\n\n### Mapping Functions\n\n```typescript\n// Map DB row to domain type\nfunction mapRowToProduct(row: ProductRow): Product {\n  return {\n    id: row.id,\n    categoryId: row.category_id,\n    name: row.name,\n    description: row.description,\n    priceCents: row.price_cents,\n    status: row.status as ProductStatus,\n    metadata: row.metadata as ProductMetadata,\n    isActive: row.is_active,\n    createdAt: row.created_at,\n    updatedAt: row.updated_at,\n  };\n}\n\n// Map domain type to DB row (for inserts/updates)\nfunction mapProductToRow(product: Partial<Product>): Partial<ProductRow> {\n  const row: Partial<ProductRow> = {};\n  \n  if (product.categoryId !== undefined) row.category_id = product.categoryId;\n  if (product.name !== undefined) row.name = product.name;\n  if (product.description !== undefined) row.description = product.description;\n  if (product.priceCents !== undefined) row.price_cents = product.priceCents;\n  if (product.status !== undefined) row.status = product.status;\n  if (product.metadata !== undefined) row.metadata = product.metadata;\n  if (product.isActive !== undefined) row.is_active = product.isActive;\n  \n  return row;\n}\n```\n\n## Repository Pattern\n\n### Base Repository\n\n```typescript\n// repositories/BaseRepository.ts\nimport { Kysely, Insertable, Updateable, Selectable } from 'kysely';\nimport { Database } from '../database';\n\nexport abstract class BaseRepository<\n  TableName extends keyof Database,\n  Row = Selectable<Database[TableName]>,\n  InsertRow = Insertable<Database[TableName]>,\n  UpdateRow = Updateable<Database[TableName]>,\n> {\n  constructor(\n    protected db: Kysely<Database>,\n    protected tableName: TableName,\n  ) {}\n\n  async findById(id: string): Promise<Row | null> {\n    const row = await this.db\n      .selectFrom(this.tableName)\n      .selectAll()\n      .where('id' as any, '=', id)\n      .executeTakeFirst();\n    \n    return (row as Row) ?? null;\n  }\n\n  async findAll(): Promise<Row[]> {\n    const rows = await this.db\n      .selectFrom(this.tableName)\n      .selectAll()\n      .execute();\n    \n    return rows as Row[];\n  }\n\n  async create(data: InsertRow): Promise<Row> {\n    const [row] = await this.db\n      .insertInto(this.tableName)\n      .values(data as any)\n      .returningAll()\n      .execute();\n    \n    return row as Row;\n  }\n\n  async update(id: string, data: UpdateRow): Promise<Row | null> {\n    const [row] = await this.db\n      .updateTable(this.tableName)\n      .set(data as any)\n      .where('id' as any, '=', id)\n      .returningAll()\n      .execute();\n    \n    return (row as Row) ?? null;\n  }\n\n  async delete(id: string): Promise<boolean> {\n    const result = await this.db\n      .deleteFrom(this.tableName)\n      .where('id' as any, '=', id)\n      .executeTakeFirst();\n    \n    return result.numDeletedRows > 0;\n  }\n}\n```\n\n### Specific Repository\n\n```typescript\n// repositories/ProductRepository.ts\nimport { db } from '../database';\nimport type { Product, CreateProductInput, UpdateProductInput } from '../models/Product';\n\nexport class ProductRepository {\n  async findById(id: string): Promise<Product | null> {\n    const row = await db\n      .selectFrom('products')\n      .selectAll()\n      .where('id', '=', id)\n      .where('deleted_at', 'is', null)\n      .executeTakeFirst();\n\n    return row ? mapRowToProduct(row) : null;\n  }\n\n  async findByCategory(categoryId: string): Promise<Product[]> {\n    const rows = await db\n      .selectFrom('products')\n      .selectAll()\n      .where('category_id', '=', categoryId)\n      .where('deleted_at', 'is', null)\n      .where('is_active', '=', true)\n      .orderBy('name', 'asc')\n      .execute();\n\n    return rows.map(mapRowToProduct);\n  }\n\n  async findByIds(ids: string[]): Promise<Product[]> {\n    if (ids.length === 0) return [];\n\n    const rows = await db\n      .selectFrom('products')\n      .selectAll()\n      .where('id', 'in', ids)\n      .where('deleted_at', 'is', null)\n      .execute();\n\n    return rows.map(mapRowToProduct);\n  }\n\n  async create(input: CreateProductInput): Promise<Product> {\n    const [row] = await db\n      .insertInto('products')\n      .values({\n        category_id: input.categoryId,\n        name: input.name,\n        description: input.description ?? null,\n        price_cents: input.priceCents,\n        metadata: input.metadata ?? {},\n        status: 'draft',\n        is_active: true,\n      })\n      .returningAll()\n      .execute();\n\n    return mapRowToProduct(row);\n  }\n\n  async update(input: UpdateProductInput): Promise<Product | null> {\n    const updateData: Record<string, unknown> = {\n      updated_at: new Date(),\n    };\n\n    if (input.name !== undefined) updateData.name = input.name;\n    if (input.description !== undefined) updateData.description = input.description;\n    if (input.priceCents !== undefined) updateData.price_cents = input.priceCents;\n    if (input.status !== undefined) updateData.status = input.status;\n    if (input.metadata !== undefined) updateData.metadata = input.metadata;\n    if (input.isActive !== undefined) updateData.is_active = input.isActive;\n\n    const [row] = await db\n      .updateTable('products')\n      .set(updateData)\n      .where('id', '=', input.id)\n      .where('deleted_at', 'is', null)\n      .returningAll()\n      .execute();\n\n    return row ? mapRowToProduct(row) : null;\n  }\n\n  async softDelete(id: string): Promise<boolean> {\n    const result = await db\n      .updateTable('products')\n      .set({ deleted_at: new Date() })\n      .where('id', '=', id)\n      .where('deleted_at', 'is', null)\n      .executeTakeFirst();\n\n    return result.numUpdatedRows > 0;\n  }\n\n  async search(query: string, limit = 20): Promise<Product[]> {\n    const rows = await db\n      .selectFrom('products')\n      .selectAll()\n      .where('deleted_at', 'is', null)\n      .where('is_active', '=', true)\n      .where((eb) =>\n        eb.or([\n          eb('name', 'ilike', `%${query}%`),\n          eb('description', 'ilike', `%${query}%`),\n        ])\n      )\n      .orderBy('name', 'asc')\n      .limit(limit)\n      .execute();\n\n    return rows.map(mapRowToProduct);\n  }\n}\n```\n\n## Query Patterns\n\n### Pagination\n\n```typescript\ninterface PaginationInput {\n  page?: number;\n  limit?: number;\n}\n\ninterface PaginatedResult<T> {\n  data: T[];\n  meta: {\n    page: number;\n    limit: number;\n    total: number;\n    totalPages: number;\n  };\n}\n\nasync findPaginated(\n  input: PaginationInput,\n): Promise<PaginatedResult<Product>> {\n  const page = input.page ?? 1;\n  const limit = Math.min(input.limit ?? 20, 100);\n  const offset = (page - 1) * limit;\n\n  // Get total count\n  const [{ count }] = await db\n    .selectFrom('products')\n    .select(db.fn.count('id').as('count'))\n    .where('deleted_at', 'is', null)\n    .execute();\n\n  const total = Number(count);\n\n  // Get page data\n  const rows = await db\n    .selectFrom('products')\n    .selectAll()\n    .where('deleted_at', 'is', null)\n    .orderBy('created_at', 'desc')\n    .limit(limit)\n    .offset(offset)\n    .execute();\n\n  return {\n    data: rows.map(mapRowToProduct),\n    meta: {\n      page,\n      limit,\n      total,\n      totalPages: Math.ceil(total / limit),\n    },\n  };\n}\n```\n\n### Cursor-Based Pagination\n\n```typescript\ninterface CursorPaginationInput {\n  cursor?: string;\n  limit?: number;\n}\n\ninterface CursorPaginatedResult<T> {\n  data: T[];\n  nextCursor: string | null;\n}\n\nasync findWithCursor(\n  input: CursorPaginationInput,\n): Promise<CursorPaginatedResult<Product>> {\n  const limit = Math.min(input.limit ?? 20, 100);\n\n  let query = db\n    .selectFrom('products')\n    .selectAll()\n    .where('deleted_at', 'is', null)\n    .orderBy('created_at', 'desc')\n    .orderBy('id', 'desc')\n    .limit(limit + 1); // Fetch one extra to check for next page\n\n  if (input.cursor) {\n    const [createdAt, id] = decodeCursor(input.cursor);\n    query = query.where((eb) =>\n      eb.or([\n        eb('created_at', '<', createdAt),\n        eb.and([\n          eb('created_at', '=', createdAt),\n          eb('id', '<', id),\n        ]),\n      ])\n    );\n  }\n\n  const rows = await query.execute();\n  const hasMore = rows.length > limit;\n  const data = rows.slice(0, limit).map(mapRowToProduct);\n\n  return {\n    data,\n    nextCursor: hasMore\n      ? encodeCursor(data[data.length - 1].createdAt, data[data.length - 1].id)\n      : null,\n  };\n}\n```\n\n### Batch Loading (DataLoader Pattern)\n\n```typescript\n// loaders/ProductLoader.ts\nimport DataLoader from 'dataloader';\nimport { ProductRepository } from '../repositories/ProductRepository';\n\nexport function createProductLoader(repo: ProductRepository) {\n  return new DataLoader<string, Product | null>(async (ids) => {\n    const products = await repo.findByIds([...ids]);\n    const productMap = new Map(products.map(p => [p.id, p]));\n    return ids.map(id => productMap.get(id) ?? null);\n  });\n}\n\n// Usage\nconst loader = createProductLoader(productRepo);\n\n// These will be batched into a single query\nconst [product1, product2, product3] = await Promise.all([\n  loader.load('id-1'),\n  loader.load('id-2'),\n  loader.load('id-3'),\n]);\n```\n\n### Joins and Relationships\n\n```typescript\n// Get product with category\nasync findWithCategory(id: string): Promise<ProductWithCategory | null> {\n  const row = await db\n    .selectFrom('products')\n    .innerJoin('categories', 'categories.id', 'products.category_id')\n    .select([\n      'products.id',\n      'products.name',\n      'products.price_cents',\n      'categories.id as category_id',\n      'categories.name as category_name',\n    ])\n    .where('products.id', '=', id)\n    .where('products.deleted_at', 'is', null)\n    .executeTakeFirst();\n\n  if (!row) return null;\n\n  return {\n    id: row.id,\n    name: row.name,\n    priceCents: row.price_cents,\n    category: {\n      id: row.category_id,\n      name: row.category_name,\n    },\n  };\n}\n```\n\n### Transactions\n\n```typescript\nasync createOrderWithItems(\n  input: CreateOrderInput,\n): Promise<Order> {\n  return await db.transaction().execute(async (trx) => {\n    // Create order\n    const [orderRow] = await trx\n      .insertInto('orders')\n      .values({\n        user_id: input.userId,\n        status: 'pending',\n        total_cents: 0,\n      })\n      .returningAll()\n      .execute();\n\n    // Create order items\n    let totalCents = 0;\n    for (const item of input.items) {\n      const product = await trx\n        .selectFrom('products')\n        .select(['price_cents'])\n        .where('id', '=', item.productId)\n        .executeTakeFirst();\n\n      if (!product) {\n        throw new Error(`Product ${item.productId} not found`);\n      }\n\n      await trx\n        .insertInto('order_items')\n        .values({\n          order_id: orderRow.id,\n          product_id: item.productId,\n          quantity: item.quantity,\n          price_cents: product.price_cents,\n        })\n        .execute();\n\n      totalCents += product.price_cents * item.quantity;\n    }\n\n    // Update order total\n    const [updatedOrder] = await trx\n      .updateTable('orders')\n      .set({ total_cents: totalCents })\n      .where('id', '=', orderRow.id)\n      .returningAll()\n      .execute();\n\n    return mapRowToOrder(updatedOrder);\n  });\n}\n```\n"
    },
    {
      "name": "error-handling-patterns.md",
      "path": "references/error-handling-patterns.md",
      "content": "# Error Handling Patterns\n\nPatterns for defining, throwing, catching, and logging errors.\n\n## Error Class Hierarchy\n\n### Base Application Error\n\n```typescript\n// common/errors/AppError.ts\nexport class AppError extends Error {\n  public readonly code: string;\n  public readonly statusCode: number;\n  public readonly isOperational: boolean;\n  public readonly details?: unknown;\n\n  constructor(\n    code: string,\n    message: string,\n    statusCode: number = 500,\n    details?: unknown,\n    isOperational: boolean = true\n  ) {\n    super(message);\n    this.code = code;\n    this.statusCode = statusCode;\n    this.isOperational = isOperational;\n    this.details = details;\n\n    // Maintains proper stack trace\n    Error.captureStackTrace(this, this.constructor);\n    Object.setPrototypeOf(this, AppError.prototype);\n  }\n}\n```\n\n### Specific Error Types\n\n```typescript\n// common/errors/index.ts\nexport class NotFoundError extends AppError {\n  constructor(resource: string, id?: string) {\n    const message = id \n      ? `${resource} with id ${id} not found`\n      : `${resource} not found`;\n    super('NOT_FOUND', message, 404);\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(message: string, errors?: ValidationDetail[]) {\n    super('VALIDATION_ERROR', message, 400, errors);\n  }\n}\n\nexport interface ValidationDetail {\n  field: string;\n  code: string;\n  message: string;\n}\n\nexport class UnauthorizedError extends AppError {\n  constructor(message: string = 'Authentication required') {\n    super('UNAUTHORIZED', message, 401);\n  }\n}\n\nexport class ForbiddenError extends AppError {\n  constructor(message: string = 'Access denied') {\n    super('FORBIDDEN', message, 403);\n  }\n}\n\nexport class ConflictError extends AppError {\n  constructor(message: string, details?: unknown) {\n    super('CONFLICT', message, 409, details);\n  }\n}\n\nexport class RateLimitError extends AppError {\n  constructor(retryAfter?: number) {\n    super(\n      'RATE_LIMITED',\n      'Too many requests, please try again later',\n      429,\n      { retryAfter }\n    );\n  }\n}\n\nexport class ServiceUnavailableError extends AppError {\n  constructor(service: string) {\n    super(\n      'SERVICE_UNAVAILABLE',\n      `${service} is temporarily unavailable`,\n      503\n    );\n  }\n}\n```\n\n### Domain-Specific Errors\n\n```typescript\n// modules/orders/errors.ts\nexport class CartEmptyError extends AppError {\n  constructor() {\n    super('CART_EMPTY', 'Cannot create order with empty cart', 400);\n  }\n}\n\nexport class OutOfStockError extends AppError {\n  constructor(productId: string, available: number, requested: number) {\n    super(\n      'OUT_OF_STOCK',\n      `Insufficient inventory for product ${productId}`,\n      400,\n      { productId, available, requested }\n    );\n  }\n}\n\nexport class PaymentFailedError extends AppError {\n  constructor(reason: string, details?: unknown) {\n    super('PAYMENT_FAILED', `Payment failed: ${reason}`, 400, details);\n  }\n}\n\nexport class OrderNotCancellableError extends AppError {\n  constructor(orderId: string, status: string) {\n    super(\n      'ORDER_NOT_CANCELLABLE',\n      `Order ${orderId} cannot be cancelled in ${status} status`,\n      400,\n      { orderId, status }\n    );\n  }\n}\n```\n\n## Error Handling in Services\n\n### Try-Catch Pattern\n\n```typescript\n// services/OrderService.ts\nasync createOrder(input: CreateOrderInput): Promise<Order> {\n  // Validate input (throws ValidationError)\n  this.validateInput(input);\n\n  // Check business rules (throws domain errors)\n  await this.checkBusinessRules(input);\n\n  try {\n    // Attempt operation\n    const order = await this.orderRepo.create(input);\n    return order;\n  } catch (error) {\n    // Transform known database errors\n    if (error.code === '23505') { // Unique violation\n      throw new ConflictError('Order already exists');\n    }\n    if (error.code === '23503') { // Foreign key violation\n      throw new ValidationError('Referenced entity not found');\n    }\n    \n    // Re-throw operational errors\n    if (error instanceof AppError) {\n      throw error;\n    }\n\n    // Wrap unexpected errors\n    this.logger.error('Unexpected error in createOrder', { error, input });\n    throw new AppError(\n      'CREATE_ORDER_FAILED',\n      'Failed to create order',\n      500,\n      undefined,\n      false // Mark as non-operational\n    );\n  }\n}\n```\n\n### Error Transformation\n\n```typescript\n// Transform external service errors\nasync processPayment(orderId: string, paymentMethod: PaymentMethod): Promise<Payment> {\n  try {\n    const result = await this.stripeClient.charges.create({\n      amount: order.totalCents,\n      currency: 'usd',\n      source: paymentMethod.token,\n    });\n    \n    return { id: result.id, status: 'succeeded' };\n  } catch (error) {\n    // Transform Stripe errors to our domain errors\n    if (error.type === 'StripeCardError') {\n      throw new PaymentFailedError(error.message, {\n        code: error.code,\n        decline_code: error.decline_code,\n      });\n    }\n    \n    if (error.type === 'StripeRateLimitError') {\n      throw new ServiceUnavailableError('Payment service');\n    }\n\n    // Log and throw generic error\n    this.logger.error('Stripe error', { error, orderId });\n    throw new AppError(\n      'PAYMENT_ERROR',\n      'Payment processing failed',\n      500\n    );\n  }\n}\n```\n\n## Error Handling in API Layer\n\n### Express Error Handler\n\n```typescript\n// middleware/errorHandler.ts\nimport { ErrorRequestHandler } from 'express';\nimport { AppError, ValidationError } from '../common/errors';\nimport { logger } from '../lib/logger';\n\nexport const errorHandler: ErrorRequestHandler = (err, req, res, _next) => {\n  const requestId = req.headers['x-request-id'] as string;\n\n  // Handle known operational errors\n  if (err instanceof AppError && err.isOperational) {\n    logger.warn('Operational error', {\n      requestId,\n      code: err.code,\n      message: err.message,\n      statusCode: err.statusCode,\n      path: req.path,\n    });\n\n    const response: ErrorResponse = {\n      error: {\n        code: err.code,\n        message: err.message,\n      },\n    };\n\n    // Include validation details if present\n    if (err instanceof ValidationError && err.details) {\n      response.error.details = err.details;\n    }\n\n    return res.status(err.statusCode).json(response);\n  }\n\n  // Handle Zod validation errors\n  if (err.name === 'ZodError') {\n    const details = err.errors.map((e: ZodIssue) => ({\n      field: e.path.join('.'),\n      code: e.code,\n      message: e.message,\n    }));\n\n    return res.status(400).json({\n      error: {\n        code: 'VALIDATION_ERROR',\n        message: 'Invalid request data',\n        details,\n      },\n    });\n  }\n\n  // Log unexpected errors\n  logger.error('Unexpected error', {\n    requestId,\n    error: err.message,\n    stack: err.stack,\n    path: req.path,\n    method: req.method,\n    body: req.body,\n  });\n\n  // Don't leak error details in production\n  const message = process.env.NODE_ENV === 'production'\n    ? 'An unexpected error occurred'\n    : err.message;\n\n  return res.status(500).json({\n    error: {\n      code: 'INTERNAL_ERROR',\n      message,\n      ...(process.env.NODE_ENV !== 'production' && { stack: err.stack }),\n    },\n  });\n};\n\ninterface ErrorResponse {\n  error: {\n    code: string;\n    message: string;\n    details?: unknown;\n  };\n}\n```\n\n### Async Error Wrapper\n\n```typescript\n// middleware/asyncHandler.ts\nimport { RequestHandler } from 'express';\n\ntype AsyncRequestHandler = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => Promise<unknown>;\n\nexport function asyncHandler(fn: AsyncRequestHandler): RequestHandler {\n  return (req, res, next) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n}\n\n// Usage in routes\nrouter.post(\n  '/',\n  asyncHandler(async (req, res) => {\n    const order = await orderService.createOrder(req.body);\n    res.status(201).json({ data: order });\n  })\n);\n```\n\n## Error Handling in UI\n\n### Global Error Boundary\n\n```typescript\n// components/ErrorBoundary.tsx\nimport { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  state: State = { hasError: false };\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    // Log to error reporting service\n    console.error('Error caught by boundary:', error, errorInfo);\n    // reportError(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback ?? (\n        <div className=\"p-8 text-center\">\n          <h1 className=\"text-2xl font-bold text-red-500\">Something went wrong</h1>\n          <p className=\"mt-2 text-gray-600\">\n            Please refresh the page or try again later.\n          </p>\n          <button\n            onClick={() => window.location.reload()}\n            className=\"mt-4 px-4 py-2 bg-blue-500 text-white rounded\"\n          >\n            Refresh Page\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n```\n\n### API Error Handling\n\n```typescript\n// lib/api.ts\nimport axios, { AxiosError } from 'axios';\n\nexport class ApiError extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public statusCode: number,\n    public details?: unknown\n  ) {\n    super(message);\n  }\n}\n\nconst api = axios.create({\n  baseURL: '/api/v1',\n});\n\napi.interceptors.response.use(\n  (response) => response,\n  (error: AxiosError<{ error: { code: string; message: string; details?: unknown } }>) => {\n    if (error.response?.data?.error) {\n      const { code, message, details } = error.response.data.error;\n      throw new ApiError(code, message, error.response.status, details);\n    }\n\n    // Network error or other\n    throw new ApiError(\n      'NETWORK_ERROR',\n      'Unable to connect to server',\n      0\n    );\n  }\n);\n\nexport { api };\n```\n\n### Component Error Handling\n\n```typescript\n// components/OrderForm.tsx\nexport function OrderForm() {\n  const createOrder = useCreateOrder();\n  const { addToast } = useToast();\n\n  const handleSubmit = async (data: OrderFormData) => {\n    try {\n      const order = await createOrder.mutateAsync(data);\n      addToast('success', 'Order placed successfully');\n      navigate(`/orders/${order.id}`);\n    } catch (error) {\n      if (error instanceof ApiError) {\n        // Handle specific error codes\n        switch (error.code) {\n          case 'CART_EMPTY':\n            addToast('error', 'Your cart is empty');\n            break;\n          case 'OUT_OF_STOCK':\n            addToast('error', 'Some items are out of stock');\n            // Could show which items\n            break;\n          case 'PAYMENT_FAILED':\n            addToast('error', 'Payment failed. Please try again.');\n            break;\n          case 'VALIDATION_ERROR':\n            // Set form errors from API response\n            if (error.details) {\n              (error.details as ValidationDetail[]).forEach((detail) => {\n                form.setError(detail.field, { message: detail.message });\n              });\n            }\n            break;\n          default:\n            addToast('error', error.message);\n        }\n      } else {\n        addToast('error', 'An unexpected error occurred');\n      }\n    }\n  };\n}\n```\n\n### React Query Error Handling\n\n```typescript\n// hooks/useOrders.ts\nexport function useCreateOrder() {\n  const queryClient = useQueryClient();\n  const { addToast } = useToast();\n\n  return useMutation({\n    mutationFn: (input: CreateOrderInput) =>\n      api.post<{ data: Order }>('/orders', input).then(r => r.data.data),\n    \n    onError: (error: ApiError) => {\n      // Global error handling\n      if (error.statusCode === 401) {\n        // Redirect to login\n        window.location.href = '/login';\n        return;\n      }\n\n      if (error.statusCode >= 500) {\n        addToast('error', 'Server error. Please try again later.');\n        return;\n      }\n\n      // Let component handle other errors\n    },\n    \n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['orders'] });\n      queryClient.invalidateQueries({ queryKey: ['cart'] });\n    },\n  });\n}\n```\n\n## Logging\n\n### Structured Logger\n\n```typescript\n// lib/logger.ts\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ninterface LogContext {\n  [key: string]: unknown;\n}\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nconst currentLevel = LOG_LEVELS[process.env.LOG_LEVEL as LogLevel] ?? LOG_LEVELS.info;\n\nfunction log(level: LogLevel, message: string, context?: LogContext) {\n  if (LOG_LEVELS[level] < currentLevel) return;\n\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level,\n    message,\n    ...context,\n    // Add request context if available\n    ...(getRequestContext() && { request: getRequestContext() }),\n  };\n\n  // In production, output JSON\n  if (process.env.NODE_ENV === 'production') {\n    console.log(JSON.stringify(entry));\n  } else {\n    // In development, pretty print\n    console[level](\n      `[${entry.timestamp}] ${level.toUpperCase()}: ${message}`,\n      context ?? ''\n    );\n  }\n}\n\nexport const logger = {\n  debug: (message: string, context?: LogContext) => log('debug', message, context),\n  info: (message: string, context?: LogContext) => log('info', message, context),\n  warn: (message: string, context?: LogContext) => log('warn', message, context),\n  error: (message: string, context?: LogContext) => log('error', message, context),\n};\n```\n\n### Error Logging Best Practices\n\n```typescript\n// Good: Structured, includes context\nlogger.error('Failed to create order', {\n  userId: input.userId,\n  itemCount: input.items.length,\n  error: error.message,\n  stack: error.stack,\n  code: error instanceof AppError ? error.code : 'UNKNOWN',\n});\n\n// Bad: Unstructured, no context\nconsole.log('Error:', error);\n\n// Good: Different log levels for different situations\nlogger.info('Order created', { orderId: order.id, userId: order.userId });\nlogger.warn('Inventory low', { productId, available, threshold });\nlogger.error('Payment failed', { orderId, error: error.message });\n\n// Good: Include correlation IDs\nlogger.info('Processing request', { requestId, path, method });\n```\n\n## Error Codes Reference\n\n```typescript\n// common/errors/codes.ts\nexport const ErrorCodes = {\n  // Authentication & Authorization\n  UNAUTHORIZED: 'UNAUTHORIZED',\n  FORBIDDEN: 'FORBIDDEN',\n  TOKEN_EXPIRED: 'TOKEN_EXPIRED',\n  INVALID_TOKEN: 'INVALID_TOKEN',\n\n  // Validation\n  VALIDATION_ERROR: 'VALIDATION_ERROR',\n  INVALID_INPUT: 'INVALID_INPUT',\n  MISSING_FIELD: 'MISSING_FIELD',\n\n  // Resources\n  NOT_FOUND: 'NOT_FOUND',\n  CONFLICT: 'CONFLICT',\n  ALREADY_EXISTS: 'ALREADY_EXISTS',\n\n  // Business Logic\n  CART_EMPTY: 'CART_EMPTY',\n  OUT_OF_STOCK: 'OUT_OF_STOCK',\n  PAYMENT_FAILED: 'PAYMENT_FAILED',\n  ORDER_NOT_CANCELLABLE: 'ORDER_NOT_CANCELLABLE',\n  INSUFFICIENT_FUNDS: 'INSUFFICIENT_FUNDS',\n\n  // System\n  INTERNAL_ERROR: 'INTERNAL_ERROR',\n  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',\n  RATE_LIMITED: 'RATE_LIMITED',\n  TIMEOUT: 'TIMEOUT',\n} as const;\n\nexport type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];\n```\n"
    },
    {
      "name": "image-generation-workflow.md",
      "path": "references/image-generation-workflow.md",
      "content": "# Image Generation Workflow\n\n## Overview\nManage AI-powered image generation including text-to-image creation and image editing workflows.\n\n## Workflow Types\n\n### Text-to-Image Generation\n1. **Prompt Engineering**\n   - Create descriptive, specific prompts\n   - Include style, composition, and detail requirements\n   - Consider model capabilities and limitations\n\n2. **Generation Process**\n   - Select appropriate model (speed vs quality)\n   - Submit generation request\n   - Handle async processing\n\n3. **Output Management**\n   - Save generated images with proper filenames\n   - Handle watermarking (e.g., SynthID)\n   - Manage file permissions and storage\n\n### Image Editing (Image-to-Image)\n1. **Input Validation**\n   - Verify image file exists and is readable\n   - Check file format compatibility\n   - Validate user rights to input images\n\n2. **Editing Instructions**\n   - Combine base image with text modifications\n   - Support add/remove/modify operations\n   - Handle style and color adjustments\n\n3. **Processing**\n   - Encode images appropriately (base64)\n   - Structure multi-part requests\n   - Process iterative edits\n\n## Quality Controls\n- Implement content policy compliance\n- Validate generated outputs\n- Handle generation failures gracefully\n- Maintain audit trails for generated content\n"
    },
    {
      "name": "multimodal-api-integration.md",
      "path": "references/multimodal-api-integration.md",
      "content": "# Multimodal API Integration\n\n## Overview\nIntegrate APIs that accept and return multiple data modalities (text, images, audio, etc.) with proper handling of different content types.\n\n## Implementation Steps\n\n### 1. Client Setup\n- Initialize API client with proper authentication\n- Configure for multimodal capabilities\n- Set up error handling for connection issues\n\n### 2. Content Preparation\n- Support multiple input types (text prompts, image files, base64 data)\n- Handle file reading and encoding (base64 for images)\n- Structure content arrays with proper MIME types\n\n### 3. API Request\n- Send requests with mixed content types\n- Specify response modalities (TEXT, IMAGE, etc.)\n- Handle async operations appropriately\n\n### 4. Response Processing\n- Iterate through response parts\n- Handle different output types (text, inline data, images)\n- Convert and save binary data (images) to files\n- Extract and display text responses\n\n### 5. Error Handling\n- Validate file paths and permissions\n- Handle API rate limits and authentication errors\n- Manage malformed responses gracefully\n\n## Best Practices\n- Always check content rights before processing\n- Implement proper file I/O error handling\n- Use appropriate data encoding (base64 for binary)\n- Structure requests with clear content boundaries\n"
    },
    {
      "name": "multimodal-input-handling.md",
      "path": "references/multimodal-input-handling.md",
      "content": "# Multimodal Input Handling\n\n## Overview\nDesign APIs that seamlessly handle multiple input modalities through a unified interface.\n\n## Input Type Flexibility\nSupport multiple input formats:\n\n```python\n# String input\ninteraction = client.interactions.create(\n    model=\"model-name\",\n    input=\"Simple text prompt\"\n)\n\n# Content object input\ninteraction = client.interactions.create(\n    model=\"model-name\",\n    input=[\n        {\"type\": \"text\", \"content\": \"Analyze this image:\"},\n        {\"type\": \"image\", \"content\": image_data}\n    ]\n)\n\n# Conversation turns input\ninteraction = client.interactions.create(\n    model=\"model-name\",\n    input=[\n        {\"role\": \"user\", \"content\": \"Message 1\"},\n        {\"role\": \"model\", \"content\": \"Response 1\"},\n        {\"role\": \"user\", \"content\": \"Message 2\"}\n    ]\n)\n```\n\n## Implementation Strategy\n1. **Type Detection**: Automatically detect input format\n2. **Normalization**: Convert all inputs to internal format\n3. **Validation**: Ensure input compatibility with model\n4. **Processing**: Handle each modality appropriately\n\n## Supported Modalities\n- Text (string, markdown, structured)\n- Images (base64, URLs, binary)\n- Audio (various formats)\n- Video (streaming, files)\n- Documents (PDFs, structured data)\n\n## Error Handling\n- Validate input format before processing\n- Provide clear error messages for unsupported types\n- Graceful fallbacks when possible\n"
    },
    {
      "name": "service-layer-patterns.md",
      "path": "references/service-layer-patterns.md",
      "content": "# Service Layer Patterns\n\nPatterns for implementing business logic, validation, and service orchestration.\n\n## Service Structure\n\n### Basic Service\n\n```typescript\n// services/ProductService.ts\nimport { ProductRepository } from '../repositories/ProductRepository';\nimport { AppError } from '../common/errors';\nimport type { Product, CreateProductInput, UpdateProductInput } from '../models/Product';\n\nexport class ProductService {\n  constructor(private productRepo: ProductRepository) {}\n\n  async getById(id: string): Promise<Product> {\n    const product = await this.productRepo.findById(id);\n    \n    if (!product) {\n      throw new AppError('PRODUCT_NOT_FOUND', `Product ${id} not found`, 404);\n    }\n    \n    return product;\n  }\n\n  async create(input: CreateProductInput): Promise<Product> {\n    // Validate\n    this.validateCreateInput(input);\n    \n    // Create\n    return this.productRepo.create(input);\n  }\n\n  async update(input: UpdateProductInput): Promise<Product> {\n    // Check exists\n    const existing = await this.productRepo.findById(input.id);\n    if (!existing) {\n      throw new AppError('PRODUCT_NOT_FOUND', `Product ${input.id} not found`, 404);\n    }\n    \n    // Validate\n    this.validateUpdateInput(input);\n    \n    // Update\n    const updated = await this.productRepo.update(input);\n    return updated!;\n  }\n\n  private validateCreateInput(input: CreateProductInput): void {\n    if (input.priceCents < 0) {\n      throw new AppError('INVALID_PRICE', 'Price cannot be negative', 400);\n    }\n    \n    if (input.name.length < 1 || input.name.length > 255) {\n      throw new AppError('INVALID_NAME', 'Name must be 1-255 characters', 400);\n    }\n  }\n\n  private validateUpdateInput(input: UpdateProductInput): void {\n    if (input.priceCents !== undefined && input.priceCents < 0) {\n      throw new AppError('INVALID_PRICE', 'Price cannot be negative', 400);\n    }\n  }\n}\n```\n\n### Service with Dependencies\n\n```typescript\n// services/OrderService.ts\nexport class OrderService {\n  constructor(\n    private orderRepo: OrderRepository,\n    private productService: ProductService,\n    private inventoryService: InventoryService,\n    private paymentService: PaymentService,\n    private emailService: EmailService,\n    private eventBus: EventBus,\n  ) {}\n\n  async createOrder(input: CreateOrderInput): Promise<Order> {\n    // 1. Validate\n    await this.validateOrder(input);\n\n    // 2. Calculate pricing\n    const pricing = await this.calculatePricing(input.items);\n\n    // 3. Reserve inventory\n    const reservation = await this.inventoryService.reserve(\n      input.items.map(i => ({ productId: i.productId, quantity: i.quantity }))\n    );\n\n    try {\n      // 4. Create order record\n      const order = await this.orderRepo.create({\n        userId: input.userId,\n        items: input.items,\n        subtotalCents: pricing.subtotal,\n        taxCents: pricing.tax,\n        totalCents: pricing.total,\n      });\n\n      // 5. Emit event (async side effects)\n      await this.eventBus.publish('order.created', {\n        orderId: order.id,\n        userId: order.userId,\n      });\n\n      return order;\n    } catch (error) {\n      // Rollback inventory reservation\n      await this.inventoryService.release(reservation.id);\n      throw error;\n    }\n  }\n}\n```\n\n## Validation Patterns\n\n### Schema Validation with Zod\n\n```typescript\n// validation/productValidation.ts\nimport { z } from 'zod';\n\nexport const createProductSchema = z.object({\n  name: z.string()\n    .min(1, 'Name is required')\n    .max(255, 'Name must be 255 characters or less'),\n  description: z.string().max(5000).optional(),\n  categoryId: z.string().uuid('Invalid category ID'),\n  priceCents: z.number()\n    .int('Price must be a whole number')\n    .min(0, 'Price cannot be negative'),\n  metadata: z.object({\n    weight: z.number().positive().optional(),\n    tags: z.array(z.string()).max(10).optional(),\n  }).optional(),\n});\n\nexport type CreateProductDTO = z.infer<typeof createProductSchema>;\n\n// Usage in service\nasync create(input: unknown): Promise<Product> {\n  // Parse and validate\n  const validated = createProductSchema.parse(input);\n  \n  // Now validated has correct types\n  return this.productRepo.create(validated);\n}\n```\n\n### Custom Validation Rules\n\n```typescript\n// validation/orderValidation.ts\nimport { z } from 'zod';\n\nexport const createOrderSchema = z.object({\n  items: z.array(\n    z.object({\n      productId: z.string().uuid(),\n      quantity: z.number().int().positive(),\n    })\n  )\n  .min(1, 'At least one item required')\n  .max(50, 'Maximum 50 items per order'),\n  \n  shippingAddressId: z.string().uuid(),\n  \n  couponCode: z.string().optional(),\n})\n.refine(\n  (data) => {\n    // Custom validation: no duplicate products\n    const productIds = data.items.map(i => i.productId);\n    return new Set(productIds).size === productIds.length;\n  },\n  { message: 'Duplicate products not allowed', path: ['items'] }\n);\n```\n\n### Business Rule Validation\n\n```typescript\n// services/OrderService.ts\nprivate async validateOrder(input: CreateOrderInput): Promise<void> {\n  const errors: ValidationError[] = [];\n\n  // Check each product exists and is available\n  for (const item of input.items) {\n    const product = await this.productService.findById(item.productId);\n    \n    if (!product) {\n      errors.push({\n        field: `items.${item.productId}`,\n        code: 'PRODUCT_NOT_FOUND',\n        message: `Product ${item.productId} not found`,\n      });\n      continue;\n    }\n\n    if (!product.isActive) {\n      errors.push({\n        field: `items.${item.productId}`,\n        code: 'PRODUCT_UNAVAILABLE',\n        message: `Product ${product.name} is no longer available`,\n      });\n    }\n\n    // Check inventory\n    const available = await this.inventoryService.getAvailable(item.productId);\n    if (available < item.quantity) {\n      errors.push({\n        field: `items.${item.productId}.quantity`,\n        code: 'INSUFFICIENT_INVENTORY',\n        message: `Only ${available} units available`,\n        context: { available, requested: item.quantity },\n      });\n    }\n  }\n\n  if (errors.length > 0) {\n    throw new ValidationError('Order validation failed', errors);\n  }\n}\n```\n\n## Transaction Patterns\n\n### Service-Level Transactions\n\n```typescript\n// services/TransferService.ts\nexport class TransferService {\n  async transfer(\n    fromAccountId: string,\n    toAccountId: string,\n    amountCents: number,\n  ): Promise<Transfer> {\n    // Use database transaction\n    return await this.db.transaction().execute(async (trx) => {\n      // Debit source account\n      const fromAccount = await this.accountRepo.debit(\n        trx, \n        fromAccountId, \n        amountCents\n      );\n      \n      if (fromAccount.balanceCents < 0) {\n        throw new AppError('INSUFFICIENT_FUNDS', 'Insufficient balance');\n      }\n\n      // Credit destination account\n      await this.accountRepo.credit(trx, toAccountId, amountCents);\n\n      // Create transfer record\n      const transfer = await this.transferRepo.create(trx, {\n        fromAccountId,\n        toAccountId,\n        amountCents,\n        status: 'completed',\n      });\n\n      return transfer;\n    });\n  }\n}\n```\n\n### Saga Pattern for Distributed Transactions\n\n```typescript\n// services/CheckoutSaga.ts\nexport class CheckoutSaga {\n  async execute(input: CheckoutInput): Promise<Order> {\n    const sagaLog: SagaStep[] = [];\n\n    try {\n      // Step 1: Reserve inventory\n      const reservation = await this.inventoryService.reserve(input.items);\n      sagaLog.push({ step: 'inventory', data: reservation, compensate: () => \n        this.inventoryService.release(reservation.id) \n      });\n\n      // Step 2: Process payment\n      const payment = await this.paymentService.charge(input.paymentMethod, input.total);\n      sagaLog.push({ step: 'payment', data: payment, compensate: () => \n        this.paymentService.refund(payment.id) \n      });\n\n      // Step 3: Create order\n      const order = await this.orderService.create({\n        ...input,\n        reservationId: reservation.id,\n        paymentId: payment.id,\n      });\n      sagaLog.push({ step: 'order', data: order, compensate: () => \n        this.orderService.cancel(order.id) \n      });\n\n      // Step 4: Confirm inventory (commit reservation)\n      await this.inventoryService.confirm(reservation.id);\n\n      return order;\n    } catch (error) {\n      // Compensate in reverse order\n      for (const step of sagaLog.reverse()) {\n        try {\n          await step.compensate();\n        } catch (compensateError) {\n          // Log but don't throw - best effort rollback\n          this.logger.error('Saga compensation failed', {\n            step: step.step,\n            error: compensateError,\n          });\n        }\n      }\n      throw error;\n    }\n  }\n}\n```\n\n## Domain Event Patterns\n\n### Event Publishing\n\n```typescript\n// events/EventBus.ts\nexport interface DomainEvent {\n  type: string;\n  payload: unknown;\n  metadata: {\n    timestamp: Date;\n    correlationId: string;\n  };\n}\n\nexport class EventBus {\n  private handlers = new Map<string, EventHandler[]>();\n\n  subscribe(eventType: string, handler: EventHandler): void {\n    const existing = this.handlers.get(eventType) ?? [];\n    this.handlers.set(eventType, [...existing, handler]);\n  }\n\n  async publish(eventType: string, payload: unknown): Promise<void> {\n    const event: DomainEvent = {\n      type: eventType,\n      payload,\n      metadata: {\n        timestamp: new Date(),\n        correlationId: getCorrelationId(),\n      },\n    };\n\n    const handlers = this.handlers.get(eventType) ?? [];\n    \n    // Fire and forget - handlers run async\n    for (const handler of handlers) {\n      handler(event).catch(error => {\n        this.logger.error('Event handler failed', { eventType, error });\n      });\n    }\n  }\n}\n```\n\n### Event Handlers\n\n```typescript\n// events/handlers/OrderEventHandlers.ts\nexport function registerOrderEventHandlers(eventBus: EventBus): void {\n  // Send confirmation email\n  eventBus.subscribe('order.created', async (event) => {\n    const { orderId, userId } = event.payload as OrderCreatedPayload;\n    \n    const order = await orderRepo.findById(orderId);\n    const user = await userRepo.findById(userId);\n    \n    await emailService.send({\n      to: user.email,\n      template: 'order-confirmation',\n      data: { order, user },\n    });\n  });\n\n  // Update analytics\n  eventBus.subscribe('order.created', async (event) => {\n    const { orderId } = event.payload as OrderCreatedPayload;\n    await analyticsService.trackOrder(orderId);\n  });\n\n  // Notify warehouse\n  eventBus.subscribe('order.paid', async (event) => {\n    const { orderId } = event.payload as OrderPaidPayload;\n    await warehouseService.queueForFulfillment(orderId);\n  });\n}\n```\n\n## Caching Patterns\n\n### Service-Level Caching\n\n```typescript\n// services/ProductService.ts\nexport class ProductService {\n  private cache: Cache;\n\n  async getById(id: string): Promise<Product> {\n    // Try cache first\n    const cacheKey = `product:${id}`;\n    const cached = await this.cache.get<Product>(cacheKey);\n    \n    if (cached) {\n      return cached;\n    }\n\n    // Fetch from database\n    const product = await this.productRepo.findById(id);\n    \n    if (!product) {\n      throw new AppError('PRODUCT_NOT_FOUND', `Product ${id} not found`, 404);\n    }\n\n    // Cache for 5 minutes\n    await this.cache.set(cacheKey, product, { ttl: 300 });\n    \n    return product;\n  }\n\n  async update(input: UpdateProductInput): Promise<Product> {\n    const updated = await this.productRepo.update(input);\n    \n    // Invalidate cache\n    await this.cache.delete(`product:${input.id}`);\n    \n    return updated!;\n  }\n}\n```\n\n### Cache-Aside with Batch Loading\n\n```typescript\n// services/ProductService.ts\nasync getByIds(ids: string[]): Promise<Product[]> {\n  if (ids.length === 0) return [];\n\n  // Check cache for all IDs\n  const cacheKeys = ids.map(id => `product:${id}`);\n  const cached = await this.cache.mget<Product>(cacheKeys);\n\n  // Find missing IDs\n  const missingIds: string[] = [];\n  const results = new Map<string, Product>();\n\n  ids.forEach((id, index) => {\n    if (cached[index]) {\n      results.set(id, cached[index]!);\n    } else {\n      missingIds.push(id);\n    }\n  });\n\n  // Fetch missing from database\n  if (missingIds.length > 0) {\n    const products = await this.productRepo.findByIds(missingIds);\n    \n    // Cache and add to results\n    const toCache: Array<{ key: string; value: Product; ttl: number }> = [];\n    \n    for (const product of products) {\n      results.set(product.id, product);\n      toCache.push({\n        key: `product:${product.id}`,\n        value: product,\n        ttl: 300,\n      });\n    }\n\n    await this.cache.mset(toCache);\n  }\n\n  // Return in original order\n  return ids.map(id => results.get(id)).filter(Boolean) as Product[];\n}\n```\n\n## Authorization Patterns\n\n### Service-Level Authorization\n\n```typescript\n// services/OrderService.ts\nasync getOrder(orderId: string, requestingUser: User): Promise<Order> {\n  const order = await this.orderRepo.findById(orderId);\n  \n  if (!order) {\n    throw new AppError('ORDER_NOT_FOUND', `Order ${orderId} not found`, 404);\n  }\n\n  // Authorization check\n  if (order.userId !== requestingUser.id && !requestingUser.isAdmin) {\n    throw new AppError('FORBIDDEN', 'You do not have access to this order', 403);\n  }\n\n  return order;\n}\n\nasync cancelOrder(orderId: string, requestingUser: User): Promise<Order> {\n  const order = await this.getOrder(orderId, requestingUser);\n\n  // Business rule: can only cancel pending orders\n  if (order.status !== 'pending') {\n    throw new AppError(\n      'CANNOT_CANCEL',\n      `Cannot cancel order in ${order.status} status`,\n      400\n    );\n  }\n\n  return this.orderRepo.update({ id: orderId, status: 'cancelled' });\n}\n```\n\n### Policy-Based Authorization\n\n```typescript\n// policies/OrderPolicy.ts\nexport class OrderPolicy {\n  canView(user: User, order: Order): boolean {\n    return order.userId === user.id || user.roles.includes('admin');\n  }\n\n  canCancel(user: User, order: Order): boolean {\n    if (!this.canView(user, order)) return false;\n    return order.status === 'pending';\n  }\n\n  canRefund(user: User, order: Order): boolean {\n    if (!user.roles.includes('admin')) return false;\n    return ['paid', 'shipped', 'delivered'].includes(order.status);\n  }\n}\n\n// Usage in service\nasync cancelOrder(orderId: string, user: User): Promise<Order> {\n  const order = await this.orderRepo.findById(orderId);\n  \n  if (!order) {\n    throw new AppError('ORDER_NOT_FOUND', `Order ${orderId} not found`, 404);\n  }\n\n  if (!this.orderPolicy.canCancel(user, order)) {\n    throw new AppError('FORBIDDEN', 'You cannot cancel this order', 403);\n  }\n\n  return this.performCancellation(order);\n}\n```\n"
    },
    {
      "name": "testing-patterns.md",
      "path": "references/testing-patterns.md",
      "content": "# Testing Patterns\n\nPatterns for unit tests, integration tests, and end-to-end tests.\n\n## Testing Philosophy\n\n**Write tests as you implement.** Don't leave testing until the end.\n\n**Test behavior, not implementation.** Tests should survive refactoring.\n\n**Follow the testing pyramid:**\n- Many unit tests (fast, isolated)\n- Fewer integration tests (slower, verify integrations)\n- Few E2E tests (slowest, critical paths only)\n\n## Unit Tests\n\n### Service Tests\n\n```typescript\n// services/__tests__/OrderService.test.ts\nimport { OrderService } from '../OrderService';\nimport { createMockOrderRepo } from '../../test/mocks/orderRepo';\nimport { createMockProductService } from '../../test/mocks/productService';\nimport { createMockInventoryService } from '../../test/mocks/inventoryService';\nimport { AppError } from '../../common/errors';\n\ndescribe('OrderService', () => {\n  let service: OrderService;\n  let mockOrderRepo: ReturnType<typeof createMockOrderRepo>;\n  let mockProductService: ReturnType<typeof createMockProductService>;\n  let mockInventoryService: ReturnType<typeof createMockInventoryService>;\n\n  beforeEach(() => {\n    mockOrderRepo = createMockOrderRepo();\n    mockProductService = createMockProductService();\n    mockInventoryService = createMockInventoryService();\n\n    service = new OrderService(\n      mockOrderRepo,\n      mockProductService,\n      mockInventoryService,\n    );\n  });\n\n  describe('createOrder', () => {\n    const validInput = {\n      userId: 'user-1',\n      items: [{ productId: 'prod-1', quantity: 2 }],\n      shippingAddressId: 'addr-1',\n    };\n\n    it('creates order with valid input', async () => {\n      // Arrange\n      mockProductService.getById.mockResolvedValue({\n        id: 'prod-1',\n        priceCents: 1000,\n        isActive: true,\n      });\n      mockInventoryService.getAvailable.mockResolvedValue(10);\n      mockOrderRepo.create.mockResolvedValue({\n        id: 'order-1',\n        userId: 'user-1',\n        status: 'pending',\n        totalCents: 2000,\n      });\n\n      // Act\n      const order = await service.createOrder(validInput);\n\n      // Assert\n      expect(order).toEqual({\n        id: 'order-1',\n        userId: 'user-1',\n        status: 'pending',\n        totalCents: 2000,\n      });\n      expect(mockOrderRepo.create).toHaveBeenCalledWith(\n        expect.objectContaining({\n          userId: 'user-1',\n          totalCents: 2000,\n        })\n      );\n    });\n\n    it('throws CART_EMPTY when items array is empty', async () => {\n      // Arrange\n      const input = { ...validInput, items: [] };\n\n      // Act & Assert\n      await expect(service.createOrder(input))\n        .rejects\n        .toThrow(AppError);\n      \n      await expect(service.createOrder(input))\n        .rejects\n        .toMatchObject({ code: 'CART_EMPTY' });\n    });\n\n    it('throws OUT_OF_STOCK when inventory is insufficient', async () => {\n      // Arrange\n      mockProductService.getById.mockResolvedValue({\n        id: 'prod-1',\n        priceCents: 1000,\n        isActive: true,\n      });\n      mockInventoryService.getAvailable.mockResolvedValue(1); // Only 1 available\n\n      // Act & Assert\n      await expect(service.createOrder(validInput))\n        .rejects\n        .toMatchObject({\n          code: 'OUT_OF_STOCK',\n          details: { available: 1, requested: 2 },\n        });\n    });\n\n    it('reserves inventory before creating order', async () => {\n      // Arrange\n      mockProductService.getById.mockResolvedValue({\n        id: 'prod-1',\n        priceCents: 1000,\n        isActive: true,\n      });\n      mockInventoryService.getAvailable.mockResolvedValue(10);\n      mockInventoryService.reserve.mockResolvedValue({ id: 'res-1' });\n\n      // Act\n      await service.createOrder(validInput);\n\n      // Assert\n      expect(mockInventoryService.reserve).toHaveBeenCalledBefore(\n        mockOrderRepo.create\n      );\n    });\n\n    it('releases reservation if order creation fails', async () => {\n      // Arrange\n      mockProductService.getById.mockResolvedValue({\n        id: 'prod-1',\n        priceCents: 1000,\n        isActive: true,\n      });\n      mockInventoryService.getAvailable.mockResolvedValue(10);\n      mockInventoryService.reserve.mockResolvedValue({ id: 'res-1' });\n      mockOrderRepo.create.mockRejectedValue(new Error('DB error'));\n\n      // Act & Assert\n      await expect(service.createOrder(validInput)).rejects.toThrow();\n      expect(mockInventoryService.releaseReservation).toHaveBeenCalledWith('res-1');\n    });\n  });\n});\n```\n\n### Mock Factories\n\n```typescript\n// test/mocks/orderRepo.ts\nimport { vi } from 'vitest';\nimport type { OrderRepository } from '../../repositories/OrderRepository';\n\nexport function createMockOrderRepo(): jest.Mocked<OrderRepository> {\n  return {\n    findById: vi.fn(),\n    findByUserId: vi.fn(),\n    create: vi.fn(),\n    update: vi.fn(),\n    delete: vi.fn(),\n  };\n}\n\n// test/mocks/productService.ts\nexport function createMockProductService(): jest.Mocked<ProductService> {\n  return {\n    getById: vi.fn(),\n    list: vi.fn(),\n    create: vi.fn(),\n    update: vi.fn(),\n    delete: vi.fn(),\n  };\n}\n```\n\n### Testing Validation\n\n```typescript\n// validation/__tests__/orderValidation.test.ts\nimport { createOrderSchema } from '../orderValidation';\n\ndescribe('createOrderSchema', () => {\n  it('accepts valid input', () => {\n    const input = {\n      items: [{ productId: '123e4567-e89b-12d3-a456-426614174000', quantity: 2 }],\n      shippingAddressId: '123e4567-e89b-12d3-a456-426614174001',\n    };\n\n    expect(() => createOrderSchema.parse(input)).not.toThrow();\n  });\n\n  it('rejects empty items array', () => {\n    const input = {\n      items: [],\n      shippingAddressId: '123e4567-e89b-12d3-a456-426614174001',\n    };\n\n    expect(() => createOrderSchema.parse(input)).toThrow(/at least one item/i);\n  });\n\n  it('rejects invalid product ID format', () => {\n    const input = {\n      items: [{ productId: 'not-a-uuid', quantity: 2 }],\n      shippingAddressId: '123e4567-e89b-12d3-a456-426614174001',\n    };\n\n    expect(() => createOrderSchema.parse(input)).toThrow(/invalid/i);\n  });\n\n  it('rejects negative quantity', () => {\n    const input = {\n      items: [{ productId: '123e4567-e89b-12d3-a456-426614174000', quantity: -1 }],\n      shippingAddressId: '123e4567-e89b-12d3-a456-426614174001',\n    };\n\n    expect(() => createOrderSchema.parse(input)).toThrow(/positive/i);\n  });\n});\n```\n\n## Integration Tests\n\n### API Integration Tests\n\n```typescript\n// tests/integration/orders.test.ts\nimport request from 'supertest';\nimport app from '../../src/app';\nimport { setupTestDb, teardownTestDb, resetTestDb } from '../helpers/db';\nimport { createTestUser, createTestProduct } from '../helpers/factories';\n\ndescribe('Orders API', () => {\n  let authToken: string;\n  let userId: string;\n  let productId: string;\n\n  beforeAll(async () => {\n    await setupTestDb();\n  });\n\n  afterAll(async () => {\n    await teardownTestDb();\n  });\n\n  beforeEach(async () => {\n    await resetTestDb();\n    \n    // Create test user and get token\n    const user = await createTestUser();\n    userId = user.id;\n    authToken = user.token;\n\n    // Create test product\n    const product = await createTestProduct({ priceCents: 1000 });\n    productId = product.id;\n  });\n\n  describe('POST /api/orders', () => {\n    it('returns 201 and creates order', async () => {\n      const response = await request(app)\n        .post('/api/orders')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          items: [{ productId, quantity: 2 }],\n          shippingAddressId: 'addr-1',\n        });\n\n      expect(response.status).toBe(201);\n      expect(response.body.data).toMatchObject({\n        status: 'pending',\n        totalCents: 2000,\n      });\n      expect(response.body.data.id).toBeDefined();\n    });\n\n    it('returns 401 without authentication', async () => {\n      const response = await request(app)\n        .post('/api/orders')\n        .send({ items: [] });\n\n      expect(response.status).toBe(401);\n      expect(response.body.error.code).toBe('UNAUTHORIZED');\n    });\n\n    it('returns 400 for empty cart', async () => {\n      const response = await request(app)\n        .post('/api/orders')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          items: [],\n          shippingAddressId: 'addr-1',\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error.code).toBe('VALIDATION_ERROR');\n    });\n\n    it('returns 400 for invalid product ID', async () => {\n      const response = await request(app)\n        .post('/api/orders')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          items: [{ productId: 'nonexistent', quantity: 1 }],\n          shippingAddressId: 'addr-1',\n        });\n\n      expect(response.status).toBe(400);\n    });\n  });\n\n  describe('GET /api/orders/:id', () => {\n    it('returns order for owner', async () => {\n      // Create order first\n      const createResponse = await request(app)\n        .post('/api/orders')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          items: [{ productId, quantity: 1 }],\n          shippingAddressId: 'addr-1',\n        });\n\n      const orderId = createResponse.body.data.id;\n\n      // Fetch order\n      const response = await request(app)\n        .get(`/api/orders/${orderId}`)\n        .set('Authorization', `Bearer ${authToken}`);\n\n      expect(response.status).toBe(200);\n      expect(response.body.data.id).toBe(orderId);\n    });\n\n    it('returns 403 for non-owner', async () => {\n      // Create order as user 1\n      const createResponse = await request(app)\n        .post('/api/orders')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          items: [{ productId, quantity: 1 }],\n          shippingAddressId: 'addr-1',\n        });\n\n      // Try to access as user 2\n      const user2 = await createTestUser();\n\n      const response = await request(app)\n        .get(`/api/orders/${createResponse.body.data.id}`)\n        .set('Authorization', `Bearer ${user2.token}`);\n\n      expect(response.status).toBe(403);\n    });\n\n    it('returns 404 for nonexistent order', async () => {\n      const response = await request(app)\n        .get('/api/orders/nonexistent-id')\n        .set('Authorization', `Bearer ${authToken}`);\n\n      expect(response.status).toBe(404);\n    });\n  });\n});\n```\n\n### Database Test Helpers\n\n```typescript\n// tests/helpers/db.ts\nimport { db } from '../../src/database';\nimport { migrate } from '../../src/database/migrations';\n\nexport async function setupTestDb() {\n  // Run migrations\n  await migrate(db, 'latest');\n}\n\nexport async function teardownTestDb() {\n  await db.destroy();\n}\n\nexport async function resetTestDb() {\n  // Truncate all tables in reverse dependency order\n  await db.deleteFrom('order_items').execute();\n  await db.deleteFrom('orders').execute();\n  await db.deleteFrom('products').execute();\n  await db.deleteFrom('users').execute();\n}\n\n// tests/helpers/factories.ts\nexport async function createTestUser(overrides = {}) {\n  const user = await db\n    .insertInto('users')\n    .values({\n      email: `test-${Date.now()}@example.com`,\n      password_hash: 'hashed',\n      ...overrides,\n    })\n    .returningAll()\n    .executeTakeFirst();\n\n  const token = generateToken({ userId: user.id });\n\n  return { ...user, token };\n}\n\nexport async function createTestProduct(overrides = {}) {\n  return db\n    .insertInto('products')\n    .values({\n      name: 'Test Product',\n      price_cents: 1000,\n      status: 'active',\n      is_active: true,\n      ...overrides,\n    })\n    .returningAll()\n    .executeTakeFirst();\n}\n```\n\n## Component Tests\n\n### React Testing Library\n\n```typescript\n// components/__tests__/ProductCard.test.tsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { ProductCard } from '../ProductCard';\n\ndescribe('ProductCard', () => {\n  const mockProduct = {\n    id: '1',\n    name: 'Test Product',\n    priceCents: 1999,\n    imageUrl: 'https://example.com/image.jpg',\n  };\n\n  it('renders product information', () => {\n    render(<ProductCard product={mockProduct} />);\n\n    expect(screen.getByText('Test Product')).toBeInTheDocument();\n    expect(screen.getByText('$19.99')).toBeInTheDocument();\n    expect(screen.getByRole('img')).toHaveAttribute('src', mockProduct.imageUrl);\n  });\n\n  it('calls onAddToCart when button clicked', () => {\n    const onAddToCart = vi.fn();\n    \n    render(<ProductCard product={mockProduct} onAddToCart={onAddToCart} />);\n\n    fireEvent.click(screen.getByRole('button', { name: /add to cart/i }));\n\n    expect(onAddToCart).toHaveBeenCalledWith('1');\n  });\n\n  it('does not show add to cart button if no handler', () => {\n    render(<ProductCard product={mockProduct} />);\n\n    expect(screen.queryByRole('button')).not.toBeInTheDocument();\n  });\n});\n```\n\n### Testing Hooks\n\n```typescript\n// hooks/__tests__/useProducts.test.ts\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { useProducts } from '../useProducts';\nimport { api } from '../../lib/api';\n\nvi.mock('../../lib/api');\n\nfunction wrapper({ children }: { children: React.ReactNode }) {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: { retry: false },\n    },\n  });\n  return (\n    <QueryClientProvider client={queryClient}>\n      {children}\n    </QueryClientProvider>\n  );\n}\n\ndescribe('useProducts', () => {\n  it('fetches products successfully', async () => {\n    const mockProducts = [\n      { id: '1', name: 'Product 1' },\n      { id: '2', name: 'Product 2' },\n    ];\n\n    vi.mocked(api.get).mockResolvedValue({\n      data: { data: mockProducts, meta: { total: 2 } },\n    });\n\n    const { result } = renderHook(() => useProducts(), { wrapper });\n\n    // Initially loading\n    expect(result.current.isLoading).toBe(true);\n\n    // Wait for data\n    await waitFor(() => {\n      expect(result.current.isSuccess).toBe(true);\n    });\n\n    expect(result.current.data?.data).toEqual(mockProducts);\n  });\n\n  it('handles error state', async () => {\n    vi.mocked(api.get).mockRejectedValue(new Error('Network error'));\n\n    const { result } = renderHook(() => useProducts(), { wrapper });\n\n    await waitFor(() => {\n      expect(result.current.isError).toBe(true);\n    });\n\n    expect(result.current.error?.message).toBe('Network error');\n  });\n});\n```\n\n### Testing Forms\n\n```typescript\n// components/__tests__/ProductForm.test.tsx\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { ProductForm } from '../ProductForm';\n\ndescribe('ProductForm', () => {\n  const mockOnSubmit = vi.fn();\n  const mockOnCancel = vi.fn();\n\n  beforeEach(() => {\n    mockOnSubmit.mockClear();\n    mockOnCancel.mockClear();\n  });\n\n  it('submits valid form data', async () => {\n    const user = userEvent.setup();\n    mockOnSubmit.mockResolvedValue(undefined);\n\n    render(\n      <ProductForm onSubmit={mockOnSubmit} onCancel={mockOnCancel} />\n    );\n\n    await user.type(screen.getByLabelText(/name/i), 'New Product');\n    await user.type(screen.getByLabelText(/price/i), '1999');\n    await user.click(screen.getByRole('button', { name: /save/i }));\n\n    await waitFor(() => {\n      expect(mockOnSubmit).toHaveBeenCalledWith({\n        name: 'New Product',\n        priceCents: 1999,\n      });\n    });\n  });\n\n  it('shows validation errors', async () => {\n    const user = userEvent.setup();\n\n    render(\n      <ProductForm onSubmit={mockOnSubmit} onCancel={mockOnCancel} />\n    );\n\n    // Submit without filling required fields\n    await user.click(screen.getByRole('button', { name: /save/i }));\n\n    await waitFor(() => {\n      expect(screen.getByText(/name is required/i)).toBeInTheDocument();\n    });\n\n    expect(mockOnSubmit).not.toHaveBeenCalled();\n  });\n\n  it('shows API errors', async () => {\n    const user = userEvent.setup();\n    mockOnSubmit.mockRejectedValue({\n      details: [{ field: 'name', message: 'Name already exists' }],\n    });\n\n    render(\n      <ProductForm onSubmit={mockOnSubmit} onCancel={mockOnCancel} />\n    );\n\n    await user.type(screen.getByLabelText(/name/i), 'Existing Product');\n    await user.type(screen.getByLabelText(/price/i), '1000');\n    await user.click(screen.getByRole('button', { name: /save/i }));\n\n    await waitFor(() => {\n      expect(screen.getByText(/name already exists/i)).toBeInTheDocument();\n    });\n  });\n\n  it('calls onCancel when cancel button clicked', async () => {\n    const user = userEvent.setup();\n\n    render(\n      <ProductForm onSubmit={mockOnSubmit} onCancel={mockOnCancel} />\n    );\n\n    await user.click(screen.getByRole('button', { name: /cancel/i }));\n\n    expect(mockOnCancel).toHaveBeenCalled();\n  });\n});\n```\n\n## E2E Tests\n\n### Playwright Tests\n\n```typescript\n// e2e/checkout.spec.ts\nimport { test, expect } from '@playwright/test';\n\ntest.describe('Checkout Flow', () => {\n  test.beforeEach(async ({ page }) => {\n    // Login\n    await page.goto('/login');\n    await page.fill('[name=\"email\"]', 'test@example.com');\n    await page.fill('[name=\"password\"]', 'password');\n    await page.click('button[type=\"submit\"]');\n    await page.waitForURL('/');\n  });\n\n  test('complete checkout flow', async ({ page }) => {\n    // Add product to cart\n    await page.goto('/products');\n    await page.click('[data-testid=\"product-card\"]:first-child button');\n    \n    // Verify cart updated\n    await expect(page.locator('[data-testid=\"cart-count\"]')).toHaveText('1');\n\n    // Go to cart\n    await page.click('[data-testid=\"cart-icon\"]');\n    await page.waitForURL('/cart');\n\n    // Proceed to checkout\n    await page.click('button:has-text(\"Checkout\")');\n    await page.waitForURL('/checkout');\n\n    // Fill shipping\n    await page.selectOption('[name=\"shippingAddressId\"]', { index: 1 });\n    await page.click('button:has-text(\"Continue\")');\n\n    // Fill payment\n    await page.fill('[name=\"cardNumber\"]', '4242424242424242');\n    await page.fill('[name=\"expiry\"]', '12/25');\n    await page.fill('[name=\"cvc\"]', '123');\n    \n    // Place order\n    await page.click('button:has-text(\"Place Order\")');\n\n    // Verify confirmation\n    await page.waitForURL(/\\/orders\\/[a-z0-9-]+/);\n    await expect(page.locator('h1')).toContainText('Order Confirmed');\n  });\n\n  test('shows error for out of stock item', async ({ page }) => {\n    // Add out of stock product\n    await page.goto('/products/out-of-stock-product');\n    await page.click('button:has-text(\"Add to Cart\")');\n    \n    await page.goto('/checkout');\n    await page.click('button:has-text(\"Place Order\")');\n\n    await expect(page.locator('.error')).toContainText(/out of stock/i);\n  });\n});\n```\n\n### Test Configuration\n\n```typescript\n// playwright.config.ts\nimport { defineConfig, devices } from '@playwright/test';\n\nexport default defineConfig({\n  testDir: './e2e',\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: 'html',\n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry',\n  },\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    },\n    {\n      name: 'firefox',\n      use: { ...devices['Desktop Firefox'] },\n    },\n    {\n      name: 'Mobile Safari',\n      use: { ...devices['iPhone 12'] },\n    },\n  ],\n  webServer: {\n    command: 'npm run dev',\n    url: 'http://localhost:3000',\n    reuseExistingServer: !process.env.CI,\n  },\n});\n```\n"
    },
    {
      "name": "ui-layer-patterns.md",
      "path": "references/ui-layer-patterns.md",
      "content": "# UI Layer Patterns\n\nPatterns for implementing React components, state management, and user interactions.\n\n## Component Structure\n\n### Basic Component\n\n```typescript\n// components/ProductCard.tsx\ninterface ProductCardProps {\n  product: Product;\n  onAddToCart?: (productId: string) => void;\n}\n\nexport function ProductCard({ product, onAddToCart }: ProductCardProps) {\n  return (\n    <div className=\"border rounded-lg p-4\">\n      <img \n        src={product.imageUrl} \n        alt={product.name}\n        className=\"w-full h-48 object-cover rounded\"\n      />\n      <h3 className=\"mt-2 font-semibold\">{product.name}</h3>\n      <p className=\"text-gray-600\">${(product.priceCents / 100).toFixed(2)}</p>\n      {onAddToCart && (\n        <button\n          onClick={() => onAddToCart(product.id)}\n          className=\"mt-2 w-full bg-blue-500 text-white py-2 rounded\"\n        >\n          Add to Cart\n        </button>\n      )}\n    </div>\n  );\n}\n```\n\n### Component with Loading/Error States\n\n```typescript\n// components/ProductList.tsx\ninterface ProductListProps {\n  categoryId: string;\n}\n\nexport function ProductList({ categoryId }: ProductListProps) {\n  const { data: products, isLoading, error } = useProducts(categoryId);\n\n  if (isLoading) {\n    return <ProductListSkeleton />;\n  }\n\n  if (error) {\n    return (\n      <div className=\"text-center py-8\">\n        <p className=\"text-red-500\">Failed to load products</p>\n        <button \n          onClick={() => refetch()}\n          className=\"mt-2 text-blue-500 underline\"\n        >\n          Try again\n        </button>\n      </div>\n    );\n  }\n\n  if (products.length === 0) {\n    return (\n      <div className=\"text-center py-8 text-gray-500\">\n        No products found\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n      {products.map(product => (\n        <ProductCard key={product.id} product={product} />\n      ))}\n    </div>\n  );\n}\n```\n\n### Compound Components\n\n```typescript\n// components/Card/index.tsx\ninterface CardContextValue {\n  variant: 'default' | 'outlined';\n}\n\nconst CardContext = createContext<CardContextValue | null>(null);\n\nfunction useCardContext() {\n  const context = useContext(CardContext);\n  if (!context) {\n    throw new Error('Card components must be used within Card');\n  }\n  return context;\n}\n\ninterface CardProps {\n  variant?: 'default' | 'outlined';\n  children: React.ReactNode;\n}\n\nexport function Card({ variant = 'default', children }: CardProps) {\n  return (\n    <CardContext.Provider value={{ variant }}>\n      <div className={cn(\n        'rounded-lg',\n        variant === 'outlined' ? 'border' : 'bg-white shadow'\n      )}>\n        {children}\n      </div>\n    </CardContext.Provider>\n  );\n}\n\nCard.Header = function CardHeader({ children }: { children: React.ReactNode }) {\n  return <div className=\"px-4 py-3 border-b\">{children}</div>;\n};\n\nCard.Body = function CardBody({ children }: { children: React.ReactNode }) {\n  return <div className=\"px-4 py-4\">{children}</div>;\n};\n\nCard.Footer = function CardFooter({ children }: { children: React.ReactNode }) {\n  return <div className=\"px-4 py-3 border-t bg-gray-50\">{children}</div>;\n};\n\n// Usage\n<Card variant=\"outlined\">\n  <Card.Header>Title</Card.Header>\n  <Card.Body>Content</Card.Body>\n  <Card.Footer>Actions</Card.Footer>\n</Card>\n```\n\n## Data Fetching\n\n### React Query Hooks\n\n```typescript\n// hooks/useProducts.ts\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { api } from '../lib/api';\nimport type { Product, CreateProductInput } from '../types';\n\n// Query keys factory\nexport const productKeys = {\n  all: ['products'] as const,\n  lists: () => [...productKeys.all, 'list'] as const,\n  list: (filters: ProductFilters) => [...productKeys.lists(), filters] as const,\n  details: () => [...productKeys.all, 'detail'] as const,\n  detail: (id: string) => [...productKeys.details(), id] as const,\n};\n\n// Fetch single product\nexport function useProduct(id: string) {\n  return useQuery({\n    queryKey: productKeys.detail(id),\n    queryFn: () => api.get<{ data: Product }>(`/products/${id}`)\n      .then(r => r.data.data),\n    enabled: !!id,\n  });\n}\n\n// Fetch product list\nexport function useProducts(filters: ProductFilters = {}) {\n  return useQuery({\n    queryKey: productKeys.list(filters),\n    queryFn: () => api.get<{ data: Product[]; meta: PaginationMeta }>(\n      '/products',\n      { params: filters }\n    ).then(r => r.data),\n  });\n}\n\n// Create product\nexport function useCreateProduct() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (input: CreateProductInput) =>\n      api.post<{ data: Product }>('/products', input)\n        .then(r => r.data.data),\n    \n    onSuccess: () => {\n      // Invalidate product lists\n      queryClient.invalidateQueries({ queryKey: productKeys.lists() });\n    },\n  });\n}\n\n// Update product\nexport function useUpdateProduct() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, ...input }: UpdateProductInput) =>\n      api.patch<{ data: Product }>(`/products/${id}`, input)\n        .then(r => r.data.data),\n    \n    onSuccess: (product) => {\n      // Update cache for this product\n      queryClient.setQueryData(productKeys.detail(product.id), product);\n      // Invalidate lists\n      queryClient.invalidateQueries({ queryKey: productKeys.lists() });\n    },\n  });\n}\n\n// Delete product\nexport function useDeleteProduct() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (id: string) => api.delete(`/products/${id}`),\n    \n    onSuccess: (_, id) => {\n      // Remove from cache\n      queryClient.removeQueries({ queryKey: productKeys.detail(id) });\n      // Invalidate lists\n      queryClient.invalidateQueries({ queryKey: productKeys.lists() });\n    },\n  });\n}\n```\n\n### Optimistic Updates\n\n```typescript\n// hooks/useUpdateCart.ts\nexport function useUpdateCartItem() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ itemId, quantity }: { itemId: string; quantity: number }) =>\n      api.patch(`/cart/items/${itemId}`, { quantity }),\n    \n    // Optimistic update\n    onMutate: async ({ itemId, quantity }) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['cart'] });\n\n      // Snapshot previous value\n      const previousCart = queryClient.getQueryData<Cart>(['cart']);\n\n      // Optimistically update\n      queryClient.setQueryData<Cart>(['cart'], (old) => {\n        if (!old) return old;\n        return {\n          ...old,\n          items: old.items.map(item =>\n            item.id === itemId ? { ...item, quantity } : item\n          ),\n        };\n      });\n\n      return { previousCart };\n    },\n    \n    // Rollback on error\n    onError: (err, variables, context) => {\n      if (context?.previousCart) {\n        queryClient.setQueryData(['cart'], context.previousCart);\n      }\n    },\n    \n    // Refetch after mutation\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: ['cart'] });\n    },\n  });\n}\n```\n\n## Form Handling\n\n### Form with React Hook Form + Zod\n\n```typescript\n// components/ProductForm.tsx\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\nconst productSchema = z.object({\n  name: z.string().min(1, 'Name is required').max(255),\n  description: z.string().max(5000).optional(),\n  priceCents: z.number().min(0, 'Price cannot be negative'),\n  categoryId: z.string().uuid('Select a category'),\n});\n\ntype ProductFormData = z.infer<typeof productSchema>;\n\ninterface ProductFormProps {\n  initialData?: Partial<ProductFormData>;\n  onSubmit: (data: ProductFormData) => Promise<void>;\n  onCancel: () => void;\n}\n\nexport function ProductForm({ initialData, onSubmit, onCancel }: ProductFormProps) {\n  const {\n    register,\n    handleSubmit,\n    formState: { errors, isSubmitting },\n    setError,\n  } = useForm<ProductFormData>({\n    resolver: zodResolver(productSchema),\n    defaultValues: initialData,\n  });\n\n  const handleFormSubmit = async (data: ProductFormData) => {\n    try {\n      await onSubmit(data);\n    } catch (error) {\n      if (error instanceof ApiError) {\n        // Set field-specific errors from API\n        error.details?.forEach((detail) => {\n          setError(detail.field as keyof ProductFormData, {\n            message: detail.message,\n          });\n        });\n      } else {\n        setError('root', { message: 'An unexpected error occurred' });\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit(handleFormSubmit)} className=\"space-y-4\">\n      {errors.root && (\n        <div className=\"bg-red-50 text-red-500 p-3 rounded\">\n          {errors.root.message}\n        </div>\n      )}\n\n      <div>\n        <label htmlFor=\"name\" className=\"block text-sm font-medium\">\n          Name\n        </label>\n        <input\n          id=\"name\"\n          {...register('name')}\n          className={cn(\n            'mt-1 block w-full rounded border p-2',\n            errors.name && 'border-red-500'\n          )}\n        />\n        {errors.name && (\n          <p className=\"mt-1 text-sm text-red-500\">{errors.name.message}</p>\n        )}\n      </div>\n\n      <div>\n        <label htmlFor=\"priceCents\" className=\"block text-sm font-medium\">\n          Price (cents)\n        </label>\n        <input\n          id=\"priceCents\"\n          type=\"number\"\n          {...register('priceCents', { valueAsNumber: true })}\n          className={cn(\n            'mt-1 block w-full rounded border p-2',\n            errors.priceCents && 'border-red-500'\n          )}\n        />\n        {errors.priceCents && (\n          <p className=\"mt-1 text-sm text-red-500\">{errors.priceCents.message}</p>\n        )}\n      </div>\n\n      <div className=\"flex gap-2\">\n        <button\n          type=\"submit\"\n          disabled={isSubmitting}\n          className=\"bg-blue-500 text-white px-4 py-2 rounded disabled:opacity-50\"\n        >\n          {isSubmitting ? 'Saving...' : 'Save'}\n        </button>\n        <button\n          type=\"button\"\n          onClick={onCancel}\n          className=\"border px-4 py-2 rounded\"\n        >\n          Cancel\n        </button>\n      </div>\n    </form>\n  );\n}\n```\n\n## Feedback Patterns\n\n### Haptic Feedback Hook\n\n```typescript\n// hooks/useHaptic.ts\nexport function useHaptic() {\n  const isSupported = 'vibrate' in navigator;\n\n  const impact = (style: 'light' | 'medium' | 'heavy') => {\n    if (!isSupported) return;\n    \n    const patterns = {\n      light: [10],\n      medium: [20],\n      heavy: [30],\n    };\n    \n    navigator.vibrate(patterns[style]);\n  };\n\n  const notification = (type: 'success' | 'warning' | 'error') => {\n    if (!isSupported) return;\n    \n    const patterns = {\n      success: [10, 50, 10],\n      warning: [20, 100, 20],\n      error: [30, 100, 30, 100, 30],\n    };\n    \n    navigator.vibrate(patterns[type]);\n  };\n\n  return { impact, notification, isSupported };\n}\n```\n\n### Button with Feedback\n\n```typescript\n// components/ui/Button.tsx\ninterface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  variant?: 'primary' | 'secondary' | 'danger';\n  loading?: boolean;\n  haptic?: boolean;\n}\n\nexport function Button({\n  variant = 'primary',\n  loading,\n  haptic = true,\n  onClick,\n  children,\n  disabled,\n  ...props\n}: ButtonProps) {\n  const { impact } = useHaptic();\n  const [pressed, setPressed] = useState(false);\n\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    if (disabled || loading) return;\n    \n    // Immediate haptic (0ms)\n    if (haptic) impact('light');\n    \n    onClick?.(e);\n  };\n\n  const handlePointerDown = () => {\n    if (!disabled && !loading) {\n      setPressed(true);\n    }\n  };\n\n  const handlePointerUp = () => {\n    setPressed(false);\n  };\n\n  return (\n    <button\n      {...props}\n      onClick={handleClick}\n      onPointerDown={handlePointerDown}\n      onPointerUp={handlePointerUp}\n      onPointerLeave={handlePointerUp}\n      disabled={disabled || loading}\n      className={cn(\n        'relative px-4 py-2 rounded font-medium transition-transform',\n        pressed && 'scale-95',\n        variant === 'primary' && 'bg-blue-500 text-white',\n        variant === 'secondary' && 'bg-gray-200 text-gray-800',\n        variant === 'danger' && 'bg-red-500 text-white',\n        (disabled || loading) && 'opacity-50 cursor-not-allowed',\n      )}\n    >\n      {loading && (\n        <span className=\"absolute inset-0 flex items-center justify-center\">\n          <Spinner size=\"sm\" />\n        </span>\n      )}\n      <span className={cn(loading && 'invisible')}>{children}</span>\n    </button>\n  );\n}\n```\n\n### Toast Notifications\n\n```typescript\n// components/Toast.tsx\nimport { createContext, useContext, useState, useCallback } from 'react';\n\ninterface Toast {\n  id: string;\n  type: 'success' | 'error' | 'info';\n  message: string;\n}\n\ninterface ToastContextValue {\n  toasts: Toast[];\n  addToast: (type: Toast['type'], message: string) => void;\n  removeToast: (id: string) => void;\n}\n\nconst ToastContext = createContext<ToastContextValue | null>(null);\n\nexport function ToastProvider({ children }: { children: React.ReactNode }) {\n  const [toasts, setToasts] = useState<Toast[]>([]);\n\n  const addToast = useCallback((type: Toast['type'], message: string) => {\n    const id = Math.random().toString(36).slice(2);\n    setToasts(prev => [...prev, { id, type, message }]);\n    \n    // Auto-remove after 5 seconds\n    setTimeout(() => {\n      setToasts(prev => prev.filter(t => t.id !== id));\n    }, 5000);\n  }, []);\n\n  const removeToast = useCallback((id: string) => {\n    setToasts(prev => prev.filter(t => t.id !== id));\n  }, []);\n\n  return (\n    <ToastContext.Provider value={{ toasts, addToast, removeToast }}>\n      {children}\n      <ToastContainer toasts={toasts} onRemove={removeToast} />\n    </ToastContext.Provider>\n  );\n}\n\nexport function useToast() {\n  const context = useContext(ToastContext);\n  if (!context) {\n    throw new Error('useToast must be used within ToastProvider');\n  }\n  return context;\n}\n\n// Usage\nconst { addToast } = useToast();\n\nconst handleSave = async () => {\n  try {\n    await saveProduct(data);\n    addToast('success', 'Product saved successfully');\n  } catch (error) {\n    addToast('error', 'Failed to save product');\n  }\n};\n```\n\n## State Management\n\n### Local Component State\n\n```typescript\n// components/Counter.tsx\nexport function Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => setCount(c => c + 1);\n  const decrement = () => setCount(c => c - 1);\n\n  return (\n    <div>\n      <button onClick={decrement}>-</button>\n      <span>{count}</span>\n      <button onClick={increment}>+</button>\n    </div>\n  );\n}\n```\n\n### Reducer for Complex State\n\n```typescript\n// components/CheckoutWizard.tsx\ntype CheckoutState = {\n  step: 'cart' | 'shipping' | 'payment' | 'confirmation';\n  shippingAddress: Address | null;\n  paymentMethod: PaymentMethod | null;\n  error: string | null;\n};\n\ntype CheckoutAction =\n  | { type: 'NEXT_STEP' }\n  | { type: 'PREV_STEP' }\n  | { type: 'SET_SHIPPING'; payload: Address }\n  | { type: 'SET_PAYMENT'; payload: PaymentMethod }\n  | { type: 'SET_ERROR'; payload: string }\n  | { type: 'RESET' };\n\nfunction checkoutReducer(state: CheckoutState, action: CheckoutAction): CheckoutState {\n  switch (action.type) {\n    case 'NEXT_STEP':\n      const steps: CheckoutState['step'][] = ['cart', 'shipping', 'payment', 'confirmation'];\n      const currentIndex = steps.indexOf(state.step);\n      return {\n        ...state,\n        step: steps[currentIndex + 1] ?? state.step,\n        error: null,\n      };\n    case 'PREV_STEP':\n      const stepsBack: CheckoutState['step'][] = ['cart', 'shipping', 'payment', 'confirmation'];\n      const idx = stepsBack.indexOf(state.step);\n      return {\n        ...state,\n        step: stepsBack[idx - 1] ?? state.step,\n        error: null,\n      };\n    case 'SET_SHIPPING':\n      return { ...state, shippingAddress: action.payload };\n    case 'SET_PAYMENT':\n      return { ...state, paymentMethod: action.payload };\n    case 'SET_ERROR':\n      return { ...state, error: action.payload };\n    case 'RESET':\n      return initialState;\n    default:\n      return state;\n  }\n}\n\nexport function CheckoutWizard() {\n  const [state, dispatch] = useReducer(checkoutReducer, initialState);\n\n  // Component implementation\n}\n```\n\n### Context for Shared State\n\n```typescript\n// context/CartContext.tsx\ninterface CartContextValue {\n  items: CartItem[];\n  addItem: (productId: string, quantity: number) => void;\n  removeItem: (itemId: string) => void;\n  updateQuantity: (itemId: string, quantity: number) => void;\n  total: number;\n}\n\nconst CartContext = createContext<CartContextValue | null>(null);\n\nexport function CartProvider({ children }: { children: React.ReactNode }) {\n  const { data: cart, refetch } = useCart();\n  const addItemMutation = useAddCartItem();\n  const removeItemMutation = useRemoveCartItem();\n  const updateQuantityMutation = useUpdateCartItem();\n\n  const value: CartContextValue = {\n    items: cart?.items ?? [],\n    addItem: (productId, quantity) => {\n      addItemMutation.mutate({ productId, quantity });\n    },\n    removeItem: (itemId) => {\n      removeItemMutation.mutate(itemId);\n    },\n    updateQuantity: (itemId, quantity) => {\n      updateQuantityMutation.mutate({ itemId, quantity });\n    },\n    total: cart?.totalCents ?? 0,\n  };\n\n  return (\n    <CartContext.Provider value={value}>\n      {children}\n    </CartContext.Provider>\n  );\n}\n\nexport function useCartContext() {\n  const context = useContext(CartContext);\n  if (!context) {\n    throw new Error('useCartContext must be used within CartProvider');\n  }\n  return context;\n}\n```\n\n## Performance Patterns\n\n### Memoization\n\n```typescript\n// Memo component\nconst ProductCard = memo(function ProductCard({ product }: { product: Product }) {\n  return <div>{/* ... */}</div>;\n});\n\n// Memoized callback\nfunction ProductList({ onSelect }: { onSelect: (id: string) => void }) {\n  const handleSelect = useCallback((id: string) => {\n    onSelect(id);\n  }, [onSelect]);\n\n  return products.map(p => (\n    <ProductCard key={p.id} product={p} onSelect={handleSelect} />\n  ));\n}\n\n// Memoized value\nfunction ExpensiveCalculation({ items }: { items: Item[] }) {\n  const total = useMemo(() => {\n    return items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n  }, [items]);\n\n  return <div>Total: {total}</div>;\n}\n```\n\n### Code Splitting\n\n```typescript\n// Lazy load pages\nconst ProductPage = lazy(() => import('./pages/ProductPage'));\nconst CheckoutPage = lazy(() => import('./pages/CheckoutPage'));\nconst AdminDashboard = lazy(() => import('./pages/AdminDashboard'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<PageSkeleton />}>\n      <Routes>\n        <Route path=\"/products/:id\" element={<ProductPage />} />\n        <Route path=\"/checkout\" element={<CheckoutPage />} />\n        <Route path=\"/admin\" element={<AdminDashboard />} />\n      </Routes>\n    </Suspense>\n  );\n}\n```\n\n### Virtualized Lists\n\n```typescript\n// components/VirtualizedProductList.tsx\nimport { useVirtualizer } from '@tanstack/react-virtual';\n\nexport function VirtualizedProductList({ products }: { products: Product[] }) {\n  const parentRef = useRef<HTMLDivElement>(null);\n\n  const virtualizer = useVirtualizer({\n    count: products.length,\n    getScrollElement: () => parentRef.current,\n    estimateSize: () => 100, // Estimated row height\n  });\n\n  return (\n    <div ref={parentRef} className=\"h-[600px] overflow-auto\">\n      <div\n        style={{\n          height: `${virtualizer.getTotalSize()}px`,\n          position: 'relative',\n        }}\n      >\n        {virtualizer.getVirtualItems().map((virtualRow) => (\n          <div\n            key={virtualRow.key}\n            style={{\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: '100%',\n              height: `${virtualRow.size}px`,\n              transform: `translateY(${virtualRow.start}px)`,\n            }}\n          >\n            <ProductCard product={products[virtualRow.index]} />\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n```\n"
    }
  ],
  "tags": [
    "coding",
    "core-workflow",
    "implementation"
  ],
  "dependsOn": [
    "spec",
    "scaffold"
  ]
}