{
  "id": "architect",
  "name": "architect",
  "version": "1.0.0",
  "description": "Design system and feature architecture from requirements. Produces high-level technical designs with component decomposition, data flow, integration patterns, and technology choices. Documents decisions via ADRs. Creates the architectural foundation that feeds into spec compilation.",
  "phase": "INIT",
  "category": "core",
  "content": "# Architect\n\nDesign system and feature architecture from requirements.\n\n## When to Use\n\n- **New feature with architectural decisions** — Multiple valid approaches, need to choose\n- **System-level design** — New service, major refactor, platform decision\n- **Integration design** — Connecting systems, API design, data flow\n- **Technical evaluation** — Build vs buy, technology selection\n- When you say: \"design this system\", \"how should we architect this?\", \"what's the best approach?\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `architecture-patterns.md` | Catalog of patterns to select from |\n| `adr-template.md` | Format for documenting decisions |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `architectural-drivers.md` | When identifying what to optimize for |\n| `architecture-diagrams.md` | When creating system diagrams |\n| `option-exploration.md` | When comparing multiple approaches |\n\n**Verification:** Ensure at least one ADR is created for the key architectural decision.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `ARCHITECTURE.md` | Project root | Always |\n| `adr/ADR-NNN-*.md` | `docs/adr/` | One per major decision |\n\n## Core Concept\n\nArchitect answers: **\"How should we structure this at a high level?\"**\n\nArchitecture decisions are:\n- **Strategic** — Affect multiple components, hard to change later\n- **Reasoned** — Trade-offs are documented, alternatives considered\n- **Enabling** — Create a foundation for implementation\n- **Communicable** — Teams can understand and follow\n\nArchitecture is NOT:\n- Detailed implementation (that's `spec` and `implement`)\n- Requirements gathering (that's `requirements`)\n- Code review (that's `code-review`)\n\n## The Architecture Process\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                 ARCHITECTURE PROCESS                    │\n│                                                         │\n│  1. UNDERSTAND REQUIREMENTS                             │\n│     └─→ What are we building? What are the constraints? │\n│                                                         │\n│  2. IDENTIFY ARCHITECTURAL DRIVERS                      │\n│     └─→ What forces shape the architecture?             │\n│                                                         │\n│  3. EXPLORE OPTIONS                                     │\n│     └─→ What approaches could work?                     │\n│                                                         │\n│  4. EVALUATE TRADE-OFFS                                 │\n│     └─→ What are the pros/cons of each?                 │\n│                                                         │\n│  5. MAKE DECISIONS                                      │\n│     └─→ Which approach and why?                         │\n│                                                         │\n│  6. DOCUMENT ARCHITECTURE                               │\n│     └─→ Diagrams, ADRs, component specs                 │\n│                                                         │\n│  7. VALIDATE                                            │\n│     └─→ Does this meet the requirements?                │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Step 1: Understand Requirements\n\nBefore architecting, ensure you understand:\n\n| Aspect | Questions |\n|--------|-----------|\n| **Functionality** | What does it need to do? |\n| **Users** | Who uses it? How many? How often? |\n| **Data** | What data? How much? How fast does it change? |\n| **Integration** | What does it connect to? |\n| **Constraints** | Budget? Timeline? Team skills? Existing systems? |\n\n### Requirements Checklist\n\n```markdown\n- [ ] Functional requirements clear\n- [ ] Non-functional requirements quantified\n- [ ] User personas and volumes understood\n- [ ] Data volumes and patterns understood\n- [ ] Integration points identified\n- [ ] Constraints documented\n```\n\n## Step 2: Identify Architectural Drivers\n\nArchitectural drivers are the forces that shape decisions:\n\n### Quality Attributes\n\n| Attribute | Questions | Affects |\n|-----------|-----------|---------|\n| **Performance** | Response time? Throughput? | Caching, async, data structures |\n| **Scalability** | Users? Data? Requests? | Statelessness, sharding, queuing |\n| **Availability** | Uptime requirements? | Redundancy, failover, monitoring |\n| **Security** | Threats? Compliance? | Auth, encryption, isolation |\n| **Maintainability** | Team size? Churn? | Modularity, documentation, testing |\n| **Extensibility** | Future features? | Plugin architecture, abstractions |\n\n### Constraints\n\n| Type | Examples |\n|------|----------|\n| **Technical** | Must use existing database, must integrate with legacy API |\n| **Organizational** | Team knows Python, budget is $X/month |\n| **Regulatory** | GDPR, HIPAA, SOC2 |\n| **Timeline** | Must ship by Q2, MVP in 4 weeks |\n\n### Prioritize Drivers\n\nNot all drivers are equal. Rank them:\n\n```markdown\n### Architecture Drivers (Prioritized)\n\n1. **Security** (P0) — Handles sensitive customer data\n2. **Availability** (P0) — 99.9% uptime SLA\n3. **Scalability** (P1) — Must handle 10x growth\n4. **Performance** (P1) — <200ms response time\n5. **Maintainability** (P2) — Small team, need simplicity\n```\n\n→ See `references/architectural-drivers.md`\n\n## Step 3: Explore Options\n\nGenerate multiple approaches. Don't commit to the first idea.\n\n### Option Generation Techniques\n\n| Technique | Description |\n|-----------|-------------|\n| **Pattern matching** | What patterns fit this problem? |\n| **Analogy** | How have similar systems been built? |\n| **Decomposition** | Can we break this into smaller decisions? |\n| **Extremes** | What's the simplest? Most scalable? Most flexible? |\n| **Constraints** | What if we had no [X]? What would we do? |\n\n### Document Options\n\nFor each option:\n\n```markdown\n### Option A: [Name]\n\n**Description:** [How it works]\n\n**Diagram:**\n[ASCII or reference to diagram]\n\n**Pros:**\n- [Advantage 1]\n- [Advantage 2]\n\n**Cons:**\n- [Disadvantage 1]\n- [Disadvantage 2]\n\n**Fits Drivers:**\n- ✅ Security — [Why]\n- ⚠️ Scalability — [Partial fit]\n- ❌ Simplicity — [Why not]\n\n**Effort:** [T-shirt size]\n\n**Risk:** [High/Medium/Low] — [Why]\n```\n\n→ See `references/option-exploration.md`\n\n## Step 4: Evaluate Trade-offs\n\n### Trade-off Matrix\n\n| Criterion | Weight | Option A | Option B | Option C |\n|-----------|--------|----------|----------|----------|\n| Security | 5 | 4 (20) | 5 (25) | 3 (15) |\n| Scalability | 4 | 5 (20) | 3 (12) | 4 (16) |\n| Simplicity | 3 | 2 (6) | 4 (12) | 5 (15) |\n| Time to build | 3 | 2 (6) | 4 (12) | 5 (15) |\n| **Total** | | **52** | **61** | **61** |\n\n### Common Trade-offs\n\n| Trade-off | Tension |\n|-----------|---------|\n| **Consistency vs Availability** | Strong consistency requires coordination |\n| **Performance vs Simplicity** | Optimization adds complexity |\n| **Flexibility vs Focus** | Generic solutions are harder to optimize |\n| **Build vs Buy** | Control vs time-to-market |\n| **Monolith vs Microservices** | Simplicity vs scalability |\n| **SQL vs NoSQL** | ACID vs scale/flexibility |\n\n→ See `references/trade-off-analysis.md`\n\n## Step 5: Make Decisions\n\n### Decision Criteria\n\n| Factor | Consider |\n|--------|----------|\n| **Driver fit** | Does it address the top priorities? |\n| **Risk** | What could go wrong? Can we mitigate? |\n| **Reversibility** | How hard to change later? |\n| **Team fit** | Does the team have the skills? |\n| **Cost** | Build cost? Run cost? Opportunity cost? |\n\n### Decision Record (ADR)\n\nDocument every significant decision:\n\n```markdown\n# ADR-001: [Decision Title]\n\n## Status\nAccepted | Proposed | Deprecated | Superseded\n\n## Context\n[What is the issue? What forces are at play?]\n\n## Decision\n[What is the decision? Be specific.]\n\n## Consequences\n### Positive\n- [Good outcome]\n\n### Negative\n- [Trade-off accepted]\n\n### Neutral\n- [Side effect]\n\n## Alternatives Considered\n- [Option B]: Rejected because [reason]\n- [Option C]: Rejected because [reason]\n```\n\n→ See `references/adr-template.md`\n\n## Step 6: Document Architecture\n\n### Architecture Document Structure\n\n```markdown\n# [System/Feature] Architecture\n\n## Overview\n[One paragraph summary]\n\n## Context\n[Business context, problem being solved]\n\n## Architectural Drivers\n[Prioritized list from Step 2]\n\n## Architecture\n\n### System Diagram\n[High-level view]\n\n### Component Diagram\n[Detailed component breakdown]\n\n### Data Flow\n[How data moves through the system]\n\n### Data Model\n[Key entities and relationships]\n\n## Key Decisions\n[Summary of ADRs or link to them]\n\n## Technology Choices\n| Component | Technology | Rationale |\n|-----------|------------|-----------|\n| [Component] | [Tech] | [Why] |\n\n## Integration Points\n| System | Protocol | Purpose |\n|--------|----------|---------|\n| [System] | [Protocol] | [Purpose] |\n\n## Security Architecture\n[Authentication, authorization, data protection]\n\n## Deployment Architecture\n[Infrastructure, scaling, monitoring]\n\n## Open Questions\n[Unresolved decisions]\n```\n\n### Diagram Types\n\n| Diagram | Purpose | When to Use |\n|---------|---------|-------------|\n| **Context** | System and its environment | Always |\n| **Container** | High-level components | Multi-component systems |\n| **Component** | Internal structure | Complex components |\n| **Sequence** | Interaction flow | Complex workflows |\n| **Data Flow** | Data movement | Data-intensive systems |\n| **Deployment** | Infrastructure | Production systems |\n\n→ See `references/architecture-diagrams.md`\n\n## Step 7: Validate\n\n### Validation Questions\n\n```markdown\n- [ ] Does this address all architectural drivers?\n- [ ] Are the top priorities (P0) fully addressed?\n- [ ] Can this scale to expected load?\n- [ ] Is security adequate for the threat model?\n- [ ] Can the team build and maintain this?\n- [ ] Does it fit the budget and timeline?\n- [ ] Are there any single points of failure?\n- [ ] Is the failure mode acceptable?\n- [ ] Can this evolve with future requirements?\n```\n\n### Architecture Review\n\nBefore finalizing, review with:\n- **Stakeholders** — Does it meet their needs?\n- **Implementers** — Can they build it?\n- **Operators** — Can they run it?\n- **Security** — Is it secure?\n\n## Output Formats\n\n### Quick Architecture (Small Features)\n\n```markdown\n## Architecture: [Feature Name]\n\n### Approach\n[One paragraph description]\n\n### Diagram\n```\n[ASCII diagram]\n```\n\n### Key Decisions\n1. [Decision 1]: [Rationale]\n2. [Decision 2]: [Rationale]\n\n### Components\n| Component | Responsibility |\n|-----------|---------------|\n| [Component] | [What it does] |\n\n### Data Flow\n[Step-by-step flow]\n```\n\n### Full Architecture (Major Systems)\n\nUse the full document structure from Step 6, with:\n- All diagram types relevant to the system\n- Complete ADRs for all significant decisions\n- Technology rationale for all choices\n- Security and deployment architecture\n\n## Common Patterns\n\n### Layered Architecture\n\n```\n┌─────────────────────────────────────┐\n│         Presentation Layer          │\n├─────────────────────────────────────┤\n│         Application Layer           │\n├─────────────────────────────────────┤\n│          Domain Layer               │\n├─────────────────────────────────────┤\n│        Infrastructure Layer         │\n└─────────────────────────────────────┘\n```\n\n**Use when:** Clear separation of concerns, traditional applications.\n\n### Event-Driven Architecture\n\n```\n┌──────────┐     ┌─────────┐     ┌──────────┐\n│ Producer │────▶│  Queue  │────▶│ Consumer │\n└──────────┘     └─────────┘     └──────────┘\n```\n\n**Use when:** Async processing, decoupled systems, high scalability.\n\n### Microservices\n\n```\n┌─────────┐  ┌─────────┐  ┌─────────┐\n│Service A│  │Service B│  │Service C│\n└────┬────┘  └────┬────┘  └────┬────┘\n     │            │            │\n     └────────────┼────────────┘\n                  │\n           ┌──────┴──────┐\n           │   Gateway   │\n           └─────────────┘\n```\n\n**Use when:** Independent scaling, team autonomy, complex domains.\n\n### CQRS\n\n```\n┌─────────────┐         ┌─────────────┐\n│   Command   │         │    Query    │\n│   Service   │         │   Service   │\n└──────┬──────┘         └──────┬──────┘\n       │                       │\n       ▼                       ▼\n┌─────────────┐         ┌─────────────┐\n│Write Database│───────▶│Read Database│\n└─────────────┘  sync   └─────────────┘\n```\n\n**Use when:** Read/write patterns differ significantly.\n\n→ See `references/architecture-patterns.md`\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `requirements` | Requirements drive architecture decisions |\n| `spec` | Architecture feeds into spec's Architecture Overview section |\n| `architecture-review` | Reviews validate architectural decisions |\n| `frontend-design` | (Frontend systems) ARCHITECTURE.md informs UI component hierarchy |\n| `implement` | Implementation follows architectural decisions |\n| `code-validation` | Validates implementation matches architecture |\n\n## Key Principles\n\n**Decisions, not diagrams.** Architecture is about making and documenting decisions, not drawing boxes.\n\n**Trade-offs, not best practices.** Every decision has trade-offs. Document why you chose this trade-off.\n\n**Drivers, not preferences.** Decisions should trace to architectural drivers, not personal preferences.\n\n**Reversibility matters.** Prefer decisions that are easy to change. Be extra careful with irreversible ones.\n\n**Simple until proven otherwise.** Start simple. Add complexity only when drivers demand it.\n\n**Document for the future.** Future you (or someone else) needs to understand why.\n\n## References\n\n- `references/architectural-drivers.md`: Identifying and prioritizing drivers\n- `references/option-exploration.md`: Generating and documenting options\n- `references/trade-off-analysis.md`: Evaluating trade-offs systematically\n- `references/adr-template.md`: Architecture Decision Record template\n- `references/architecture-diagrams.md`: Diagram types and when to use them\n- `references/architecture-patterns.md`: Common patterns and when to apply them",
  "references": [
    {
      "name": "adr-template.md",
      "path": "references/adr-template.md",
      "content": "# Architecture Decision Records (ADRs)\n\nTemplates and guidance for documenting architectural decisions.\n\n## What Is an ADR?\n\nAn Architecture Decision Record (ADR) is a document that captures an important architectural decision along with its context and consequences.\n\n**Why ADRs?**\n- Future developers understand *why*, not just *what*\n- Decisions are explicit, not tribal knowledge\n- Trade-offs are documented\n- Changes can reference original reasoning\n\n## When to Write an ADR\n\nWrite an ADR when the decision:\n- Is hard to reverse\n- Affects multiple components\n- Has significant trade-offs\n- Might be questioned later\n- Deviates from conventions\n\n**Examples requiring ADRs:**\n- Choice of database technology\n- Service boundary decisions\n- Authentication approach\n- API design patterns\n- Deployment architecture\n- Major library selections\n\n**Examples NOT requiring ADRs:**\n- Variable naming conventions\n- Which linter to use\n- Minor dependency updates\n- Bug fixes\n\n## ADR Template\n\n```markdown\n# ADR-[NUMBER]: [TITLE]\n\n## Status\n\n[Proposed | Accepted | Deprecated | Superseded by ADR-XXX]\n\n## Date\n\n[YYYY-MM-DD]\n\n## Context\n\n[What is the issue that we're seeing that is motivating this decision or change?\nWhat forces are at play? What is the background?]\n\n## Decision\n\n[What is the change that we're proposing and/or doing?\nState the decision clearly and specifically.]\n\n## Consequences\n\n### Positive\n\n- [Good outcome 1]\n- [Good outcome 2]\n\n### Negative\n\n- [Trade-off or downside 1]\n- [Trade-off or downside 2]\n\n### Neutral\n\n- [Side effect that is neither clearly positive nor negative]\n\n## Alternatives Considered\n\n### [Alternative 1 Name]\n\n[Brief description]\n\n**Rejected because:** [Reason]\n\n### [Alternative 2 Name]\n\n[Brief description]\n\n**Rejected because:** [Reason]\n\n## Related Decisions\n\n- [ADR-XXX: Related decision]\n- [ADR-YYY: Decision this supersedes]\n\n## References\n\n- [Link to relevant documentation]\n- [Link to discussion or RFC]\n```\n\n## Example ADRs\n\n### ADR-001: Use PostgreSQL as Primary Database\n\n**Status:** Accepted\n\n**Date:** 2024-01-15\n\n**Context:**\n\nWe need to select a primary database for the Order Management System. Key requirements:\n- ACID transactions for financial data\n- Support for complex queries (reporting)\n- JSON support for flexible schemas\n- Team familiarity\n- Hosting flexibility (cloud-agnostic)\n\n**Decision:**\n\nWe will use PostgreSQL as our primary database.\n\n**Consequences:**\n\n*Positive:*\n- Strong ACID guarantees for order and payment data\n- Excellent JSON/JSONB support for flexible fields\n- Team has 5+ years PostgreSQL experience\n- Can run anywhere (AWS RDS, GCP Cloud SQL, self-hosted)\n- Mature ecosystem, excellent tooling\n\n*Negative:*\n- Horizontal scaling requires more effort than NoSQL alternatives\n- Need to manage schema migrations carefully\n- Connection pooling needed at scale\n\n*Neutral:*\n- Will need to add read replicas as load increases\n- May add Redis for caching hot data\n\n**Alternatives Considered:**\n\n*DynamoDB:*\nBetter horizontal scaling, lower operational overhead.\n**Rejected because:** Team lacks DynamoDB experience, and complex queries would require workarounds or separate analytics database.\n\n*MongoDB:*\nFlexible schema, good scaling story.\n**Rejected because:** Weaker transaction guarantees not acceptable for financial data, and PostgreSQL's JSONB provides sufficient schema flexibility.\n\n---\n\n### ADR-002: Adopt Event-Driven Architecture for Order Processing\n\n**Status:** Accepted\n\n**Date:** 2024-01-20\n\n**Context:**\n\nOrder processing involves multiple steps: inventory reservation, payment processing, fulfillment initiation, and notifications. Currently considering:\n- Synchronous API calls between services\n- Event-driven with message queue\n- Hybrid approach\n\nReliability and auditability are critical (P0 drivers). Current volume is low (100 orders/day) but expected to grow 10x in 12 months.\n\n**Decision:**\n\nWe will adopt an event-driven architecture using Amazon SQS for order processing. Each processing step will:\n1. Consume events from its input queue\n2. Process the work\n3. Publish events to downstream queues\n4. Use dead-letter queues for failed messages\n\n**Consequences:**\n\n*Positive:*\n- Failure in one step doesn't fail entire order\n- Natural audit trail via events\n- Steps can scale independently\n- Easy to add new consumers (analytics, notifications)\n- Retries handled automatically\n\n*Negative:*\n- More complex than direct API calls\n- Eventual consistency (order status not immediately final)\n- Need to handle out-of-order messages\n- Debugging requires tracing across services\n\n*Neutral:*\n- Will need to build order state machine to track status\n- Idempotency required in all consumers\n\n**Alternatives Considered:**\n\n*Synchronous orchestration:*\nSimpler implementation, immediate consistency.\n**Rejected because:** Single failure fails entire order, harder to retry individual steps, doesn't scale as well.\n\n*Saga pattern with orchestrator:*\nCentralized control, easier to understand flow.\n**Rejected because:** Adds single point of failure, and choreography is sufficient for our use case.\n\n**Related Decisions:**\n- ADR-001: PostgreSQL selection (events stored in PostgreSQL)\n- ADR-003: Idempotency patterns (required by this decision)\n\n---\n\n### ADR-003: Use Idempotency Keys for All Mutations\n\n**Status:** Accepted\n\n**Date:** 2024-01-22\n\n**Context:**\n\nWith event-driven architecture (ADR-002), messages may be delivered more than once. We need to ensure operations are idempotent to prevent:\n- Duplicate orders\n- Double charges\n- Duplicate notifications\n\n**Decision:**\n\nAll mutation operations will use idempotency keys:\n\n1. **Client-generated keys:** Clients must include `Idempotency-Key` header\n2. **Server-side storage:** Store key + response for 24 hours\n3. **Duplicate detection:** Return cached response for duplicate keys\n4. **Key format:** UUID v4, client-generated\n\nImplementation:\n```sql\nCREATE TABLE idempotency_keys (\n  key UUID PRIMARY KEY,\n  endpoint VARCHAR(255) NOT NULL,\n  response_code INT NOT NULL,\n  response_body JSONB NOT NULL,\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '24 hours'\n);\n\nCREATE INDEX idx_idempotency_expires ON idempotency_keys(expires_at);\n```\n\n**Consequences:**\n\n*Positive:*\n- Safe retries from clients\n- Safe message redelivery from queues\n- No duplicate side effects\n\n*Negative:*\n- Additional storage for idempotency records\n- Slight latency for key lookup\n- Clients must generate and track keys\n\n*Neutral:*\n- Need background job to clean expired keys\n- 24-hour window is a policy decision (can adjust)\n\n**Alternatives Considered:**\n\n*Database constraints only:*\nUse unique constraints to prevent duplicates.\n**Rejected because:** Doesn't work for all operations, can't return original response.\n\n*Server-generated keys:*\nServer generates idempotency key from request hash.\n**Rejected because:** Subtle bugs with timing (same request moments apart might be intentional).\n\n## ADR Lifecycle\n\n### Statuses\n\n| Status | Meaning |\n|--------|---------|\n| **Proposed** | Under discussion, not yet decided |\n| **Accepted** | Decision made, in effect |\n| **Deprecated** | No longer applies, but not replaced |\n| **Superseded** | Replaced by a newer decision |\n\n### Superseding an ADR\n\nWhen a decision changes:\n\n```markdown\n# ADR-007: Migrate from SQS to Kafka\n\n## Status\n\nAccepted (supersedes ADR-002)\n\n## Context\n\nADR-002 chose SQS for event-driven architecture. After 18 months:\n- Volume grew to 50,000 events/day\n- Need for event replay and reprocessing\n- Multiple consumers need same events\n- SQS costs becoming significant\n\n## Decision\n\nMigrate from SQS to Apache Kafka...\n```\n\nUpdate the original ADR:\n\n```markdown\n# ADR-002: Adopt Event-Driven Architecture for Order Processing\n\n## Status\n\nSuperseded by ADR-007\n\n[Rest of original content preserved for history]\n```\n\n## ADR Organization\n\n### File Structure\n\n```\ndocs/\n└── architecture/\n    └── decisions/\n        ├── README.md          # Index of all ADRs\n        ├── 0001-postgresql.md\n        ├── 0002-event-driven.md\n        ├── 0003-idempotency.md\n        └── ...\n```\n\n### README Index\n\n```markdown\n# Architecture Decision Records\n\n| ADR | Title | Status | Date |\n|-----|-------|--------|------|\n| [001](0001-postgresql.md) | Use PostgreSQL | Accepted | 2024-01-15 |\n| [002](0002-event-driven.md) | Event-driven architecture | Superseded | 2024-01-20 |\n| [003](0003-idempotency.md) | Idempotency keys | Accepted | 2024-01-22 |\n| [007](0007-kafka-migration.md) | Migrate to Kafka | Accepted | 2025-07-01 |\n```\n\n## ADR Writing Tips\n\n### Do\n\n- Be specific about the decision\n- Quantify where possible (\"100 orders/day\", \"5ms latency\")\n- Document alternatives seriously considered\n- Explain *why* alternatives were rejected\n- Link to related ADRs\n- Keep context concise but complete\n\n### Don't\n\n- Write a novel (ADRs should be scannable)\n- Skip the alternatives (even if obvious choice)\n- Forget negative consequences\n- Leave status as \"Proposed\" indefinitely\n- Delete or overwrite old ADRs (supersede instead)\n\n## ADR Checklist\n\n```markdown\n- [ ] Title is clear and specific\n- [ ] Status is set correctly\n- [ ] Context explains the problem and forces\n- [ ] Decision is specific and actionable\n- [ ] Positive consequences listed\n- [ ] Negative consequences (trade-offs) listed\n- [ ] At least 2 alternatives considered\n- [ ] Rejection reasons are clear\n- [ ] Related ADRs linked\n- [ ] Added to index/README\n```\n"
    },
    {
      "name": "architectural-drivers.md",
      "path": "references/architectural-drivers.md",
      "content": "# Architectural Drivers\n\nIdentifying and prioritizing the forces that shape architecture.\n\n## What Are Architectural Drivers?\n\nArchitectural drivers are the key requirements and constraints that significantly influence architectural decisions. They're the \"why\" behind architectural choices.\n\n**Types of drivers:**\n- Quality attributes (performance, security, scalability, etc.)\n- Functional requirements (key features that drive structure)\n- Constraints (technical, organizational, regulatory)\n- Business goals (time-to-market, cost, growth)\n\n## Quality Attributes\n\n### Performance\n\n| Aspect | Questions | Architectural Impact |\n|--------|-----------|---------------------|\n| **Latency** | What response time is acceptable? p50? p99? | Caching, async, CDN, database optimization |\n| **Throughput** | How many requests per second? | Horizontal scaling, queuing, batching |\n| **Resource usage** | CPU/memory constraints? | Algorithm choice, data structures, lazy loading |\n\n**Quantify:**\n- \"API responses must complete in <200ms at p95\"\n- \"System must handle 10,000 concurrent users\"\n- \"Batch processing must complete in <1 hour for 1M records\"\n\n### Scalability\n\n| Aspect | Questions | Architectural Impact |\n|--------|-----------|---------------------|\n| **User scale** | 100? 10,000? 1M users? | Statelessness, session management |\n| **Data scale** | GB? TB? PB? | Sharding, partitioning, archival |\n| **Request scale** | RPS? Bursty or steady? | Auto-scaling, queuing, rate limiting |\n| **Team scale** | How many developers? | Service boundaries, API contracts |\n\n**Quantify:**\n- \"Must support 10x growth without re-architecture\"\n- \"Database will grow 100GB/month\"\n- \"Black Friday traffic is 50x normal\"\n\n### Availability\n\n| Aspect | Questions | Architectural Impact |\n|--------|-----------|---------------------|\n| **Uptime** | 99%? 99.9%? 99.99%? | Redundancy, failover, regions |\n| **Recovery time** | RTO? | Backup strategy, failover automation |\n| **Data durability** | RPO? | Replication, backup frequency |\n| **Degradation** | What can fail gracefully? | Circuit breakers, fallbacks |\n\n**Quantify:**\n- \"99.9% uptime = 8.7 hours downtime/year\"\n- \"RTO: 15 minutes, RPO: 1 hour\"\n- \"Core checkout must work even if recommendations fail\"\n\n### Security\n\n| Aspect | Questions | Architectural Impact |\n|--------|-----------|---------------------|\n| **Authentication** | Who can access? How verified? | Identity provider, session management |\n| **Authorization** | Who can do what? | RBAC, ABAC, policy enforcement |\n| **Data protection** | What's sensitive? | Encryption, tokenization, masking |\n| **Compliance** | GDPR? HIPAA? SOC2? | Audit logging, data residency, retention |\n| **Threat model** | What attacks? | Input validation, rate limiting, WAF |\n\n**Quantify:**\n- \"PII must be encrypted at rest and in transit\"\n- \"All access must be logged for 7 years\"\n- \"Must pass SOC2 Type 2 audit\"\n\n### Maintainability\n\n| Aspect | Questions | Architectural Impact |\n|--------|-----------|---------------------|\n| **Understandability** | How complex? | Modularity, documentation, naming |\n| **Changeability** | How often does it change? | Loose coupling, versioning |\n| **Testability** | How to verify? | Dependency injection, interfaces |\n| **Debuggability** | How to diagnose? | Observability, tracing, logging |\n\n**Quantify:**\n- \"New developers productive in <2 weeks\"\n- \"Feature changes should not require coordinated deploys\"\n- \"Any incident debuggable from logs within 15 minutes\"\n\n### Other Quality Attributes\n\n| Attribute | Description | Architectural Impact |\n|-----------|-------------|---------------------|\n| **Extensibility** | Adding new features | Plugin architecture, abstractions |\n| **Portability** | Running in different environments | Containerization, abstraction layers |\n| **Interoperability** | Working with other systems | Standard protocols, APIs |\n| **Usability** | User experience | Client architecture, responsiveness |\n| **Compliance** | Regulatory requirements | Audit trails, data handling |\n\n## Constraints\n\n### Technical Constraints\n\n| Constraint | Examples |\n|------------|----------|\n| **Existing systems** | Must integrate with legacy ERP |\n| **Technology mandates** | Must use company's standard database |\n| **Infrastructure** | Must run on existing Kubernetes cluster |\n| **Protocols** | Must expose REST API, not GraphQL |\n| **Languages** | Must use approved language set |\n\n### Organizational Constraints\n\n| Constraint | Examples |\n|------------|----------|\n| **Team skills** | Team knows Python, not Go |\n| **Team size** | Only 3 developers available |\n| **Budget** | $5,000/month infrastructure limit |\n| **Timeline** | Must ship MVP in 6 weeks |\n| **Process** | Must pass security review |\n\n### Regulatory Constraints\n\n| Constraint | Examples |\n|------------|----------|\n| **Data residency** | EU data must stay in EU |\n| **Retention** | Financial records kept 7 years |\n| **Privacy** | GDPR right to deletion |\n| **Industry** | HIPAA for healthcare data |\n| **Audit** | All changes must be traceable |\n\n## Prioritizing Drivers\n\nNot all drivers are equal. Use priority levels:\n\n| Priority | Meaning | Treatment |\n|----------|---------|-----------|\n| **P0** | Non-negotiable | Architecture MUST address |\n| **P1** | Important | Architecture SHOULD address |\n| **P2** | Nice to have | Address if possible |\n\n### Prioritization Questions\n\n1. **What happens if we don't meet this?**\n   - Business fails? → P0\n   - Users unhappy? → P1\n   - Inconvenient? → P2\n\n2. **How likely is the scenario?**\n   - Happens daily? → Increase priority\n   - Once a year? → Decrease priority\n\n3. **Can we address it later?**\n   - Requires re-architecture? → Address now\n   - Incremental improvement? → Can defer\n\n### Example Prioritization\n\n```markdown\n## Architectural Drivers: Order Management System\n\n### P0 (Non-negotiable)\n1. **Security** — Handles payment data, PCI compliance required\n2. **Availability** — 99.9% uptime, orders are revenue\n3. **Data integrity** — Cannot lose or corrupt orders\n\n### P1 (Important)\n4. **Performance** — Checkout <2s, affects conversion\n5. **Scalability** — 10x growth expected in 2 years\n6. **Auditability** — All changes must be traceable\n\n### P2 (Nice to have)\n7. **Extensibility** — May add new payment methods\n8. **Portability** — May move clouds eventually\n\n### Constraints\n- Must integrate with existing inventory system (REST API)\n- Team of 4 developers, Python/TypeScript skills\n- $3,000/month infrastructure budget\n- Ship MVP in 8 weeks\n```\n\n## Driver Documentation Template\n\n```markdown\n## Driver: [Name]\n\n**Category:** Quality Attribute | Constraint | Business Goal\n\n**Priority:** P0 | P1 | P2\n\n**Description:**\n[What is this driver? Why does it matter?]\n\n**Quantified Requirement:**\n[Specific, measurable target]\n\n**Scenarios:**\n1. [Scenario that exercises this driver]\n2. [Another scenario]\n\n**Architectural Impact:**\n[How does this driver influence architecture decisions?]\n\n**Trade-offs:**\n[What might we sacrifice to address this driver?]\n```\n\n## Driver Analysis Checklist\n\n```markdown\n### Quality Attributes\n- [ ] Performance requirements quantified\n- [ ] Scalability targets defined\n- [ ] Availability SLA specified\n- [ ] Security requirements clear\n- [ ] Maintainability needs understood\n\n### Constraints\n- [ ] Technical constraints documented\n- [ ] Organizational constraints documented\n- [ ] Regulatory constraints documented\n- [ ] Budget constraints clear\n- [ ] Timeline constraints clear\n\n### Prioritization\n- [ ] All drivers assigned priority\n- [ ] P0 drivers are truly non-negotiable\n- [ ] Trade-offs between drivers understood\n- [ ] Stakeholders agree on priorities\n```\n"
    },
    {
      "name": "architecture-diagrams.md",
      "path": "references/architecture-diagrams.md",
      "content": "# Architecture Diagrams\n\nTypes of diagrams and when to use them.\n\n## Diagram Principles\n\n**Good diagrams:**\n- Have a clear purpose (what question do they answer?)\n- Show the right level of detail (not too much, not too little)\n- Have a legend if symbols aren't obvious\n- Are kept up to date (or marked as \"point in time\")\n\n**Avoid:**\n- Diagrams that try to show everything\n- Mixing abstraction levels\n- Unlabeled boxes and arrows\n- Diagrams without context\n\n## The C4 Model\n\nC4 provides four levels of abstraction, each answering different questions:\n\n### Level 1: System Context\n\n**Question:** What is this system and who uses it?\n\n**Shows:**\n- The system as a single box\n- Users/actors who interact with it\n- External systems it connects to\n\n**Audience:** Non-technical stakeholders, new team members\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                         SYSTEM CONTEXT                                  │\n│                                                                         │\n│                         ┌─────────────┐                                 │\n│    ┌──────────┐         │             │         ┌──────────────┐        │\n│    │ Customer │────────▶│   Order     │────────▶│   Payment    │        │\n│    │          │         │  Management │         │   Gateway    │        │\n│    └──────────┘         │   System    │         │  [External]  │        │\n│                         │             │         └──────────────┘        │\n│    ┌──────────┐         │             │         ┌──────────────┐        │\n│    │  Admin   │────────▶│             │────────▶│  Inventory   │        │\n│    │          │         │             │         │   System     │        │\n│    └──────────┘         └─────────────┘         │  [External]  │        │\n│                                                 └──────────────┘        │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n### Level 2: Container Diagram\n\n**Question:** What are the high-level components and how do they communicate?\n\n**Shows:**\n- Applications, services, databases\n- Communication protocols\n- Technology choices\n\n**Audience:** Technical stakeholders, architects, developers\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                        CONTAINER DIAGRAM                                │\n│                                                                         │\n│    ┌─────────────────────────────────────────────────────────────┐     │\n│    │                    Order Management System                   │     │\n│    │                                                              │     │\n│    │   ┌──────────────┐        ┌──────────────┐                  │     │\n│    │   │   Web App    │        │  Mobile App  │                  │     │\n│    │   │   [React]    │        │   [React     │                  │     │\n│    │   │              │        │    Native]   │                  │     │\n│    │   └──────┬───────┘        └──────┬───────┘                  │     │\n│    │          │                       │                          │     │\n│    │          │       HTTPS/JSON      │                          │     │\n│    │          └───────────┬───────────┘                          │     │\n│    │                      ▼                                      │     │\n│    │              ┌──────────────┐                               │     │\n│    │              │   API        │                               │     │\n│    │              │   Gateway    │                               │     │\n│    │              │   [Kong]     │                               │     │\n│    │              └──────┬───────┘                               │     │\n│    │                     │                                       │     │\n│    │     ┌───────────────┼───────────────┐                       │     │\n│    │     ▼               ▼               ▼                       │     │\n│    │ ┌────────┐    ┌────────┐    ┌────────────┐                  │     │\n│    │ │ Order  │    │Payment │    │Notification│                  │     │\n│    │ │Service │    │Service │    │  Service   │                  │     │\n│    │ │[Python]│    │[Python]│    │  [Python]  │                  │     │\n│    │ └───┬────┘    └───┬────┘    └─────┬──────┘                  │     │\n│    │     │             │               │                         │     │\n│    │     └─────────────┼───────────────┘                         │     │\n│    │                   ▼                                         │     │\n│    │           ┌──────────────┐    ┌──────────────┐              │     │\n│    │           │  PostgreSQL  │    │    Redis     │              │     │\n│    │           │  [Database]  │    │   [Cache]    │              │     │\n│    │           └──────────────┘    └──────────────┘              │     │\n│    │                                                              │     │\n│    └─────────────────────────────────────────────────────────────┘     │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n### Level 3: Component Diagram\n\n**Question:** What are the components inside a container?\n\n**Shows:**\n- Major classes/modules\n- Their responsibilities\n- Internal dependencies\n\n**Audience:** Developers working on that container\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                   ORDER SERVICE - COMPONENT DIAGRAM                     │\n│                                                                         │\n│   ┌─────────────────────────────────────────────────────────────────┐   │\n│   │                        Order Service                             │   │\n│   │                                                                  │   │\n│   │   ┌────────────────┐     ┌────────────────┐                     │   │\n│   │   │ OrderController│────▶│  OrderService  │                     │   │\n│   │   │    (REST)      │     │   (Business    │                     │   │\n│   │   │                │     │    Logic)      │                     │   │\n│   │   └────────────────┘     └───────┬────────┘                     │   │\n│   │                                  │                               │   │\n│   │                    ┌─────────────┼─────────────┐                 │   │\n│   │                    ▼             ▼             ▼                 │   │\n│   │            ┌────────────┐ ┌────────────┐ ┌────────────┐         │   │\n│   │            │  Order     │ │ Inventory  │ │  Payment   │         │   │\n│   │            │ Repository │ │  Client    │ │  Client    │         │   │\n│   │            │            │ │  (HTTP)    │ │  (HTTP)    │         │   │\n│   │            └─────┬──────┘ └─────┬──────┘ └─────┬──────┘         │   │\n│   │                  │              │              │                 │   │\n│   └──────────────────│──────────────│──────────────│─────────────────┘   │\n│                      │              │              │                     │\n│                      ▼              ▼              ▼                     │\n│               ┌──────────┐  ┌────────────┐  ┌───────────┐               │\n│               │PostgreSQL│  │ Inventory  │  │  Payment  │               │\n│               │          │  │  Service   │  │  Gateway  │               │\n│               └──────────┘  └────────────┘  └───────────┘               │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n### Level 4: Code Diagram\n\n**Question:** How is a component implemented?\n\n**Shows:**\n- Classes, interfaces, modules\n- Relationships (inheritance, composition)\n- Method signatures\n\n**Audience:** Developers implementing/modifying the code\n\nUsually UML class diagrams. In practice, often unnecessary if code is well-organized.\n\n## Other Diagram Types\n\n### Sequence Diagram\n\n**Question:** How do components interact over time?\n\n**Use when:** Complex workflows, multi-step processes\n\n```\n┌────────┐     ┌────────┐     ┌────────┐     ┌────────┐\n│ Client │     │  API   │     │ Order  │     │Payment │\n│        │     │Gateway │     │Service │     │Service │\n└───┬────┘     └───┬────┘     └───┬────┘     └───┬────┘\n    │              │              │              │\n    │ POST /orders │              │              │\n    │─────────────▶│              │              │\n    │              │ createOrder  │              │\n    │              │─────────────▶│              │\n    │              │              │              │\n    │              │              │ processPayment\n    │              │              │─────────────▶│\n    │              │              │              │\n    │              │              │    result    │\n    │              │              │◀─────────────│\n    │              │              │              │\n    │              │    order     │              │\n    │              │◀─────────────│              │\n    │              │              │              │\n    │   201 Created│              │              │\n    │◀─────────────│              │              │\n    │              │              │              │\n```\n\n### Data Flow Diagram\n\n**Question:** How does data move through the system?\n\n**Use when:** Data-intensive systems, ETL pipelines\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                           DATA FLOW                                     │\n│                                                                         │\n│   ┌──────────┐    orders     ┌──────────┐    events    ┌──────────┐    │\n│   │  Web     │──────────────▶│  Order   │─────────────▶│  Event   │    │\n│   │  Client  │               │  API     │              │  Queue   │    │\n│   └──────────┘               └────┬─────┘              └────┬─────┘    │\n│                                   │                         │          │\n│                              order data                  events        │\n│                                   │                         │          │\n│                                   ▼                         ▼          │\n│                              ┌──────────┐              ┌──────────┐    │\n│                              │  Orders  │              │Analytics │    │\n│                              │   DB     │─────────────▶│ Warehouse│    │\n│                              └──────────┘   nightly    └──────────┘    │\n│                                             sync                       │\n│                                                                        │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n### Deployment Diagram\n\n**Question:** How is the system deployed to infrastructure?\n\n**Use when:** DevOps planning, infrastructure design\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                         DEPLOYMENT DIAGRAM                              │\n│                                                                         │\n│   ┌─────────────────────────────────────────────────────────────────┐   │\n│   │                        AWS us-east-1                             │   │\n│   │                                                                  │   │\n│   │   ┌─────────────┐                                                │   │\n│   │   │ CloudFront  │                                                │   │\n│   │   │    (CDN)    │                                                │   │\n│   │   └──────┬──────┘                                                │   │\n│   │          │                                                       │   │\n│   │          ▼                                                       │   │\n│   │   ┌─────────────┐         ┌─────────────────────────────────┐   │   │\n│   │   │     ALB     │         │          EKS Cluster            │   │   │\n│   │   │             │────────▶│                                 │   │   │\n│   │   └─────────────┘         │  ┌───────┐ ┌───────┐ ┌───────┐  │   │   │\n│   │                           │  │Order  │ │Payment│ │Notify │  │   │   │\n│   │                           │  │ x3    │ │  x2   │ │  x2   │  │   │   │\n│   │                           │  └───────┘ └───────┘ └───────┘  │   │   │\n│   │                           │                                 │   │   │\n│   │                           └─────────────────────────────────┘   │   │\n│   │                                          │                       │   │\n│   │                    ┌─────────────────────┼───────────────────┐   │   │\n│   │                    ▼                     ▼                   ▼   │   │\n│   │             ┌──────────┐          ┌──────────┐        ┌────────┐ │   │\n│   │             │   RDS    │          │  Elasti  │        │  SQS   │ │   │\n│   │             │ Postgres │          │  Cache   │        │        │ │   │\n│   │             │ (Multi-AZ)│         │ (Redis)  │        │        │ │   │\n│   │             └──────────┘          └──────────┘        └────────┘ │   │\n│   │                                                                  │   │\n│   └─────────────────────────────────────────────────────────────────┘   │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n### State Diagram\n\n**Question:** What states can an entity be in and how does it transition?\n\n**Use when:** Complex state machines, workflow systems\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                      ORDER STATE MACHINE                                │\n│                                                                         │\n│                          ┌──────────┐                                   │\n│                          │  DRAFT   │                                   │\n│                          └────┬─────┘                                   │\n│                               │ submit                                  │\n│                               ▼                                         │\n│                          ┌──────────┐                                   │\n│               ┌─────────▶│ PENDING  │◀─────────┐                        │\n│               │          │ PAYMENT  │          │                        │\n│               │          └────┬─────┘          │                        │\n│               │               │                │                        │\n│               │    payment    │    payment     │                        │\n│               │    failed     │    success     │ retry                  │\n│               │               │                │                        │\n│               │               ▼                │                        │\n│          ┌────┴─────┐   ┌──────────┐    ┌─────┴────┐                    │\n│          │ PAYMENT  │   │CONFIRMED │    │ PAYMENT  │                    │\n│          │ FAILED   │   │          │    │ RETRY    │                    │\n│          └──────────┘   └────┬─────┘    └──────────┘                    │\n│                              │ fulfill                                  │\n│                              ▼                                          │\n│                         ┌──────────┐                                    │\n│              ┌─────────▶│FULFILLED │                                    │\n│              │          └────┬─────┘                                    │\n│              │               │                                          │\n│          ship│               │ deliver                                  │\n│              │               ▼                                          │\n│         ┌────┴─────┐   ┌──────────┐                                     │\n│         │ SHIPPED  │───│DELIVERED │                                     │\n│         └──────────┘   └──────────┘                                     │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n## Diagram Selection Guide\n\n| Question | Diagram Type |\n|----------|--------------|\n| What is this system? | System Context |\n| What are the main components? | Container |\n| What's inside this component? | Component |\n| How do things interact over time? | Sequence |\n| How does data flow through? | Data Flow |\n| How is it deployed? | Deployment |\n| What states can this be in? | State |\n| How does the database look? | Entity Relationship |\n\n## ASCII Diagram Tips\n\n### Box Characters\n\n```\nSimple:     ┌───────┐\n            │       │\n            └───────┘\n\nRounded:    ╭───────╮\n            │       │\n            ╰───────╯\n\nDouble:     ╔═══════╗\n            ║       ║\n            ╚═══════╝\n```\n\n### Arrows\n\n```\nRight:      ────▶   ────→   --->\nLeft:       ◀────   ←────   <---\nBoth:       ◀───▶   ←───→   <-->\nDown:         │       │\n              ▼       ↓\nUp:           ▲       ↑\n              │       │\n```\n\n### Connectors\n\n```\nT-junction:  ───┬───    ───┴───    │        │\n                │          │       ├───  ───┤\n                                   │        │\n\nCorners:     ┌───    ───┐    └───    ───┘\n\nCross:       ───┼───\n                │\n```\n\n## Diagram Checklist\n\n```markdown\n- [ ] Clear title stating what diagram shows\n- [ ] Appropriate level of detail for audience\n- [ ] Legend if symbols aren't obvious\n- [ ] Labels on all boxes\n- [ ] Labels on arrows (what flows/happens)\n- [ ] Technology choices shown where relevant\n- [ ] External systems clearly marked\n- [ ] Boundaries/groupings shown\n- [ ] Date or version if diagram may change\n```\n"
    },
    {
      "name": "architecture-patterns.md",
      "path": "references/architecture-patterns.md",
      "content": "# Architecture Patterns\n\nCommon patterns and when to apply them.\n\n## Pattern Selection\n\nPatterns are not good or bad — they fit or don't fit your context. Before applying a pattern, ask:\n\n1. What problem does this pattern solve?\n2. Do I have that problem?\n3. What are the trade-offs?\n4. Is my team equipped to implement it?\n\n## Application Architecture Patterns\n\n### Layered Architecture\n\n```\n┌─────────────────────────────────────┐\n│         Presentation Layer          │  ← UI, controllers\n├─────────────────────────────────────┤\n│         Application Layer           │  ← Use cases, orchestration\n├─────────────────────────────────────┤\n│           Domain Layer              │  ← Business logic, entities\n├─────────────────────────────────────┤\n│        Infrastructure Layer         │  ← Database, external services\n└─────────────────────────────────────┘\n```\n\n**Solves:** Separation of concerns, testability\n\n**Use when:**\n- Traditional CRUD applications\n- Clear separation between UI and business logic needed\n- Team familiar with the pattern\n\n**Trade-offs:**\n- Can become \"lasagna\" with too many layers\n- Changes often ripple through layers\n- May be overkill for simple apps\n\n---\n\n### Hexagonal Architecture (Ports & Adapters)\n\n```\n                    ┌─────────────────┐\n                    │   HTTP API      │\n                    │   (Adapter)     │\n                    └────────┬────────┘\n                             │\n                    ┌────────▼────────┐\n                    │    Port         │\n┌───────────┐       │   (Interface)   │       ┌───────────┐\n│  CLI      │──────▶├─────────────────┤◀──────│ Database  │\n│ (Adapter) │       │                 │       │ (Adapter) │\n└───────────┘       │   DOMAIN        │       └───────────┘\n                    │   (Core Logic)  │\n┌───────────┐       │                 │       ┌───────────┐\n│  Queue    │──────▶├─────────────────┤◀──────│  Email    │\n│ (Adapter) │       │    Port         │       │ (Adapter) │\n└───────────┘       │   (Interface)   │       └───────────┘\n                    └─────────────────┘\n```\n\n**Solves:** Dependency inversion, infrastructure independence\n\n**Use when:**\n- Domain logic is complex and valuable\n- Need to swap infrastructure (database, APIs)\n- Testing domain logic in isolation is important\n\n**Trade-offs:**\n- More interfaces and indirection\n- Can be over-engineered for simple domains\n- Learning curve for teams\n\n---\n\n### Clean Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                     Frameworks & Drivers                        │\n│  ┌───────────────────────────────────────────────────────────┐  │\n│  │                    Interface Adapters                      │  │\n│  │  ┌─────────────────────────────────────────────────────┐  │  │\n│  │  │                   Application                        │  │  │\n│  │  │  ┌───────────────────────────────────────────────┐  │  │  │\n│  │  │  │                  Entities                      │  │  │  │\n│  │  │  │             (Enterprise Rules)                 │  │  │  │\n│  │  │  └───────────────────────────────────────────────┘  │  │  │\n│  │  └─────────────────────────────────────────────────────┘  │  │\n│  └───────────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────────┘\n\nDependencies point INWARD only\n```\n\n**Solves:** Framework independence, testability, clean domain\n\n**Use when:**\n- Long-lived systems that will outlive frameworks\n- Domain is the competitive advantage\n- High test coverage requirements\n\n**Trade-offs:**\n- Significant boilerplate\n- Can feel over-engineered\n- Team needs discipline to maintain boundaries\n\n## Service Architecture Patterns\n\n### Monolith\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                        MONOLITH                             │\n│                                                             │\n│   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │\n│   │  Orders  │  │ Payments │  │Inventory │  │  Users   │   │\n│   │  Module  │  │  Module  │  │  Module  │  │  Module  │   │\n│   └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │\n│        │             │             │             │          │\n│        └─────────────┴─────────────┴─────────────┘          │\n│                           │                                 │\n│                    ┌──────┴──────┐                          │\n│                    │   Database  │                          │\n│                    └─────────────┘                          │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n**Solves:** Simplicity, easy deployment, transactional consistency\n\n**Use when:**\n- Starting a new project (start here!)\n- Small team (< 10 developers)\n- Simple deployment requirements\n- Strong consistency requirements\n\n**Trade-offs:**\n- Scaling is all-or-nothing\n- Long build/deploy times at scale\n- Team coupling (everyone in same codebase)\n\n---\n\n### Microservices\n\n```\n┌─────────────┐  ┌─────────────┐  ┌─────────────┐\n│   Orders    │  │  Payments   │  │  Inventory  │\n│   Service   │  │   Service   │  │   Service   │\n└──────┬──────┘  └──────┬──────┘  └──────┬──────┘\n       │                │                │\n       ▼                ▼                ▼\n┌─────────────┐  ┌─────────────┐  ┌─────────────┐\n│  Orders DB  │  │ Payments DB │  │Inventory DB │\n└─────────────┘  └─────────────┘  └─────────────┘\n```\n\n**Solves:** Independent scaling, team autonomy, technology flexibility\n\n**Use when:**\n- Large team (multiple teams)\n- Different scaling requirements per domain\n- Need to deploy parts independently\n- Different technology needs per domain\n\n**Trade-offs:**\n- Distributed system complexity\n- Network latency between services\n- Data consistency is hard\n- Operational overhead (monitoring, deployment)\n\n**Prerequisites:**\n- Mature DevOps practices\n- Good observability\n- Clear domain boundaries\n- Experienced team\n\n---\n\n### Modular Monolith\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                    MODULAR MONOLITH                         │\n│                                                             │\n│   ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │\n│   │    Orders    │  │   Payments   │  │  Inventory   │     │\n│   │    Module    │  │    Module    │  │    Module    │     │\n│   │   ┌──────┐   │  │   ┌──────┐   │  │   ┌──────┐   │     │\n│   │   │  DB  │   │  │   │  DB  │   │  │   │  DB  │   │     │\n│   │   │Schema│   │  │   │Schema│   │  │   │Schema│   │     │\n│   │   └──────┘   │  │   └──────┘   │  │   └──────┘   │     │\n│   └──────────────┘  └──────────────┘  └──────────────┘     │\n│          │                 │                 │              │\n│          └─────────────────┼─────────────────┘              │\n│                            │                                │\n│                    ┌───────┴───────┐                        │\n│                    │   Shared DB   │                        │\n│                    │   (Schemas)   │                        │\n│                    └───────────────┘                        │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n**Solves:** Monolith simplicity with clear boundaries, path to microservices\n\n**Use when:**\n- Want benefits of modularity without distributed complexity\n- Planning potential future split to microservices\n- Need clear ownership boundaries\n\n**Trade-offs:**\n- Requires discipline to maintain boundaries\n- Still single deployment unit\n- Database schemas can drift if not careful\n\n## Data Patterns\n\n### CQRS (Command Query Responsibility Segregation)\n\n```\n        Commands                           Queries\n           │                                  │\n           ▼                                  ▼\n    ┌─────────────┐                    ┌─────────────┐\n    │   Command   │                    │    Query    │\n    │   Handler   │                    │   Handler   │\n    └──────┬──────┘                    └──────┬──────┘\n           │                                  │\n           ▼                                  ▼\n    ┌─────────────┐    sync/async      ┌─────────────┐\n    │   Write     │───────────────────▶│    Read     │\n    │   Model     │                    │    Model    │\n    └─────────────┘                    └─────────────┘\n```\n\n**Solves:** Read/write optimization, complex queries\n\n**Use when:**\n- Read and write patterns are very different\n- High read-to-write ratio\n- Complex read queries (reporting)\n\n**Trade-offs:**\n- Eventual consistency between models\n- Duplication of data\n- More complex than single model\n\n---\n\n### Event Sourcing\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                      EVENT STORE                            │\n│                                                             │\n│   Event 1: OrderCreated { orderId, items, timestamp }       │\n│   Event 2: PaymentReceived { orderId, amount, timestamp }   │\n│   Event 3: OrderShipped { orderId, trackingId, timestamp }  │\n│   Event 4: OrderDelivered { orderId, timestamp }            │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n                              │\n                              │ replay\n                              ▼\n                    ┌─────────────────┐\n                    │  Current State  │\n                    │  (Projection)   │\n                    └─────────────────┘\n```\n\n**Solves:** Complete audit trail, temporal queries, event replay\n\n**Use when:**\n- Audit trail is critical (finance, healthcare)\n- Need to replay/reprocess events\n- Domain is naturally event-based\n\n**Trade-offs:**\n- Querying current state requires projections\n- Schema evolution is complex\n- Storage grows indefinitely\n- Steep learning curve\n\n---\n\n### Saga Pattern\n\n```\n┌───────────────────────────────────────────────────────────────────────┐\n│                        ORDER SAGA                                     │\n│                                                                       │\n│   ┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐    │\n│   │ Reserve  │────▶│  Charge  │────▶│   Ship   │────▶│ Complete │    │\n│   │Inventory │     │ Payment  │     │  Order   │     │  Order   │    │\n│   └────┬─────┘     └────┬─────┘     └────┬─────┘     └──────────┘    │\n│        │                │                │                            │\n│   On failure:      On failure:      On failure:                       │\n│        │                │                │                            │\n│        ▼                ▼                ▼                            │\n│   ┌──────────┐     ┌──────────┐     ┌──────────┐                     │\n│   │ Release  │◀────│  Refund  │◀────│  Cancel  │                     │\n│   │Inventory │     │ Payment  │     │ Shipment │                     │\n│   └──────────┘     └──────────┘     └──────────┘                     │\n│                                                                       │\n└───────────────────────────────────────────────────────────────────────┘\n```\n\n**Solves:** Distributed transactions across services\n\n**Use when:**\n- Need transactions across microservices\n- Each service has its own database\n- Eventual consistency is acceptable\n\n**Trade-offs:**\n- Complex compensating transactions\n- Partial failure states\n- Debugging is difficult\n\n## Integration Patterns\n\n### API Gateway\n\n```\n┌──────────┐     ┌─────────────────┐     ┌──────────────┐\n│  Client  │────▶│   API Gateway   │────▶│   Service A  │\n└──────────┘     │                 │     └──────────────┘\n                 │  • Auth         │     ┌──────────────┐\n                 │  • Rate limit   │────▶│   Service B  │\n                 │  • Routing      │     └──────────────┘\n                 │  • Aggregation  │     ┌──────────────┐\n                 │                 │────▶│   Service C  │\n                 └─────────────────┘     └──────────────┘\n```\n\n**Solves:** Single entry point, cross-cutting concerns\n\n**Use when:**\n- Multiple backend services\n- Need centralized auth, rate limiting\n- Want to hide service topology from clients\n\n---\n\n### Message Queue\n\n```\n┌──────────┐     ┌─────────────────┐     ┌──────────────┐\n│ Producer │────▶│     Queue       │────▶│   Consumer   │\n└──────────┘     │  (SQS, RabbitMQ)│     └──────────────┘\n                 └─────────────────┘\n```\n\n**Solves:** Decoupling, async processing, load leveling\n\n**Use when:**\n- Producer and consumer have different throughput\n- Processing can be async\n- Need guaranteed delivery\n\n---\n\n### Event Bus (Pub/Sub)\n\n```\n┌──────────┐                              ┌──────────────┐\n│Publisher │──┐                       ┌──▶│ Subscriber A │\n└──────────┘  │    ┌─────────────┐    │   └──────────────┘\n              ├───▶│  Event Bus  │────┤   ┌──────────────┐\n┌──────────┐  │    │(Kafka, SNS) │    ├──▶│ Subscriber B │\n│Publisher │──┘    └─────────────┘    │   └──────────────┘\n└──────────┘                          │   ┌──────────────┐\n                                      └──▶│ Subscriber C │\n                                          └──────────────┘\n```\n\n**Solves:** Many-to-many communication, event-driven architecture\n\n**Use when:**\n- Multiple consumers need same events\n- Loose coupling between services\n- Event replay needed (Kafka)\n\n## Resilience Patterns\n\n### Circuit Breaker\n\n```\n        ┌─────────────────────────────────────────┐\n        │                                         │\n        ▼                                         │\n   ┌─────────┐    failures     ┌─────────┐       │\n   │ CLOSED  │────────────────▶│  OPEN   │       │\n   │(normal) │                 │ (fail   │       │\n   └─────────┘                 │  fast)  │       │\n        ▲                      └────┬────┘       │\n        │                           │            │\n        │    success          timeout            │\n        │                           │            │\n        │                      ┌────▼────┐       │\n        └──────────────────────│HALF-OPEN│───────┘\n                               │ (test)  │  failure\n                               └─────────┘\n```\n\n**Solves:** Cascading failures, fail fast\n\n**Use when:**\n- Calling external/unreliable services\n- Want to avoid overloading failing service\n\n---\n\n### Retry with Backoff\n\n```\nRequest failed ──▶ Wait 1s ──▶ Retry ──▶ Failed\n                                           │\n                              Wait 2s ◀────┘\n                                 │\n                              Retry ──▶ Failed\n                                           │\n                              Wait 4s ◀────┘\n                                 │\n                              Retry ──▶ Success!\n```\n\n**Solves:** Transient failures\n\n**Use when:**\n- Failures are likely temporary\n- Operation is idempotent\n\n---\n\n### Bulkhead\n\n```\n┌──────────────────────────────────────────────────────────┐\n│                      APPLICATION                          │\n│                                                          │\n│   ┌─────────────────┐    ┌─────────────────┐            │\n│   │   Thread Pool   │    │   Thread Pool   │            │\n│   │   (Service A)   │    │   (Service B)   │            │\n│   │                 │    │                 │            │\n│   │  ████████░░░░   │    │  ██░░░░░░░░░░   │            │\n│   │  (80% used)     │    │  (20% used)     │            │\n│   └─────────────────┘    └─────────────────┘            │\n│                                                          │\n│   Service A slowdown doesn't affect Service B            │\n│                                                          │\n└──────────────────────────────────────────────────────────┘\n```\n\n**Solves:** Isolation of failures\n\n**Use when:**\n- Different operations have different reliability\n- Want to contain failures\n\n## Pattern Selection Matrix\n\n| Scenario | Recommended Pattern |\n|----------|-------------------|\n| Starting new project | Monolith (modular) |\n| Complex domain logic | Hexagonal / Clean Architecture |\n| High read load | CQRS |\n| Audit requirements | Event Sourcing |\n| Multiple teams, services | Microservices + API Gateway |\n| Async processing | Message Queue |\n| Calling unreliable services | Circuit Breaker + Retry |\n| Distributed transactions | Saga |\n\n## Anti-patterns to Avoid\n\n| Anti-pattern | Problem | Instead |\n|--------------|---------|---------|\n| **Distributed Monolith** | Microservices that must deploy together | Define clear contracts, or stay monolith |\n| **Golden Hammer** | Using one pattern everywhere | Choose pattern based on context |\n| **Resume-Driven Architecture** | Picking tech for resume, not fit | Start simple, add complexity when needed |\n| **Big Ball of Mud** | No clear structure | Establish and enforce module boundaries |\n| **Premature Microservices** | Splitting too early | Start monolith, split when boundaries clear |\n"
    },
    {
      "name": "option-exploration.md",
      "path": "references/option-exploration.md",
      "content": "# Option Exploration\n\nGenerating and documenting architectural options systematically.\n\n## Why Explore Options?\n\nThe first solution that comes to mind is rarely the best. Exploring multiple options:\n- Reveals hidden trade-offs\n- Prevents anchoring on familiar patterns\n- Ensures you've considered alternatives\n- Makes the final decision defensible\n\n**Rule of Three:** Generate at least three options before deciding. If you can only think of one, you haven't explored enough.\n\n## Option Generation Techniques\n\n### 1. Pattern Matching\n\nWhat architectural patterns fit this problem?\n\n| Problem Type | Candidate Patterns |\n|--------------|-------------------|\n| Request/response | Layered, MVC, Clean Architecture |\n| High throughput | Event-driven, CQRS, streaming |\n| Complex domain | Domain-Driven Design, microservices |\n| Real-time | WebSockets, Server-Sent Events, polling |\n| Batch processing | Queue-based, MapReduce, workflow engines |\n| Multi-tenant | Shared database, isolated databases, hybrid |\n\n### 2. Analogy\n\nHow have similar systems been built?\n\n```markdown\n### Similar Systems Analysis\n\n**Our problem:** Real-time collaboration on documents\n\n**Similar systems:**\n- Google Docs → Operational Transformation (OT)\n- Figma → CRDTs (Conflict-free Replicated Data Types)\n- Notion → Hybrid OT/CRDT\n\n**Insights:**\n- OT is complex but well-understood\n- CRDTs are simpler but newer\n- Hybrid approaches are emerging\n```\n\n### 3. Decomposition\n\nBreak the problem into smaller decisions:\n\n```markdown\n### Decision Decomposition\n\n**Big decision:** How to build real-time collaboration\n\n**Sub-decisions:**\n1. Conflict resolution strategy (OT vs CRDT vs locking)\n2. Transport mechanism (WebSockets vs SSE vs polling)\n3. Persistence strategy (event sourcing vs snapshots)\n4. Sync topology (client-server vs peer-to-peer)\n\nEach sub-decision can have its own options.\n```\n\n### 4. Extremes\n\nWhat if we optimized for one thing completely?\n\n| Extreme | What It Looks Like |\n|---------|-------------------|\n| **Simplest** | Single server, SQLite, no caching |\n| **Cheapest** | Serverless, pay-per-use, minimal infrastructure |\n| **Most scalable** | Microservices, sharding, global distribution |\n| **Most flexible** | Plugin architecture, configuration over code |\n| **Fastest to build** | Off-the-shelf SaaS, minimal customization |\n\n### 5. Constraint Removal\n\nWhat would we do if we didn't have constraint X?\n\n```markdown\n### Constraint Removal Analysis\n\n**Current constraints:**\n- Must use existing PostgreSQL database\n- Team only knows Python\n- $5,000/month budget\n\n**If we removed the database constraint:**\n→ Could use DynamoDB for infinite scale\n→ Could use MongoDB for flexible schema\n\n**Insight:** PostgreSQL can actually handle our scale. \nThe constraint isn't limiting us here.\n\n**If we removed the language constraint:**\n→ Could use Go for better performance\n→ Could use Elixir for better concurrency\n\n**Insight:** Python's performance is sufficient, but \nwe should consider async Python for concurrency.\n```\n\n## Option Documentation Template\n\nFor each option, document:\n\n```markdown\n### Option [Letter]: [Name]\n\n**Summary:**\n[One paragraph description of the approach]\n\n**How It Works:**\n1. [Step 1]\n2. [Step 2]\n3. [Step 3]\n\n**Architecture Diagram:**\n```\n[ASCII diagram showing components and flow]\n```\n\n**Key Technologies:**\n| Component | Technology | Rationale |\n|-----------|------------|-----------|\n| [Component] | [Tech] | [Why this tech] |\n\n**Pros:**\n- ✅ [Advantage 1]\n- ✅ [Advantage 2]\n- ✅ [Advantage 3]\n\n**Cons:**\n- ❌ [Disadvantage 1]\n- ❌ [Disadvantage 2]\n\n**Fits Architectural Drivers:**\n| Driver | Fit | Notes |\n|--------|-----|-------|\n| Performance | ✅ Good | [Why] |\n| Scalability | ⚠️ Partial | [Limitation] |\n| Simplicity | ❌ Poor | [Why] |\n\n**Effort Estimate:**\n- Initial build: [T-shirt size]\n- Ongoing maintenance: [Low/Medium/High]\n\n**Risks:**\n| Risk | Likelihood | Impact | Mitigation |\n|------|------------|--------|------------|\n| [Risk 1] | [H/M/L] | [H/M/L] | [How to mitigate] |\n\n**Open Questions:**\n- [Question 1]\n- [Question 2]\n```\n\n## Example: Options for a Notification System\n\n### Option A: Direct Push\n\n**Summary:**\nSend notifications directly to users via WebSocket connections. Server maintains connection pool and pushes messages in real-time.\n\n**How It Works:**\n1. Event occurs in system\n2. Server looks up connected users\n3. Server pushes message via WebSocket\n4. Client displays notification\n\n**Architecture Diagram:**\n```\n┌─────────┐    event    ┌─────────────┐   WebSocket   ┌────────┐\n│ Service │────────────▶│Notification │◀─────────────▶│ Client │\n└─────────┘             │   Server    │               └────────┘\n                        └─────────────┘\n                              │\n                              ▼\n                        ┌─────────────┐\n                        │  Postgres   │\n                        │(connections)│\n                        └─────────────┘\n```\n\n**Pros:**\n- ✅ Simple architecture\n- ✅ True real-time (no polling)\n- ✅ Low latency\n\n**Cons:**\n- ❌ Requires persistent connections\n- ❌ Scaling is complex (sticky sessions)\n- ❌ Mobile battery impact\n\n**Fits Drivers:**\n| Driver | Fit | Notes |\n|--------|-----|-------|\n| Real-time | ✅ Good | Sub-second delivery |\n| Scalability | ⚠️ Partial | Needs Redis pub/sub at scale |\n| Battery | ❌ Poor | Always-on connection |\n\n---\n\n### Option B: Queue + Push Service\n\n**Summary:**\nUse message queue for reliable delivery, integrate with push notification services (FCM, APNs) for mobile delivery.\n\n**How It Works:**\n1. Event occurs in system\n2. Message published to queue\n3. Worker processes queue\n4. Worker sends via FCM/APNs for mobile, WebSocket for web\n\n**Architecture Diagram:**\n```\n┌─────────┐    ┌─────────┐    ┌─────────┐    ┌──────┐\n│ Service │───▶│  Queue  │───▶│ Worker  │───▶│ FCM  │\n└─────────┘    └─────────┘    └─────────┘    └──────┘\n                                   │          \n                                   ▼          \n                              ┌─────────┐    ┌────────┐\n                              │WebSocket│───▶│ Client │\n                              │ Server  │    └────────┘\n                              └─────────┘\n```\n\n**Pros:**\n- ✅ Reliable delivery (queue persistence)\n- ✅ Works on mobile (native push)\n- ✅ Scales horizontally\n\n**Cons:**\n- ❌ More complex architecture\n- ❌ Higher latency (queue processing)\n- ❌ Dependency on external services\n\n**Fits Drivers:**\n| Driver | Fit | Notes |\n|--------|-----|-------|\n| Real-time | ⚠️ Partial | ~1-3s latency typical |\n| Reliability | ✅ Good | Queue ensures delivery |\n| Mobile | ✅ Good | Native push support |\n\n---\n\n### Option C: Polling + SSE Hybrid\n\n**Summary:**\nUse Server-Sent Events for connected clients, periodic polling as fallback, store notifications in database.\n\n**How It Works:**\n1. Event occurs, notification stored in database\n2. SSE channel notifies connected clients\n3. Disconnected clients poll on reconnect\n4. Mobile apps poll in background\n\n**Architecture Diagram:**\n```\n┌─────────┐    ┌─────────┐    ┌─────────┐\n│ Service │───▶│Postgres │◀───│   API   │◀─── polling ───┐\n└─────────┘    └─────────┘    └─────────┘                 │\n                    │              │                      │\n                    │              ▼                      │\n                    │         ┌─────────┐           ┌────────┐\n                    └────────▶│   SSE   │──────────▶│ Client │\n                              │ Server  │           └────────┘\n                              └─────────┘\n```\n\n**Pros:**\n- ✅ Simple, uses existing infrastructure\n- ✅ Graceful degradation (polling fallback)\n- ✅ Notifications persist in database\n\n**Cons:**\n- ❌ Not true real-time (polling delay)\n- ❌ Database load from polling\n- ❌ SSE is one-way only\n\n**Fits Drivers:**\n| Driver | Fit | Notes |\n|--------|-----|-------|\n| Simplicity | ✅ Good | Minimal new infrastructure |\n| Real-time | ⚠️ Partial | Good for web, polling for mobile |\n| Reliability | ✅ Good | Database-backed |\n\n## Narrowing Down\n\nAfter generating options, narrow down:\n\n### Quick Elimination\n\nSome options can be eliminated quickly:\n\n```markdown\n### Eliminated Options\n\n**Option D: Third-party notification SaaS**\n❌ Eliminated: Doesn't meet data residency requirements (P0 driver)\n\n**Option E: Peer-to-peer WebRTC**\n❌ Eliminated: Team has no WebRTC experience, timeline too tight\n```\n\n### Head-to-Head Comparison\n\nFor remaining options, compare directly:\n\n```markdown\n### Comparison: Option A vs Option B vs Option C\n\n| Criterion | Option A | Option B | Option C |\n|-----------|----------|----------|----------|\n| Latency | <100ms ✅ | 1-3s ⚠️ | 5-30s ❌ |\n| Reliability | Medium ⚠️ | High ✅ | High ✅ |\n| Complexity | Low ✅ | High ❌ | Medium ⚠️ |\n| Mobile support | Poor ❌ | Good ✅ | Medium ⚠️ |\n| Build time | 2 weeks ✅ | 4 weeks ❌ | 3 weeks ⚠️ |\n```\n\n## Option Exploration Checklist\n\n```markdown\n- [ ] Generated at least 3 viable options\n- [ ] Used multiple generation techniques\n- [ ] Each option is genuinely different (not minor variations)\n- [ ] Documented pros/cons for each\n- [ ] Evaluated against architectural drivers\n- [ ] Estimated effort for each\n- [ ] Identified risks for each\n- [ ] Eliminated clearly unfit options with rationale\n- [ ] Remaining options ready for trade-off analysis\n```\n"
    },
    {
      "name": "trade-off-analysis.md",
      "path": "references/trade-off-analysis.md",
      "content": "# Trade-off Analysis\n\nEvaluating architectural trade-offs systematically.\n\n## Why Trade-offs Matter\n\nEvery architectural decision involves trade-offs. There is no \"best\" architecture — only architectures that are better or worse for specific contexts and priorities.\n\n**The goal:** Make trade-offs explicit, so stakeholders understand what they're getting and what they're giving up.\n\n## Common Architectural Trade-offs\n\n### Fundamental Trade-offs\n\n| Trade-off | Tension |\n|-----------|---------|\n| **Consistency vs Availability** | Strong consistency requires coordination, which reduces availability |\n| **Latency vs Throughput** | Batching improves throughput but increases latency |\n| **Performance vs Simplicity** | Optimizations add complexity |\n| **Flexibility vs Focus** | Generic solutions are harder to optimize |\n| **Control vs Speed** | Building gives control; buying is faster |\n| **Coupling vs Cohesion** | Loose coupling can reduce cohesion |\n\n### Technology Trade-offs\n\n| Decision | Trade-off |\n|----------|-----------|\n| **SQL vs NoSQL** | ACID guarantees vs flexibility and scale |\n| **Monolith vs Microservices** | Simplicity vs independent scaling |\n| **Server vs Serverless** | Control vs operational simplicity |\n| **REST vs GraphQL** | Simplicity vs flexibility |\n| **Synchronous vs Asynchronous** | Simplicity vs resilience |\n\n### Operational Trade-offs\n\n| Decision | Trade-off |\n|----------|-----------|\n| **Multi-tenant vs Single-tenant** | Efficiency vs isolation |\n| **Cloud vs On-prem** | Flexibility vs control |\n| **Managed vs Self-hosted** | Cost vs control |\n| **Active-active vs Active-passive** | Availability vs complexity |\n\n## Trade-off Analysis Methods\n\n### 1. Weighted Scoring Matrix\n\nAssign weights to criteria based on priorities, score each option:\n\n```markdown\n### Scoring Matrix: Database Selection\n\n**Criteria weights (total 10):**\n- Performance: 3\n- Scalability: 3\n- Simplicity: 2\n- Cost: 2\n\n**Scoring (1-5):**\n\n| Criterion | Weight | PostgreSQL | DynamoDB | MongoDB |\n|-----------|--------|------------|----------|---------|\n| Performance | 3 | 4 (12) | 5 (15) | 4 (12) |\n| Scalability | 3 | 3 (9) | 5 (15) | 4 (12) |\n| Simplicity | 2 | 5 (10) | 3 (6) | 4 (8) |\n| Cost | 2 | 5 (10) | 2 (4) | 3 (6) |\n| **Total** | | **41** | **40** | **38** |\n\n**Result:** PostgreSQL wins slightly, mainly due to simplicity and cost.\n```\n\n### 2. SWOT Analysis\n\nFor each option, analyze:\n\n```markdown\n### SWOT: Microservices Architecture\n\n**Strengths:**\n- Independent deployment and scaling\n- Technology flexibility per service\n- Team autonomy\n\n**Weaknesses:**\n- Distributed system complexity\n- Network latency between services\n- Operational overhead\n\n**Opportunities:**\n- Can adopt new technologies incrementally\n- Can scale team with clear boundaries\n\n**Threats:**\n- Team too small to manage effectively\n- Debugging distributed issues is hard\n- Could over-engineer for current scale\n```\n\n### 3. Risk-Based Analysis\n\nFocus on what could go wrong:\n\n```markdown\n### Risk Analysis: Serverless Architecture\n\n| Risk | Likelihood | Impact | Mitigation |\n|------|------------|--------|------------|\n| Cold start latency | High | Medium | Provisioned concurrency |\n| Vendor lock-in | Medium | High | Abstract provider interfaces |\n| Runaway costs | Medium | High | Budget alerts, throttling |\n| Debugging difficulty | High | Medium | Structured logging, tracing |\n| Execution time limits | Low | High | Break into smaller functions |\n\n**Risk Score:** Medium-High\n\n**Accept if:** Cost savings outweigh operational complexity,\nteam comfortable with observability tooling.\n```\n\n### 4. Cost-Benefit Analysis\n\nQuantify costs and benefits where possible:\n\n```markdown\n### Cost-Benefit: Build vs Buy (Auth System)\n\n**Build:**\n- Development cost: ~$50,000 (2 engineers × 2 months)\n- Maintenance cost: ~$2,000/month (ongoing)\n- Time to production: 2 months\n- Benefits: Full control, no per-user fees\n\n**Buy (Auth0):**\n- Development cost: ~$5,000 (integration)\n- Subscription cost: ~$3,000/month (at expected scale)\n- Time to production: 2 weeks\n- Benefits: Faster, proven security, compliance features\n\n**Break-even analysis:**\n- Build saves $1,000/month after initial investment\n- Break-even: ~50 months\n- But: Time-to-market value of 6 weeks worth ~$30,000\n\n**Decision:** Buy. Time-to-market value exceeds long-term savings.\n```\n\n### 5. Reversibility Analysis\n\nHow hard is it to change this decision later?\n\n```markdown\n### Reversibility Analysis\n\n| Decision | Reversibility | Effort to Change |\n|----------|---------------|------------------|\n| Programming language | Low | Rewrite |\n| Database type | Low | Data migration + rewrite |\n| Cloud provider | Medium | Infrastructure rebuild |\n| API design | Medium | Versioning + migration |\n| Framework choice | Medium | Incremental rewrite |\n| Service boundaries | Medium-High | Refactoring |\n| Caching strategy | High | Configuration change |\n| Feature flag system | High | Easy to change |\n\n**Principle:** Be extra careful with low-reversibility decisions.\nPrefer high-reversibility options when differences are small.\n```\n\n## Trade-off Documentation\n\n### Trade-off Summary Template\n\n```markdown\n## Trade-off: [Decision]\n\n### Options Considered\n1. Option A: [Brief description]\n2. Option B: [Brief description]\n3. Option C: [Brief description]\n\n### Key Trade-offs\n\n| Aspect | Option A | Option B | Option C |\n|--------|----------|----------|----------|\n| [Aspect 1] | [Rating] | [Rating] | [Rating] |\n| [Aspect 2] | [Rating] | [Rating] | [Rating] |\n\n### What We Gain\n- [Benefit 1 from chosen option]\n- [Benefit 2 from chosen option]\n\n### What We Give Up\n- [Trade-off accepted 1]\n- [Trade-off accepted 2]\n\n### Why This Trade-off Is Acceptable\n[Explanation of why the benefits outweigh the costs]\n\n### Conditions That Would Change This Decision\n- If [condition], we would reconsider because [reason]\n- If [condition], Option B becomes better because [reason]\n```\n\n## Example: Complete Trade-off Analysis\n\n### Synchronous vs Asynchronous Order Processing\n\n**Context:** E-commerce system needs to process orders. Each order involves inventory check, payment processing, and notification.\n\n---\n\n**Option A: Synchronous (All in One Request)**\n\n```\nUser → API → Check Inventory → Process Payment → Send Notification → Response\n```\n\n*Pros:*\n- Simple to implement and debug\n- Immediate feedback to user\n- Transactional (all or nothing)\n\n*Cons:*\n- Slow response (sum of all operations)\n- Single failure fails entire order\n- Can't scale operations independently\n\n---\n\n**Option B: Asynchronous (Queue-Based)**\n\n```\nUser → API → Queue → [Workers process independently] → Response via webhook/polling\n```\n\n*Pros:*\n- Fast initial response\n- Resilient to individual failures\n- Operations scale independently\n\n*Cons:*\n- Complex error handling\n- Eventual consistency\n- User doesn't get immediate confirmation\n\n---\n\n**Option C: Hybrid (Sync Critical, Async Rest)**\n\n```\nUser → API → Check Inventory → Process Payment → Response\n                    ↓\n              Queue → Send Notification (async)\n```\n\n*Pros:*\n- Fast for critical path\n- User gets payment confirmation\n- Non-critical work is resilient\n\n*Cons:*\n- Moderate complexity\n- Must decide what's critical\n- Partial failure scenarios\n\n---\n\n**Trade-off Matrix:**\n\n| Criterion | Weight | Sync | Async | Hybrid |\n|-----------|--------|------|-------|--------|\n| User experience | 4 | 3 (12) | 2 (8) | 4 (16) |\n| Reliability | 3 | 2 (6) | 4 (12) | 3 (9) |\n| Simplicity | 2 | 5 (10) | 2 (4) | 3 (6) |\n| Scalability | 2 | 2 (4) | 5 (10) | 4 (8) |\n| **Total** | | **32** | **34** | **39** |\n\n**Decision:** Hybrid approach\n\n**What we gain:**\n- Fast checkout experience\n- Guaranteed payment confirmation\n- Resilient notification delivery\n\n**What we give up:**\n- Simplicity of pure sync\n- Full async scalability\n\n**Why acceptable:**\n- User experience is top priority (P0)\n- Notifications are not critical path\n- Complexity is manageable for team\n\n**Would reconsider if:**\n- Order volume exceeds 10K/hour → Move to full async\n- Payment provider has frequent timeouts → Add async payment with polling\n\n## Trade-off Anti-patterns\n\n### 1. Analysis Paralysis\n**Problem:** Endless analysis without decision\n**Solution:** Set a timebox. Decide with 70% confidence.\n\n### 2. Hidden Trade-offs\n**Problem:** Trade-offs not documented\n**Solution:** Every decision needs explicit \"what we give up\"\n\n### 3. False Dichotomies\n**Problem:** Only considering two options\n**Solution:** Always generate at least three options\n\n### 4. Ignoring Reversibility\n**Problem:** Treating all decisions as permanent\n**Solution:** Explicitly assess reversibility, prefer reversible when close\n\n### 5. Quantifying the Unquantifiable\n**Problem:** Forcing numbers on qualitative trade-offs\n**Solution:** Use qualitative comparison (✅ ⚠️ ❌) where appropriate\n\n## Trade-off Analysis Checklist\n\n```markdown\n- [ ] Multiple options genuinely considered\n- [ ] Criteria aligned with architectural drivers\n- [ ] Weights reflect actual priorities\n- [ ] Scores are justified, not arbitrary\n- [ ] Trade-offs explicitly documented\n- [ ] \"What we give up\" is clear\n- [ ] Reversibility assessed\n- [ ] Conditions for reconsidering documented\n- [ ] Stakeholders understand trade-offs\n```\n"
    }
  ],
  "tags": [
    "planning",
    "design",
    "architecture",
    "decisions"
  ],
  "dependsOn": []
}