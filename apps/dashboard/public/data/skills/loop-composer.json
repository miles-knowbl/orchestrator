{
  "id": "loop-composer",
  "name": "loop-composer",
  "version": "1.0.0",
  "description": "Design and compose loops from requirements. Handles skill selection, phase sequencing, gate placement, dependency validation, and loop.json generation. The architectural counterpart to loop-controller's runtime execution.",
  "phase": "SCAFFOLD",
  "category": "meta",
  "content": "# Loop Composer\n\nDesign and compose loops from requirements. Transform domain intent into executable loop definitions.\n\n## When to Use\n\n- **Building a new loop from scratch** -- You have a domain (engineering, proposal, analysis) and need a structured multi-phase workflow\n- **Customizing an existing loop** -- An existing loop is close but needs phases added, removed, or reordered for a different use case\n- **Composing a lightweight loop** -- You need a minimal 3-4 phase loop for a focused task rather than the full engineering gauntlet\n- **Validating loop correctness** -- You have a loop.json and need to verify skill coverage, dependency satisfaction, and gate placement\n- **Designing domain-specific workflows** -- A new domain (security audit, data pipeline, content creation) needs its own loop pattern\n- When you say: \"create a loop for...\", \"design a workflow that...\", \"compose a new loop\", \"what skills do I need for...\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `loop-schema.md` | Complete loop.json schema -- every field you can set |\n| `phase-sequencing.md` | Phase ordering rules, required vs optional, valid transitions |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `gate-design.md` | When placing human-in-the-loop gates or configuring approval types |\n| `skill-selection.md` | When querying the registry to find skills for a domain |\n| `composition-patterns.md` | When following a known pattern (engineering, proposal, lightweight) |\n\n**Verification:** Ensure the composed loop.json passes schema validation and all referenced skills exist in the registry.\n\n## Required Deliverables\n\n| Deliverable | Condition | Purpose |\n|-------------|-----------|---------|\n| `loop.json` | Always | The executable loop definition consumed by loop-controller |\n| `LOOP.md` | Always | Human-readable description of the loop's purpose and flow |\n| `COMPOSITION-NOTES.md` | When design decisions are non-obvious | Documents why skills were selected, phases ordered, and gates placed |\n\n## Core Concept\n\nThis skill answers: **\"Given a domain and desired outcome, what is the optimal sequence of skills, phases, and gates to achieve it?\"**\n\nLoop composition IS:\n- Selecting the right skills from the registry for a domain\n- Sequencing phases in valid order with correct dependencies\n- Placing gates at decision points where human review adds value\n- Generating a valid loop.json that loop-controller can execute\n- Configuring UI, metadata, and defaults for the loop's context\n\nLoop composition IS NOT:\n- Executing the loop (that is `loop-controller`)\n- Creating new skills (that is `skill-design`)\n- Defining requirements (that is `requirements` or `spec`)\n- Runtime orchestration (that is `orchestrator`)\n- Modifying skill behavior (skills are atomic units, compose them, don't change them)\n\n## Process Overview\n\n```\n┌──────────────────────────────────────────────────────────────────────┐\n│                     LOOP COMPOSITION PROCESS                        │\n│                                                                     │\n│  1. REQUIREMENTS GATHERING                                          │\n│     └─→ Domain, outcome, constraints, autonomy level                │\n│                                                                     │\n│  2. SKILL DISCOVERY                                                 │\n│     └─→ Query registry, filter by domain/phase, check coverage      │\n│                                                                     │\n│  3. PHASE MAPPING                                                   │\n│     └─→ Assign skills to phases, enforce ordering rules             │\n│                                                                     │\n│  4. GATE PLACEMENT                                                  │\n│     └─→ Insert human checkpoints at decision boundaries             │\n│                                                                     │\n│  5. DEPENDENCY VALIDATION                                           │\n│     └─→ Verify skill deps satisfied, no circular references         │\n│                                                                     │\n│  6. CONFIGURATION                                                   │\n│     └─→ Set defaults, UI theme, skillUI entries, metadata           │\n│                                                                     │\n│  7. COMPOSITION                                                     │\n│     └─→ Assemble loop.json, validate against schema                 │\n│                                                                     │\n│  8. TESTING                                                         │\n│     └─→ Dry-run validation, verify skills exist, check integrity    │\n│                                                                     │\n│  Output: loop.json + LOOP.md + (optional) COMPOSITION-NOTES.md      │\n└──────────────────────────────────────────────────────────────────────┘\n```\n\n## Step 1: Requirements Gathering\n\nBefore composing a loop, capture the design inputs. Every loop starts with understanding what it needs to accomplish.\n\n### Requirements Interview\n\n| Question | Purpose | Example Answer |\n|----------|---------|----------------|\n| What domain is this loop for? | Determines skill pool | \"Engineering\", \"Proposal\", \"Security Audit\" |\n| What is the desired outcome? | Shapes phase selection | \"Production-deployed feature\", \"Approved proposal\" |\n| What quality level is needed? | Controls phase depth | \"Full rigor\" vs \"Quick iteration\" |\n| Who are the stakeholders? | Determines gate placement | \"Engineering lead reviews architecture\" |\n| What autonomy level? | Sets supervision model | \"supervised\", \"semi-autonomous\", \"autonomous\" |\n| Are there constraints? | Limits skill/phase choices | \"No deployment phase\", \"Must include security\" |\n| Greenfield or brownfield? | Sets mode defaults | Affects skill behavior within the loop |\n\n### Requirements Template\n\n```markdown\n## Loop Requirements\n\n### Domain\n[Engineering | Proposal | Analysis | Security | Content | Custom: ___]\n\n### Desired Outcome\n[What does a successful loop execution produce?]\n\n### Quality Level\n- [ ] Lightweight (3-4 phases, minimal gates)\n- [ ] Standard (5-7 phases, key gates)\n- [ ] Full rigor (8-10 phases, comprehensive gates)\n\n### Stakeholders & Review Points\n- [Role]: Reviews at [phase]\n- [Role]: Approves at [phase]\n\n### Autonomy\n- [ ] Supervised (human approves every gate)\n- [ ] Semi-autonomous (human approves critical gates only)\n- [ ] Autonomous (automated gates, human notified)\n\n### Constraints\n- Must include: [skills/phases]\n- Must exclude: [skills/phases]\n- Mode: [greenfield | brownfield]\n```\n\n### Requirement Validation Checklist\n\n```markdown\n- [ ] Domain is identified\n- [ ] Outcome is concrete and measurable\n- [ ] Quality level is chosen\n- [ ] At least one stakeholder role is defined\n- [ ] Autonomy level is set\n- [ ] Hard constraints are documented\n```\n\n## Step 2: Skill Discovery\n\nQuery the skill registry to find candidate skills for the loop. The registry contains all available skills with their phase assignments, categories, dependencies, and descriptions.\n\n### Discovery Process\n\n1. **List all skills** -- Get the full registry inventory\n2. **Filter by relevance** -- Match skills to the domain and outcome\n3. **Check phase coverage** -- Ensure at least one skill per required phase\n4. **Identify gaps** -- Find phases with no skill coverage\n5. **Resolve dependencies** -- Pull in skills required by selected skills\n\n### Skill Query Strategy\n\n| Strategy | When to Use | How |\n|----------|-------------|-----|\n| **Phase-based** | Building a standard loop | Query skills grouped by phase, pick best per phase |\n| **Domain-based** | Domain-specific loop | Filter by tags matching the domain |\n| **Category-based** | Infrastructure loop | Filter by category (core, infra, specialized, meta) |\n| **Dependency-based** | Extending a skill | Start from a skill, pull in all its dependencies |\n\n### Coverage Analysis Table\n\nBuild this table during discovery to track coverage:\n\n```markdown\n| Phase | Available Skills | Selected | Reason |\n|-------|-----------------|----------|--------|\n| INIT | spec, entry-portal, document, ... | spec | Core requirements capture |\n| SCAFFOLD | architect, scaffold | architect, scaffold | Design + file generation |\n| IMPLEMENT | implement, error-handling | implement | Core implementation |\n| TEST | test-generation | test-generation | Test suite generation |\n| VERIFY | code-verification | code-verification | Structural checks |\n| VALIDATE | perf-analysis | -- | Not needed for MVP |\n| DOCUMENT | document | document | API docs generation |\n| REVIEW | code-review | code-review | PR review |\n| SHIP | deploy | deploy | Production deployment |\n| COMPLETE | loop-controller | loop-controller | Loop finalization |\n```\n\n### Skill Selection Criteria\n\nFor each candidate skill, evaluate:\n\n| Criterion | Weight | Question |\n|-----------|--------|----------|\n| Domain fit | High | Does this skill serve the loop's domain? |\n| Phase fit | High | Is it assigned to a phase we need? |\n| Dependency cost | Medium | How many additional skills does it pull in? |\n| Category match | Medium | Does its category match our loop type? |\n| Optionality | Low | Can we skip it without breaking the loop? |\n\nSee `references/skill-selection.md` for detailed selection algorithms.\n\n## Step 3: Phase Mapping\n\nAssign selected skills to phases following the canonical phase order. Every loop uses a subset of the 10 standard phases.\n\n### Canonical Phase Order\n\n```\nINIT → SCAFFOLD → IMPLEMENT → TEST → VERIFY → VALIDATE → DOCUMENT → REVIEW → SHIP → COMPLETE\n```\n\nPlus `META` for meta-skills that operate outside the standard flow.\n\n### Phase Mapping Rules\n\n| Rule | Description | Enforcement |\n|------|-------------|-------------|\n| **Order preservation** | Phases must appear in canonical order | Hard -- loop.json is rejected otherwise |\n| **INIT required** | Every loop must start with an INIT phase | Hard -- no valid loop without initialization |\n| **COMPLETE required** | Every loop must end with COMPLETE | Hard -- loop-controller must finalize |\n| **No empty phases** | Every listed phase must have at least one skill | Hard -- empty phases are invalid |\n| **Multi-skill phases** | A phase can have multiple skills (executed in order) | Allowed -- e.g., SCAFFOLD: [architect, scaffold] |\n| **Phase skipping** | Phases can be omitted entirely | Allowed -- e.g., skip VALIDATE for lightweight loops |\n| **Required flag** | Each phase has a `required` boolean | Soft -- optional phases can be skipped at runtime |\n\n### Phase Assignment Table\n\nUse this template to assign skills to phases:\n\n```markdown\n| Phase | Skills (ordered) | Required | Rationale |\n|-------|-----------------|----------|-----------|\n| INIT | [skill-a] | true | [why] |\n| SCAFFOLD | [skill-b, skill-c] | true | [why] |\n| IMPLEMENT | [skill-d] | true | [why] |\n| ... | ... | ... | ... |\n| COMPLETE | [loop-controller] | true | Always required |\n```\n\n### Phase Required vs Optional Decision\n\n| Mark Required When | Mark Optional When |\n|--------------------|--------------------|\n| Loop cannot succeed without this phase | Phase adds value but is not essential |\n| Downstream phases depend on its output | Stakeholder may choose to skip |\n| Phase contains critical quality gate | Phase is domain-specific, not universal |\n| Phase is INIT or COMPLETE | Phase is DOCUMENT, SHIP, or VALIDATE |\n\nSee `references/phase-sequencing.md` for detailed ordering rules and valid transitions.\n\n## Step 4: Gate Placement\n\nGates are human-in-the-loop checkpoints between phases. They pause execution until a human approves, providing oversight at critical decision boundaries.\n\n### Gate Placement Rules\n\n| Rule | Description |\n|------|-------------|\n| **After, not before** | Gates are placed `afterPhase`, blocking the next phase |\n| **Decision boundaries** | Place gates where a wrong decision is expensive to reverse |\n| **Deliverable-backed** | Every gate should reference deliverables the human reviews |\n| **Diminishing returns** | More gates slow execution -- place only where review adds value |\n| **Required matches phase** | If the phase is optional, the gate should be optional too |\n\n### Gate Types\n\n| Type | `approvalType` | When to Use |\n|------|----------------|-------------|\n| **Human** | `\"human\"` | Critical decisions: architecture, spec, final review |\n| **Conditional** | `\"conditional\"` | Only needed if a condition is met (e.g., deploy only if SHIP phase runs) |\n| **Automated** | `\"automated\"` | Programmatic checks: tests pass, linting clean, coverage threshold |\n\n### Standard Gate Patterns\n\n| Gate | After Phase | Type | Deliverables | When to Include |\n|------|-------------|------|-------------|-----------------|\n| Spec Gate | INIT | human | FEATURESPEC.md | Always for engineering loops |\n| Architecture Gate | SCAFFOLD | human | ARCHITECTURE.md | When architecture decisions are made |\n| Test Gate | TEST | automated | test-results.json | When automated test validation is needed |\n| Verification Gate | VERIFY | automated | verification-report.md | When structural checks must pass |\n| Review Gate | REVIEW | human | CODE-REVIEW.md | Always for production-bound code |\n| Deploy Gate | SHIP | conditional | -- | Only when deployment is included |\n| Context Gate | INIT | human | CONTEXT-SOURCES.md | For research/proposal loops |\n| Final Gate | COMPLETE | human | [final deliverable] | When final human sign-off is needed |\n\n### Gate Template\n\n```json\n{\n  \"id\": \"[phase]-gate\",\n  \"name\": \"[Human-Readable Gate Name]\",\n  \"afterPhase\": \"[PHASE]\",\n  \"required\": true,\n  \"approvalType\": \"human\",\n  \"deliverables\": [\"DELIVERABLE.md\"]\n}\n```\n\n### Autonomy Level Affects Gates\n\n| Autonomy | Gate Behavior |\n|----------|---------------|\n| **supervised** | All gates are human-approved |\n| **semi-autonomous** | Critical gates human, others automated |\n| **autonomous** | All gates automated, human notified post-facto |\n\nSee `references/gate-design.md` for detailed gate design guidance.\n\n## Step 5: Dependency Validation\n\nBefore finalizing the loop, validate that all skill dependencies are satisfied within the composed phase sequence.\n\n### Dependency Rules\n\n| Rule | Description | Action on Violation |\n|------|-------------|---------------------|\n| **Forward dependency** | A skill's dependencies must appear in earlier or same phases | Add missing skill to an earlier phase |\n| **No circular deps** | Skill A depends on B, B must not depend on A (transitively) | Reject -- restructure skill selection |\n| **Cross-phase deps** | Dependencies can span phases | Valid as long as ordering is preserved |\n| **Registry existence** | Every skill ID must exist in the registry | Reject -- cannot compose with missing skills |\n\n### Validation Algorithm\n\n```\nFor each phase P in order:\n  For each skill S in P.skills:\n    For each dependency D of S:\n      Assert D appears in phase P or an earlier phase\n      Assert no circular path from D back to S\n\nIf any assertion fails:\n  Report missing dependency and suggest fix\n```\n\n### Dependency Resolution Checklist\n\n```markdown\n- [ ] All skill IDs exist in the registry\n- [ ] All skill dependencies are satisfied by earlier phases\n- [ ] No circular dependency chains detected\n- [ ] No duplicate skills across phases (unless intentional)\n- [ ] Meta skills (loop-controller) are in COMPLETE phase\n- [ ] Required infrastructure skills are included if needed\n```\n\n### Common Dependency Issues\n\n| Issue | Symptom | Resolution |\n|-------|---------|------------|\n| Missing prerequisite | Skill X needs Y, Y not in loop | Add Y to an earlier phase |\n| Wrong phase order | Dependency in later phase | Move dependency skill to earlier phase |\n| Circular chain | A needs B, B needs A | Remove one, or restructure into separate loops |\n| Orphan skill | Skill has no consumers | Remove if not needed, or note as intentionally terminal |\n\n## Step 6: Configuration\n\nConfigure the non-structural aspects of the loop: defaults, UI settings, skill display, and metadata.\n\n### Defaults Configuration\n\n```json\n{\n  \"defaults\": {\n    \"mode\": \"greenfield | brownfield\",\n    \"autonomy\": \"supervised | semi-autonomous | autonomous\"\n  }\n}\n```\n\n| Field | Options | Guidance |\n|-------|---------|----------|\n| `mode` | `greenfield`, `brownfield` | Greenfield for new projects, brownfield for existing codebases |\n| `autonomy` | `supervised`, `semi-autonomous`, `autonomous` | Start with supervised, relax as trust builds |\n\n### UI Configuration\n\n```json\n{\n  \"ui\": {\n    \"theme\": \"[domain-name]\",\n    \"layout\": \"chat-focused | dashboard\",\n    \"features\": {\n      \"skillBrowser\": true,\n      \"deliverableViewer\": true,\n      \"gateApprovalUI\": true,\n      \"progressTimeline\": true,\n      \"metricsPanel\": false\n    },\n    \"branding\": {\n      \"title\": \"[Loop Display Title]\",\n      \"subtitle\": \"[One-line description]\"\n    }\n  }\n}\n```\n\n| Feature | Enable When |\n|---------|-------------|\n| `skillBrowser` | Loop has many skills, users may want to explore |\n| `deliverableViewer` | Loop produces markdown deliverables for review |\n| `gateApprovalUI` | Loop has human gates requiring approval interface |\n| `progressTimeline` | Loop has 5+ phases, visual progress is helpful |\n| `metricsPanel` | Loop collects performance/quality metrics |\n\n### Skill UI Configuration\n\nFor each skill in the loop, define how it appears in the UI:\n\n```json\n{\n  \"skillUI\": {\n    \"[skill-id]\": {\n      \"displayName\": \"[Human-Readable Name]\",\n      \"icon\": \"[icon-name]\",\n      \"outputDisplay\": \"markdown | code | diff | table\"\n    }\n  }\n}\n```\n\n| `outputDisplay` | Use For |\n|-----------------|---------|\n| `markdown` | Documentation, specs, reviews, proposals |\n| `code` | Test generation, scaffolding output |\n| `diff` | Implementation changes, refactoring |\n| `table` | Matrix output, comparison data |\n\n### Metadata Configuration\n\n```json\n{\n  \"metadata\": {\n    \"author\": \"Orchestrator\",\n    \"tags\": [\"domain-tag\", \"scope-tag\", \"purpose-tag\"]\n  }\n}\n```\n\nTags should include:\n- **Domain tag**: engineering, proposal, security, content, analysis\n- **Scope tag**: full-loop, lightweight, focused, custom\n- **Purpose tag**: production, prototype, audit, research\n\n## Step 7: Composition\n\nAssemble all components into the final loop.json structure.\n\n### Assembly Order\n\n1. Set top-level identifiers: `id`, `name`, `version`, `description`\n2. Build `phases` array from Step 3 mapping\n3. Build `gates` array from Step 4 placement\n4. Set `defaults` from Step 6\n5. Set `ui` configuration from Step 6\n6. Set `skillUI` entries for each skill from Step 6\n7. Set `metadata` from Step 6\n\n### Loop ID Convention\n\n```\n[domain]-loop          # Primary domain loop: engineering-loop, proposal-loop\n[domain]-[variant]     # Variant loop: engineering-lite, proposal-quick\ncustom-loop-[timestamp] # Auto-generated: custom-loop-1706000000000\n```\n\n### Schema Validation Checklist\n\n```markdown\n- [ ] `id` is kebab-case, unique across all loops\n- [ ] `name` is human-readable title case\n- [ ] `version` follows semver (major.minor.patch)\n- [ ] `description` is one sentence summarizing the loop\n- [ ] `phases` is non-empty array in canonical order\n- [ ] Each phase has `name`, `skills` (non-empty), `required` (boolean)\n- [ ] `gates` reference valid phase names via `afterPhase`\n- [ ] Each gate has `id`, `name`, `afterPhase`, `required`, `approvalType`\n- [ ] `defaults.mode` is valid mode string\n- [ ] `defaults.autonomy` is valid autonomy level\n- [ ] `ui` has `theme`, `layout`, `features`, `branding`\n- [ ] `skillUI` has entry for each unique skill in the loop\n- [ ] `metadata` has `author` and `tags`\n```\n\n### Composition Template\n\n```json\n{\n  \"id\": \"[domain]-loop\",\n  \"name\": \"[Domain] Loop\",\n  \"version\": \"1.0.0\",\n  \"description\": \"[One sentence describing what this loop does]\",\n\n  \"phases\": [\n    { \"name\": \"INIT\", \"skills\": [\"[skill]\"], \"required\": true },\n    { \"name\": \"[PHASE]\", \"skills\": [\"[skill]\"], \"required\": true },\n    { \"name\": \"COMPLETE\", \"skills\": [\"loop-controller\"], \"required\": true }\n  ],\n\n  \"gates\": [\n    {\n      \"id\": \"[phase]-gate\",\n      \"name\": \"[Gate Name]\",\n      \"afterPhase\": \"[PHASE]\",\n      \"required\": true,\n      \"approvalType\": \"human\",\n      \"deliverables\": [\"[DELIVERABLE.md]\"]\n    }\n  ],\n\n  \"defaults\": {\n    \"mode\": \"greenfield\",\n    \"autonomy\": \"supervised\"\n  },\n\n  \"ui\": {\n    \"theme\": \"[domain]\",\n    \"layout\": \"chat-focused\",\n    \"features\": {\n      \"skillBrowser\": true,\n      \"deliverableViewer\": true,\n      \"gateApprovalUI\": true,\n      \"progressTimeline\": true,\n      \"metricsPanel\": false\n    },\n    \"branding\": {\n      \"title\": \"[Loop Title]\",\n      \"subtitle\": \"[Subtitle]\"\n    }\n  },\n\n  \"skillUI\": {\n    \"[skill-id]\": {\n      \"displayName\": \"[Display Name]\",\n      \"icon\": \"[icon]\",\n      \"outputDisplay\": \"markdown\"\n    }\n  },\n\n  \"metadata\": {\n    \"author\": \"Orchestrator\",\n    \"tags\": [\"[tag1]\", \"[tag2]\", \"[tag3]\"]\n  }\n}\n```\n\nSee `references/loop-schema.md` for the complete field reference.\n\n## Step 8: Testing\n\nValidate the composed loop before saving it. A broken loop.json will cause runtime failures in loop-controller.\n\n### Validation Levels\n\n| Level | What It Checks | When to Run |\n|-------|---------------|-------------|\n| **Schema** | JSON structure, required fields, types | Always |\n| **Referential** | Skills exist, phases valid, gates reference valid phases | Always |\n| **Dependency** | Skill dependencies satisfied across phases | Always |\n| **Semantic** | Reasonable phase ordering, sensible gate placement | On review |\n| **Dry-run** | Simulate loop execution without side effects | Before deployment |\n\n### Schema Validation\n\n```markdown\n- [ ] Valid JSON (parseable)\n- [ ] All required top-level fields present\n- [ ] `phases` array has valid entries\n- [ ] `gates` array has valid entries (or is empty)\n- [ ] `defaults` has valid mode and autonomy\n- [ ] No unknown fields at top level\n```\n\n### Referential Validation\n\n```markdown\n- [ ] Every skill ID in phases exists in the skill registry\n- [ ] Every `afterPhase` in gates matches a phase name in the phases array\n- [ ] No duplicate phase names\n- [ ] No duplicate gate IDs\n- [ ] Phase names are from the valid set (INIT, SCAFFOLD, ..., COMPLETE, META)\n```\n\n### Dependency Validation\n\n```markdown\n- [ ] Every skill's `depends_on` skills appear in the same or earlier phase\n- [ ] No circular dependency chains\n- [ ] No skill appears in multiple phases (unless intentional and documented)\n```\n\n### Semantic Validation\n\n```markdown\n- [ ] INIT is the first phase\n- [ ] COMPLETE is the last phase\n- [ ] Required phases have at least one required gate after them (for supervised loops)\n- [ ] Optional phases do not have required gates\n- [ ] Gate deliverables match expected skill outputs\n- [ ] Autonomy level is consistent with gate types\n```\n\n### Dry-Run Procedure\n\n1. Load the loop.json into LoopComposer\n2. Call `validateLoop(config)` to check errors and warnings\n3. Walk the phase sequence, verifying each skill can be loaded\n4. Confirm gate deliverables are producible by preceding skills\n5. Report any issues before saving\n\n### Testing Checklist\n\n```markdown\n- [ ] Schema validation passes\n- [ ] Referential validation passes\n- [ ] Dependency validation passes\n- [ ] Semantic validation passes (or warnings documented)\n- [ ] Dry-run completes without errors\n- [ ] loop.json saved to loops/[loop-id]/loop.json\n- [ ] LOOP.md saved to loops/[loop-id]/LOOP.md\n- [ ] COMPOSITION-NOTES.md saved (if non-obvious decisions were made)\n```\n\n## Output Formats\n\n### Quick Composition (Lightweight Loop)\n\n```markdown\n## Loop: [Domain] Loop\n\n### Summary\n[One paragraph describing the loop]\n\n### Phases\n| # | Phase | Skills | Required |\n|---|-------|--------|----------|\n| 1 | INIT | [skill] | Yes |\n| 2 | IMPLEMENT | [skill] | Yes |\n| 3 | COMPLETE | loop-controller | Yes |\n\n### Gates\n| Gate | After | Type |\n|------|-------|------|\n| [gate-name] | [phase] | human |\n\n### Files Generated\n- `loops/[id]/loop.json`\n- `loops/[id]/LOOP.md`\n```\n\n### Full Composition (Production Loop)\n\n```markdown\n## Loop: [Domain] Loop\n\n### Summary\n[Detailed paragraph describing the loop, its domain, and intended use]\n\n### Requirements Captured\n- Domain: [domain]\n- Outcome: [outcome]\n- Quality: [level]\n- Autonomy: [level]\n\n### Skill Selection\n| Phase | Skill | Reason Selected | Dependencies |\n|-------|-------|-----------------|--------------|\n| INIT | [skill] | [reason] | [deps] |\n| ... | ... | ... | ... |\n\n### Phase Sequence\n| # | Phase | Skills | Required | Rationale |\n|---|-------|--------|----------|-----------|\n| 1 | INIT | [skills] | Yes | [why] |\n| ... | ... | ... | ... | ... |\n\n### Gate Configuration\n| Gate ID | Name | After | Type | Required | Deliverables |\n|---------|------|-------|------|----------|--------------|\n| [id] | [name] | [phase] | [type] | [bool] | [files] |\n\n### Configuration\n- Mode: [greenfield/brownfield]\n- Autonomy: [level]\n- Theme: [theme]\n- Layout: [layout]\n\n### Validation Results\n- Schema: PASS\n- Referential: PASS\n- Dependency: PASS\n- Semantic: PASS (N warnings)\n\n### Files Generated\n- `loops/[id]/loop.json`\n- `loops/[id]/LOOP.md`\n- `loops/[id]/COMPOSITION-NOTES.md`\n```\n\n## Common Patterns\n\n### Engineering Loop Pattern\nFull software development lifecycle with all quality gates. 9 phases, 4 gates, supervised autonomy.\n**Use when:** Building production software with full rigor and human oversight at every decision boundary.\n\n### Proposal Loop Pattern\nResearch-to-document pipeline with context gathering and synthesis. 4 phases, 4 gates, supervised autonomy.\n**Use when:** Creating proposals, reports, or analysis documents from raw context and requirements.\n\n### Lightweight Loop Pattern\nMinimal viable loop with only INIT, IMPLEMENT, and COMPLETE. 3 phases, 1 gate, semi-autonomous.\n**Use when:** Quick prototyping, small features, or tasks where full rigor is overhead.\n\n### Infrastructure Loop Pattern\nSetup-focused loop with infrastructure skills: scaffold, database, docker, services. 5 phases, 2 gates.\n**Use when:** Standing up new project infrastructure, configuring environments, or setting up deployment pipelines.\n\nSee `references/composition-patterns.md` for complete examples of each pattern.\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `loop-controller` | Composer produces loop.json that controller executes at runtime |\n| `skill-design` | Dependency -- composer needs skills to exist before composing them into loops |\n| `architect` | Analogous -- architect designs system structure, composer designs loop structure |\n| `scaffold` | Analogous -- scaffold generates project files, composer generates loop files |\n| `orchestrator` | Orchestrator selects which loop to run; composer designs the loops it selects from |\n| `skill-verifier` | Verifier can validate that composed loops reference skills correctly |\n| `retrospective` | Retrospective output may suggest loop composition changes |\n| `spec` | Spec defines what to build; composer defines how the build process flows |\n\n## Key Principles\n\n**Compose, don't create.** Loops are compositions of existing skills. If a skill doesn't exist, use `skill-design` to create it first, then compose.\n\n**Canonical order is law.** Phases must follow INIT through COMPLETE ordering. There are no exceptions. Skipping phases is fine; reordering them is not.\n\n**Gates at decision boundaries.** Place gates where the cost of a wrong decision multiplied by the probability of error is highest. Not after every phase -- after consequential ones.\n\n**Dependencies flow forward.** A skill in phase N can depend on skills in phases 1 through N, never on phases N+1 and beyond. This is the fundamental constraint of sequential composition.\n\n**Start supervised, relax later.** New loops should default to supervised autonomy with human gates. As the loop proves reliable, gates can be changed to conditional or automated.\n\n**Every loop needs a controller.** The COMPLETE phase with loop-controller is non-negotiable. It handles finalization, metrics, and state cleanup that every loop requires.\n\n## References\n\n- `references/loop-schema.md`: Complete loop.json schema with all fields documented\n- `references/phase-sequencing.md`: Phase ordering rules, valid transitions, required vs optional\n- `references/gate-design.md`: Gate types, placement rules, autonomy interaction\n- `references/skill-selection.md`: Querying the registry, coverage analysis, dependency resolution\n- `references/composition-patterns.md`: Concrete examples -- engineering, proposal, lightweight, custom",
  "references": [
    {
      "name": "composition-patterns.md",
      "path": "references/composition-patterns.md",
      "content": "# Composition Patterns Reference\n\nConcrete, production-tested loop compositions for common use cases. Use these as starting points for new loops -- customize rather than compose from scratch.\n\n## Pattern 1: Engineering Loop (Full Rigor)\n\nThe flagship pattern. Complete software development lifecycle with comprehensive quality gates.\n\n### Characteristics\n\n| Property | Value |\n|----------|-------|\n| Phases | 9 (INIT through COMPLETE, skip VALIDATE) |\n| Gates | 4 (spec, architecture, review, deploy) |\n| Autonomy | supervised |\n| Mode | greenfield |\n| Skills | 9 unique |\n\n### Phase Layout\n\n```\nINIT ──────────── spec\n    [spec-gate]\nSCAFFOLD ──────── architect, scaffold\n    [architecture-gate]\nIMPLEMENT ─────── implement\nTEST ──────────── test-generation\nVERIFY ─────────── code-verification\nDOCUMENT ──────── document\nREVIEW ─────────── code-review\n    [review-gate]\nSHIP ──────────── deploy\n    [deploy-gate]\nCOMPLETE ──────── loop-controller\n```\n\n### When to Use\n\n- Building production software from requirements\n- Full team review and approval workflow\n- Projects where quality and correctness are paramount\n- New features in established codebases\n\n### When NOT to Use\n\n- Quick prototypes (too much overhead)\n- Non-code deliverables (use proposal or content pattern)\n- Infrastructure-only changes (use infrastructure pattern)\n\n### Key Design Decisions\n\n1. **SCAFFOLD has two skills** (architect + scaffold): Architecture decisions before file generation\n2. **DOCUMENT is optional**: Not all features need dedicated documentation\n3. **SHIP is optional**: Not all features deploy immediately\n4. **Deploy gate is conditional**: Only gates if SHIP phase ran\n\n### Customization Points\n\n| Modification | How |\n|-------------|-----|\n| Add security review | Add `security-audit` to REVIEW phase |\n| Add performance validation | Add VALIDATE phase with `perf-analysis` |\n| Remove documentation | Remove DOCUMENT phase |\n| Make autonomous | Change autonomy to `autonomous`, gates to `automated` |\n\n---\n\n## Pattern 2: Proposal Loop (Research to Document)\n\nContext-gathering and synthesis pipeline for creating proposals, analyses, and reports.\n\n### Characteristics\n\n| Property | Value |\n|----------|-------|\n| Phases | 4 (INIT, SCAFFOLD, IMPLEMENT, COMPLETE) |\n| Gates | 4 (context, cultivation, priorities, final) |\n| Autonomy | supervised |\n| Mode | greenfield |\n| Skills | 4 unique (all custom category) |\n\n### Phase Layout\n\n```\nINIT ──────────── context-ingestion\n    [context-gate]\nSCAFFOLD ──────── context-cultivation\n    [cultivation-gate]\nIMPLEMENT ─────── priority-matrix\n    [priorities-gate]\nCOMPLETE ──────── proposal-builder\n    [final-gate]\n```\n\n### When to Use\n\n- Creating proposals from raw research context\n- Analysis pipelines that synthesize information\n- Document-centric workflows (not code)\n- Consulting deliverables\n\n### Key Design Decisions\n\n1. **Gate after every phase**: Proposals require human judgment at each synthesis step\n2. **Custom skills only**: Domain-specific skills rather than engineering core skills\n3. **No TEST/VERIFY/REVIEW**: Not code, so code quality phases are irrelevant\n4. **COMPLETE produces output**: proposal-builder generates the final deliverable\n\n### Customization Points\n\n| Modification | How |\n|-------------|-----|\n| Add quantitative analysis | Add `perf-analysis` or custom analysis skill to IMPLEMENT |\n| Reduce gates | Remove cultivation-gate for faster iteration |\n| Add review cycle | Insert REVIEW phase with human review skill |\n| Multi-proposal | Run IMPLEMENT + COMPLETE multiple times with different parameters |\n\n---\n\n## Pattern 3: Lightweight Loop (Minimal Viable)\n\nFastest path from idea to output. Minimal phases, minimal gates, maximum velocity.\n\n### Characteristics\n\n| Property | Value |\n|----------|-------|\n| Phases | 3 (INIT, IMPLEMENT, COMPLETE) |\n| Gates | 1 (approval after INIT) |\n| Autonomy | semi-autonomous |\n| Mode | greenfield |\n| Skills | 3 unique |\n\n### Phase Layout\n\n```\nINIT ──────────── spec\n    [approval-gate]\nIMPLEMENT ─────── implement\nCOMPLETE ──────── loop-controller\n```\n\n### loop.json\n\n```json\n{\n  \"id\": \"lightweight-loop\",\n  \"name\": \"Lightweight Loop\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Minimal loop for quick prototyping and small features. Spec to implementation with one approval gate.\",\n\n  \"phases\": [\n    { \"name\": \"INIT\", \"skills\": [\"spec\"], \"required\": true },\n    { \"name\": \"IMPLEMENT\", \"skills\": [\"implement\"], \"required\": true },\n    { \"name\": \"COMPLETE\", \"skills\": [\"loop-controller\"], \"required\": true }\n  ],\n\n  \"gates\": [\n    {\n      \"id\": \"approval-gate\",\n      \"name\": \"Spec Approval\",\n      \"afterPhase\": \"INIT\",\n      \"required\": true,\n      \"approvalType\": \"human\",\n      \"deliverables\": [\"FEATURESPEC.md\"]\n    }\n  ],\n\n  \"defaults\": {\n    \"mode\": \"greenfield\",\n    \"autonomy\": \"semi-autonomous\"\n  },\n\n  \"ui\": {\n    \"theme\": \"engineering\",\n    \"layout\": \"chat-focused\",\n    \"features\": {\n      \"skillBrowser\": false,\n      \"deliverableViewer\": true,\n      \"gateApprovalUI\": true,\n      \"progressTimeline\": false,\n      \"metricsPanel\": false\n    },\n    \"branding\": {\n      \"title\": \"Quick Build\",\n      \"subtitle\": \"Prototype fast\"\n    }\n  },\n\n  \"skillUI\": {\n    \"spec\": {\n      \"displayName\": \"Quick Spec\",\n      \"icon\": \"document-text\",\n      \"outputDisplay\": \"markdown\"\n    },\n    \"implement\": {\n      \"displayName\": \"Implementation\",\n      \"icon\": \"code\",\n      \"outputDisplay\": \"diff\"\n    },\n    \"loop-controller\": {\n      \"displayName\": \"Finalize\",\n      \"icon\": \"check-circle\",\n      \"outputDisplay\": \"markdown\"\n    }\n  },\n\n  \"metadata\": {\n    \"author\": \"Orchestrator\",\n    \"tags\": [\"engineering\", \"lightweight\", \"prototype\"]\n  }\n}\n```\n\n### When to Use\n\n- Small features (under 1 day of work)\n- Prototypes and experiments\n- Scripts and utilities\n- When speed matters more than rigor\n\n### When NOT to Use\n\n- Production features (add TEST, VERIFY, REVIEW)\n- Multi-component systems (add SCAFFOLD)\n- Anything needing deployment (add SHIP)\n\n---\n\n## Pattern 4: Infrastructure Loop\n\nFocused on project setup, environment configuration, and infrastructure provisioning.\n\n### Characteristics\n\n| Property | Value |\n|----------|-------|\n| Phases | 5 (INIT, SCAFFOLD, IMPLEMENT, VERIFY, COMPLETE) |\n| Gates | 2 (architecture, verification) |\n| Autonomy | supervised |\n| Mode | greenfield |\n| Skills | 5-7 (mix of core and infra) |\n\n### Phase Layout\n\n```\nINIT ──────────── requirements\n    [requirements-gate]\nSCAFFOLD ──────── architect, scaffold\nIMPLEMENT ─────── infra-database, infra-docker, infra-services\nVERIFY ─────────── code-verification\n    [verification-gate]\nCOMPLETE ──────── loop-controller\n```\n\n### When to Use\n\n- New project bootstrapping\n- Adding database, Docker, or service layers\n- Environment configuration\n- DevOps pipeline setup\n\n### Key Design Decisions\n\n1. **requirements instead of spec**: Infrastructure needs requirements, not feature specs\n2. **Multiple IMPLEMENT skills**: Infrastructure often has parallel workstreams\n3. **No TEST phase**: Infrastructure testing is handled within implementation\n4. **No REVIEW or SHIP**: Infrastructure is verified, not reviewed or deployed as a feature\n\n---\n\n## Pattern 5: Security Audit Loop\n\nFocused assessment of code and system security posture.\n\n### Characteristics\n\n| Property | Value |\n|----------|-------|\n| Phases | 5 (INIT, IMPLEMENT, VERIFY, REVIEW, COMPLETE) |\n| Gates | 3 (requirements, findings, final) |\n| Autonomy | supervised |\n| Mode | brownfield |\n| Skills | 5 |\n\n### Phase Layout\n\n```\nINIT ──────────── requirements\n    [requirements-gate]\nIMPLEMENT ─────── implement\nVERIFY ─────────── code-verification\nREVIEW ─────────── security-audit, code-review\n    [findings-gate]\nCOMPLETE ──────── loop-controller\n    [final-gate]\n```\n\n### When to Use\n\n- Pre-launch security review\n- Compliance audits (SOC2, HIPAA)\n- Post-incident security hardening\n- Periodic security assessment\n\n---\n\n## Pattern Comparison Matrix\n\n| Aspect | Engineering | Proposal | Lightweight | Infrastructure | Security |\n|--------|------------|----------|-------------|----------------|----------|\n| Phases | 9 | 4 | 3 | 5 | 5 |\n| Gates | 4 | 4 | 1 | 2 | 3 |\n| Skills | 9 | 4 | 3 | 5-7 | 5 |\n| Autonomy | supervised | supervised | semi-auto | supervised | supervised |\n| Mode | greenfield | greenfield | greenfield | greenfield | brownfield |\n| Time | Hours-days | Hours | Minutes-hours | Hours | Hours |\n| Output | Code + docs | Document | Code | Config + infra | Report + fixes |\n\n## Composing Custom Loops\n\nWhen none of the standard patterns fit:\n\n1. **Identify the closest pattern** from the five above\n2. **Start with that pattern's phase layout**\n3. **Add phases** that the domain requires\n4. **Remove phases** that add no value\n5. **Swap skills** for domain-specific alternatives\n6. **Adjust gates** to match the decision boundary profile\n7. **Set defaults** for the domain's mode and autonomy needs\n8. **Validate** using the composition testing process\n\n### Example: Content Creation Loop (Custom)\n\nStarting from Proposal pattern, customized:\n\n```\nINIT ──────────── requirements (swapped from context-ingestion)\n    [brief-gate]\nSCAFFOLD ──────── architect (content structure design)\nIMPLEMENT ─────── implement (content writing)\nREVIEW ─────────── code-review (adapted for content review)\n    [editorial-gate]\nCOMPLETE ──────── loop-controller\n```\n\nChanges from proposal pattern:\n- Added REVIEW phase for editorial review\n- Swapped context-ingestion for requirements (clearer briefs)\n- Used architect for content structure (reusable skill)\n- Removed priority-matrix (not relevant for content)\n- Reduced gates from 4 to 2 (brief + editorial)\n"
    },
    {
      "name": "gate-design.md",
      "path": "references/gate-design.md",
      "content": "# Gate Design Reference\n\nComprehensive guide to designing and placing gates within loops. Gates are the human-in-the-loop mechanism that provides oversight, quality control, and decision authority at critical points in the workflow.\n\n## Gate Purpose\n\nGates serve three functions:\n\n1. **Quality checkpoint** -- Ensure the output of preceding phases meets standards before continuing\n2. **Decision point** -- Allow humans to approve, redirect, or abort based on intermediate results\n3. **Audit trail** -- Create a documented record of approvals and reviews for compliance\n\n## Gate Types\n\n### Human Gate\n\n```json\n{\n  \"id\": \"spec-gate\",\n  \"name\": \"Specification Approval\",\n  \"afterPhase\": \"INIT\",\n  \"required\": true,\n  \"approvalType\": \"human\",\n  \"deliverables\": [\"FEATURESPEC.md\"]\n}\n```\n\n**Behavior:** Loop pauses. Human reviews deliverables. Human explicitly approves or rejects.\n\n**Use when:**\n- Decisions are consequential and hard to reverse (architecture, spec, final review)\n- Stakeholder sign-off is required\n- Output quality cannot be assessed programmatically\n- Trust in the automation is still being established\n\n### Conditional Gate\n\n```json\n{\n  \"id\": \"deploy-gate\",\n  \"name\": \"Deployment Approval\",\n  \"afterPhase\": \"SHIP\",\n  \"required\": false,\n  \"approvalType\": \"conditional\",\n  \"deliverables\": []\n}\n```\n\n**Behavior:** Gate auto-clears if a condition is met (e.g., phase actually ran). Blocks if condition is not met.\n\n**Use when:**\n- Gate is needed only if an optional phase executed\n- Approval depends on runtime state rather than human judgment\n- Deployment gating (only gate if SHIP phase was included)\n\n### Automated Gate\n\n```json\n{\n  \"id\": \"test-gate\",\n  \"name\": \"Test Verification\",\n  \"afterPhase\": \"TEST\",\n  \"required\": true,\n  \"approvalType\": \"automated\",\n  \"deliverables\": [\"test-results.json\"]\n}\n```\n\n**Behavior:** Programmatic check runs automatically. Gate clears if check passes, blocks if check fails.\n\n**Use when:**\n- Pass/fail criteria are objective and measurable\n- Tests, linting, coverage thresholds, type checks\n- Speed is important and human review adds no value\n- Loop is configured for semi-autonomous or autonomous execution\n\n## Gate Placement Rules\n\n### Rule 1: After Decision Boundaries\n\nPlace gates where the cost of proceeding with a bad decision is high:\n\n| Boundary | Why Gate Here | Example |\n|----------|---------------|---------|\n| After INIT | Wrong spec leads to building the wrong thing | Spec Gate |\n| After SCAFFOLD | Wrong architecture is expensive to refactor | Architecture Gate |\n| After REVIEW | Merging bad code is hard to undo | Review Gate |\n| After COMPLETE | Final output needs stakeholder sign-off | Final Gate |\n\n### Rule 2: Deliverable-Backed\n\nEvery human gate should reference specific deliverables the reviewer examines. Gates without deliverables force reviewers to assess the phase's effect holistically, which is unreliable.\n\n```\nGOOD: \"deliverables\": [\"FEATURESPEC.md\"]\n      (Reviewer reads the spec)\n\nBAD:  \"deliverables\": []\n      (Reviewer must somehow assess \"was INIT done well?\")\n```\n\nException: Conditional and automated gates may have empty deliverables when the gate logic is programmatic.\n\n### Rule 3: Match Phase Required-ness\n\n| Phase Required? | Gate Required? | Valid? |\n|-----------------|----------------|--------|\n| Yes | Yes | Valid -- required phase, required gate |\n| Yes | No | Valid -- required phase, optional gate (skip-able review) |\n| No | Yes | INVALID -- cannot require gate on optional phase |\n| No | No | Valid -- optional phase, optional gate |\n\n### Rule 4: Diminishing Returns\n\nEach gate adds latency (waiting for human). Add gates only where the expected value of review exceeds the cost of delay.\n\n| Phases | Recommended Gates | Rationale |\n|--------|-------------------|-----------|\n| 3 (minimal) | 1 gate (after INIT) | Minimal overhead for minimal loop |\n| 5 (standard) | 2 gates (INIT, REVIEW) | Bookend review -- start and end |\n| 7 (quality) | 3 gates (INIT, SCAFFOLD, REVIEW) | Design review + output review |\n| 9 (full) | 3-4 gates (INIT, SCAFFOLD, REVIEW, SHIP) | Full oversight |\n\n### Rule 5: No Adjacent Gates\n\nAvoid placing gates after consecutive phases. If phases P1 and P2 are adjacent and both have gates, consider whether one gate after P2 covers both.\n\n## Autonomy and Gate Interaction\n\nThe loop's `defaults.autonomy` affects how gates behave:\n\n### Supervised (default)\n\n```\nAll gates active.\nHuman gates: require explicit approval.\nConditional gates: evaluate condition, block if unmet.\nAutomated gates: run checks, block if failed.\n```\n\n### Semi-Autonomous\n\n```\nCritical gates active (required: true, approvalType: \"human\").\nNon-critical gates: auto-clear with notification.\nAutomated gates: run checks silently.\n```\n\n### Autonomous\n\n```\nAll gates auto-clear.\nHuman notification sent at each gate point.\nAutomated gates still enforce pass/fail.\nLoop runs to completion unless automated gate fails.\n```\n\n## Gate Design Checklist\n\nWhen designing gates for a new loop:\n\n```markdown\n- [ ] Identified the 2-3 highest-consequence decision points\n- [ ] Each human gate has deliverables to review\n- [ ] No required gate on an optional phase\n- [ ] Gate count is proportional to loop length (not 1:1 with phases)\n- [ ] Gate IDs are unique and follow naming convention\n- [ ] Gate names are descriptive for the approval UI\n- [ ] Autonomy level is consistent with gate types chosen\n- [ ] Conditional gates have clear auto-clear conditions\n- [ ] Automated gates have measurable pass/fail criteria\n```\n\n## Gate Naming Convention\n\n```\n[context]-gate\n\nExamples:\n  spec-gate           (after INIT, reviews specification)\n  architecture-gate   (after SCAFFOLD, reviews architecture)\n  test-gate           (after TEST, verifies test results)\n  review-gate         (after REVIEW, approves code review)\n  deploy-gate         (after SHIP, approves deployment)\n  context-gate        (after INIT in proposal loops)\n  cultivation-gate    (after SCAFFOLD in proposal loops)\n  priorities-gate     (after IMPLEMENT in proposal loops)\n  final-gate          (after COMPLETE, final sign-off)\n```\n\n## Common Anti-Patterns\n\n| Anti-Pattern | Problem | Fix |\n|-------------|---------|-----|\n| Gate after every phase | Excessive latency, reviewer fatigue | Only gate at decision boundaries |\n| Gate with no deliverables | Reviewer has nothing concrete to assess | Add deliverable references |\n| Required gate on optional phase | Loop blocks on a phase that may not run | Make gate optional or phase required |\n| All automated gates on supervised loop | Contradicts supervision intent | Use human gates for critical points |\n| Human gate on trivial phase | Delays loop for no value | Remove gate or make automated |\n\n## Real-World Gate Configurations\n\n### Engineering Loop (4 gates)\n\n```\nINIT ──[spec-gate: human]──→ SCAFFOLD ──[architecture-gate: human]──→\nIMPLEMENT → TEST → VERIFY → DOCUMENT →\nREVIEW ──[review-gate: human]──→ SHIP ──[deploy-gate: conditional]──→ COMPLETE\n```\n\n### Proposal Loop (4 gates)\n\n```\nINIT ──[context-gate: human]──→ SCAFFOLD ──[cultivation-gate: human]──→\nIMPLEMENT ──[priorities-gate: human]──→ COMPLETE ──[final-gate: human]──→ END\n```\n\n### Lightweight Loop (1 gate)\n\n```\nINIT ──[approval-gate: human]──→ IMPLEMENT → COMPLETE\n```\n\n### Autonomous Loop (2 automated gates)\n\n```\nINIT → IMPLEMENT → TEST ──[test-gate: automated]──→\nVERIFY ──[verify-gate: automated]──→ COMPLETE\n```\n"
    },
    {
      "name": "loop-schema.md",
      "path": "references/loop-schema.md",
      "content": "# Loop Schema Reference\n\nComplete field-by-field documentation of the `loop.json` schema. This is the authoritative reference for every field a loop definition can contain.\n\n## Top-Level Structure\n\n```json\n{\n  \"id\": \"string (required)\",\n  \"name\": \"string (required)\",\n  \"version\": \"string (required)\",\n  \"description\": \"string (required)\",\n  \"phases\": \"Phase[] (required)\",\n  \"gates\": \"Gate[] (optional, default: [])\",\n  \"defaults\": \"Defaults (optional)\",\n  \"ui\": \"UIConfig (optional)\",\n  \"skillUI\": \"Record<string, SkillUIConfig> (optional)\",\n  \"metadata\": \"Metadata (optional)\"\n}\n```\n\n## Field Reference\n\n### `id` (string, required)\n\nUnique identifier for the loop. Used as the directory name under `loops/` and as the key in the loop registry.\n\n- **Format:** kebab-case, lowercase, alphanumeric with hyphens\n- **Convention:** `[domain]-loop` for primary loops, `[domain]-[variant]` for variants\n- **Examples:** `engineering-loop`, `proposal-loop`, `security-audit`, `engineering-lite`\n- **Constraint:** Must be unique across all loops in the system\n\n### `name` (string, required)\n\nHuman-readable display name for the loop.\n\n- **Format:** Title Case\n- **Examples:** `\"Engineering Loop\"`, `\"Proposal Loop\"`, `\"Security Audit Loop\"`\n\n### `version` (string, required)\n\nSemantic version of the loop definition.\n\n- **Format:** `major.minor.patch` (semver)\n- **Increment major:** Breaking changes to phase structure or gates\n- **Increment minor:** New skills added, optional phases added\n- **Increment patch:** Description changes, UI tweaks, metadata updates\n\n### `description` (string, required)\n\nOne-sentence summary of the loop's purpose. Displayed in loop listings and selection UIs.\n\n- **Max length:** 200 characters (truncated in list views)\n- **Should answer:** \"What does this loop do from start to finish?\"\n\n## Phase Object\n\n```json\n{\n  \"name\": \"Phase (required)\",\n  \"skills\": \"string[] (required, non-empty)\",\n  \"required\": \"boolean (required)\"\n}\n```\n\n### `name` (Phase enum, required)\n\nMust be one of the canonical phases:\n\n| Phase | Position | Typical Purpose |\n|-------|----------|-----------------|\n| `INIT` | First | Requirements, spec, context gathering |\n| `SCAFFOLD` | Early | Architecture, project structure, design |\n| `IMPLEMENT` | Middle | Core implementation, coding |\n| `TEST` | Middle | Test generation, test execution |\n| `VERIFY` | Middle | Structural verification, lint, type checks |\n| `VALIDATE` | Middle | Semantic validation, performance, correctness |\n| `DOCUMENT` | Late | Documentation generation |\n| `REVIEW` | Late | Code review, architecture review |\n| `SHIP` | Late | Deployment, release |\n| `COMPLETE` | Last | Loop finalization, metrics, cleanup |\n| `META` | Any | Meta-operations (rarely used in loop definitions) |\n\n### `skills` (string[], required)\n\nArray of skill IDs to execute during this phase, in order.\n\n- **Non-empty:** At least one skill per phase\n- **Ordered:** Skills execute sequentially within a phase\n- **Valid:** Each skill ID must exist in the skill registry\n\n### `required` (boolean, required)\n\nWhether this phase must execute for the loop to complete.\n\n- `true`: Phase cannot be skipped, loop fails if phase fails\n- `false`: Phase can be skipped by user or automation\n\n## Gate Object\n\n```json\n{\n  \"id\": \"string (required)\",\n  \"name\": \"string (required)\",\n  \"afterPhase\": \"Phase (required)\",\n  \"required\": \"boolean (required)\",\n  \"approvalType\": \"ApprovalType (required)\",\n  \"deliverables\": \"string[] (required, can be empty)\"\n}\n```\n\n### `id` (string, required)\n\nUnique identifier for the gate within this loop.\n\n- **Format:** kebab-case\n- **Convention:** `[phase-or-purpose]-gate`\n- **Examples:** `spec-gate`, `architecture-gate`, `review-gate`, `deploy-gate`\n\n### `name` (string, required)\n\nHuman-readable name displayed in the gate approval UI.\n\n- **Examples:** `\"Specification Approval\"`, `\"Architecture Review\"`, `\"Deployment Approval\"`\n\n### `afterPhase` (Phase, required)\n\nThe phase after which this gate is placed. Execution pauses here until the gate is cleared.\n\n- **Must reference** a phase that exists in the loop's `phases` array\n- Gate blocks execution of the next phase in sequence\n\n### `required` (boolean, required)\n\nWhether the gate must be cleared for the loop to proceed.\n\n- `true`: Loop cannot continue past this gate without approval\n- `false`: Gate can be auto-cleared or skipped\n\n### `approvalType` (enum, required)\n\nHow the gate is cleared:\n\n| Type | Behavior | Use When |\n|------|----------|----------|\n| `\"human\"` | Human must explicitly approve | Critical decisions, spec/architecture/review |\n| `\"conditional\"` | Auto-clears if condition is met, else blocks | Deployment (only if SHIP ran) |\n| `\"automated\"` | Programmatic check, no human needed | Test pass/fail, lint results |\n\n### `deliverables` (string[], required)\n\nFiles the human should review before approving the gate.\n\n- Can be empty array `[]` for automated or conditional gates\n- Files are relative to the execution directory\n- **Examples:** `[\"FEATURESPEC.md\"]`, `[\"ARCHITECTURE.md\", \"docs/adr/ADR-001.md\"]`\n\n## Defaults Object\n\n```json\n{\n  \"mode\": \"LoopMode (optional, default: 'greenfield')\",\n  \"autonomy\": \"AutonomyLevel (optional, default: 'supervised')\"\n}\n```\n\n### `mode` (LoopMode enum)\n\n| Value | Meaning |\n|-------|---------|\n| `\"greenfield\"` | New project, no existing code constraints |\n| `\"brownfield\"` | Existing codebase, must respect existing patterns |\n\n### `autonomy` (AutonomyLevel enum)\n\n| Value | Meaning |\n|-------|---------|\n| `\"supervised\"` | Human approves every gate |\n| `\"semi-autonomous\"` | Human approves critical gates, others automated |\n| `\"autonomous\"` | All gates automated, human notified |\n\n## UI Configuration Object\n\n```json\n{\n  \"theme\": \"string\",\n  \"layout\": \"string\",\n  \"features\": {\n    \"skillBrowser\": \"boolean\",\n    \"deliverableViewer\": \"boolean\",\n    \"gateApprovalUI\": \"boolean\",\n    \"progressTimeline\": \"boolean\",\n    \"metricsPanel\": \"boolean\"\n  },\n  \"branding\": {\n    \"title\": \"string\",\n    \"subtitle\": \"string\"\n  }\n}\n```\n\n### `theme` (string)\n\nVisual theme identifier. Typically matches the domain: `\"engineering\"`, `\"proposal\"`, `\"security\"`.\n\n### `layout` (string)\n\nUI layout mode:\n- `\"chat-focused\"`: Primary chat interface with side panels\n- `\"dashboard\"`: Multi-panel dashboard layout\n\n### `features` (object)\n\nToggle individual UI features on/off based on the loop's needs.\n\n### `branding` (object)\n\nDisplay title and subtitle shown in the loop UI header.\n\n## Skill UI Configuration\n\n```json\n{\n  \"[skill-id]\": {\n    \"displayName\": \"string\",\n    \"icon\": \"string\",\n    \"outputDisplay\": \"string\"\n  }\n}\n```\n\nOne entry per unique skill used in the loop. Controls how each skill appears in the UI.\n\n### `outputDisplay` options\n\n| Value | Renders As |\n|-------|-----------|\n| `\"markdown\"` | Rendered markdown document |\n| `\"code\"` | Syntax-highlighted code block |\n| `\"diff\"` | Side-by-side or unified diff view |\n| `\"table\"` | Structured table display |\n\n## Metadata Object\n\n```json\n{\n  \"author\": \"string\",\n  \"tags\": \"string[]\"\n}\n```\n\n### `author` (string)\n\nCreator of the loop definition. Typically `\"Orchestrator\"` for system-generated loops.\n\n### `tags` (string[])\n\nSearchable tags for loop discovery. Include domain, scope, and purpose tags.\n\n## Complete Example\n\nSee the engineering-loop (`loops/engineering-loop/loop.json`) and proposal-loop (`loops/proposal-loop/loop.json`) for production examples.\n"
    },
    {
      "name": "phase-sequencing.md",
      "path": "references/phase-sequencing.md",
      "content": "# Phase Sequencing Reference\n\nRules and guidance for ordering phases within a loop. Phase sequencing is the structural backbone of every loop -- get it wrong and skills execute in an invalid order.\n\n## Canonical Phase Order\n\nEvery loop must respect the canonical ordering. Phases can be omitted but never reordered.\n\n```\nPosition 1:  INIT        -- Requirements, context, specification\nPosition 2:  SCAFFOLD    -- Architecture, project structure, design\nPosition 3:  IMPLEMENT   -- Core implementation, coding\nPosition 4:  TEST        -- Test generation and execution\nPosition 5:  VERIFY      -- Structural verification (lint, types, complexity)\nPosition 6:  VALIDATE    -- Semantic validation (correctness, performance)\nPosition 7:  DOCUMENT    -- Documentation generation\nPosition 8:  REVIEW      -- Code review, architecture review\nPosition 9:  SHIP        -- Deployment, release, distribution\nPosition 10: COMPLETE    -- Loop finalization, metrics, cleanup\nSpecial:     META        -- Meta-operations (outside standard flow)\n```\n\n## Phase Categories\n\n### Always Required\n\n| Phase | Why |\n|-------|-----|\n| INIT | Every loop must begin somewhere -- requirements, context, or specification |\n| COMPLETE | Every loop must finalize -- cleanup, metrics, state transitions |\n\n### Typically Required\n\n| Phase | Why |\n|-------|-----|\n| IMPLEMENT | Most loops produce something -- code, documents, analysis |\n| SCAFFOLD | Design before implementation prevents rework |\n\n### Conditionally Required\n\n| Phase | Include When |\n|-------|-------------|\n| TEST | Loop produces code that needs testing |\n| VERIFY | Loop produces code that needs structural checking |\n| VALIDATE | Loop needs semantic correctness checks |\n| REVIEW | Loop output needs human quality assessment |\n\n### Typically Optional\n\n| Phase | Include When |\n|-------|-------------|\n| DOCUMENT | Loop output needs documentation beyond the deliverables themselves |\n| SHIP | Loop output needs to be deployed or distributed |\n\n## Valid Phase Subsets\n\nNot every loop needs all 10 phases. Here are common valid subsets:\n\n### Minimal (3 phases)\n```\nINIT → IMPLEMENT → COMPLETE\n```\nUse for: Quick prototypes, focused tasks, scripting.\n\n### Standard (5 phases)\n```\nINIT → SCAFFOLD → IMPLEMENT → REVIEW → COMPLETE\n```\nUse for: Features that need design and review but not full testing infrastructure.\n\n### Quality (7 phases)\n```\nINIT → SCAFFOLD → IMPLEMENT → TEST → VERIFY → REVIEW → COMPLETE\n```\nUse for: Production code with testing and verification.\n\n### Full (9 phases)\n```\nINIT → SCAFFOLD → IMPLEMENT → TEST → VERIFY → DOCUMENT → REVIEW → SHIP → COMPLETE\n```\nUse for: Full engineering lifecycle with documentation and deployment.\n\n### Research (4 phases)\n```\nINIT → SCAFFOLD → IMPLEMENT → COMPLETE\n```\nUse for: Proposal loops, analysis pipelines, content creation.\n\n## Phase Transition Rules\n\n### Valid Transitions\n\nAny phase can transition to any later phase in the canonical order. Skipping phases is valid.\n\n```\nINIT → SCAFFOLD       (standard next)\nINIT → IMPLEMENT      (skip SCAFFOLD)\nINIT → COMPLETE       (skip everything -- degenerate but valid)\nSCAFFOLD → IMPLEMENT  (standard next)\nSCAFFOLD → REVIEW     (skip middle phases)\nIMPLEMENT → TEST      (standard next)\nIMPLEMENT → COMPLETE  (skip quality phases)\n```\n\n### Invalid Transitions\n\nA phase can NEVER transition to an earlier phase. Loops do not cycle.\n\n```\nIMPLEMENT → INIT       (INVALID -- backward)\nREVIEW → IMPLEMENT     (INVALID -- backward)\nCOMPLETE → INIT        (INVALID -- backward, loops don't repeat)\n```\n\n### META Phase\n\nThe META phase is special -- it exists outside the canonical order and is used for meta-skills that operate on the loop itself (like loop-controller during certain operations). In practice, META is rarely used in loop.json definitions.\n\n## Phase-Skill Mapping Guidance\n\nWhile any skill CAN be assigned to any phase, the following are conventional assignments:\n\n| Phase | Natural Skills | Anti-pattern |\n|-------|---------------|--------------|\n| INIT | spec, entry-portal, requirements, context-ingestion | Putting implementation skills in INIT |\n| SCAFFOLD | architect, scaffold, context-cultivation | Putting review skills in SCAFFOLD |\n| IMPLEMENT | implement, error-handling, priority-matrix | Putting spec skills in IMPLEMENT |\n| TEST | test-generation, integration-test | Putting deployment in TEST |\n| VERIFY | code-verification | Putting documentation in VERIFY |\n| VALIDATE | code-validation, perf-analysis | Skipping validation for security-critical code |\n| DOCUMENT | document | Excessive documentation for prototypes |\n| REVIEW | code-review, security-audit | Review before implementation |\n| SHIP | deploy, distribute | Shipping without review |\n| COMPLETE | loop-controller, proposal-builder | Non-finalization skills in COMPLETE |\n\n## Required vs Optional Decision Matrix\n\n| Factor | Mark Required | Mark Optional |\n|--------|--------------|---------------|\n| Loop cannot succeed without this phase | Yes | -- |\n| Phase produces a deliverable that downstream phases need | Yes | -- |\n| Phase has a required gate after it | Yes | -- |\n| Phase is INIT or COMPLETE | Yes | -- |\n| Phase adds value but loop can succeed without it | -- | Yes |\n| Phase is domain-specific, not universally needed | -- | Yes |\n| Stakeholder may choose to skip at runtime | -- | Yes |\n| Phase is DOCUMENT or SHIP | Usually | Yes |\n\n## Phase Ordering Validation Algorithm\n\n```\nGiven: phases[] from loop.json\n\ncanonical = [INIT, SCAFFOLD, IMPLEMENT, TEST, VERIFY, VALIDATE, DOCUMENT, REVIEW, SHIP, COMPLETE]\n\nFor i = 0 to phases.length - 1:\n  Assert phases[i].name is in canonical\n  If i > 0:\n    Assert indexOf(canonical, phases[i].name) > indexOf(canonical, phases[i-1].name)\n\nAssert phases[0].name == \"INIT\"\nAssert phases[phases.length - 1].name == \"COMPLETE\"\nAssert no duplicate phase names\n```\n\nAny violation of these assertions is a composition error that must be fixed before the loop can be saved.\n"
    },
    {
      "name": "skill-selection.md",
      "path": "references/skill-selection.md",
      "content": "# Skill Selection Reference\n\nHow to query, filter, evaluate, and select skills from the registry for loop composition. Skill selection is the most consequential step in composition -- the wrong skills produce the wrong loop.\n\n## The Skill Registry\n\nThe skill registry is served by the skills-library-mcp service. It exposes:\n\n| Operation | Description | Use In Composition |\n|-----------|-------------|-------------------|\n| `list_skills` | List all skills with optional phase/category filter | Initial discovery |\n| `get_skill` | Get full skill definition including SKILL.md content | Detailed evaluation |\n| `search_skills` | Search by keyword in name and description | Domain-specific discovery |\n| `validate_selection` | Validate a set of skills for loop composition | Pre-composition check |\n| `get_phases` | List all phases with their associated skills | Phase coverage analysis |\n\n## Discovery Strategies\n\n### Strategy 1: Phase-First (Recommended for Standard Loops)\n\nStart with the phases you need, then find skills for each:\n\n```\n1. Determine required phases (e.g., INIT, SCAFFOLD, IMPLEMENT, TEST, REVIEW, COMPLETE)\n2. For each phase, query: list_skills(phase: \"[PHASE]\")\n3. From each result set, select the best-fitting skill(s)\n4. Fill gaps where no skill matches\n```\n\n**Best for:** Engineering loops, standard workflows where phase structure is clear.\n\n### Strategy 2: Domain-First (Recommended for Custom Loops)\n\nStart with the domain, find relevant skills, then map to phases:\n\n```\n1. Search: search_skills(query: \"[domain keyword]\")\n2. Filter results by relevance to the loop's purpose\n3. Group selected skills by their assigned phase\n4. Fill phase gaps with core skills\n```\n\n**Best for:** Proposal loops, analysis pipelines, domain-specific workflows.\n\n### Strategy 3: Dependency-First (Recommended for Extension Loops)\n\nStart with a must-have skill, pull in its dependency tree:\n\n```\n1. Identify the essential skill(s) for the loop\n2. Get full definition: get_skill(name: \"[skill]\", includeReferences: true)\n3. Read depends_on field for each skill\n4. Recursively resolve dependencies\n5. Map the full set to phases\n```\n\n**Best for:** Loops built around a specific capability (e.g., security audit loop built around security-audit skill).\n\n### Strategy 4: Template-First (Recommended for Quick Composition)\n\nStart with a known pattern, customize:\n\n```\n1. Pick a composition pattern (engineering, proposal, lightweight)\n2. Use the template's skill set as starting point\n3. Add/remove/swap skills for the specific use case\n4. Re-validate phase coverage\n```\n\n**Best for:** Loops that are variants of existing patterns.\n\n## Skill Evaluation Criteria\n\nWhen multiple skills could fill a phase, evaluate:\n\n| Criterion | Weight | Question | How to Assess |\n|-----------|--------|----------|---------------|\n| Domain fit | Critical | Does this skill serve the loop's domain? | Read skill description and tags |\n| Phase alignment | Critical | Is the skill designed for this phase? | Check skill's `phase` field |\n| Dependency cost | High | How many additional skills does it require? | Check `depends_on` field |\n| Category match | Medium | Core? Specialized? Infrastructure? | Match to loop type |\n| Output compatibility | Medium | Does its output feed the next phase's input? | Read deliverable descriptions |\n| Maturity | Low | Does it have references? Is it well-documented? | Check `referenceCount` |\n\n### Decision Matrix Example\n\nChoosing an INIT skill for a security-focused loop:\n\n| Criterion | Weight | `spec` | `entry-portal` | `requirements` |\n|-----------|--------|--------|-----------------|----------------|\n| Domain fit | 5 | 3 (15) | 2 (10) | 4 (20) |\n| Phase alignment | 5 | 5 (25) | 5 (25) | 5 (25) |\n| Dependency cost | 3 | 1 (3) | 2 (6) | 1 (3) |\n| Output compatibility | 4 | 4 (16) | 3 (12) | 4 (16) |\n| **Total** | | **59** | **53** | **64** |\n\nResult: `requirements` wins for a security-focused loop because its output (requirements document) feeds security-audit better than a feature spec.\n\n## Coverage Analysis\n\nAfter selecting skills, verify coverage across all required phases:\n\n```markdown\n### Coverage Report\n\n| Phase | Required | Skills Selected | Coverage |\n|-------|----------|----------------|----------|\n| INIT | Yes | spec | COVERED |\n| SCAFFOLD | Yes | architect, scaffold | COVERED |\n| IMPLEMENT | Yes | implement | COVERED |\n| TEST | Yes | test-generation | COVERED |\n| VERIFY | Yes | code-verification | COVERED |\n| VALIDATE | No | -- | SKIPPED (optional) |\n| DOCUMENT | No | document | COVERED |\n| REVIEW | Yes | code-review | COVERED |\n| SHIP | No | deploy | COVERED |\n| COMPLETE | Yes | loop-controller | COVERED |\n\nStatus: ALL REQUIRED PHASES COVERED\nGaps: None\n```\n\n### Gap Resolution\n\nIf a required phase has no skill:\n\n| Situation | Resolution |\n|-----------|------------|\n| No skill exists for the phase | Create a new skill using `skill-design`, then compose |\n| Skill exists but wrong category | Assess whether it can serve the purpose anyway |\n| Multiple skills, none ideal | Compose multiple partial-fit skills in the phase |\n| Phase is not actually needed | Remove phase from requirements, mark as optional |\n\n## Dependency Resolution\n\n### Forward Dependency Rule\n\nIf skill A in phase N depends on skill B, then B must appear in phase N or an earlier phase.\n\n```\nPhase 1 (INIT):      [spec]           -- no dependencies\nPhase 2 (SCAFFOLD):  [architect]      -- depends_on: [] (OK)\nPhase 3 (IMPLEMENT): [implement]      -- depends_on: [spec] (OK, spec is in phase 1)\n```\n\n### Dependency Resolution Algorithm\n\n```\nselected_skills = skills chosen for the loop\nresolved = empty set\n\nFor each skill S in selected_skills (in phase order):\n  For each dependency D in S.depends_on:\n    If D not in resolved AND D not in selected_skills:\n      Find D in registry\n      Add D to the earliest valid phase\n      Add D to selected_skills\n    Add S to resolved\n\nReturn updated selected_skills\n```\n\n### Circular Dependency Detection\n\n```\nFor each skill S:\n  Walk dependency chain: S → D1 → D2 → ...\n  If S appears in the chain: CIRCULAR DEPENDENCY\n  Report: \"Skill [S] has circular dependency through [chain]\"\n  Resolution: Remove one skill, restructure, or file a bug\n```\n\n## Skill Categories and Loop Types\n\n| Loop Type | Primary Categories | Secondary Categories |\n|-----------|--------------------|---------------------|\n| Engineering | core | infra, specialized |\n| Proposal | custom | core |\n| Security | core (security-audit, code-verification) | specialized |\n| Infrastructure | infra | core |\n| Content | custom, specialized | core |\n| Meta/Process | meta | core |\n\n## Common Skill Combinations\n\nThese skill groups frequently appear together:\n\n| Combination | Phase Spread | Purpose |\n|-------------|-------------|---------|\n| spec + architect + scaffold | INIT + SCAFFOLD | Full design pipeline |\n| implement + error-handling | IMPLEMENT | Robust implementation |\n| test-generation + integration-test | TEST | Comprehensive testing |\n| code-verification + code-validation | VERIFY + VALIDATE | Full quality check |\n| code-review + security-audit | REVIEW | Thorough review |\n| deploy + distribute | SHIP | Full deployment |\n| context-ingestion + context-cultivation | INIT + SCAFFOLD | Research pipeline |\n| priority-matrix + proposal-builder | IMPLEMENT + COMPLETE | Analysis to output |\n\n## Validation Before Composition\n\nBefore proceeding to phase mapping, run:\n\n```\nvalidate_selection(skills: [list of selected skill IDs])\n```\n\nThis checks:\n- All skill IDs exist in the registry\n- Dependencies between selected skills are satisfiable\n- No circular dependencies\n- Skills can be assigned to valid phases\n\nFix any validation errors before proceeding to Step 3 (Phase Mapping).\n"
    }
  ],
  "tags": [
    "meta",
    "loops",
    "composition",
    "design",
    "orchestration"
  ],
  "dependsOn": [
    "skill-design"
  ]
}