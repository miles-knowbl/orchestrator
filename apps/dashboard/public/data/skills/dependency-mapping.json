{
  "id": "dependency-mapping",
  "name": "dependency-mapping",
  "version": "1.0.0",
  "description": "Map cross-pipeline dependencies and handoffs (X-series). Identifies where pipelines connect, share data, or have timing dependencies. Documents failure modes at integration boundaries that span multiple pipelines.",
  "phase": "INIT",
  "category": "core",
  "content": "# Dependency Mapping\n\nMap cross-pipeline dependencies (X-series).\n\n## When to Use\n\n- **After pipeline discovery** — Runs after P-series and U-series are identified\n- **Understanding integration points** — Document where pipelines connect\n- **Identifying cross-cutting failures** — Find failure modes at boundaries\n- When you say: \"map the dependencies\", \"find integration points\", \"what connects these?\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `dependency-identification.md` | How to find cross-pipeline dependencies |\n| `dependency-diagram.md` | Visualization format |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `x-series-patterns.md` | Common cross-pipeline failure patterns |\n\n**Verification:** All pipeline handoffs are documented with failure modes.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Dependency map | `AUDIT-SCOPE.md` | Always (X-series section) |\n| X-series failure modes | `PIPELINE-FAILURE-MODES.md` | Always |\n\n## Core Concept\n\nDependency Mapping answers: **\"Where do pipelines connect and what can fail there?\"**\n\nCross-pipeline failures occur at:\n- **Data handoffs** — One pipeline's output is another's input\n- **Shared state** — Multiple pipelines read/write same data\n- **Timing dependencies** — One pipeline must complete before another starts\n- **Event chains** — One pipeline triggers another\n\nThese are often the most dangerous failures because:\n- No single pipeline \"owns\" them\n- They're invisible in unit tests\n- They only appear under specific conditions\n\n## Dependency Types\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                  DEPENDENCY TYPES                           │\n│                                                             │\n│  DATA HANDOFF                                               │\n│    P1 produces data → P2 consumes it                        │\n│    X-001: P1 output missing field P2 expects               │\n│                                                             │\n│  SHARED STATE                                               │\n│    P1 and U1 both read/write user.preferences               │\n│    X-002: Race condition on concurrent updates              │\n│                                                             │\n│  TIMING DEPENDENCY                                          │\n│    P2 must wait for P1.source_schema to exist              │\n│    X-003: P2 runs before P1 completes                       │\n│                                                             │\n│  EVENT CHAIN                                                │\n│    P3.publish triggers U2.notification                      │\n│    X-004: Event lost, notification never shows              │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Discovery Process\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│             DEPENDENCY MAPPING PROCESS                      │\n│                                                             │\n│  1. FOR EACH PIPELINE                                       │\n│     ├─→ What data does it consume? (inputs)                │\n│     └─→ What data does it produce? (outputs)               │\n│                                                             │\n│  2. FIND CONNECTIONS                                        │\n│     └─→ Where output of one = input of another             │\n│                                                             │\n│  3. IDENTIFY SHARED STATE                                   │\n│     └─→ Tables/state accessed by multiple pipelines        │\n│                                                             │\n│  4. MAP TIMING DEPENDENCIES                                 │\n│     └─→ What must exist before pipeline can run            │\n│                                                             │\n│  5. DOCUMENT FAILURE MODES                                  │\n│     └─→ What can go wrong at each boundary                 │\n│                                                             │\n│  6. ASSIGN X-SERIES IDS                                     │\n│     └─→ X-001, X-002... per dependency                     │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Dependency Documentation Format\n\n```markdown\n### X-001: P1 → P2 (source_schema handoff)\n\n**Type:** Data Handoff\n**From:** P1 (Source Ingestion)\n**To:** P2 (Content Generation)\n\n**Dependency:**\nP2 reads `source_schema` produced by P1 to build prompts.\n\n**Failure Modes:**\n\n| ID | Failure | Severity | Detection |\n|----|---------|----------|-----------|\n| X-001a | source_schema is null | S4-Blocking | P2 throws |\n| X-001b | source_schema is stale | S1-Silent | Lower quality output |\n| X-001c | source_schema format changed | S3-Visible | Parse error |\n\n**Validation:**\n- [ ] P2 checks source_schema exists before use\n- [ ] P2 handles null gracefully\n- [ ] Schema version is validated\n```\n\n## Output Format\n\n### In AUDIT-SCOPE.md\n\n```markdown\n## Cross-Pipeline Dependencies (X-series)\n\n### Dependency Map\n\n```\nP1 (Source Ingestion)\n  │\n  ├──[source_schema]──► P2 (Content Generation)\n  │                       │\n  └──[source_id]─────────►├──[artifact_id]──► U1 (Chat-to-Edit)\n                          │\n                          └──[artifact_id]──► P3 (Publishing)\n                                               │\n                                               └──[post_status]──► U3 (Status Display)\n```\n\n### Dependencies\n\n| ID | Type | From | To | Data | Risk |\n|----|------|------|----|----|------|\n| X-001 | Data Handoff | P1 | P2 | source_schema | High |\n| X-002 | Shared State | P2, U1 | - | artifact.content | Medium |\n| X-003 | Timing | P1 | P2 | source ready | High |\n| X-004 | Event Chain | P3 | U3 | publish event | Medium |\n```\n\n### In audit-state.json\n\n```json\n{\n  \"dependencies\": [\n    {\n      \"id\": \"X-001\",\n      \"type\": \"data_handoff\",\n      \"from\": \"P1\",\n      \"to\": \"P2\",\n      \"data\": \"source_schema\",\n      \"failure_modes\": [\"X-001a\", \"X-001b\", \"X-001c\"]\n    }\n  ]\n}\n```\n\n## Common X-Series Patterns\n\n| Pattern | Example | Typical Failures |\n|---------|---------|------------------|\n| Schema Handoff | P1 schema → P2 prompt | Missing fields, format changes |\n| ID Reference | P2 artifact_id → U1 edit | Invalid ID, deleted entity |\n| Status Sync | P3 status → U3 display | Stale status, race condition |\n| Event Propagation | P3 event → U2 notification | Lost event, duplicate delivery |\n| Context Sync | U1 selection → U2 action | Stale context, wrong entity |\n\n## Failure Mode Format\n\nX-series failure modes follow the same MECE taxonomy:\n\n```yaml\nid: X-001a\ndependency: X-001\nlocation: L4-Integration  # Always L4 for cross-pipeline\ntype: T1-Data\nseverity: S4-Blocking\ndescription: source_schema is null when P2 runs\nimpact: Generation fails completely\ndetection: Error thrown in P2\nstatus: UNVALIDATED\n```\n\n## Validation Checklist\n\n- [ ] All P-series outputs mapped to consumers\n- [ ] All U-series context dependencies documented\n- [ ] Shared state identified and race conditions analyzed\n- [ ] Timing dependencies have validation checks\n- [ ] Each dependency has at least one failure mode\n- [ ] X-series IDs assigned consistently",
  "references": [
    {
      "name": "dependency-diagram.md",
      "path": "references/dependency-diagram.md",
      "content": "# Dependency Diagram\n\nVisualization format for cross-pipeline dependencies.\n\n## ASCII Diagram Format\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                    PIPELINE DEPENDENCY MAP                   │\n├─────────────────────────────────────────────────────────────┤\n│                                                             │\n│  P1 (Source Ingestion)                                      │\n│    │                                                        │\n│    ├──[source_schema]──► P2 (Content Generation)            │\n│    │                       │                                │\n│    └──[source_id]─────────►├──[artifact_id]──► U1 (Edit)    │\n│                            │                    │           │\n│                            └──[artifact_id]──► P3 (Publish) │\n│                                                 │           │\n│  U3 (Selection) ──[selected_ids]───────────────►│           │\n│                                                 │           │\n│                                                 └──► U4     │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Legend\n\n```\nP{N}  = Backend pipeline\nU{N}  = UI pipeline\n──►   = Data flow direction\n[x]   = Data being passed\n```\n\n## Dependency Table Format\n\n| ID | Type | From | To | Data | Failure Risk |\n|----|------|------|----|----|--------------|\n| X-001 | Data Handoff | P1 | P2 | source_schema | High |\n| X-002 | Data Handoff | P2 | U1 | artifact_id | Medium |\n| X-003 | Shared State | P2, U1 | - | artifact.content | High |\n| X-004 | Context Sync | U3 | P2 | selected_ids | Medium |\n| X-005 | Event Chain | P3 | U4 | publish_event | Low |\n\n## Mermaid Format (if supported)\n\n```mermaid\ngraph LR\n    P1[P1: Source Ingestion] -->|source_schema| P2[P2: Content Generation]\n    P1 -->|source_id| P2\n    P2 -->|artifact_id| U1[U1: Chat-to-Edit]\n    P2 -->|artifact_id| P3[P3: Publishing]\n    U3[U3: Selection] -->|selected_ids| P2\n    P3 -->|publish_event| U4[U4: Status Display]\n```\n\n## Detailed Dependency Box\n\nFor complex dependencies, use expanded format:\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│  X-001: P1 → P2                                             │\n├─────────────────────────────────────────────────────────────┤\n│  Type: Data Handoff                                         │\n│  Data: source_schema                                        │\n│                                                             │\n│  Flow:                                                      │\n│    P1 writes source_schema to sources.schema                │\n│    P2 reads sources.schema when building prompt             │\n│                                                             │\n│  Failure Modes:                                             │\n│    X-001a: schema is null (S4-Blocking)                     │\n│    X-001b: schema is stale (S1-Silent)                      │\n│    X-001c: schema format changed (S3-Visible)               │\n│                                                             │\n│  Validation: ✗ No null check before use                     │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Color Coding (for visual tools)\n\n| Risk Level | Color | Meaning |\n|------------|-------|---------|\n| High | Red | Critical path, no fallback |\n| Medium | Yellow | Has fallback but degraded |\n| Low | Green | Optional, graceful handling |\n"
    },
    {
      "name": "dependency-identification.md",
      "path": "references/dependency-identification.md",
      "content": "# Dependency Identification\n\nHow to find cross-pipeline dependencies.\n\n## Analysis Approach\n\n### Step 1: List Pipeline Inputs/Outputs\n\nFor each pipeline, document:\n\n**P1: Source Ingestion**\n- Inputs: file, user_id\n- Outputs: source record, source_schema, embeddings\n\n**P2: Content Generation**\n- Inputs: source_ids, prompt, artifact_type\n- Outputs: artifact record, content\n\n**U1: Chat-to-Edit**\n- Inputs: artifact_id, edit_instruction\n- Outputs: updated artifact, change_summary\n\n### Step 2: Find Overlaps\n\nLook for where one pipeline's output is another's input:\n\n```\nP1.outputs.source_schema ──► P2.inputs.source_schema\nP2.outputs.artifact_id ──► U1.inputs.artifact_id\n```\n\n### Step 3: Identify Shared State\n\nFind tables/state accessed by multiple pipelines:\n\n```\nTable: artifacts\n  - P2: creates\n  - U1: updates\n  - P3: reads for publish\n  = Shared state, potential conflicts\n```\n\n### Step 4: Map Timing Requirements\n\nIdentify what must exist before a pipeline runs:\n\n```\nP2 requires:\n  - source exists (from P1)\n  - source_schema populated (from P1)\n  - user authenticated\n\nU1 requires:\n  - artifact exists (from P2)\n  - artifact_id in context\n  - SSE stream available\n```\n\n## Code Patterns to Search\n\n### Data Dependencies\n```typescript\n// One pipeline reading another's output\nconst sourceSchema = await getSourceSchema(sourceId);\nconst artifact = await getArtifact(artifactId);\n```\n\n### Shared State Access\n```typescript\n// Multiple writes to same entity\nawait updateArtifact(id, { content });  // In P2\nawait updateArtifact(id, { content });  // In U1\n```\n\n### Event Publishing\n```typescript\n// Events that trigger other pipelines\nchannel.send('artifact_created', { id });\neventEmitter.emit('publish_complete', { postId });\n```\n\n### Context Reading\n```typescript\n// UI pipelines reading shared context\nconst { artifactId } = useContext(ChatContext);\nconst { selectedSources } = useContext(SelectionContext);\n```\n\n## Dependency Classification\n\n### Direct Dependencies\nPipeline B cannot run without Pipeline A's output.\n\n**Indicator:** B throws error if A's output missing.\n\n### Soft Dependencies\nPipeline B works without A's output but with degraded behavior.\n\n**Indicator:** B has fallback logic for missing data.\n\n### Timing Dependencies\nPipeline B must wait for A to complete.\n\n**Indicator:** B checks status or waits for event.\n\n### Inverse Dependencies\nPipeline B cleans up after A fails.\n\n**Indicator:** B is error handler or compensation flow.\n"
    },
    {
      "name": "x-series-patterns.md",
      "path": "references/x-series-patterns.md",
      "content": "# X-Series Patterns\n\nCommon cross-pipeline failure patterns.\n\n## Data Handoff Failures\n\n### Missing Data\nOutput from upstream pipeline doesn't exist.\n\n```\nP1 didn't run → P2 tries to read source_schema → null\n```\n\n**Severity:** Usually S4-Blocking\n**Prevention:** Check existence before use\n\n### Stale Data\nData exists but is outdated.\n\n```\nUser updates source → P1 re-ingests → P2 still using cached schema\n```\n\n**Severity:** Usually S1-Silent (wrong output, no error)\n**Prevention:** Cache invalidation, version checks\n\n### Format Mismatch\nData format changed incompatibly.\n\n```\nP1 now outputs schema v2 → P2 expects schema v1 → parse fails\n```\n\n**Severity:** Usually S3-Visible (parse error)\n**Prevention:** Schema versioning, migration\n\n## Shared State Failures\n\n### Race Condition\nTwo pipelines write same data concurrently.\n\n```\nU1 edits artifact → P2 regenerates artifact → Last write wins\n```\n\n**Severity:** S1-Silent (data loss) or S2-Partial\n**Prevention:** Optimistic locking, versioning\n\n### Phantom Read\nPipeline reads data that's about to change.\n\n```\nP3 reads artifact → U1 edits → P3 publishes stale content\n```\n\n**Severity:** S1-Silent (wrong publish)\n**Prevention:** Transaction isolation, refresh before use\n\n### Lost Update\nPipeline overwrites another's changes.\n\n```\nU1 saves v1 → P2 saves v2 → U1 saves v1 again (didn't see v2)\n```\n\n**Severity:** S1-Silent (data loss)\n**Prevention:** Version checks, conflict detection\n\n## Timing Failures\n\n### Premature Execution\nDownstream runs before upstream completes.\n\n```\nP2 starts → P1 still running → P2 gets incomplete data\n```\n\n**Severity:** S2-Partial or S4-Blocking\n**Prevention:** Status checks, event-driven triggering\n\n### Timeout\nUpstream takes too long, downstream gives up.\n\n```\nP1 processing large file → P2 times out waiting → Error\n```\n\n**Severity:** S3-Visible or S4-Blocking\n**Prevention:** Longer timeouts, async handling\n\n### Ordering Violation\nSteps execute in wrong order.\n\n```\nExpected: P1 → P2 → P3\nActual: P1 → P3 → P2 (P3 sees incomplete state)\n```\n\n**Severity:** Varies\n**Prevention:** Explicit dependencies, state machines\n\n## Event Chain Failures\n\n### Lost Event\nEvent published but not received.\n\n```\nP3 emits publish_complete → Network glitch → U4 never updates\n```\n\n**Severity:** S1-Silent (UI out of sync)\n**Prevention:** Acknowledgment, polling fallback\n\n### Duplicate Event\nSame event delivered multiple times.\n\n```\nRetry logic → Event delivered twice → U4 shows duplicate\n```\n\n**Severity:** S2-Partial\n**Prevention:** Idempotency, deduplication\n\n### Event Storm\nCascade of events overwhelms system.\n\n```\nP1 → triggers P2, P3, P4 → each triggers more → system overload\n```\n\n**Severity:** S3-Visible or S4-Blocking\n**Prevention:** Rate limiting, circuit breakers\n\n## Context Sync Failures\n\n### Stale Context\nUI context doesn't reflect current state.\n\n```\nUser selects sources → navigates away → returns → context still has old selection\n```\n\n**Severity:** S1-Silent (wrong operation)\n**Prevention:** Context refresh, subscription\n\n### Context Loss\nContext cleared unexpectedly.\n\n```\nUser has artifact open → page refresh → context.artifact_id is null\n```\n\n**Severity:** S4-Blocking (can't edit)\n**Prevention:** Persistence, URL state\n\n### Context Conflict\nMultiple sources trying to set context.\n\n```\nU1 sets artifact_id → U2 also sets → Wrong artifact edited\n```\n\n**Severity:** S1-Silent (wrong target)\n**Prevention:** Single source of truth, locks\n"
    }
  ],
  "tags": [
    "audit",
    "pipeline",
    "dependencies",
    "integration",
    "cross-cutting"
  ],
  "dependsOn": [
    "pipeline-discovery",
    "ui-pipeline-discovery"
  ]
}