{
  "id": "code-validation",
  "name": "code-validation",
  "version": "1.0.0",
  "description": "Semantic correctness checks at development checkpoints. Use before committing, before PR, or at feature milestones to verify the code solves the right problem correctly. Evaluates requirements alignment, edge case coverage, failure modes, operational readiness, and integration correctness. Complements code-verification (structural) with semantic analysis.",
  "phase": "VALIDATE",
  "category": "core",
  "content": "# Code Validation\n\nSemantic correctness checks for development checkpoints. Ensures code solves the intended problem correctly and completely.\n\n## When to Use\n\n- **Before committing** â€” \"Is this feature complete?\"\n- **Before opening PR** â€” \"Is this ready for review?\"\n- **At milestones** â€” \"Does this increment deliver value?\"\n- **After major changes** â€” \"Did refactoring preserve behavior?\"\n- When you say: \"validate this\", \"is this complete?\", \"am I missing anything?\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `requirements-alignment.md` | How to verify requirements coverage |\n| `edge-cases.md` | Common edge cases to check |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `failure-modes.md` | When validating error handling |\n| `integration-correctness.md` | When validating integrations |\n| `operational-readiness.md` | When validating for production |\n\n**Verification:** Ensure VALIDATION.md is produced with all categories addressed.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `VALIDATION.md` | Project root | Always |\n\n## Core Concept\n\nValidation answers: **\"Did we build the right thing?\"**\n\nThis is distinct from verification (\"Did we build it correctly?\"). Validation requires understanding intentâ€”it can't be fully automated. It asks:\n\n- Does this actually solve the stated problem?\n- What inputs or scenarios weren't considered?\n- What happens when things go wrong?\n- Is this ready for production?\n\n## Relationship to Verification\n\n| Aspect | Verification | Validation |\n|--------|--------------|------------|\n| Question | \"Is this structurally sound?\" | \"Does this solve the problem?\" |\n| Focus | Code patterns | Requirements + behavior |\n| Speed | Fast (seconds) | Deliberate (minutes) |\n| Trigger | Auto, every iteration | Explicit checkpoint |\n| Automation | Fully automatable | Requires judgment |\n\n**Run verification first.** If verification fails, fix structural issues before validation. Validation assumes the code is structurally sound.\n\n## Validation Dimensions\n\nSix dimensions, each with guiding questions:\n\n### 1. Requirements Alignment\n\n**Question:** Does this code actually solve what was asked?\n\n**Check for:**\n- Spec-to-implementation traceability â€” can you map each requirement to code?\n- Scope creep â€” does it do MORE than asked? (often a smell)\n- Scope gap â€” does it do LESS than asked?\n- Implicit requirements â€” what wasn't stated but was assumed?\n- Acceptance criteria â€” if defined, are they all met?\n\n**Key questions:**\n- \"What was the user actually trying to accomplish?\"\n- \"If I demo this, will they say 'yes, that's what I wanted'?\"\n- \"What did I assume that wasn't explicitly stated?\"\n\nâ†’ See `references/requirements-alignment.md`\n\n### 2. Edge Case Coverage\n\n**Question:** What inputs or scenarios weren't considered?\n\n**Check for:**\n- Boundary values â€” 0, 1, -1, MAX_INT, empty string, empty array\n- Null/undefined/missing â€” what if required data isn't there?\n- Type variations â€” what if string instead of number? Array instead of object?\n- Unicode/i18n â€” special characters, RTL text, emoji, long strings\n- Timing â€” what if slow? What if instant? What if never?\n- State â€” what if called twice? Out of order? During shutdown?\n\n**Key questions:**\n- \"What's the weirdest valid input?\"\n- \"What's the most malicious valid input?\"\n- \"What happens at the boundaries?\"\n\nâ†’ See `references/edge-cases.md`\n\n### 3. Failure Mode Analysis\n\n**Question:** What happens when dependencies fail?\n\n**Check for:**\n- External service failures â€” API down, slow, returning errors\n- Database failures â€” connection lost, query timeout, constraint violation\n- Resource exhaustion â€” out of memory, disk full, rate limited\n- Partial failures â€” some items succeed, some fail\n- Cascading failures â€” does this failure cause other failures?\n\n**Key questions:**\n- \"What are all the external dependencies?\"\n- \"For each: what if it's down? Slow? Wrong?\"\n- \"What's the blast radius if this fails?\"\n\nâ†’ See `references/failure-modes.md`\n\n### 4. Operational Readiness\n\n**Question:** Is this ready to run in production?\n\n**Check for:**\n- Observability â€” can you tell if it's working? Logs? Metrics? Traces?\n- Configurability â€” are magic numbers configurable? Environment-specific?\n- Deployment â€” any migration needed? Feature flags? Rollback plan?\n- Documentation â€” how does someone operate this at 3 AM?\n- Alerting â€” what should page someone?\n\n**Key questions:**\n- \"How will I know this is broken in production?\"\n- \"What does the runbook look like?\"\n- \"Can this be rolled back?\"\n\nâ†’ See `references/operational-readiness.md`\n\n### 5. Integration Correctness\n\n**Question:** Does this work with the rest of the system?\n\n**Check for:**\n- API contracts â€” does this match what callers expect?\n- Data contracts â€” does this produce/consume the right schema?\n- State management â€” does this interact correctly with shared state?\n- Event/message contracts â€” correct format, correct topics?\n- Backward compatibility â€” does this break existing clients?\n\n**Key questions:**\n- \"What calls this? What does this call?\"\n- \"If I change this interface, what breaks?\"\n- \"Is there a contract test?\"\n\nâ†’ See `references/integration-correctness.md`\n\n### 6. Scalability Assessment\n\n**Question:** What happens at 10x the current load?\n\n**Check for:**\n- Hot paths â€” what runs most frequently?\n- Data growth â€” what if the table has 10M rows instead of 10K?\n- Concurrency â€” what if 100 users do this simultaneously?\n- Resource scaling â€” does this need more memory/CPU/connections?\n- Bottleneck identification â€” what's the first thing to break?\n\n**Key questions:**\n- \"What's N in production? What if N Ã— 10?\"\n- \"Where's the bottleneck?\"\n- \"What's the scaling strategy?\"\n\nâ†’ See `references/scalability-assessment.md`\n\n## Workflow\n\n### Standard Validation (Pre-PR)\n\n```\n1. Confirm verification passed (if not, run code-verification first)\n2. Gather context:\n   - What was the requirement/spec?\n   - What changed? (diff if available)\n   - What's the deployment context?\n3. Evaluate each dimension:\n   - Requirements alignment\n   - Edge case coverage\n   - Failure mode analysis\n   - Operational readiness\n   - Integration correctness\n   - Scalability assessment\n4. Synthesize findings:\n   - Blockers (must fix before merge)\n   - Recommendations (should fix)\n   - Notes (nice to have / future work)\n5. Verdict: READY / NOT READY with reasoning\n```\n\n### Quick Validation (Checkpoint)\n\nFor mid-development checkpoints, focus on:\n1. Requirements alignment â€” \"Am I still solving the right problem?\"\n2. Edge cases â€” \"What am I not handling yet?\"\n3. Integration â€” \"Will this work with the rest of the system?\"\n\nSkip operational readiness and scalability until closer to PR.\n\n## Output Format\n\n### Structured Output\n\n```json\n{\n  \"validation_result\": \"NOT_READY\",\n  \"summary\": \"Core functionality complete but missing error handling for external API failures\",\n  \"dimensions\": {\n    \"requirements_alignment\": {\n      \"status\": \"pass\",\n      \"notes\": \"All acceptance criteria addressed\"\n    },\n    \"edge_cases\": {\n      \"status\": \"pass\",\n      \"notes\": \"Boundary conditions handled, null checks present\"\n    },\n    \"failure_modes\": {\n      \"status\": \"fail\",\n      \"blockers\": [\n        {\n          \"issue\": \"No handling for payment API timeout\",\n          \"impact\": \"User sees generic error, order state unknown\",\n          \"suggestion\": \"Add timeout handling with retry and idempotency key\"\n        }\n      ]\n    },\n    \"operational_readiness\": {\n      \"status\": \"warn\",\n      \"recommendations\": [\n        \"Add metrics for payment processing duration\",\n        \"Add alert for payment failure rate > 5%\"\n      ]\n    },\n    \"integration_correctness\": {\n      \"status\": \"pass\",\n      \"notes\": \"API contract matches OpenAPI spec\"\n    },\n    \"scalability_assessment\": {\n      \"status\": \"pass\",\n      \"notes\": \"Query uses indexed columns, pagination in place\"\n    }\n  },\n  \"blockers\": 1,\n  \"recommendations\": 2,\n  \"notes\": 0\n}\n```\n\n### Conversational Output\n\n> **Validation: NOT READY**\n>\n> Core functionality is solidâ€”requirements are met, edge cases handled, integration looks correct. However:\n>\n> **Blockers (1):**\n> - Payment API timeout isn't handled. If the API is slow, users see a generic error and the order state is unknown. Add timeout handling with retry logic and idempotency keys.\n>\n> **Recommendations (2):**\n> - Add metrics for payment processing duration\n> - Add alert for payment failure rate > 5%\n>\n> Fix the blocker, then this is ready for review.\n\n## Validation Without Spec\n\nSometimes there's no formal spec. In that case:\n\n1. **Infer intent** from code, commit messages, PR description, conversation\n2. **State your understanding** explicitly before validating\n3. **Ask clarifying questions** if intent is ambiguous\n4. **Validate against inferred requirements** with caveat\n\nExample:\n> \"Based on the code and commit message, I understand this feature should:\n> 1. Allow users to export orders as CSV\n> 2. Include all orders from the last 30 days\n> 3. Support filtering by status\n>\n> Is this correct? Validating against these assumptions...\"\n\n## Integration with Development Loop\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    DEVELOPMENT LOOP                      â”‚\nâ”‚                                                          â”‚\nâ”‚   â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚   â”‚ spec â”‚â”€â”€â”€â–¶â”‚ implement â”‚â”€â”€â”€â–¶â”‚ code-verification  â”‚   â”‚\nâ”‚   â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ (auto, every iter) â”‚   â”‚\nâ”‚                     â–²          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”‚                     â”‚                    â”‚              â”‚\nâ”‚                     â”‚ fix issues         â”‚ pass        â”‚\nâ”‚                     â”‚                    â–¼              â”‚\nâ”‚                     â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ code-validation    â”‚   â”‚\nâ”‚                      fail      â”‚ (explicit checkpoint)â”‚  â”‚\nâ”‚                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”‚                                          â”‚              â”‚\nâ”‚                                          â”‚ ready        â”‚\nâ”‚                                          â–¼              â”‚\nâ”‚                                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚\nâ”‚                                   â”‚ code-review â”‚       â”‚\nâ”‚                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Key Principles\n\n**Judgment over automation.** Validation requires understanding what the code should do. The checklist helps structure thinking, but the answers require judgment.\n\n**Context is critical.** A feature for an internal tool has different validation criteria than a public API. Adjust scrutiny to risk.\n\n**Blockers are binary.** Either something must be fixed before merge, or it's a recommendation. Don't hedge with \"maybe blockers.\"\n\n**Missing requirements are findings.** If validation reveals the spec was incomplete, that's valuable. Document what was assumed or discovered.\n\n**Validate early, validate often.** Don't wait until PR to discover you solved the wrong problem. Quick validation at milestones catches drift early.\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `spec` | Validation checks against spec; good spec makes validation easier |\n| `code-verification` | Run verification first; validation assumes structural soundness |\n| `code-review` | Invokes validation as Pass 2 of PR review |\n| `test-generation` | Validation findings often become test cases |\n| `debug-assist` | Validation may reveal issues that need debugging |\n\n## Mode-Specific Behavior\n\nValidation scope and criteria differ by orchestrator mode:\n\n### Greenfield Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Full system validation against FEATURESPEC.md |\n| **Approach** | Comprehensive validation of all six dimensions |\n| **Patterns** | Free choice of validation criteria |\n| **Deliverables** | Full VALIDATION.md with all dimensions |\n| **Validation** | Standard validation checklist |\n| **Constraints** | Minimalâ€”validate what was specified |\n\n### Brownfield-Polish Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Gap-specific validation + integration boundaries |\n| **Approach** | Extend existing validation with gap focus |\n| **Patterns** | Should match existing validation practices |\n| **Deliverables** | Delta validation for gap scope |\n| **Validation** | Existing tests + new gap validation |\n| **Constraints** | Don't break existing functionality |\n\n**Polish considerations:**\n- Does gap fill the identified need?\n- Does gap integrate with existing code correctly?\n- Are existing tests still passing?\n- Is existing functionality unchanged?\n\n### Brownfield-Enterprise Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Change-specific validation against CR |\n| **Approach** | Surgical validation of change boundaries only |\n| **Patterns** | Must conform exactly to enterprise validation policy |\n| **Deliverables** | Change record with validation evidence |\n| **Validation** | Full regression + security review |\n| **Constraints** | Requires approval for any validation scope expansion |\n\n**Enterprise validation requirements:**\n- Change implements CR exactlyâ€”no more, no less\n- No unintended side effects\n- Rollback capability verified\n- All validation results documented\n- Security impact assessed\n\n**Enterprise validation checklist:**\n- [ ] Change matches CR specification exactly\n- [ ] No scope creep detected\n- [ ] Existing behavior unchanged\n- [ ] Regression tests pass\n- [ ] Rollback procedure tested\n- [ ] Security review complete\n\n---\n\n## References\n\n- `references/requirements-alignment.md`: Spec-to-code traceability techniques\n- `references/edge-cases.md`: Comprehensive edge case checklist\n- `references/failure-modes.md`: Failure analysis framework\n- `references/operational-readiness.md`: Production readiness checklist\n- `references/integration-correctness.md`: Contract validation techniques\n- `references/scalability-assessment.md`: Load and growth analysis",
  "references": [
    {
      "name": "edge-cases.md",
      "path": "references/edge-cases.md",
      "content": "# Edge Cases\n\nComprehensive checklist for inputs, states, and scenarios that are often missed.\n\n## Why This Matters\n\nAI-generated code handles the happy path beautifully. Edge cases are where it falls apart. These aren't exotic scenariosâ€”they're the inputs your users will inevitably provide.\n\nYour job: Think like the weirdest, most adversarial user.\n\n## Edge Case Categories\n\n### 1. Boundary Values\n\nThe edges of valid ranges:\n\n| Type | Boundaries to Test |\n|------|-------------------|\n| Numbers | 0, 1, -1, MAX_INT, MIN_INT, MAX_SAFE_INTEGER |\n| Strings | \"\", single char, very long (10K+ chars) |\n| Arrays | [], single element, very large (10K+ items) |\n| Dates | epoch, far future, far past, DST transitions |\n| IDs | first valid, last valid, just outside range |\n\n**Common misses:**\n- Zero is often not handled (division, array access)\n- Negative numbers when only positive expected\n- Empty collections causing null reference\n- Off-by-one at boundaries\n\n### 2. Null/Undefined/Missing\n\nWhat if expected data isn't there?\n\n```javascript\n// For every property access, ask: what if this is null?\nuser.address.city          // What if user is null? address is null?\norders[0].total            // What if orders is empty?\nresponse.data.items.map()  // What if any level is missing?\n```\n\n**Checklist:**\n- [ ] Function parameters: what if null/undefined?\n- [ ] API responses: what if fields missing?\n- [ ] Database results: what if no rows?\n- [ ] Config values: what if not set?\n- [ ] Optional fields: what if omitted?\n\n### 3. Type Variations\n\nWhat if the type isn't what you expect?\n\n```javascript\n// User input often comes as strings\nconst quantity = req.body.quantity;  // \"5\" not 5\nconst enabled = req.query.enabled;   // \"true\" not true\n\n// API responses may vary\nconst id = response.id;  // Sometimes string, sometimes number\n```\n\n**Checklist:**\n- [ ] String where number expected (and vice versa)\n- [ ] Array where object expected (and vice versa)\n- [ ] \"null\" (string) vs null (value)\n- [ ] \"undefined\" (string) vs undefined\n- [ ] \"true\"/\"false\" (string) vs boolean\n- [ ] Scientific notation: \"1e10\" parsed as number\n\n### 4. String Edge Cases\n\nStrings have many edge cases:\n\n| Case | Example | What Breaks |\n|------|---------|-------------|\n| Empty | \"\" | Length checks, display |\n| Whitespace only | \"   \" | Validation that checks truthiness |\n| Unicode | \"ã“ã‚“ã«ã¡ã¯\" | Length, display, storage |\n| Emoji | \"ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦\" | Length (this is 11 code units!) |\n| RTL text | \"Ù…Ø±Ø­Ø¨Ø§\" | Layout, display |\n| Null chars | \"hello\\0world\" | C-based systems, some DBs |\n| Very long | 10KB+ | Memory, display, DB columns |\n| HTML/Script | \"<script>\" | XSS (also a security issue) |\n| SQL chars | \"'; DROP\" | Injection (also a security issue) |\n| Newlines | \"line1\\nline2\" | Single-line displays |\n| Tabs | \"col1\\tcol2\" | Parsing, display |\n\n### 5. Timing Edge Cases\n\nWhat if timing is unexpected?\n\n| Scenario | What Could Break |\n|----------|------------------|\n| Instant response | Loading state flickers |\n| Very slow response | Timeouts, user retries |\n| Never responds | Memory leaks, stuck UI |\n| Response after cancel | State corruption |\n| Out-of-order responses | Race conditions |\n| Exactly at timeout boundary | Flaky behavior |\n\n### 6. State Edge Cases\n\nWhat if the system is in an unexpected state?\n\n| Scenario | Example |\n|----------|---------|\n| First use | No data, no history, no preferences |\n| After logout | Cached data from previous user |\n| Mid-operation | Page refresh during checkout |\n| Concurrent access | Same record opened in two tabs |\n| After failure | Partial state from failed operation |\n| During shutdown | Cleanup interrupted |\n| Stale data | Cache expired, data changed |\n\n### 7. Sequence/Ordering Edge Cases\n\nWhat if operations happen in unexpected order?\n\n- Called before initialization\n- Called after cleanup/dispose\n- Called twice in a row\n- Callbacks fire out of order\n- Events processed out of order\n- Operations interleaved (concurrent)\n\n### 8. Volume Edge Cases\n\nWhat if there's much more (or less) than expected?\n\n| Scenario | Impact |\n|----------|--------|\n| Zero items | Empty state handling |\n| One item | Singular/plural text |\n| Exactly page size | Pagination edge |\n| Page size + 1 | Off-by-one in pagination |\n| Maximum allowed | Boundary behavior |\n| Above maximum | Rejection handling |\n| Millions | Performance, memory |\n\n## Edge Case Discovery Process\n\n### Step 1: Identify Inputs\n\nList all inputs to the code:\n- Function parameters\n- User input (forms, URL, etc.)\n- API responses\n- Database results\n- Configuration\n- Environment variables\n- Time/date\n\n### Step 2: For Each Input, Ask\n\n```\n- What if it's null/undefined?\n- What if it's empty?\n- What if it's at the boundary?\n- What if it's the wrong type?\n- What if it's malformed?\n- What if it's missing expected fields?\n- What if it's much larger than expected?\n```\n\n### Step 3: Identify State Dependencies\n\nList all state the code depends on:\n- Local state (variables, caches)\n- Shared state (global, database)\n- External state (APIs, services)\n\n### Step 4: For Each State, Ask\n\n```\n- What if it doesn't exist yet?\n- What if it was deleted?\n- What if it changed since we read it?\n- What if another process changed it?\n- What if it's corrupted?\n```\n\n## Edge Case Checklist by Domain\n\n### Form Input\n- [ ] Empty submission\n- [ ] Whitespace-only fields\n- [ ] Very long input (paste 10KB)\n- [ ] Special characters in all fields\n- [ ] Emoji in text fields\n- [ ] Negative numbers in quantity fields\n- [ ] Zero in required numeric fields\n- [ ] Future dates where past expected\n- [ ] Invalid email formats\n- [ ] Script tags in text fields\n\n### File Upload\n- [ ] Zero-byte file\n- [ ] Very large file (over limit)\n- [ ] Wrong extension with valid content\n- [ ] Right extension with wrong content\n- [ ] Filename with special characters\n- [ ] Filename with path traversal (../../../)\n- [ ] Duplicate filenames\n- [ ] Upload cancellation mid-transfer\n\n### Lists/Tables\n- [ ] Zero rows\n- [ ] One row\n- [ ] Exactly one page\n- [ ] Many pages\n- [ ] Search with no results\n- [ ] Filter that excludes everything\n- [ ] Sort on null values\n- [ ] Items added/removed during scroll\n\n### Authentication\n- [ ] Login while already logged in\n- [ ] Token expires during session\n- [ ] Multiple tabs with different users\n- [ ] Login from new device\n- [ ] Password with special characters\n- [ ] Very long password\n- [ ] Account locked after attempts\n\n### Payments\n- [ ] Zero amount\n- [ ] Fractional cents\n- [ ] Very large amount\n- [ ] Currency conversion edge cases\n- [ ] Declined card\n- [ ] Card expires mid-checkout\n- [ ] Duplicate submission\n- [ ] Timeout during processing\n\n## Output Format\n\nWhen documenting edge case coverage:\n\n```markdown\n## Edge Case Analysis\n\n**Covered:**\n- Empty input: âœ… Shows validation error\n- Null user: âœ… Redirects to login\n- Large files: âœ… Size limit enforced\n\n**Not Covered (Blockers):**\n- Concurrent edits: âŒ Last write wins silently\n  - Impact: Data loss possible\n  - Recommendation: Add optimistic locking\n\n**Not Covered (Recommendations):**\n- Very long names: âš ï¸ May break layout\n  - Impact: Visual only\n  - Recommendation: Truncate with ellipsis\n\n**Out of Scope:**\n- Unicode normalization: Different representations treated as different\n  - Acceptable for MVP, track for future\n```\n"
    },
    {
      "name": "failure-modes.md",
      "path": "references/failure-modes.md",
      "content": "# Failure Modes\n\nFramework for analyzing what happens when dependencies fail.\n\n## Why This Matters\n\nProduction is where things fail. Networks drop, databases timeout, third-party services go down. AI-generated code typically handles the happy pathâ€”your job is to ask \"what if this breaks?\"\n\n## Failure Analysis Framework\n\n### Step 1: Dependency Inventory\n\nList everything the code depends on:\n\n```markdown\n## Dependencies\n\n**External Services:**\n- Stripe API (payments)\n- SendGrid API (email)\n- S3 (file storage)\n\n**Internal Services:**\n- Auth service\n- User service\n- Notification service\n\n**Infrastructure:**\n- PostgreSQL database\n- Redis cache\n- Message queue\n\n**Resources:**\n- File system\n- Memory\n- CPU\n```\n\n### Step 2: Failure Mode Analysis\n\nFor each dependency, analyze three failure modes:\n\n| Mode | What Happens | Duration |\n|------|--------------|----------|\n| **Down** | Service completely unavailable | Minutes to hours |\n| **Slow** | Service responds but takes 10-100x longer | Intermittent |\n| **Wrong** | Service responds but with bad data | Until noticed |\n\n### Step 3: Impact Assessment\n\nFor each failure mode, determine:\n\n1. **User impact**: What does the user see/experience?\n2. **Data impact**: Is data lost, corrupted, or inconsistent?\n3. **System impact**: Does this cascade to other failures?\n4. **Business impact**: Revenue loss? Reputation damage?\n\n### Step 4: Mitigation Strategy\n\nFor each significant impact, define:\n\n1. **Detection**: How do we know it's happening?\n2. **Response**: What happens automatically?\n3. **Recovery**: How do we restore normal operation?\n4. **Communication**: Who needs to know?\n\n## Failure Mode Catalog\n\n### External API Failures\n\n| Failure | Impact | Mitigation |\n|---------|--------|------------|\n| Connection refused | Request fails immediately | Retry with backoff, circuit breaker |\n| Timeout | Resource held, user waiting | Aggressive timeout, async processing |\n| 500 error | Request fails | Retry for idempotent, fail for mutations |\n| 429 rate limit | Requests rejected | Queue, backoff, request pooling |\n| Bad gateway/proxy | Intermittent failures | Retry, alternative endpoints |\n| SSL/TLS failure | Complete failure | Alert, manual intervention |\n| DNS failure | Can't reach service | Cache DNS, fallback IPs |\n\n### Database Failures\n\n| Failure | Impact | Mitigation |\n|---------|--------|------------|\n| Connection lost | Queries fail | Connection pooling, retry |\n| Connection pool exhausted | New requests wait/fail | Pool sizing, timeout, monitoring |\n| Query timeout | Long operations fail | Query optimization, pagination |\n| Lock contention | Transactions wait/fail | Smaller transactions, retry |\n| Disk full | Writes fail | Monitoring, cleanup policies |\n| Replication lag | Stale reads | Read from primary for critical ops |\n| Full database down | Complete failure | Failover, degraded mode |\n\n### Cache Failures\n\n| Failure | Impact | Mitigation |\n|---------|--------|------------|\n| Cache miss | Slower response, DB load | Graceful fallback, warm-up |\n| Cache down | All requests hit DB | Circuit breaker, DB can handle |\n| Stale cache | Wrong data served | TTL, invalidation, versioning |\n| Cache full | New entries rejected | Eviction policy, monitoring |\n\n### File System Failures\n\n| Failure | Impact | Mitigation |\n|---------|--------|------------|\n| Disk full | Writes fail | Monitoring, cleanup, quota |\n| Permission denied | Operations fail | Proper permissions, error handling |\n| File locked | Operations wait/fail | Retry, timeout |\n| File corrupted | Bad data read | Validation, checksums |\n\n### Message Queue Failures\n\n| Failure | Impact | Mitigation |\n|---------|--------|------------|\n| Queue unavailable | Messages can't be sent | Retry, fallback to sync |\n| Consumer down | Messages accumulate | Auto-scaling, alerts |\n| Poison message | Consumer crashes repeatedly | Dead letter queue |\n| Duplicate delivery | Operation runs twice | Idempotency |\n\n## Cascade Analysis\n\nFailures often cascade. Map the domino effect:\n\n```\nPayment API slow (5s â†’ 30s response)\n    â†“\nRequest threads held longer\n    â†“\nThread pool exhausted\n    â†“\nNew requests queued/rejected\n    â†“\nUser-facing timeouts\n    â†“\nUsers retry (making it worse)\n    â†“\nOther endpoints affected (shared thread pool)\n    â†“\nHealth checks fail\n    â†“\nLoad balancer removes instance\n    â†“\nRemaining instances overloaded\n    â†“\nFull outage\n```\n\n**Breaking the cascade:**\n- Timeouts at each step (don't wait forever)\n- Circuit breakers (stop calling failing service)\n- Bulkheads (isolate resources per dependency)\n- Backpressure (reject early when overloaded)\n- Graceful degradation (return partial results)\n\n## Failure Mode Questions\n\nAsk these for each dependency:\n\n```markdown\n### [Dependency Name]\n\n**If it's completely down:**\n- What happens to in-flight requests?\n- What error does the user see?\n- What data is lost or stuck?\n- Can the operation be retried later?\n- What's the fallback?\n\n**If it's slow (10x normal):**\n- Do we timeout? At what threshold?\n- What happens to resources while waiting?\n- Does slowness cascade to other operations?\n- Will users retry and make it worse?\n\n**If it returns bad data:**\n- How would we know?\n- What validation exists?\n- What's the blast radius of bad data?\n- Can bad data be detected and corrected?\n\n**If it's intermittently failing:**\n- Do we retry? How many times?\n- Is the operation idempotent?\n- How do we avoid making it worse?\n```\n\n## Graceful Degradation Strategies\n\nWhen dependencies fail, degrade gracefully:\n\n| Scenario | Bad Response | Good Response |\n|----------|--------------|---------------|\n| Recommendation service down | Show error page | Show popular items instead |\n| Payment slow | User waits indefinitely | Queue payment, confirm later |\n| Search down | Search broken | Show browse/categories |\n| Profile picture service down | Broken images | Show default avatar |\n| Analytics down | Block user action | Skip analytics, continue |\n\n**Principle:** Core functionality should survive non-core failures.\n\n## Output Format\n\nWhen documenting failure mode analysis:\n\n```markdown\n## Failure Mode Analysis\n\n### Payment API (Stripe)\n\n**Down:**\n- Detection: 5xx responses, connection refused\n- User impact: Cannot complete checkout\n- Response: Show \"payment temporarily unavailable\" message\n- Recovery: Retry on next attempt\n- Mitigation: âŒ NOT IMPLEMENTED - should queue for retry\n\n**Slow (>5s):**\n- Detection: Response time metrics\n- User impact: Checkout feels stuck\n- Response: Show progress indicator, timeout at 30s\n- Mitigation: âœ… Timeout configured, loading state shown\n\n**Wrong (bad response):**\n- Detection: Schema validation\n- User impact: Charge might fail silently\n- Response: Validate response, log anomalies\n- Mitigation: âš ï¸ Basic validation only, needs improvement\n\n### Blockers\n\n1. No retry mechanism for failed payments - user must retry manually\n\n### Recommendations\n\n1. Add payment queue for retry\n2. Implement circuit breaker for Stripe API\n3. Add fallback payment provider\n```\n"
    },
    {
      "name": "integration-correctness.md",
      "path": "references/integration-correctness.md",
      "content": "# Integration Correctness\n\nVerifying code works correctly with the rest of the system.\n\n## Why This Matters\n\nCode doesn't exist in isolation. It calls other services, gets called by others, shares data, publishes events. Integration bugs are the most common production issuesâ€”code works in isolation but fails when connected.\n\n## Integration Points\n\n### 1. API Contracts (Calling Others)\n\n**Does your code call external APIs correctly?**\n\n| Check | What Could Go Wrong |\n|-------|---------------------|\n| Request format | Missing fields, wrong types, wrong encoding |\n| Authentication | Wrong credentials, expired tokens |\n| Headers | Missing Content-Type, wrong Accept header |\n| URL construction | Wrong path, wrong query params |\n| Error handling | Not handling all error codes |\n\n**Verification:**\n```markdown\nFor each external API call:\n- [ ] Request matches API documentation\n- [ ] All required fields present\n- [ ] Types match expected (string vs number)\n- [ ] Authentication method correct\n- [ ] Error codes handled (4xx, 5xx)\n- [ ] Rate limits respected\n```\n\n### 2. API Contracts (Being Called)\n\n**Does your API behave as documented?**\n\n| Check | What Could Go Wrong |\n|-------|---------------------|\n| Response format | Missing fields, wrong types |\n| Status codes | Wrong code for situation |\n| Error format | Inconsistent error responses |\n| Pagination | Wrong cursor format, off-by-one |\n| Versioning | Breaking changes without version bump |\n\n**Verification:**\n```markdown\nFor each endpoint:\n- [ ] Response matches OpenAPI/schema\n- [ ] Status codes match REST conventions\n- [ ] Error responses are consistent\n- [ ] Backward compatible with existing clients\n- [ ] Contract test exists (if critical)\n```\n\n### 3. Data Contracts\n\n**Does your code read/write data correctly?**\n\n| Check | What Could Go Wrong |\n|-------|---------------------|\n| Schema match | Writing fields that don't exist |\n| Type coercion | String IDs vs numeric IDs |\n| Nullability | Null where required expected |\n| Encoding | UTF-8 vs Latin-1, timezone handling |\n| Constraints | Unique violations, FK violations |\n\n**Verification:**\n```markdown\nFor each data store interaction:\n- [ ] Schema matches model\n- [ ] Types match database column types\n- [ ] Required fields always provided\n- [ ] Unique constraints respected\n- [ ] Foreign keys valid\n- [ ] Indexes exist for query patterns\n```\n\n### 4. Event/Message Contracts\n\n**Do your events match what consumers expect?**\n\n| Check | What Could Go Wrong |\n|-------|---------------------|\n| Topic/queue name | Wrong destination |\n| Message format | Schema mismatch |\n| Ordering | Events out of expected order |\n| Idempotency | Consumer can't handle duplicates |\n| Versioning | Breaking schema change |\n\n**Verification:**\n```markdown\nFor each event published:\n- [ ] Topic/queue correct\n- [ ] Schema matches consumer expectations\n- [ ] Includes all required fields\n- [ ] Version field if schema can change\n- [ ] Consumers can handle duplicates\n\nFor each event consumed:\n- [ ] Handles all expected event types\n- [ ] Validates event schema\n- [ ] Idempotent processing\n- [ ] Handles out-of-order events\n```\n\n### 5. State Interactions\n\n**How does this code interact with shared state?**\n\n| Check | What Could Go Wrong |\n|-------|---------------------|\n| Race conditions | Concurrent modification |\n| Stale reads | Cache invalidation issues |\n| Lock contention | Deadlocks, timeouts |\n| Transaction scope | Too broad, too narrow |\n| Isolation level | Read anomalies |\n\n**Verification:**\n```markdown\nFor shared state:\n- [ ] Concurrent access is safe\n- [ ] Transactions have appropriate scope\n- [ ] Cache invalidation is correct\n- [ ] Optimistic locking if needed\n- [ ] No deadlock potential\n```\n\n## Breaking Change Detection\n\n### What Constitutes a Breaking Change?\n\n**API Breaking Changes:**\n- Removing an endpoint\n- Removing a field from response\n- Adding a required field to request\n- Changing a field's type\n- Changing URL structure\n- Changing authentication method\n\n**Data Breaking Changes:**\n- Removing a column\n- Changing column type\n- Adding NOT NULL without default\n- Changing enum values\n\n**Event Breaking Changes:**\n- Removing a field\n- Changing field type\n- Changing topic/routing\n\n### Safe Changes (Usually)\n\n- Adding optional fields to request\n- Adding fields to response\n- Adding new endpoints\n- Adding new event types\n- Adding database columns with defaults\n\n### Compatibility Matrix\n\nWhen old and new versions must coexist:\n\n```\n                    New Schema\n                 Can Read | Can Write\nOld Code           ?           ?\nNew Code           âœ“           âœ“\n```\n\nBoth must be true for safe deployment.\n\n## Contract Testing\n\n### Types of Contract Tests\n\n| Type | What It Tests | When to Use |\n|------|---------------|-------------|\n| **Consumer-driven** | Consumer's expectations against provider | Critical dependencies |\n| **Schema validation** | Response matches schema | All APIs |\n| **Smoke tests** | Basic connectivity and response | All integrations |\n\n### Example Contract Test\n\n```javascript\n// Consumer-driven contract test\ndescribe('User Service Contract', () => {\n  it('returns user with expected fields', async () => {\n    const user = await userService.getUser(123);\n\n    // Contract: these fields must exist with these types\n    expect(user).toMatchObject({\n      id: expect.any(Number),\n      email: expect.any(String),\n      createdAt: expect.any(String),  // ISO date\n    });\n\n    // Contract: these fields must NOT exist (privacy)\n    expect(user).not.toHaveProperty('passwordHash');\n    expect(user).not.toHaveProperty('ssn');\n  });\n});\n```\n\n## Integration Verification Questions\n\nFor each integration point:\n\n```markdown\n### [Integration Point Name]\n\n**Contract:**\n- What is the agreed interface?\n- Is it documented? Where?\n- Is there a contract test?\n\n**Direction:**\n- Are we calling or being called?\n- What's on the other side?\n\n**Changes:**\n- Did we change the contract?\n- Is the change backward compatible?\n- Do consumers need to update?\n\n**Error handling:**\n- What errors can the other side return?\n- Do we handle all of them?\n- What do we return on failure?\n\n**Performance:**\n- What's the expected latency?\n- What's the expected throughput?\n- Any rate limits?\n```\n\n## Output Format\n\nWhen documenting integration correctness:\n\n```markdown\n## Integration Correctness Assessment\n\n### External APIs Called\n\n**Stripe API:**\n- Contract: âœ… Request matches Stripe docs\n- Auth: âœ… API key in header\n- Errors: âš ï¸ Only handling 402, need to handle 429\n- Rate limits: âŒ Not implemented\n\n**User Service:**\n- Contract: âœ… Request/response match schema\n- Auth: âœ… Internal auth token\n- Errors: âœ… All codes handled\n\n### APIs Exposed\n\n**POST /orders:**\n- Contract: âœ… Matches OpenAPI spec\n- Backward compat: âœ… No breaking changes\n- Error format: âœ… Consistent with other endpoints\n\n### Events Published\n\n**order.created:**\n- Schema: âœ… Matches documented schema\n- Topic: âœ… Correct topic\n- Versioning: âš ï¸ No version field, add before schema changes\n\n### Data Contracts\n\n**orders table:**\n- Schema match: âœ…\n- Types: âœ…\n- Constraints: âœ…\n- Migration: N/A (no schema changes)\n\n### Blockers\n\n1. Need to handle Stripe rate limit (429) responses\n\n### Recommendations\n\n1. Add version field to events\n2. Add contract test for User Service integration\n```\n"
    },
    {
      "name": "operational-readiness.md",
      "path": "references/operational-readiness.md",
      "content": "# Operational Readiness\n\nChecklist for production readinessâ€”can this be deployed, monitored, and operated?\n\n## Why This Matters\n\nCode that works locally isn't ready for production. Production requires observability, configurability, recoverability. AI-generated code almost never includes operational concernsâ€”that's your job to add.\n\n## Operational Readiness Checklist\n\n### 1. Observability\n\n**Can you tell if it's working?**\n\n| Category | Questions | Signals |\n|----------|-----------|---------|\n| **Logging** | What gets logged? At what level? | Key operations, errors, request IDs |\n| **Metrics** | What numbers matter? | Rate, errors, duration, saturation |\n| **Tracing** | Can you follow a request? | Trace IDs propagated, spans created |\n| **Health checks** | How does the system report health? | Endpoint, dependencies checked |\n\n**Minimum logging:**\n```javascript\n// Every external call\nlogger.info('Calling payment API', { orderId, amount, requestId });\nlogger.info('Payment API responded', { orderId, status, duration, requestId });\n\n// Every error\nlogger.error('Payment failed', { orderId, error: error.message, requestId });\n\n// Key business events\nlogger.info('Order completed', { orderId, userId, total });\n```\n\n**Minimum metrics:**\n```\n- Request rate (requests/second)\n- Error rate (errors/second, error percentage)\n- Duration (p50, p95, p99 latency)\n- Saturation (queue depth, connection pool usage)\n```\n\n### 2. Configurability\n\n**Are environment-specific values externalized?**\n\n| Category | Example | Configuration Method |\n|----------|---------|---------------------|\n| Service URLs | API endpoints | Environment variables |\n| Credentials | API keys, passwords | Secrets management |\n| Timeouts | Connection, request timeouts | Environment variables |\n| Feature flags | New feature enabled | Feature flag service |\n| Rate limits | Max requests/second | Environment or config |\n\n**Anti-patterns:**\n```javascript\n// BAD: Hardcoded values\nconst API_URL = 'https://api.stripe.com';\nconst TIMEOUT = 5000;\nconst MAX_RETRIES = 3;\n\n// GOOD: Configurable\nconst API_URL = process.env.STRIPE_API_URL || 'https://api.stripe.com';\nconst TIMEOUT = parseInt(process.env.PAYMENT_TIMEOUT_MS) || 5000;\nconst MAX_RETRIES = parseInt(process.env.PAYMENT_MAX_RETRIES) || 3;\n```\n\n### 3. Deployment Readiness\n\n**Can this be deployed safely?**\n\n| Concern | Questions |\n|---------|-----------|\n| **Migration** | Database schema changes? Data migration needed? |\n| **Backward compatibility** | Can old and new versions run simultaneously? |\n| **Feature flags** | Can this be deployed dark and enabled later? |\n| **Rollback** | If this breaks, can we roll back safely? |\n| **Dependencies** | New services or infrastructure required? |\n\n**Migration safety checklist:**\n- [ ] Schema changes are backward compatible\n- [ ] Old code can run with new schema\n- [ ] New code can run with old schema (during rollout)\n- [ ] Migration is reversible\n- [ ] Migration has been tested with production-like data volume\n\n### 4. Error Handling for Operations\n\n**What happens when things go wrong?**\n\n| Scenario | Operational Need |\n|----------|------------------|\n| Unexpected error | Logged with context, alert if frequent |\n| Expected error | Handled gracefully, metrics updated |\n| Dependency failure | Circuit breaker, fallback behavior |\n| Rate limiting | Backpressure, queue management |\n| Data inconsistency | Detection, alert, recovery path |\n\n### 5. Alerting\n\n**What should wake someone up at 3 AM?**\n\nAlerts should be:\n- **Actionable**: Someone can do something about it\n- **Urgent**: It can't wait until morning\n- **Accurate**: Low false positive rate\n\n| Alert | Threshold | Rationale |\n|-------|-----------|-----------|\n| Error rate spike | >5% errors over 5 min | Users impacted |\n| Latency spike | p99 > 10s over 5 min | Users impacted |\n| Service down | Health check fails | Complete outage |\n| Queue backup | >1000 items for 10 min | Processing blocked |\n| Disk space | <10% free | Imminent failure |\n\n**NOT alertworthy (log/dashboard only):**\n- Individual errors (unless very unusual)\n- Slightly elevated latency\n- Expected error types (validation errors)\n\n### 6. Documentation\n\n**Can someone else operate this at 3 AM?**\n\n| Document | Content |\n|----------|---------|\n| **README** | What is this? How to run/deploy? |\n| **Architecture** | Components, data flow, dependencies |\n| **Runbook** | How to diagnose common issues |\n| **API docs** | Endpoints, request/response formats |\n| **Config reference** | Environment variables and their effects |\n\n**Runbook template:**\n```markdown\n## [Issue Name]\n\n**Symptoms:**\n- What you'll see in logs\n- What users will report\n- What metrics will show\n\n**Diagnosis:**\n1. Check X\n2. Look at Y\n3. Verify Z\n\n**Resolution:**\n1. If A, do B\n2. If C, do D\n3. Escalate if E\n\n**Prevention:**\nHow to prevent recurrence\n```\n\n### 7. Graceful Shutdown\n\n**Does the service stop cleanly?**\n\n```javascript\n// Handle shutdown signals\nprocess.on('SIGTERM', async () => {\n  logger.info('Shutdown signal received');\n\n  // Stop accepting new requests\n  server.close();\n\n  // Complete in-flight requests (with timeout)\n  await Promise.race([\n    finishInFlightRequests(),\n    timeout(30000)\n  ]);\n\n  // Close connections cleanly\n  await database.close();\n  await cache.close();\n\n  process.exit(0);\n});\n```\n\n### 8. Resource Limits\n\n**Are resources bounded?**\n\n| Resource | Limit | What Happens at Limit |\n|----------|-------|----------------------|\n| Memory | Container limit | OOM kill, restart |\n| Connections | Pool max | Queue, timeout |\n| Request rate | Rate limit | 429 response |\n| Request size | Body limit | 413 response |\n| File upload | Size limit | Rejection |\n\n## Operational Readiness Review\n\n### Pre-Deployment Checklist\n\n```markdown\n## Operational Readiness: [Feature Name]\n\n### Observability\n- [ ] Key operations logged with context\n- [ ] Errors logged with stack traces\n- [ ] Metrics exported (rate, errors, duration)\n- [ ] Request tracing implemented\n- [ ] Health check updated if needed\n\n### Configuration\n- [ ] No hardcoded secrets\n- [ ] Environment-specific values externalized\n- [ ] Defaults are safe for production\n- [ ] Config changes don't require redeploy\n\n### Deployment\n- [ ] Migration plan documented\n- [ ] Rollback plan documented\n- [ ] Feature flag available (if high risk)\n- [ ] No breaking API changes (or versioned)\n\n### Alerting\n- [ ] New alerts defined (if needed)\n- [ ] Existing alerts still valid\n- [ ] Dashboard updated\n\n### Documentation\n- [ ] README updated\n- [ ] Runbook entry added (if new failure mode)\n- [ ] API docs updated (if API changed)\n\n### Resource Management\n- [ ] Timeouts configured on external calls\n- [ ] Connection pools sized appropriately\n- [ ] Graceful shutdown handled\n```\n\n## Output Format\n\nWhen documenting operational readiness:\n\n```markdown\n## Operational Readiness Assessment\n\n### Observability\n- Logging: âœ… Key operations logged, request IDs present\n- Metrics: âš ï¸ No custom metrics for payment processing\n- Tracing: âœ… Spans created for external calls\n- Health: âœ… Health check includes DB and cache\n\n### Configuration\n- âœ… All URLs configurable\n- âœ… Secrets in environment variables\n- âš ï¸ Timeout hardcoded (should be configurable)\n\n### Deployment\n- âœ… No schema changes\n- âœ… API backward compatible\n- âœ… Feature flag available\n\n### Alerting\n- âš ï¸ No alert for payment failure rate\n\n### Documentation\n- âœ… README current\n- âŒ No runbook for payment failures\n\n### Blockers\n1. Need runbook for payment failures\n\n### Recommendations\n1. Add payment processing metrics\n2. Make timeout configurable\n3. Add alert for payment failure rate > 2%\n```\n"
    },
    {
      "name": "requirements-alignment.md",
      "path": "references/requirements-alignment.md",
      "content": "# Requirements Alignment\n\nHow to verify code actually solves the stated problem.\n\n## Why This Matters\n\nThe most expensive bugs aren't technicalâ€”they're building the wrong thing. AI agents are excellent at producing correct code for the wrong problem. Validation catches this before it reaches review.\n\nYour job: Ensure the solution matches the intent.\n\n## Alignment Techniques\n\n### 1. Spec-to-Code Traceability\n\nFor each requirement, find the corresponding implementation:\n\n```\nRequirement: \"Users can filter orders by status\"\n     â†“\nCode: OrderList component with statusFilter prop\n      + filterOrders(orders, status) function\n      + API endpoint: GET /orders?status=pending\n```\n\n**Red flags:**\n- Requirement with no corresponding code â†’ incomplete\n- Code with no corresponding requirement â†’ scope creep or implicit requirement\n\n### 2. Acceptance Criteria Walkthrough\n\nIf acceptance criteria exist, verify each one:\n\n```markdown\n## Acceptance Criteria\n\n- [x] User can select status from dropdown (COMPLETED: StatusFilter component)\n- [x] Filtered results update without page reload (COMPLETED: React state update)\n- [ ] Filter persists across sessions (MISSING: No localStorage implementation)\n- [x] \"All\" option shows unfiltered results (COMPLETED: null status handling)\n```\n\n### 3. Intent Verification Questions\n\nAsk these questions to surface misalignment:\n\n| Question | What It Reveals |\n|----------|-----------------|\n| \"What problem is the user trying to solve?\" | Whether you're solving root cause or symptom |\n| \"What will the user do immediately after?\" | Missing next steps in the flow |\n| \"What did they do before this existed?\" | Whether solution matches mental model |\n| \"What's the 'job to be done'?\" | Core need vs. stated request |\n| \"If I demo this, will they say 'yes'?\" | Overall alignment check |\n\n### 4. Scope Analysis\n\n**Scope Gap (doing less than asked):**\n- Missing requirements\n- Partial implementations (\"works for happy path only\")\n- Deferred functionality without documentation\n\n**Scope Creep (doing more than asked):**\n- Features nobody requested\n- \"While I was in there...\" additions\n- Premature optimization\n- Unnecessary abstraction\n\nScope creep isn't always bad, but it should be intentional and documented.\n\n## Common Misalignment Patterns\n\n### Pattern 1: Solving the Wrong Level\n\n**Request:** \"Make the page load faster\"\n**Wrong solution:** Add a loading spinner\n**Right solution:** Optimize the slow query\n\n**Detection:** Ask \"Does this solve the root cause or mask the symptom?\"\n\n### Pattern 2: Literal vs. Intent\n\n**Request:** \"Add a button to refresh the data\"\n**Literal solution:** Refresh button that reloads everything\n**Intent solution:** Auto-refresh with manual override (user wanted fresh data, not a button)\n\n**Detection:** Ask \"What's the user actually trying to accomplish?\"\n\n### Pattern 3: Missing Context\n\n**Request:** \"Allow users to delete their account\"\n**Implementation:** DELETE /users/:id endpoint\n**Missing context:** Legal requirement for data retention, soft delete, confirmation flow\n\n**Detection:** Ask \"What regulatory, business, or UX constraints apply?\"\n\n### Pattern 4: Assumed Requirements\n\nThings often assumed but not stated:\n- Error handling for invalid input\n- Loading states during async operations\n- Mobile responsiveness\n- Accessibility basics\n- Reasonable performance\n- Security (auth, input validation)\n\n**Detection:** Explicitly list assumptions: \"I assumed X. Is that correct?\"\n\n## Validation Checklist\n\n### With Spec/Requirements\n\n```markdown\nFor each stated requirement:\n- [ ] Requirement is implemented (not just planned)\n- [ ] Implementation is complete (not partial)\n- [ ] Implementation matches intent (not just letter)\n- [ ] Edge cases for this requirement are handled\n\nFor the implementation:\n- [ ] No significant code without corresponding requirement\n- [ ] Scope creep is intentional and documented\n- [ ] Assumptions are stated and validated\n```\n\n### Without Spec\n\n```markdown\n1. State inferred requirements explicitly\n2. Get confirmation or correction\n3. Then validate against stated understanding\n\nInference sources:\n- [ ] Code structure and naming\n- [ ] Commit messages and PR description\n- [ ] Conversation history\n- [ ] Similar features in codebase\n- [ ] Domain knowledge\n```\n\n## Output Format\n\nWhen documenting requirements alignment:\n\n```markdown\n## Requirements Alignment\n\n**Stated Requirements:**\n1. Users can filter orders by status âœ…\n2. Filter selection persists across sessions âŒ NOT IMPLEMENTED\n3. Results update without page reload âœ…\n\n**Inferred Requirements:**\n- Error state when API fails âœ…\n- Loading indicator during fetch âœ…\n- Mobile responsive âš ï¸ NOT TESTED\n\n**Scope Additions (not requested):**\n- Added keyboard shortcuts for filter selection (intentional UX improvement)\n\n**Assumptions Made:**\n- \"Status\" means order status (pending, shipped, delivered), not payment status\n- \"Persist\" means localStorage, not server-side preference\n\n**Verdict:** NOT ALIGNED - missing session persistence requirement\n```\n\n## When Requirements Are Ambiguous\n\nDon't guess. Surface the ambiguity:\n\n```markdown\n**Ambiguity Identified:**\n\nThe requirement \"users can export orders\" doesn't specify:\n- Export format (CSV? Excel? PDF?)\n- Which orders (all? filtered? selected?)\n- Who can export (all users? admins only?)\n\n**Current Implementation:**\n- CSV format\n- Currently visible (filtered) orders\n- All authenticated users\n\n**Recommendation:** Confirm these decisions before merge.\n```\n"
    },
    {
      "name": "scalability-assessment.md",
      "path": "references/scalability-assessment.md",
      "content": "# Scalability Assessment\n\nAnalyzing what happens when load increases.\n\n## Why This Matters\n\nCode that works at 100 users breaks at 10,000. Code that works with 10,000 database rows crawls at 10 million. AI-generated code optimizes for correctness at current scaleâ€”you need to think about future scale.\n\n## Scalability Questions Framework\n\n### The Core Question\n\n> \"What is N, and what happens when N Ã— 10?\"\n\nFor every piece of code, identify what scales:\n- Number of users\n- Number of records\n- Request rate\n- Data size\n- Concurrent connections\n\nThen ask: what breaks first?\n\n## Scalability Dimensions\n\n### 1. Data Volume\n\n**What happens as data grows?**\n\n| Concern | Current | 10x | 100x |\n|---------|---------|-----|------|\n| Table rows | 10K | 100K | 1M |\n| Query time | 50ms | ? | ? |\n| Memory usage | 100MB | ? | ? |\n| Index size | 10MB | ? | ? |\n\n**What to check:**\n```markdown\n- [ ] Queries use indexes (EXPLAIN ANALYZE)\n- [ ] Pagination implemented (not loading all)\n- [ ] Aggregations are bounded\n- [ ] Old data archival strategy exists\n- [ ] Partitioning needed?\n```\n\n### 2. Request Rate\n\n**What happens as traffic grows?**\n\n| Concern | Current | 10x | 100x |\n|---------|---------|-----|------|\n| Requests/sec | 10 | 100 | 1000 |\n| Response time | 100ms | ? | ? |\n| CPU usage | 20% | ? | ? |\n| DB connections | 5 | 50 | 500? |\n\n**What to check:**\n```markdown\n- [ ] Connection pooling configured\n- [ ] Caching for repeated queries\n- [ ] Rate limiting for protection\n- [ ] Horizontal scaling possible\n- [ ] No per-request resource leaks\n```\n\n### 3. Concurrency\n\n**What happens with more simultaneous users?**\n\n| Concern | What Breaks |\n|---------|-------------|\n| Lock contention | Operations wait, timeout |\n| Connection exhaustion | New requests rejected |\n| Race conditions | Data corruption |\n| Thundering herd | Cache stampede |\n\n**What to check:**\n```markdown\n- [ ] Locks are fine-grained\n- [ ] Connection pools sized for concurrency\n- [ ] Race conditions handled\n- [ ] Cache stampede protection\n```\n\n### 4. Payload Size\n\n**What happens with larger data?**\n\n| Concern | Current | 10x | 100x |\n|---------|---------|-----|------|\n| Request body | 1KB | 10KB | 100KB |\n| Response body | 10KB | 100KB | 1MB |\n| File uploads | 1MB | 10MB | 100MB |\n\n**What to check:**\n```markdown\n- [ ] Request size limits set\n- [ ] Streaming for large responses\n- [ ] Pagination for lists\n- [ ] Chunked uploads for large files\n- [ ] Memory usage bounded\n```\n\n## Bottleneck Identification\n\n### Common Bottlenecks\n\n| Bottleneck | Symptoms | Diagnosis | Fix |\n|------------|----------|-----------|-----|\n| Database queries | High latency, DB CPU | EXPLAIN, slow query log | Index, cache, optimize |\n| Connection pool | Requests waiting | Pool metrics | Increase pool, optimize queries |\n| Memory | OOM, GC pauses | Memory profiling | Reduce allocation, streaming |\n| CPU | High CPU, slow responses | CPU profiling | Optimize hot paths, cache |\n| Network | High latency to external | Latency metrics | Caching, connection reuse |\n| Single resource | One thing at 100% | Resource metrics | Scale or optimize that resource |\n\n### Finding the Bottleneck\n\nAsk these questions in order:\n\n1. **What's the slowest part?** (measure, don't guess)\n2. **What resource is most utilized?** (CPU? Memory? DB? Network?)\n3. **What happens if we add more of that resource?**\n4. **What becomes the bottleneck after?**\n\n## Scalability Patterns\n\n### Patterns That Scale\n\n| Pattern | Why It Scales |\n|---------|---------------|\n| Stateless services | Can add instances |\n| Connection pooling | Reuse expensive resources |\n| Caching | Reduce repeated work |\n| Pagination | Bound response size |\n| Async processing | Decouple from request |\n| Partitioning/sharding | Divide data across nodes |\n| Read replicas | Scale reads independently |\n\n### Patterns That Don't Scale\n\n| Pattern | Why It Doesn't Scale |\n|---------|----------------------|\n| Loading all into memory | O(n) memory |\n| Full table scans | O(n) queries |\n| Synchronous external calls | Latency accumulates |\n| Global locks | Serializes operations |\n| Single database | Vertical scaling limits |\n| Session stickiness | Uneven load distribution |\n\n## Scalability Checklist\n\n### Database Queries\n\n```markdown\nFor each query:\n- [ ] Uses appropriate indexes\n- [ ] No SELECT * (only needed columns)\n- [ ] Has LIMIT/pagination\n- [ ] No N+1 patterns\n- [ ] EXPLAIN ANALYZE looks reasonable\n- [ ] Estimated rows at scale are acceptable\n```\n\n### API Endpoints\n\n```markdown\nFor each endpoint:\n- [ ] Response size bounded\n- [ ] Pagination for lists\n- [ ] Caching where appropriate\n- [ ] No unbounded loops\n- [ ] Async for expensive operations\n```\n\n### Background Jobs\n\n```markdown\nFor each job:\n- [ ] Batch size limited\n- [ ] Can be parallelized\n- [ ] Progress is resumable\n- [ ] Memory usage bounded\n- [ ] Run time predictable\n```\n\n## Load Estimation\n\n### How to Estimate\n\n1. **Current load**: What are the actual numbers today?\n2. **Growth rate**: How fast is it growing?\n3. **Target horizon**: What load in 1 year? 3 years?\n4. **Margin**: 2-3x headroom beyond target\n\n### Example Estimation\n\n```markdown\n## Load Estimation: Order Service\n\n**Current (measured):**\n- Orders/day: 1,000\n- Peak orders/hour: 200\n- Orders table size: 500K rows\n- Avg response time: 80ms\n\n**Growth:**\n- Orders growing 3x/year\n- Users growing 2x/year\n\n**1-Year Target:**\n- Orders/day: 3,000\n- Peak orders/hour: 600\n- Orders table size: 1.5M rows\n\n**3-Year Target:**\n- Orders/day: 27,000\n- Peak orders/hour: 5,400\n- Orders table size: 13.5M rows\n\n**Current architecture can handle:**\n- Orders/day: ~5,000 (tested)\n- Table size: ~2M (before queries degrade)\n\n**Action needed:**\n- Query optimization before 1.5M rows\n- Consider sharding before 10M rows\n```\n\n## Output Format\n\nWhen documenting scalability assessment:\n\n```markdown\n## Scalability Assessment\n\n### Current Scale\n- Users: 5,000 DAU\n- Requests: 50/sec peak\n- Data: 500K orders, 2M line items\n\n### Growth Projection\n- 3x in 12 months based on current trend\n\n### Bottleneck Analysis\n\n**Database:**\n- âœ… Queries use indexes\n- âœ… Pagination implemented\n- âš ï¸ Aggregate queries may slow at 2M+ orders\n  - Recommendation: Pre-compute daily summaries\n\n**API:**\n- âœ… Response size bounded\n- âœ… Caching for product catalog\n- âš ï¸ Order history loads all orders\n  - Blocker: Add pagination\n\n**Background Jobs:**\n- âœ… Batch processing for exports\n- âŒ Invoice generation is serial\n  - Recommendation: Parallelize invoice generation\n\n### Scaling Strategy\n\n| At | Action Needed |\n|----|---------------|\n| 2M orders | Optimize aggregate queries |\n| 10M orders | Consider partitioning by date |\n| 500 req/sec | Add read replica |\n| 1000 req/sec | Consider caching layer |\n\n### Blockers\n1. Order history must have pagination before 10K orders/user\n\n### Recommendations\n1. Pre-compute daily order summaries\n2. Parallelize invoice generation\n3. Add query for order count to avoid loading all\n```\n"
    }
  ],
  "tags": [
    "validation",
    "semantics",
    "logic",
    "correctness",
    "core-workflow"
  ],
  "dependsOn": [
    "code-verification"
  ]
}