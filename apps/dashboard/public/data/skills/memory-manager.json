{
  "id": "memory-manager",
  "name": "memory-manager",
  "version": "1.0.0",
  "description": "Maintains context across long-running autonomous tasks. Handles session handoffs, context compression, cold boot procedures, and domain memory persistence. Enables continuity between sessions and coordination between multiple agents working on the same domain.",
  "phase": "META",
  "category": "meta",
  "content": "# Memory Manager\n\nPersist context across sessions and agents.\n\n## When to Use\n\n- **Ending a session** ‚Äî Create handoff document for next session\n- **Starting a session** ‚Äî Cold boot from previous handoff\n- **Context limit approaching** ‚Äî Compress context to continue\n- **Recording decisions** ‚Äî Archive ADRs and design decisions\n- **Cross-system contracts** ‚Äî Document interfaces between systems\n- **Multiple agents** ‚Äî Coordinate shared understanding\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `handoff-template.md` | Template for session handoff documents |\n| `cold-boot-checklist.md` | Procedure for resuming work |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `adr-template.md` | When recording architectural decisions |\n| `interface-contracts.md` | When documenting cross-system contracts |\n| `compression-strategies.md` | When context window filling up |\n\n**Verification:** Ensure handoff document enables cold boot by another agent.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `HANDOFF.md` | `domain-memory/{domain}/` | On warm handoff |\n| `loop-state.json` | `domain-memory/{domain}/` | Always (create or update) |\n| `context-summary.md` | `domain-memory/{domain}/` | On session end |\n\n## Hook Integration\n\nSession lifecycle hooks automate context loading and handoff prompting:\n\n| Hook | Trigger | What it does |\n|------|---------|--------------|\n| `cold-boot-loader` | Notification (session_start) | Loads prior state, displays resume context |\n| `warm-handoff-creator` | Notification (session_end) | Prompts for handoff creation |\n| `context-pruner` | Notification (context_limit_warning) | Prompts for emergency handoff |\n\n**Note:** Hooks handle prompting and context display. This skill creates the actual `HANDOFF.md` document with full context.\n\nSee `.claude/hooks/cold-boot-loader.sh`, `.claude/hooks/warm-handoff-creator.sh`, and `HOOKS.md` for details.\n\n## Core Concept\n\nMemory Manager solves the **context continuity problem**: how does an agent resume work after a session ends, or how do multiple agents share understanding of a domain?\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                        MEMORY ARCHITECTURE                                   ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îÇ\n‚îÇ  ‚îÇ   Session 1     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ Handoff ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Session 2     ‚îÇ             ‚îÇ\n‚îÇ  ‚îÇ   Agent A       ‚îÇ      Document          ‚îÇ   Agent A       ‚îÇ             ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ\n‚îÇ           ‚îÇ                                          ‚îÇ                      ‚îÇ\n‚îÇ           ‚îÇ  write                          read     ‚îÇ                      ‚îÇ\n‚îÇ           ‚ñº                                          ‚ñº                      ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ                       DOMAIN MEMORY                                  ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îÇ  Dream   ‚îÇ ‚îÇ  System  ‚îÇ ‚îÇDecisions ‚îÇ ‚îÇInterfaces‚îÇ ‚îÇ Sessions ‚îÇ  ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îÇ  State   ‚îÇ ‚îÇ  Queue   ‚îÇ ‚îÇ  (ADRs)  ‚îÇ ‚îÇ(Contracts)‚îÇ ‚îÇ(Handoffs)‚îÇ  ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Domain Memory Structure\n\n### File Organization\n\n```\ndomain-memory/\n‚îî‚îÄ‚îÄ {domain-name}/\n    ‚îú‚îÄ‚îÄ dream-state.md              # The vision (from entry-portal)\n    ‚îú‚îÄ‚îÄ system-queue.json           # Current queue state\n    ‚îú‚îÄ‚îÄ glossary.md                 # Domain terminology\n    ‚îÇ\n    ‚îú‚îÄ‚îÄ decisions/                  # Architectural Decision Records\n    ‚îÇ   ‚îú‚îÄ‚îÄ 000-template.md\n    ‚îÇ   ‚îú‚îÄ‚îÄ 001-technology-stack.md\n    ‚îÇ   ‚îú‚îÄ‚îÄ 002-auth-approach.md\n    ‚îÇ   ‚îî‚îÄ‚îÄ ...\n    ‚îÇ\n    ‚îú‚îÄ‚îÄ interfaces/                 # Cross-system contracts\n    ‚îÇ   ‚îú‚îÄ‚îÄ api/\n    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth-service.yaml\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ order-service.yaml\n    ‚îÇ   ‚îî‚îÄ‚îÄ events/\n    ‚îÇ       ‚îú‚îÄ‚îÄ order-events.yaml\n    ‚îÇ       ‚îî‚îÄ‚îÄ notification-events.yaml\n    ‚îÇ\n    ‚îî‚îÄ‚îÄ sessions/                   # Session handoff logs\n        ‚îú‚îÄ‚îÄ 2024-01-15-auth-service.md\n        ‚îú‚îÄ‚îÄ 2024-01-16-order-service-part1.md\n        ‚îú‚îÄ‚îÄ 2024-01-17-order-service-part2.md\n        ‚îî‚îÄ‚îÄ ...\n```\n\n### Initialize Domain Memory\n\n```bash\n# Create domain memory structure\nmkdir -p domain-memory/{domain-name}/{decisions,interfaces/api,interfaces/events,sessions}\n\n# Create initial files\ntouch domain-memory/{domain-name}/dream-state.md\ntouch domain-memory/{domain-name}/system-queue.json\ntouch domain-memory/{domain-name}/glossary.md\n```\n\n## Session Handoff\n\n### When to Create Handoff\n\nCreate a handoff document when:\n- Session is ending (time limit, user leaving)\n- Context window is filling up\n- Switching to different system/task\n- Handing off to human engineer\n- Pausing for external dependency\n\n### Handoff Document Format\n\n```markdown\n# Session Handoff: [Date] - [System/Task]\n\n## Session Metadata\n| Property | Value |\n|----------|-------|\n| Date | YYYY-MM-DD |\n| Duration | [X hours] |\n| System | [system name] |\n| Agent/Engineer | [identifier] |\n| Branch | feature/[name] |\n| Last Commit | [hash] - [message] |\n\n---\n\n## Context Summary\n\n[2-3 paragraph summary of what this session was about and the current state]\n\n---\n\n## Completed This Session\n\n- [x] [Completed item 1]\n- [x] [Completed item 2]\n- [x] [Completed item 3]\n\n### Key Commits\n| Commit | Description |\n|--------|-------------|\n| abc1234 | [What it did] |\n| def5678 | [What it did] |\n\n---\n\n## Current State\n\n### Working On\n[What was actively being worked on when session ended]\n\n### Code State\n- Tests: [passing/failing - details if failing]\n- Lint: [passing/failing]\n- Build: [passing/failing]\n\n### Files Modified (uncommitted)\n- [file1.ts] - [what changed]\n- [file2.ts] - [what changed]\n\n---\n\n## Decisions Made\n\n| Decision | Choice | Rationale |\n|----------|--------|-----------|\n| [Decision 1] | [Choice] | [Why] |\n| [Decision 2] | [Choice] | [Why] |\n\n[If significant, create ADR in decisions/ folder]\n\n---\n\n## Blockers & Issues\n\n### Current Blockers\n- [ ] [Blocker 1] - [who/what is needed]\n- [ ] [Blocker 2] - [who/what is needed]\n\n### Known Issues\n- [Issue 1] - [details]\n- [Issue 2] - [details]\n\n---\n\n## Next Steps\n\n### Immediate (Next Session)\n1. [First thing to do]\n2. [Second thing to do]\n3. [Third thing to do]\n\n### After That\n- [Subsequent task 1]\n- [Subsequent task 2]\n\n---\n\n## Open Questions\n\nQuestions needing answers:\n- [ ] [Question 1] - [context]\n- [ ] [Question 2] - [context]\n\n---\n\n## References\n\n- GitHub Issue: #[number]\n- PR (if open): #[number]\n- Related Docs: [links]\n\n---\n\n## For Next Session\n\n### Commands to Run First\n```bash\ncd [path]\ngit status\nnpm test  # or equivalent\n```\n\n### Files to Review\n- [file1] - [why]\n- [file2] - [why]\n\n### Context to Load\n- Read: decisions/[relevant].md\n- Read: interfaces/[relevant].yaml\n- Read: Last 2-3 session handoffs\n```\n\n‚Üí See `references/handoff-template.md`\n\n## Cold Boot Procedure\n\n### When Starting a New Session\n\nFollow this procedure to resume work:\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                         COLD BOOT PROCEDURE                                  ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  1. LOAD DOMAIN CONTEXT                                                     ‚îÇ\n‚îÇ     ‚îú‚îÄ‚Üí Read dream-state.md (understand the vision)                         ‚îÇ\n‚îÇ     ‚îú‚îÄ‚Üí Read glossary.md (understand terminology)                           ‚îÇ\n‚îÇ     ‚îî‚îÄ‚Üí Read system-queue.json (understand priorities)                      ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  2. LOAD CURRENT SYSTEM CONTEXT                                             ‚îÇ\n‚îÇ     ‚îú‚îÄ‚Üí Read GitHub issue for current system                                ‚îÇ\n‚îÇ     ‚îú‚îÄ‚Üí Read FeatureSpec attached to issue                                  ‚îÇ\n‚îÇ     ‚îî‚îÄ‚Üí Read relevant interface contracts                                   ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  3. LOAD SESSION HISTORY                                                    ‚îÇ\n‚îÇ     ‚îú‚îÄ‚Üí Read last 2-3 session handoffs                                      ‚îÇ\n‚îÇ     ‚îú‚îÄ‚Üí Understand what was completed                                       ‚îÇ\n‚îÇ     ‚îî‚îÄ‚Üí Understand current blockers/issues                                  ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  4. LOAD DECISIONS                                                          ‚îÇ\n‚îÇ     ‚îî‚îÄ‚Üí Read relevant ADRs in decisions/                                    ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  5. VERIFY STATE                                                            ‚îÇ\n‚îÇ     ‚îú‚îÄ‚Üí Check git status in worktree                                        ‚îÇ\n‚îÇ     ‚îú‚îÄ‚Üí Run tests to confirm state                                          ‚îÇ\n‚îÇ     ‚îî‚îÄ‚Üí Review any uncommitted changes                                      ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  6. CONFIRM UNDERSTANDING                                                   ‚îÇ\n‚îÇ     ‚îî‚îÄ‚Üí Summarize context back to verify                                    ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### Cold Boot Checklist\n\n```markdown\n## Cold Boot Checklist\n\n### Domain Context\n- [ ] Read dream-state.md\n- [ ] Read glossary.md\n- [ ] Read system-queue.json\n- [ ] Understand current priorities\n\n### System Context\n- [ ] Identified current system to work on\n- [ ] Read GitHub issue #[number]\n- [ ] Read FeatureSpec\n- [ ] Read relevant interface contracts\n\n### Session History\n- [ ] Read last session handoff\n- [ ] Understand what was completed\n- [ ] Understand current blockers\n- [ ] Know immediate next steps\n\n### Decisions\n- [ ] Read relevant ADRs\n- [ ] Understand architectural constraints\n\n### Code State\n- [ ] Navigated to correct worktree\n- [ ] Checked git status\n- [ ] Ran tests\n- [ ] Reviewed any uncommitted changes\n\n### Ready to Continue\n- [ ] Can articulate what I'm working on\n- [ ] Know the immediate next task\n- [ ] Understand success criteria\n```\n\n‚Üí See `references/cold-boot-checklist.md`\n\n## Context Compression\n\n### When to Compress\n\nCompress context when:\n- Approaching context window limit\n- Session becoming unwieldy\n- Need to switch focus\n- Conversation has lots of verbose output\n\n### Compression Strategies\n\n| Strategy | What to Do | When to Use |\n|----------|------------|-------------|\n| **Summarize** | Replace verbose content with summary | Long outputs, exploration |\n| **Extract** | Move decisions to ADRs | Architectural discussions |\n| **Archive** | Move to handoff, reference by file | Completed work |\n| **Prune** | Remove irrelevant content | Tangential discussions |\n| **Reference** | Point to files instead of including | Large code blocks |\n\n### Compression Process\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                       CONTEXT COMPRESSION                                    ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  1. IDENTIFY what's taking space                                            ‚îÇ\n‚îÇ     ‚Ä¢ Long code outputs                                                     ‚îÇ\n‚îÇ     ‚Ä¢ Verbose error messages                                                ‚îÇ\n‚îÇ     ‚Ä¢ Exploratory discussions                                               ‚îÇ\n‚îÇ     ‚Ä¢ Completed work details                                                ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  2. EXTRACT important information                                           ‚îÇ\n‚îÇ     ‚Ä¢ Decisions ‚Üí ADRs                                                      ‚îÇ\n‚îÇ     ‚Ä¢ Code ‚Üí files (already there)                                          ‚îÇ\n‚îÇ     ‚Ä¢ Findings ‚Üí handoff notes                                              ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  3. SUMMARIZE for continuity                                                ‚îÇ\n‚îÇ     ‚Ä¢ \"We explored X, Y, Z and decided on Y because...\"                     ‚îÇ\n‚îÇ     ‚Ä¢ \"The error was caused by... and fixed by...\"                          ‚îÇ\n‚îÇ     ‚Ä¢ \"Completed: A, B, C. Remaining: D, E\"                                 ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  4. CREATE handoff document                                                 ‚îÇ\n‚îÇ     ‚Ä¢ Capture everything needed to continue                                 ‚îÇ\n‚îÇ     ‚Ä¢ Reference files instead of including content                          ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  5. CONTINUE with fresh context                                             ‚îÇ\n‚îÇ     ‚Ä¢ Start new session with cold boot                                      ‚îÇ\n‚îÇ     ‚Ä¢ Load only what's needed                                               ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### What to Keep vs. Archive\n\n| Keep in Context | Archive to Files |\n|-----------------|------------------|\n| Current task and immediate context | Completed tasks |\n| Active blockers | Resolved issues |\n| Relevant decisions | Decision rationale (‚Üí ADR) |\n| Current file state | Previous iterations |\n| Next steps | Historical exploration |\n\n‚Üí See `references/compression-strategies.md`\n\n## Decision Records (ADRs)\n\n### When to Create an ADR\n\nCreate an ADR when:\n- Choosing between technologies\n- Defining architectural patterns\n- Establishing conventions\n- Making trade-offs\n- Decisions that affect multiple systems\n\n### ADR Format\n\n```markdown\n# ADR-[NNN]: [Title]\n\n## Status\n[Proposed | Accepted | Deprecated | Superseded by ADR-XXX]\n\n## Date\nYYYY-MM-DD\n\n## Context\n[What is the issue that we're seeing that is motivating this decision?]\n\n## Options Considered\n\n### Option 1: [Name]\n**Description:** [What is this option?]\n\n**Pros:**\n- [Pro 1]\n- [Pro 2]\n\n**Cons:**\n- [Con 1]\n- [Con 2]\n\n### Option 2: [Name]\n[Same structure]\n\n### Option 3: [Name]\n[Same structure]\n\n## Decision\n[What is the decision that was made?]\n\n## Rationale\n[Why was this decision made? What factors were most important?]\n\n## Consequences\n\n### Positive\n- [Consequence 1]\n- [Consequence 2]\n\n### Negative\n- [Consequence 1]\n- [Consequence 2]\n\n### Risks\n- [Risk 1] - Mitigation: [how]\n\n## Related\n- ADR-[NNN]: [Related decision]\n- Issue: #[number]\n```\n\n‚Üí See `references/adr-template.md`\n\n## Interface Contracts\n\n### API Contracts\n\nStore in `interfaces/api/`:\n\n```yaml\n# auth-service.yaml\nopenapi: 3.0.0\ninfo:\n  title: Auth Service API\n  version: 1.0.0\n  description: Authentication and authorization endpoints\n\npaths:\n  /auth/login:\n    post:\n      summary: Authenticate user\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/LoginRequest'\n      responses:\n        '200':\n          description: Successful authentication\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/AuthResponse'\n\ncomponents:\n  schemas:\n    LoginRequest:\n      type: object\n      required: [email, password]\n      properties:\n        email:\n          type: string\n          format: email\n        password:\n          type: string\n\n    AuthResponse:\n      type: object\n      properties:\n        token:\n          type: string\n        expiresAt:\n          type: string\n          format: date-time\n```\n\n### Event Contracts\n\nStore in `interfaces/events/`:\n\n```yaml\n# order-events.yaml\nasyncapi: 2.0.0\ninfo:\n  title: Order Events\n  version: 1.0.0\n\nchannels:\n  orders/created:\n    publish:\n      message:\n        $ref: '#/components/messages/OrderCreated'\n\n  orders/completed:\n    publish:\n      message:\n        $ref: '#/components/messages/OrderCompleted'\n\ncomponents:\n  messages:\n    OrderCreated:\n      payload:\n        type: object\n        properties:\n          orderId:\n            type: string\n          customerId:\n            type: string\n          createdAt:\n            type: string\n            format: date-time\n\n    OrderCompleted:\n      payload:\n        type: object\n        properties:\n          orderId:\n            type: string\n          completedAt:\n            type: string\n            format: date-time\n          signature:\n            type: string\n            description: Base64 encoded signature image\n```\n\n‚Üí See `references/interface-contracts.md`\n\n## Glossary\n\nMaintain domain terminology:\n\n```markdown\n# Glossary: [Domain Name]\n\n## Business Terms\n\n| Term | Definition | Example |\n|------|------------|---------|\n| Work Order | A task assigned to a technician | WO-12345 |\n| Service Window | Time range for appointment | 8am-12pm |\n| First-Time Fix Rate | % of jobs completed on first visit | 85% |\n\n## Technical Terms\n\n| Term | Definition | Used In |\n|------|------------|---------|\n| JWT | JSON Web Token for auth | Auth Service |\n| Idempotency Key | Unique key to prevent duplicates | Order Service |\n\n## Abbreviations\n\n| Abbrev | Full Form |\n|--------|-----------|\n| WO | Work Order |\n| SLA | Service Level Agreement |\n| ETA | Estimated Time of Arrival |\n\n## System Names\n\n| Name | Description | Repo |\n|------|-------------|------|\n| ServiceGrid | Core work order system | azure-standard/servicegrid |\n| RouteOpt | Route optimization | azure-standard/routeopt |\n```\n\n## Multi-Agent Coordination\n\n### Shared Memory Protocol\n\nWhen multiple agents work on same domain:\n\n1. **Read before write** ‚Äî Always load latest memory state\n2. **Atomic updates** ‚Äî Complete handoff before stopping\n3. **Conflict resolution** ‚Äî Later timestamp wins, merge if possible\n4. **Communication** ‚Äî Use GitHub issue comments for async coordination\n\n### Coordination File\n\n```json\n// domain-memory/{domain}/coordination.json\n{\n  \"domain\": \"azure-standard\",\n  \"activeAgents\": [\n    {\n      \"id\": \"agent-1\",\n      \"system\": \"sys-002\",\n      \"worktree\": \"system-orders\",\n      \"startedAt\": \"2024-01-17T09:00:00Z\",\n      \"lastHeartbeat\": \"2024-01-17T14:30:00Z\"\n    }\n  ],\n  \"locks\": [\n    {\n      \"resource\": \"interfaces/api/order-service.yaml\",\n      \"holder\": \"agent-1\",\n      \"acquiredAt\": \"2024-01-17T14:00:00Z\",\n      \"reason\": \"Updating API contract\"\n    }\n  ]\n}\n```\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `entry-portal` | Creates dream-state.md and system-queue.json |\n| `engineering` (loop) | Uses memory for cold boot and handoff |\n| `architect` | Decisions go to ADRs |\n| `git-workflow` | Worktree state tracked in handoffs |\n| `spec` | FeatureSpecs referenced from issues |\n\n## Key Principles\n\n**Always create handoff.** Never end a session without documenting state.\n\n**Read before you work.** Cold boot procedure ensures continuity.\n\n**Compress, don't lose.** Extract value before archiving.\n\n**Decisions are forever.** ADRs capture why, not just what.\n\n**Contracts are agreements.** Interface changes need coordination.\n\n## Mode-Specific Behavior\n\nContext management and handoff scope differ by orchestrator mode:\n\n### Greenfield Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Full domain memory structure |\n| **Approach** | Comprehensive context management setup |\n| **Patterns** | Free choice of memory organization |\n| **Deliverables** | Full HANDOFF.md + domain memory structure |\n| **Validation** | Standard handoff verification |\n| **Constraints** | Minimal - design optimal memory structure |\n\n### Brownfield-Polish Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Gap-specific context management |\n| **Approach** | Extend existing domain memory |\n| **Patterns** | Should match existing documentation patterns |\n| **Deliverables** | Delta handoff + gap-specific context |\n| **Validation** | Existing context + new additions |\n| **Constraints** | Don't restructure existing memory artifacts |\n\n**Polish considerations:**\n- Existing project may have its own context storage\n- Handoffs should reference existing docs, not duplicate\n- ADRs only for new decisions, not existing ones\n- Cold boot includes understanding existing system state\n\n### Brownfield-Enterprise Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Change-specific context only |\n| **Approach** | Surgical context updates for audit |\n| **Patterns** | Must conform exactly to existing conventions |\n| **Deliverables** | Change record referencing ticket |\n| **Validation** | Full compliance verification |\n| **Constraints** | Requires approval for any memory structure changes |\n\n**Enterprise memory constraints:**\n- Memory artifacts must follow existing conventions\n- No new domain memory structures without approval\n- Handoffs must reference change tickets\n- Cold boot must verify change approval still valid",
  "references": [
    {
      "name": "adr-template.md",
      "path": "references/adr-template.md",
      "content": "# ADR Template\n\nArchitecture Decision Records capture significant technical decisions.\n\n## What is an ADR?\n\nAn Architecture Decision Record documents:\n- **Context** ‚Äî The situation that led to the decision\n- **Options** ‚Äî What alternatives were considered\n- **Decision** ‚Äî What was chosen\n- **Rationale** ‚Äî Why it was chosen\n- **Consequences** ‚Äî What happens as a result\n\n## When to Create an ADR\n\n### Create ADR For\n\n- Technology selection (language, framework, database)\n- Architectural patterns (monolith vs microservices, event sourcing)\n- Security approaches (auth mechanism, encryption)\n- Integration strategies (sync vs async, push vs pull)\n- Data modeling decisions (schema design, relationships)\n- API design decisions (REST vs GraphQL, versioning)\n- Infrastructure choices (cloud provider, deployment strategy)\n\n### Don't Need ADR For\n\n- Implementation details (how to write a specific function)\n- Bug fixes (unless they reveal architectural issues)\n- Temporary solutions (document as tech debt instead)\n- Obvious choices (only one viable option)\n\n## ADR Numbering\n\n```\ndecisions/\n‚îú‚îÄ‚îÄ 000-template.md           # This template\n‚îú‚îÄ‚îÄ 001-technology-stack.md   # First decision\n‚îú‚îÄ‚îÄ 002-auth-approach.md      # Second decision\n‚îú‚îÄ‚îÄ 003-database-choice.md    # Third decision\n‚îî‚îÄ‚îÄ ...\n```\n\nNumbers are sequential. Never reuse numbers.\n\n## Template\n\n```markdown\n# ADR-[NNN]: [Short Title]\n\n## Status\n\n[Proposed | Accepted | Deprecated | Superseded by ADR-XXX]\n\n## Date\n\nYYYY-MM-DD\n\n## Participants\n\n- [Name/Role] - [Author/Reviewer/Approver]\n- [Name/Role] - [Author/Reviewer/Approver]\n\n## Context\n\n[Describe the situation that requires a decision. Include:\n- What problem are we trying to solve?\n- What constraints exist?\n- What is the current state?\n- Why is this decision needed now?]\n\n## Decision Drivers\n\n- [Driver 1: e.g., \"Need to support 10,000 concurrent users\"]\n- [Driver 2: e.g., \"Team has experience with Python\"]\n- [Driver 3: e.g., \"Must integrate with existing SAP system\"]\n\n## Options Considered\n\n### Option 1: [Name]\n\n**Description:**\n[What is this option? How would it work?]\n\n**Pros:**\n- [Pro 1]\n- [Pro 2]\n- [Pro 3]\n\n**Cons:**\n- [Con 1]\n- [Con 2]\n\n**Estimated Effort:** [Low/Medium/High]\n\n### Option 2: [Name]\n\n**Description:**\n[What is this option? How would it work?]\n\n**Pros:**\n- [Pro 1]\n- [Pro 2]\n\n**Cons:**\n- [Con 1]\n- [Con 2]\n- [Con 3]\n\n**Estimated Effort:** [Low/Medium/High]\n\n### Option 3: [Name]\n\n**Description:**\n[What is this option? How would it work?]\n\n**Pros:**\n- [Pro 1]\n- [Pro 2]\n\n**Cons:**\n- [Con 1]\n- [Con 2]\n\n**Estimated Effort:** [Low/Medium/High]\n\n## Decision\n\n**We will use [Option X]: [Name]**\n\n[One or two sentences stating the decision clearly]\n\n## Rationale\n\n[Explain why this option was chosen. Address:\n- How does it best meet the decision drivers?\n- Why were other options rejected?\n- What trade-offs are being accepted?]\n\n## Consequences\n\n### Positive\n\n- [Positive consequence 1]\n- [Positive consequence 2]\n- [Positive consequence 3]\n\n### Negative\n\n- [Negative consequence 1]\n- [Negative consequence 2]\n\n### Neutral\n\n- [Neutral consequence / change in process]\n\n## Risks and Mitigations\n\n| Risk | Likelihood | Impact | Mitigation |\n|------|------------|--------|------------|\n| [Risk 1] | Low/Med/High | Low/Med/High | [How to mitigate] |\n| [Risk 2] | Low/Med/High | Low/Med/High | [How to mitigate] |\n\n## Related Decisions\n\n- ADR-[NNN]: [Related ADR title]\n- ADR-[NNN]: [Related ADR title]\n\n## References\n\n- [Link to relevant documentation]\n- [Link to research or benchmarks]\n- GitHub Issue: #[number]\n\n## Notes\n\n[Any additional context, caveats, or future considerations]\n\n---\n\n*Last updated: YYYY-MM-DD*\n```\n\n## Example ADR\n\n```markdown\n# ADR-002: Authentication Approach\n\n## Status\n\nAccepted\n\n## Date\n\n2024-01-15\n\n## Participants\n\n- Tech Lead - Author\n- Security Team - Reviewer\n- CTO - Approver\n\n## Context\n\nWe need to implement authentication for the ServiceGrid platform. The system will have:\n- Web application for dispatchers\n- Mobile app for technicians\n- API for third-party integrations\n\nCurrently, we have no authentication system. The team has experience with both\nsession-based and token-based auth. We need to support offline mobile access.\n\n## Decision Drivers\n\n- Must support offline mobile access (technicians in areas with poor connectivity)\n- Must support third-party API access\n- Security team requires short-lived credentials\n- Team has experience with JWT from previous projects\n\n## Options Considered\n\n### Option 1: Session-Based Authentication\n\n**Description:**\nStore sessions server-side in Redis. Cookie-based for web, custom header for mobile.\n\n**Pros:**\n- Simple to implement\n- Easy to revoke (delete session)\n- Server has full control\n\n**Cons:**\n- Requires session store (Redis)\n- Doesn't work offline on mobile\n- Not great for third-party APIs\n- Additional infrastructure\n\n**Estimated Effort:** Medium\n\n### Option 2: JWT-Based Authentication\n\n**Description:**\nUse JSON Web Tokens with short expiry. Refresh tokens for long sessions.\nAccess tokens stored in memory (web) or secure storage (mobile).\n\n**Pros:**\n- Stateless (no session store needed)\n- Works offline (until token expires)\n- Standard approach for APIs\n- Team has experience\n\n**Cons:**\n- Token revocation requires additional strategy\n- Token size larger than session ID\n- Must handle token refresh\n\n**Estimated Effort:** Medium\n\n### Option 3: OAuth 2.0 with External Provider\n\n**Description:**\nUse Auth0 or Okta for authentication. Delegate all auth complexity to provider.\n\n**Pros:**\n- Handles all auth complexity\n- Built-in MFA, social login\n- Security handled by experts\n\n**Cons:**\n- Additional cost ($$$)\n- External dependency for critical path\n- May not work offline\n- Less control\n\n**Estimated Effort:** Low (implementation) / High (cost)\n\n## Decision\n\n**We will use Option 2: JWT-Based Authentication**\n\nWe will implement JWT authentication with:\n- 15-minute access token expiry\n- 7-day refresh token expiry\n- Refresh token rotation on use\n- Redis-based revocation list for compromised tokens\n\n## Rationale\n\nJWT best meets our decision drivers:\n1. **Offline support**: Tokens work without server contact until expiry\n2. **API support**: Standard Bearer token approach\n3. **Short-lived credentials**: 15-minute expiry satisfies security\n4. **Team experience**: We've built JWT auth before\n\nSessions were rejected due to offline requirements. OAuth providers were\nrejected due to cost and offline concerns.\n\n## Consequences\n\n### Positive\n\n- No session store needed for normal operation\n- Mobile app works offline until token expiry\n- Clean API authentication story\n- Standard approach, easy to understand\n\n### Negative\n\n- Must implement token refresh logic\n- Must maintain revocation list for compromised tokens\n- Tokens larger than session IDs (minor bandwidth impact)\n\n### Neutral\n\n- Will use Redis for revocation list only (not all sessions)\n\n## Risks and Mitigations\n\n| Risk | Likelihood | Impact | Mitigation |\n|------|------------|--------|------------|\n| Token theft | Medium | High | Short expiry, HTTPS only, secure storage |\n| Refresh token leak | Low | High | Token rotation, device binding |\n| Offline token expiry | Medium | Medium | Grace period, background refresh |\n\n## Related Decisions\n\n- ADR-001: Technology Stack (chose Node.js)\n- ADR-003: API Design (will use REST)\n\n## References\n\n- OWASP JWT Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html\n- RFC 7519 (JWT): https://tools.ietf.org/html/rfc7519\n- GitHub Issue: #45\n\n---\n\n*Last updated: 2024-01-15*\n```\n\n## ADR Lifecycle\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   Proposed   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Accepted   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Superseded  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                            ‚îÇ                    ‚ñ≤\n                            ‚îÇ                    ‚îÇ\n                            ‚ñº                    ‚îÇ\n                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ\n                     ‚îÇ  Deprecated  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### Status Definitions\n\n| Status | Meaning |\n|--------|---------|\n| **Proposed** | Under discussion, not yet decided |\n| **Accepted** | Decision made, actively followed |\n| **Deprecated** | No longer recommended, but still understood |\n| **Superseded** | Replaced by a newer ADR |\n\n### Updating ADRs\n\n- **Never delete** ADRs (they're history)\n- **Never modify** decisions retroactively\n- **Add notes** for clarifications\n- **Create new ADR** to supersede old one\n\n## Quick ADR Template\n\nFor simpler decisions:\n\n```markdown\n# ADR-[NNN]: [Title]\n\n**Status:** Accepted\n**Date:** YYYY-MM-DD\n\n## Context\n[What's the situation?]\n\n## Decision\n[What did we decide?]\n\n## Consequences\n[What happens as a result?]\n```\n"
    },
    {
      "name": "cold-boot-checklist.md",
      "path": "references/cold-boot-checklist.md",
      "content": "# Cold Boot Checklist\n\nStep-by-step procedure for resuming work on a domain.\n\n## Overview\n\nCold boot is the process of loading context when starting a new session. It ensures continuity and prevents lost work or duplicated effort.\n\n## Full Cold Boot Procedure\n\n### Phase 1: Domain Context\n\n```markdown\n## 1. Load Domain Context\n\n### 1.1 Read Dream State\n- [ ] Open `domain-memory/{domain}/dream-state.md`\n- [ ] Understand the overall vision\n- [ ] Note key capabilities and constraints\n- [ ] Understand success metrics\n\n**Quick check:** Can I explain the domain's purpose in one sentence?\n\n### 1.2 Read Glossary\n- [ ] Open `domain-memory/{domain}/glossary.md`\n- [ ] Review business terms\n- [ ] Review technical terms\n- [ ] Note any abbreviations\n\n**Quick check:** Do I understand domain-specific terminology?\n\n### 1.3 Check System Queue\n- [ ] Open `domain-memory/{domain}/system-queue.json`\n- [ ] Identify current system (status: in-progress)\n- [ ] Note dependencies and blockers\n- [ ] Understand priority order\n\n**Quick check:** Do I know which system to work on?\n```\n\n### Phase 2: System Context\n\n```markdown\n## 2. Load System Context\n\n### 2.1 Read GitHub Issue\n- [ ] Open issue #[number] for current system\n- [ ] Read the overview and acceptance criteria\n- [ ] Check comments for updates or discussions\n- [ ] Note any linked PRs or related issues\n\n**Quick check:** Do I know what this system should do?\n\n### 2.2 Read FeatureSpec\n- [ ] Expand FeatureSpec in issue (or open linked doc)\n- [ ] Review all 18 sections\n- [ ] Pay attention to:\n  - Capabilities (what to build)\n  - Validation criteria (how to verify)\n  - Technical requirements (constraints)\n  - Edge cases (what could go wrong)\n\n**Quick check:** Do I know the detailed requirements?\n\n### 2.3 Read Interface Contracts\n- [ ] Check `domain-memory/{domain}/interfaces/api/`\n- [ ] Check `domain-memory/{domain}/interfaces/events/`\n- [ ] Identify APIs this system:\n  - Exposes (we define)\n  - Consumes (others define)\n\n**Quick check:** Do I know the integration points?\n```\n\n### Phase 3: Session History\n\n```markdown\n## 3. Load Session History\n\n### 3.1 Find Latest Handoff\n- [ ] Open `domain-memory/{domain}/sessions/`\n- [ ] Find most recent handoff for this system\n- [ ] Read the complete handoff document\n\n### 3.2 Understand Completed Work\n- [ ] Review \"Completed This Session\" section\n- [ ] Review commits listed\n- [ ] Understand what's already done\n\n### 3.3 Understand Current State\n- [ ] Read \"Current State\" section\n- [ ] Note code state (tests passing/failing)\n- [ ] Note any uncommitted changes\n- [ ] Note any stashed work\n\n### 3.4 Understand Next Steps\n- [ ] Read \"Next Steps\" section\n- [ ] Understand immediate tasks\n- [ ] Note any blockers or issues\n\n### 3.5 Check Previous Sessions (if needed)\n- [ ] Read 1-2 previous handoffs if context unclear\n- [ ] Understand progression of work\n\n**Quick check:** Do I know exactly where we left off?\n```\n\n### Phase 4: Decisions\n\n```markdown\n## 4. Load Decisions\n\n### 4.1 Identify Relevant ADRs\n- [ ] Check `domain-memory/{domain}/decisions/`\n- [ ] Identify ADRs relevant to current system\n- [ ] Typically relevant:\n  - Technology stack decisions\n  - Architectural patterns\n  - Security approaches\n  - Integration decisions\n\n### 4.2 Read Relevant ADRs\n- [ ] Read each relevant ADR\n- [ ] Understand the decision and rationale\n- [ ] Note any constraints this imposes\n\n**Quick check:** Do I know the architectural constraints?\n```\n\n### Phase 5: Code State\n\n```markdown\n## 5. Verify Code State\n\n### 5.1 Navigate to Worktree\n```bash\ncd /path/to/repo/.worktrees/{system-name}\npwd  # Verify location\n```\n\n### 5.2 Check Git Status\n```bash\ngit status\ngit branch --show-current  # Verify branch\ngit log --oneline -5       # Verify recent commits\n```\n\n### 5.3 Check for Uncommitted Work\n```bash\ngit diff                   # Modified files\ngit diff --staged          # Staged files\ngit stash list             # Stashed changes\n```\n\n### 5.4 Verify Build/Tests\n```bash\nnpm install                # Or equivalent\nnpm run build              # Verify build\nnpm test                   # Verify tests\nnpm run lint               # Verify lint\n```\n\n### 5.5 Reconcile with Handoff\n- [ ] Code state matches handoff description\n- [ ] Any discrepancies investigated and understood\n\n**Quick check:** Is the code in the expected state?\n```\n\n### Phase 6: Confirm Understanding\n\n```markdown\n## 6. Confirm Understanding\n\n### 6.1 Self-Check\nAnswer these questions:\n\n1. **What domain am I working in?**\n   [Answer]\n\n2. **What system am I building?**\n   [Answer]\n\n3. **What was completed last session?**\n   [Answer]\n\n4. **What is the immediate next task?**\n   [Answer]\n\n5. **What are the current blockers?**\n   [Answer]\n\n6. **What architectural constraints apply?**\n   [Answer]\n\n### 6.2 Summarize Context (Optional)\nIf working with human, summarize understanding:\n\n\"I'm working on [system] for [domain]. Last session completed [X, Y, Z].\nThe immediate next step is [task]. Current blockers are [blockers].\nTests are [passing/failing]. Ready to continue with [specific action].\"\n\n**Quick check:** Could I explain the context to someone else?\n```\n\n## Quick Cold Boot\n\nFor shorter sessions or familiar context:\n\n```markdown\n## Quick Cold Boot Checklist\n\n- [ ] Read last session handoff\n- [ ] Check system-queue.json for current system\n- [ ] Navigate to worktree\n- [ ] Run `git status` and `npm test`\n- [ ] Confirm next steps from handoff\n- [ ] Begin work\n```\n\n## Cold Boot by Scenario\n\n### Scenario: Continuing Yesterday's Work\n\n```markdown\n1. Read yesterday's handoff\n2. Go to worktree\n3. Check git status\n4. Run tests\n5. Continue from \"Next Steps\"\n```\n\n### Scenario: New System (First Session)\n\n```markdown\n1. Read dream-state.md\n2. Read glossary.md\n3. Read system-queue.json\n4. Read GitHub issue with FeatureSpec\n5. Read relevant ADRs\n6. Create worktree\n7. Begin scaffold\n```\n\n### Scenario: Picking Up After Another Agent\n\n```markdown\n1. Read ALL handoffs for this system\n2. Read GitHub issue comments\n3. Check PR if one exists\n4. Go to worktree\n5. Review ALL uncommitted changes\n6. Run full test suite\n7. Reconcile any confusion before proceeding\n```\n\n### Scenario: Resuming After Long Break\n\n```markdown\n1. Full cold boot (all phases)\n2. Read last 3-5 handoffs\n3. Check for any GitHub activity\n4. Check if dependencies changed\n5. Update dependencies\n6. Run full test suite\n7. Consider reviewing recent commits in detail\n```\n\n## Troubleshooting\n\n### Handoff Missing or Incomplete\n\n```markdown\nOptions:\n1. Check git log for commits since last known state\n2. Check GitHub issue comments\n3. Review code changes to infer progress\n4. Ask human engineer for context\n5. Document gaps and proceed carefully\n```\n\n### Code State Doesn't Match Handoff\n\n```markdown\nOptions:\n1. Check for uncommitted changes\n2. Check git stash\n3. Check other branches\n4. Compare commit hashes\n5. May need to investigate with git reflog\n```\n\n### Tests Failing Unexpectedly\n\n```markdown\nOptions:\n1. Check if handoff mentioned failing tests\n2. Check if dependencies changed\n3. Check if environment differs\n4. Run tests in isolation\n5. May be regression - investigate before continuing\n```\n\n### Can't Find Worktree\n\n```markdown\nCommands:\ngit worktree list  # Find all worktrees\ngit branch -a      # Find all branches\n\nRecovery:\ngit worktree add .worktrees/{name} {branch-name}\n```\n\n## Cold Boot Timing\n\n| Scenario | Expected Time |\n|----------|---------------|\n| Quick boot (familiar context) | 5-10 min |\n| Standard boot | 15-20 min |\n| Full boot (new system) | 30-45 min |\n| Boot after long break | 45-60 min |\n\nInvest the time upfront - it saves debugging later.\n"
    },
    {
      "name": "compression-strategies.md",
      "path": "references/compression-strategies.md",
      "content": "# Compression Strategies\n\nTechniques for managing context window limits.\n\n## Why Compress?\n\nContext windows are finite. Long sessions accumulate:\n- Verbose command outputs\n- Exploratory discussions\n- Code iterations\n- Error messages and stack traces\n- Back-and-forth debugging\n\nCompression extracts value and discards noise.\n\n## When to Compress\n\n### Proactive (Before Limit)\n\n| Signal | Action |\n|--------|--------|\n| Session > 2 hours | Consider creating checkpoint handoff |\n| Many long outputs | Summarize and archive |\n| Switching focus | Compress current topic, start fresh |\n| Exploration complete | Extract decisions, discard attempts |\n\n### Reactive (At Limit)\n\n| Signal | Action |\n|--------|--------|\n| Context limit warning | Immediate handoff creation |\n| Responses truncating | Emergency compression |\n| Memory feeling \"foggy\" | Create handoff, cold boot |\n\n## Compression Strategies\n\n### Strategy 1: Summarize\n\n**What:** Replace verbose content with concise summary.\n\n**When:** Long outputs, exploratory discussions, debugging sessions.\n\n**Before:**\n```\n[50 lines of npm install output]\n[30 lines of build output]\n[20 lines of test output showing all tests]\n```\n\n**After:**\n```\nDependencies installed successfully.\nBuild completed with 0 warnings.\nAll 47 tests passing.\n```\n\n**Rule:** If output confirmed something works, one sentence is enough.\n\n### Strategy 2: Extract to ADR\n\n**What:** Move architectural discussions to permanent ADR.\n\n**When:** Decision made after exploring options.\n\n**Before:**\n```\n[Long discussion about auth approaches]\n\"We could use JWT because X, or sessions because Y, or OAuth because Z...\"\n[More back and forth]\n\"Let's go with JWT because of A, B, C reasons\"\n```\n\n**After:**\n```\nCreated ADR-003: Authentication Approach\nDecision: JWT-based authentication\nSee: domain-memory/{domain}/decisions/003-auth-approach.md\n```\n\n**Rule:** If a decision affects architecture, it deserves an ADR.\n\n### Strategy 3: Archive to Handoff\n\n**What:** Move completed work details to handoff document.\n\n**When:** Task/feature complete, moving to next thing.\n\n**Before:**\n```\n[Detailed implementation of UserService]\n[All the code changes made]\n[Test results and iterations]\n[Debugging session for that one bug]\n```\n\n**After:**\n```\nCompleted: UserService implementation\n- Added CRUD operations\n- Added validation\n- Fixed timezone bug (was using local instead of UTC)\n- All tests passing\nDetails: sessions/2024-01-17-user-service.md\nCommits: abc1234, def5678\n```\n\n**Rule:** If it's done, the details can live in files.\n\n### Strategy 4: Reference Files\n\n**What:** Point to files instead of including content.\n\n**When:** Code, configs, large documents.\n\n**Before:**\n```typescript\n// Here's the complete implementation:\nexport class OrderService {\n  // [100 lines of code]\n}\n```\n\n**After:**\n```\nOrderService implemented at: src/services/order.service.ts\nKey methods: create(), update(), complete(), cancel()\n```\n\n**Rule:** Code lives in files. Context holds pointers.\n\n### Strategy 5: Prune Irrelevant\n\n**What:** Acknowledge and discard tangential content.\n\n**When:** Off-topic discussions, abandoned approaches.\n\n**Before:**\n```\n[Long tangent about whether to use Prisma or TypeORM]\n[Ultimately didn't matter because we're using raw SQL]\n```\n\n**After:**\n```\n[Removed: ORM discussion - decided on raw SQL per ADR-005]\n```\n\n**Rule:** If it didn't affect outcomes, it can go.\n\n### Strategy 6: Batch Similar Items\n\n**What:** Combine multiple similar items into summary.\n\n**When:** Repetitive operations, multiple file changes.\n\n**Before:**\n```\nCreated src/models/user.ts\nCreated src/models/order.ts\nCreated src/models/product.ts\nCreated src/models/category.ts\nCreated src/models/inventory.ts\n```\n\n**After:**\n```\nCreated 5 model files: user, order, product, category, inventory\nLocation: src/models/*.ts\n```\n\n**Rule:** If pattern is clear, summarize the batch.\n\n## Compression Process\n\n### Step 1: Identify Compression Candidates\n\nLook for:\n- Long command outputs (builds, tests, installs)\n- Exploratory discussions (trying options)\n- Debugging sessions (once bug is fixed)\n- Repeated information\n- Verbose error messages (once resolved)\n\n### Step 2: Extract Value\n\nFor each candidate:\n- What was the outcome?\n- What decision was made?\n- What did we learn?\n- What needs to be preserved for future?\n\n### Step 3: Choose Strategy\n\n| Content Type | Strategy |\n|--------------|----------|\n| Command output | Summarize |\n| Architecture discussion | Extract to ADR |\n| Completed work | Archive to handoff |\n| Code blocks | Reference files |\n| Tangents | Prune |\n| Repetitive items | Batch |\n\n### Step 4: Create Handoff\n\nBefore compressing, ensure handoff captures:\n- Current state\n- Decisions made\n- Next steps\n- Anything surprising\n\n### Step 5: Compress\n\nApply strategies, leaving context with:\n- Current task and immediate context\n- Active blockers\n- Pointers to archived content\n- Clean starting point\n\n## What to NEVER Compress\n\n| Keep | Reason |\n|------|--------|\n| Current task context | Need it now |\n| Active blockers | Need resolution |\n| Uncommitted changes | Could be lost |\n| Recent decisions | Need to remember |\n| Error being debugged | Currently relevant |\n\n## Compression Templates\n\n### Completed Feature\n\n```markdown\n‚úÖ [Feature Name] Complete\n- Commits: [list hashes]\n- Tests: [X] passing\n- Key files: [list]\n- Details: sessions/[handoff-file].md\n```\n\n### Resolved Bug\n\n```markdown\nüêõ Fixed: [Bug description]\n- Cause: [Root cause]\n- Fix: [What was changed]\n- Commit: [hash]\n```\n\n### Decision Made\n\n```markdown\nüìã Decision: [Topic]\n- Choice: [What was decided]\n- Rationale: [One sentence]\n- ADR: decisions/[number]-[name].md\n```\n\n### Exploration Completed\n\n```markdown\nüîç Explored: [Topic]\n- Options: [A, B, C]\n- Selected: [B]\n- Why: [One sentence]\n- Details: [ADR or handoff reference]\n```\n\n## Emergency Compression\n\nWhen hitting limit unexpectedly:\n\n```markdown\n## EMERGENCY COMPRESSION CHECKLIST\n\n1. [ ] Stop current task safely\n2. [ ] Commit any code changes\n3. [ ] Note current state in quick handoff:\n   - Branch:\n   - Last commit:\n   - Working on:\n   - Tests status:\n   - Next step:\n4. [ ] Save handoff to sessions/\n5. [ ] Start new session with cold boot\n```\n\n## Context Budget Guidelines\n\n| Category | Budget |\n|----------|--------|\n| Current task context | 40% |\n| Recent history | 20% |\n| Decisions & constraints | 15% |\n| Blockers & issues | 10% |\n| File references | 10% |\n| Buffer | 5% |\n\nIf any category exceeds budget, compress that category first.\n"
    },
    {
      "name": "handoff-template.md",
      "path": "references/handoff-template.md",
      "content": "# Handoff Template\n\nComplete template for session handoff documents.\n\n## Template\n\n```markdown\n# Session Handoff: [YYYY-MM-DD] - [System/Task Name]\n\n## Session Metadata\n\n| Property | Value |\n|----------|-------|\n| **Date** | YYYY-MM-DD |\n| **Time** | HH:MM - HH:MM (timezone) |\n| **Duration** | X hours |\n| **Domain** | [domain-name] |\n| **System** | [system-name] (sys-XXX) |\n| **GitHub Issue** | #[number] |\n| **Agent/Engineer** | [identifier] |\n| **Branch** | feature/[name] |\n| **Worktree** | .worktrees/[name] |\n| **Last Commit** | [short-hash] - [message] |\n\n---\n\n## Executive Summary\n\n[2-3 sentences: What was this session about? What's the current state?]\n\n---\n\n## Completed This Session\n\n### Tasks Completed\n- [x] [Task 1 - brief description]\n- [x] [Task 2 - brief description]\n- [x] [Task 3 - brief description]\n\n### Commits Made\n\n| Commit | Type | Description |\n|--------|------|-------------|\n| `abc1234` | feat | [What it implemented] |\n| `def5678` | test | [What tests were added] |\n| `ghi9012` | fix | [What was fixed] |\n\n### Tests Added/Updated\n- [test file 1]: [what it tests]\n- [test file 2]: [what it tests]\n\n### Documentation Updated\n- [doc 1]: [what changed]\n- [doc 2]: [what changed]\n\n---\n\n## Current State\n\n### Active Work Item\n**Currently working on:** [Specific task or feature]\n\n**Progress:** [X]% complete\n\n**State:** [Description of where things left off]\n\n### Code State\n\n| Check | Status | Notes |\n|-------|--------|-------|\n| Build | ‚úÖ Pass / ‚ùå Fail | [details if failing] |\n| Lint | ‚úÖ Pass / ‚ùå Fail | [details if failing] |\n| Types | ‚úÖ Pass / ‚ùå Fail | [details if failing] |\n| Unit Tests | ‚úÖ Pass / ‚ùå Fail | [X/Y passing, details if failing] |\n| Integration Tests | ‚úÖ Pass / ‚ùå Fail | [details if failing] |\n\n### Uncommitted Changes\n\n| File | Change Type | Description |\n|------|-------------|-------------|\n| `src/file1.ts` | Modified | [What was changed] |\n| `src/file2.ts` | Added | [What it contains] |\n\n**Stashed changes:** [Yes/No - if yes, describe]\n\n---\n\n## Decisions Made\n\n### This Session\n\n| Decision | Choice | Rationale |\n|----------|--------|-----------|\n| [Decision 1] | [What was chosen] | [Why] |\n| [Decision 2] | [What was chosen] | [Why] |\n\n### ADRs Created/Updated\n- ADR-[NNN]: [Title] - [New/Updated]\n\n---\n\n## Blockers & Issues\n\n### Current Blockers\n\n| Blocker | Impact | Needed Resolution |\n|---------|--------|-------------------|\n| [Blocker 1] | [What it blocks] | [Who/what needed] |\n| [Blocker 2] | [What it blocks] | [Who/what needed] |\n\n### Known Issues\n\n| Issue | Severity | Status |\n|-------|----------|--------|\n| [Issue 1] | Low/Med/High | [Investigating/Workaround/Deferred] |\n| [Issue 2] | Low/Med/High | [Status] |\n\n### Technical Debt Identified\n- [Debt item 1] - [Impact]\n- [Debt item 2] - [Impact]\n\n---\n\n## Next Steps\n\n### Immediate (Start of Next Session)\n\n1. **[First task]**\n   - [Specific action to take]\n   - [Expected outcome]\n\n2. **[Second task]**\n   - [Specific action to take]\n   - [Expected outcome]\n\n3. **[Third task]**\n   - [Specific action to take]\n   - [Expected outcome]\n\n### Remaining for This System\n\n- [ ] [Remaining task 1]\n- [ ] [Remaining task 2]\n- [ ] [Remaining task 3]\n\n### Estimated Remaining Effort\n[X hours/days] to complete current system\n\n---\n\n## Open Questions\n\n| Question | Context | Who Can Answer |\n|----------|---------|----------------|\n| [Question 1] | [Why it matters] | [Person/Team] |\n| [Question 2] | [Why it matters] | [Person/Team] |\n\n---\n\n## Dependencies & Integration\n\n### Waiting On\n- [Dependency 1]: [Status/ETA]\n- [Dependency 2]: [Status/ETA]\n\n### Interface Changes Made\n- [API/Event change]: [Description]\n\n### Coordination Needed\n- [Team/Person]: [What's needed]\n\n---\n\n## Artifacts & References\n\n### Files to Review (Next Session)\n| File | Reason |\n|------|--------|\n| `src/[path]` | [Why to review] |\n| `tests/[path]` | [Why to review] |\n\n### Documentation\n- FeatureSpec: [link to issue]\n- API Docs: [link]\n- Architecture: [link]\n\n### External References\n- [Reference 1]: [link]\n- [Reference 2]: [link]\n\n---\n\n## Environment & Setup\n\n### Commands to Run First\n```bash\n# Navigate to worktree\ncd /path/to/repo/.worktrees/[system-name]\n\n# Verify state\ngit status\ngit log --oneline -5\n\n# Run checks\nnpm test\nnpm run lint\n```\n\n### Environment Variables Needed\n```bash\nexport VAR_NAME=value\n```\n\n### Services Required\n- [Service 1]: [How to start]\n- [Service 2]: [How to start]\n\n---\n\n## Session Log Highlights\n\n### Key Discoveries\n- [Discovery 1]: [Implication]\n- [Discovery 2]: [Implication]\n\n### Approaches Tried & Abandoned\n| Approach | Why Abandoned |\n|----------|---------------|\n| [Approach 1] | [Reason] |\n| [Approach 2] | [Reason] |\n\n### Performance Notes\n- [Any performance observations]\n\n---\n\n## Handoff Notes\n\n### For Human Engineers\n[Any specific context a human would need]\n\n### For AI Agents\n[Any specific context an AI agent would need]\n\n### Warnings\n- ‚ö†Ô∏è [Warning 1]\n- ‚ö†Ô∏è [Warning 2]\n\n---\n\n*Handoff created: [timestamp]*\n*Previous handoff: [link to previous session file]*\n```\n\n## Minimal Handoff Template\n\nFor quick handoffs when time is limited:\n\n```markdown\n# Quick Handoff: [Date] - [System]\n\n**Branch:** feature/[name]\n**Last Commit:** [hash] - [message]\n**Tests:** ‚úÖ All passing / ‚ùå [X] failing\n\n## Done\n- [x] [Item 1]\n- [x] [Item 2]\n\n## In Progress\n[What was being worked on]\n\n## Next\n1. [Immediate next step]\n2. [Following step]\n\n## Blockers\n- [Any blockers]\n\n## Notes\n[Anything critical to know]\n```\n\n## Handoff Best Practices\n\n### Do\n- Write handoff BEFORE ending session\n- Be specific about next steps\n- Include commands to run\n- Note anything surprising or non-obvious\n- Reference files by path\n\n### Don't\n- Leave handoff until memory is fuzzy\n- Use vague descriptions (\"fix the thing\")\n- Assume context will be remembered\n- Skip the verification steps\n- Forget uncommitted changes\n\n### Timing\n- Start handoff 15-30 min before session end\n- Leave time to verify completeness\n- Commit handoff file to repo if appropriate\n\n## File Naming Convention\n\n```\nsessions/\n‚îú‚îÄ‚îÄ 2024-01-15-auth-service-initial.md\n‚îú‚îÄ‚îÄ 2024-01-16-auth-service-complete.md\n‚îú‚îÄ‚îÄ 2024-01-17-order-service-part1.md\n‚îú‚îÄ‚îÄ 2024-01-18-order-service-part2.md\n‚îî‚îÄ‚îÄ 2024-01-19-order-service-complete.md\n```\n\nFormat: `YYYY-MM-DD-{system-name}-{descriptor}.md`\n\nDescriptors:\n- `initial` - First session on system\n- `part1`, `part2`, etc. - Multi-session work\n- `complete` - Final session for system\n- `hotfix` - Urgent fix session\n- `review` - Review/refactor session\n"
    },
    {
      "name": "interface-contracts.md",
      "path": "references/interface-contracts.md",
      "content": "# Interface Contracts\n\nDocumenting APIs and events between systems.\n\n## Why Interface Contracts?\n\nWhen multiple systems need to communicate:\n- Contracts define the agreement between producer and consumer\n- Changes can be coordinated before implementation\n- Documentation serves as single source of truth\n- Contracts can be validated automatically\n\n## Contract Types\n\n| Type | Format | Use Case |\n|------|--------|----------|\n| REST API | OpenAPI 3.0 | Synchronous HTTP APIs |\n| GraphQL | SDL | Flexible query APIs |\n| Events | AsyncAPI | Async message passing |\n| gRPC | Protocol Buffers | High-performance RPC |\n\n## Directory Structure\n\n```\ninterfaces/\n‚îú‚îÄ‚îÄ api/                    # REST/HTTP APIs\n‚îÇ   ‚îú‚îÄ‚îÄ auth-service.yaml\n‚îÇ   ‚îú‚îÄ‚îÄ order-service.yaml\n‚îÇ   ‚îî‚îÄ‚îÄ user-service.yaml\n‚îú‚îÄ‚îÄ events/                 # Async events\n‚îÇ   ‚îú‚îÄ‚îÄ order-events.yaml\n‚îÇ   ‚îî‚îÄ‚îÄ notification-events.yaml\n‚îî‚îÄ‚îÄ shared/                 # Shared schemas\n    ‚îú‚îÄ‚îÄ common-types.yaml\n    ‚îî‚îÄ‚îÄ error-responses.yaml\n```\n\n## REST API Contracts (OpenAPI)\n\n### Basic Template\n\n```yaml\nopenapi: 3.0.3\ninfo:\n  title: [Service Name] API\n  version: 1.0.0\n  description: |\n    [Description of what this API does]\n  contact:\n    name: [Team Name]\n    email: team@example.com\n\nservers:\n  - url: https://api.example.com/v1\n    description: Production\n  - url: https://staging-api.example.com/v1\n    description: Staging\n\ntags:\n  - name: [Resource]\n    description: Operations on [Resource]\n\npaths:\n  /resource:\n    get:\n      summary: List resources\n      tags: [Resource]\n      parameters:\n        - $ref: '#/components/parameters/PageParam'\n        - $ref: '#/components/parameters/LimitParam'\n      responses:\n        '200':\n          description: Successful response\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/ResourceList'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n\n    post:\n      summary: Create resource\n      tags: [Resource]\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/CreateResourceRequest'\n      responses:\n        '201':\n          description: Resource created\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Resource'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n\n  /resource/{id}:\n    get:\n      summary: Get resource by ID\n      tags: [Resource]\n      parameters:\n        - $ref: '#/components/parameters/ResourceId'\n      responses:\n        '200':\n          description: Successful response\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Resource'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\ncomponents:\n  schemas:\n    Resource:\n      type: object\n      required:\n        - id\n        - name\n        - createdAt\n      properties:\n        id:\n          type: string\n          format: uuid\n          example: \"123e4567-e89b-12d3-a456-426614174000\"\n        name:\n          type: string\n          example: \"Example Resource\"\n        description:\n          type: string\n          nullable: true\n        createdAt:\n          type: string\n          format: date-time\n        updatedAt:\n          type: string\n          format: date-time\n\n    CreateResourceRequest:\n      type: object\n      required:\n        - name\n      properties:\n        name:\n          type: string\n          minLength: 1\n          maxLength: 255\n        description:\n          type: string\n          maxLength: 1000\n\n    ResourceList:\n      type: object\n      properties:\n        data:\n          type: array\n          items:\n            $ref: '#/components/schemas/Resource'\n        pagination:\n          $ref: '#/components/schemas/Pagination'\n\n    Pagination:\n      type: object\n      properties:\n        page:\n          type: integer\n        limit:\n          type: integer\n        total:\n          type: integer\n        hasMore:\n          type: boolean\n\n    Error:\n      type: object\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: string\n        message:\n          type: string\n        details:\n          type: object\n\n  parameters:\n    ResourceId:\n      name: id\n      in: path\n      required: true\n      schema:\n        type: string\n        format: uuid\n      description: Resource ID\n\n    PageParam:\n      name: page\n      in: query\n      schema:\n        type: integer\n        minimum: 1\n        default: 1\n      description: Page number\n\n    LimitParam:\n      name: limit\n      in: query\n      schema:\n        type: integer\n        minimum: 1\n        maximum: 100\n        default: 20\n      description: Items per page\n\n  responses:\n    BadRequest:\n      description: Invalid request\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n          example:\n            code: \"VALIDATION_ERROR\"\n            message: \"Invalid request parameters\"\n\n    Unauthorized:\n      description: Authentication required\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n          example:\n            code: \"UNAUTHORIZED\"\n            message: \"Authentication required\"\n\n    NotFound:\n      description: Resource not found\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n          example:\n            code: \"NOT_FOUND\"\n            message: \"Resource not found\"\n\n  securitySchemes:\n    BearerAuth:\n      type: http\n      scheme: bearer\n      bearerFormat: JWT\n\nsecurity:\n  - BearerAuth: []\n```\n\n### Example: Order Service API\n\n```yaml\nopenapi: 3.0.3\ninfo:\n  title: Order Service API\n  version: 1.0.0\n  description: Work order management for field service operations\n\nservers:\n  - url: https://api.servicegrid.example.com/v1\n\npaths:\n  /orders:\n    get:\n      summary: List work orders\n      parameters:\n        - name: status\n          in: query\n          schema:\n            type: string\n            enum: [pending, assigned, in_progress, completed, cancelled]\n        - name: assignedTo\n          in: query\n          schema:\n            type: string\n            format: uuid\n        - name: from\n          in: query\n          schema:\n            type: string\n            format: date\n        - name: to\n          in: query\n          schema:\n            type: string\n            format: date\n      responses:\n        '200':\n          description: List of orders\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  data:\n                    type: array\n                    items:\n                      $ref: '#/components/schemas/WorkOrder'\n\n    post:\n      summary: Create work order\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/CreateWorkOrderRequest'\n      responses:\n        '201':\n          description: Order created\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/WorkOrder'\n\n  /orders/{id}/assign:\n    post:\n      summary: Assign order to technician\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: string\n            format: uuid\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required: [technicianId]\n              properties:\n                technicianId:\n                  type: string\n                  format: uuid\n                scheduledFor:\n                  type: string\n                  format: date-time\n      responses:\n        '200':\n          description: Order assigned\n\n  /orders/{id}/complete:\n    post:\n      summary: Mark order as complete\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: string\n            format: uuid\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/CompleteOrderRequest'\n      responses:\n        '200':\n          description: Order completed\n\ncomponents:\n  schemas:\n    WorkOrder:\n      type: object\n      properties:\n        id:\n          type: string\n          format: uuid\n        orderNumber:\n          type: string\n          example: \"WO-2024-001234\"\n        status:\n          type: string\n          enum: [pending, assigned, in_progress, completed, cancelled]\n        priority:\n          type: string\n          enum: [low, normal, high, urgent]\n        customerId:\n          type: string\n          format: uuid\n        assignedTo:\n          type: string\n          format: uuid\n          nullable: true\n        location:\n          $ref: '#/components/schemas/Location'\n        description:\n          type: string\n        scheduledFor:\n          type: string\n          format: date-time\n          nullable: true\n        completedAt:\n          type: string\n          format: date-time\n          nullable: true\n        createdAt:\n          type: string\n          format: date-time\n\n    CreateWorkOrderRequest:\n      type: object\n      required:\n        - customerId\n        - location\n        - description\n      properties:\n        customerId:\n          type: string\n          format: uuid\n        location:\n          $ref: '#/components/schemas/Location'\n        description:\n          type: string\n        priority:\n          type: string\n          enum: [low, normal, high, urgent]\n          default: normal\n        scheduledFor:\n          type: string\n          format: date-time\n\n    CompleteOrderRequest:\n      type: object\n      required:\n        - signature\n        - notes\n      properties:\n        signature:\n          type: string\n          description: Base64 encoded signature image\n        notes:\n          type: string\n        photos:\n          type: array\n          items:\n            type: string\n            description: Base64 encoded photo\n\n    Location:\n      type: object\n      required:\n        - address\n      properties:\n        address:\n          type: string\n        city:\n          type: string\n        state:\n          type: string\n        zip:\n          type: string\n        latitude:\n          type: number\n        longitude:\n          type: number\n```\n\n## Event Contracts (AsyncAPI)\n\n### Basic Template\n\n```yaml\nasyncapi: 2.6.0\ninfo:\n  title: [Service] Events\n  version: 1.0.0\n  description: Events published by [Service]\n\nservers:\n  production:\n    url: kafka.example.com:9092\n    protocol: kafka\n\nchannels:\n  domain/event-name:\n    description: Description of this event channel\n    publish:\n      operationId: publishEventName\n      message:\n        $ref: '#/components/messages/EventName'\n\ncomponents:\n  messages:\n    EventName:\n      name: EventName\n      title: Event Name\n      summary: What this event represents\n      contentType: application/json\n      payload:\n        $ref: '#/components/schemas/EventNamePayload'\n\n  schemas:\n    EventNamePayload:\n      type: object\n      required:\n        - eventId\n        - timestamp\n        - data\n      properties:\n        eventId:\n          type: string\n          format: uuid\n        timestamp:\n          type: string\n          format: date-time\n        data:\n          type: object\n          properties:\n            # Event-specific fields\n```\n\n### Example: Order Events\n\n```yaml\nasyncapi: 2.6.0\ninfo:\n  title: Order Service Events\n  version: 1.0.0\n  description: Events published by the Order Service\n\nservers:\n  production:\n    url: kafka.servicegrid.example.com:9092\n    protocol: kafka\n\nchannels:\n  orders/created:\n    description: Published when a new work order is created\n    publish:\n      operationId: publishOrderCreated\n      message:\n        $ref: '#/components/messages/OrderCreated'\n\n  orders/assigned:\n    description: Published when an order is assigned to a technician\n    publish:\n      operationId: publishOrderAssigned\n      message:\n        $ref: '#/components/messages/OrderAssigned'\n\n  orders/status-changed:\n    description: Published when order status changes\n    publish:\n      operationId: publishOrderStatusChanged\n      message:\n        $ref: '#/components/messages/OrderStatusChanged'\n\n  orders/completed:\n    description: Published when an order is completed\n    publish:\n      operationId: publishOrderCompleted\n      message:\n        $ref: '#/components/messages/OrderCompleted'\n\ncomponents:\n  messages:\n    OrderCreated:\n      name: OrderCreated\n      title: Order Created Event\n      contentType: application/json\n      payload:\n        type: object\n        required: [eventId, timestamp, orderId, customerId]\n        properties:\n          eventId:\n            type: string\n            format: uuid\n          timestamp:\n            type: string\n            format: date-time\n          orderId:\n            type: string\n            format: uuid\n          orderNumber:\n            type: string\n          customerId:\n            type: string\n            format: uuid\n          priority:\n            type: string\n            enum: [low, normal, high, urgent]\n\n    OrderAssigned:\n      name: OrderAssigned\n      title: Order Assigned Event\n      contentType: application/json\n      payload:\n        type: object\n        required: [eventId, timestamp, orderId, technicianId]\n        properties:\n          eventId:\n            type: string\n            format: uuid\n          timestamp:\n            type: string\n            format: date-time\n          orderId:\n            type: string\n            format: uuid\n          technicianId:\n            type: string\n            format: uuid\n          scheduledFor:\n            type: string\n            format: date-time\n\n    OrderStatusChanged:\n      name: OrderStatusChanged\n      title: Order Status Changed Event\n      contentType: application/json\n      payload:\n        type: object\n        required: [eventId, timestamp, orderId, previousStatus, newStatus]\n        properties:\n          eventId:\n            type: string\n            format: uuid\n          timestamp:\n            type: string\n            format: date-time\n          orderId:\n            type: string\n            format: uuid\n          previousStatus:\n            type: string\n            enum: [pending, assigned, in_progress, completed, cancelled]\n          newStatus:\n            type: string\n            enum: [pending, assigned, in_progress, completed, cancelled]\n          changedBy:\n            type: string\n            format: uuid\n\n    OrderCompleted:\n      name: OrderCompleted\n      title: Order Completed Event\n      contentType: application/json\n      payload:\n        type: object\n        required: [eventId, timestamp, orderId, completedAt]\n        properties:\n          eventId:\n            type: string\n            format: uuid\n          timestamp:\n            type: string\n            format: date-time\n          orderId:\n            type: string\n            format: uuid\n          completedAt:\n            type: string\n            format: date-time\n          completedBy:\n            type: string\n            format: uuid\n          hasSignature:\n            type: boolean\n          photoCount:\n            type: integer\n```\n\n## Contract Governance\n\n### Versioning\n\n| Change Type | Version Impact | Example |\n|-------------|----------------|---------|\n| Additive (new field, optional) | Patch/Minor | 1.0.0 ‚Üí 1.0.1 |\n| Behavioral (new validation) | Minor | 1.0.0 ‚Üí 1.1.0 |\n| Breaking (remove field, change type) | Major | 1.0.0 ‚Üí 2.0.0 |\n\n### Change Process\n\n1. **Propose** ‚Äî Update contract in branch\n2. **Review** ‚Äî Affected teams review\n3. **Coordinate** ‚Äî Agree on rollout plan\n4. **Implement** ‚Äî Producer implements, then consumers\n5. **Deprecate** ‚Äî Old version with notice period\n\n### Breaking Change Checklist\n\n- [ ] All consumers identified\n- [ ] Migration path documented\n- [ ] Deprecation notice sent\n- [ ] Support both versions during transition\n- [ ] Sunset date communicated\n"
    }
  ],
  "tags": [
    "meta",
    "memory",
    "context",
    "session",
    "handoff"
  ],
  "dependsOn": []
}