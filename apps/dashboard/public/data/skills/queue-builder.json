{
  "id": "queue-builder",
  "name": "queue-builder",
  "version": "1.0.0",
  "description": "Builds prioritized work queue for async operation. Creates a 5-10 move plan with estimated durations and gate points.",
  "phase": "PLAN",
  "category": "operations",
  "content": "# Queue Builder\n\nCreates the prioritized work queue for async operation.\n\n## When to Use\n\n- During async-loop PLAN phase\n- After leverage calculations complete\n- To produce the executable work plan\n\n## What It Builds\n\n### Queue Structure\n\n```json\n{\n  \"queue\": [\n    {\n      \"position\": 1,\n      \"module\": \"auth-service\",\n      \"loop\": \"engineering-loop\",\n      \"leverage_score\": 8.2,\n      \"estimated_hours\": 3.5,\n      \"gate_count\": 3,\n      \"auto_gates\": 2,\n      \"human_gates\": 1\n    }\n  ]\n}\n```\n\n### Queue Properties\n\n| Property | Description |\n|----------|-------------|\n| Size | 5-10 moves (configurable) |\n| Ordering | By compound leverage |\n| Dependencies | Respects blocking order |\n| Gates | Identifies approval points |\n\n## Workflow\n\n### Step 1: Load Leverage Data\n\n```typescript\nconst leverage = await loadJSON('memory/async-queue.json');\nconst topMoves = leverage.leverage.top_5;\n```\n\n### Step 2: Expand to Queue\n\n```typescript\nfunction buildQueue(topMoves, maxSize = 10) {\n  const queue = [];\n\n  for (const move of topMoves) {\n    // Add the move\n    queue.push({\n      position: queue.length + 1,\n      module: move.module,\n      loop: move.recommended_loop,\n      leverage_score: move.leverage_score,\n      estimated_hours: move.estimated_hours,\n      ...analyzeGates(move)\n    });\n\n    // Add unlocked moves if space\n    if (queue.length < maxSize) {\n      const unlocked = getUnlockedAfter(move);\n      for (const next of unlocked) {\n        if (queue.length >= maxSize) break;\n        queue.push(buildQueueItem(next, queue.length + 1));\n      }\n    }\n  }\n\n  return queue;\n}\n```\n\n### Step 3: Analyze Gates\n\nFor each queue item:\n\n```typescript\nfunction analyzeGates(move) {\n  const loop = loops[move.recommended_loop];\n  const gates = loop.gates || [];\n\n  return {\n    gate_count: gates.length,\n    auto_gates: gates.filter(g => g.approvalType === 'auto').length,\n    human_gates: gates.filter(g => g.approvalType !== 'auto').length,\n    first_human_gate: gates.find(g => g.approvalType !== 'auto')?.afterPhase\n  };\n}\n```\n\n### Step 4: Calculate Totals\n\n```typescript\nconst totals = {\n  total_moves: queue.length,\n  total_estimated_hours: sum(queue, 'estimated_hours'),\n  total_gates: sum(queue, 'gate_count'),\n  total_human_gates: sum(queue, 'human_gates'),\n  expected_duration: calculateExpectedDuration(queue)\n};\n```\n\n### Step 5: Add Metadata\n\n```json\n{\n  \"queue_metadata\": {\n    \"built_at\": \"ISO-timestamp\",\n    \"queue_size\": 7,\n    \"estimated_total_hours\": 15.5,\n    \"gate_summary\": {\n      \"total\": 12,\n      \"auto\": 8,\n      \"human\": 4\n    },\n    \"expected_completion\": \"ISO-timestamp\",\n    \"pause_points\": [\n      { \"after_position\": 3, \"reason\": \"human_gate\" }\n    ]\n  }\n}\n```\n\n## Output\n\nCreates/updates `memory/async-queue.json`:\n\n```json\n{\n  \"queue\": {\n    \"built_at\": \"ISO-timestamp\",\n    \"items\": [\n      {\n        \"position\": 1,\n        \"module\": \"auth-service\",\n        \"loop\": \"engineering-loop\",\n        \"leverage_score\": 8.2,\n        \"estimated_hours\": 3.5,\n        \"gates\": {\n          \"total\": 3,\n          \"auto\": 2,\n          \"human\": 1,\n          \"first_human\": \"REVIEW\"\n        },\n        \"status\": \"pending\"\n      }\n    ],\n    \"totals\": {\n      \"moves\": 7,\n      \"estimated_hours\": 15.5,\n      \"human_gates\": 4\n    },\n    \"execution_plan\": {\n      \"can_auto_complete\": 3,\n      \"first_human_stop\": {\n        \"position\": 1,\n        \"gate\": \"REVIEW\"\n      }\n    }\n  }\n}\n```\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Async queue file | `memory/async-queue.json` | Always |\n\n## Gate at Plan Review\n\nBefore proceeding, this phase has a gate for reviewing the queue:\n\n```\n╔══════════════════════════════════════════════════════════╗\n║  PLAN REVIEW GATE                           [MANUAL]     ║\n╠══════════════════════════════════════════════════════════╣\n║  Queue: 7 moves                                          ║\n║  Estimated: 15.5 hours                                   ║\n║  Human gates: 4 (first at position 1, REVIEW phase)      ║\n║                                                          ║\n║  Top 3 moves:                                            ║\n║    1. auth-service (V: 8.2) - engineering-loop           ║\n║    2. api-endpoints (V: 7.1) - engineering-loop          ║\n║    3. user-dashboard (V: 6.5) - engineering-loop         ║\n║                                                          ║\n║  Commands:                                               ║\n║    approved  — Accept queue, proceed to verification     ║\n║    revise    — Adjust queue parameters                   ║\n╚══════════════════════════════════════════════════════════╝\n```\n\n## References\n\n- [queue-optimization.md](references/queue-optimization.md) — Queue optimization strategies",
  "references": [
    {
      "name": "queue-optimization.md",
      "path": "references/queue-optimization.md",
      "content": "# Queue Optimization\n\nStrategies for building optimal async work queues.\n\n## Size Optimization\n\n### Minimum Size: 5\n\nEnsures meaningful async session:\n- Enough work to stay busy\n- Provides options if one blocks\n- Justifies async setup overhead\n\n### Maximum Size: 10\n\nPrevents over-planning:\n- Context changes over time\n- Priorities may shift\n- Estimates become unreliable far out\n\n### Optimal Size\n\n```\noptimal_size = min(\n  available_modules,\n  max(5, estimated_hours_available / 2)\n)\n```\n\n## Ordering Strategies\n\n### Leverage-First (Default)\n\nOrder by leverage score:\n- Maximizes value per time\n- Front-loads impact\n- May hit blockers early\n\n### Dependency-Aware\n\nRespects dependency chains:\n- Never schedule blocked work\n- Automatically reorder when dependencies complete\n- May not be strictly leverage-ordered\n\n### Gate-Optimized\n\nMinimizes context switches:\n- Group auto-gate work together\n- Batch human gates when possible\n- Ideal for async operation\n\n## Gate Handling\n\n### Auto-Gate Batching\n\nWhen multiple items have only auto-gates:\n- Can run back-to-back\n- No human intervention needed\n- Good for overnight/mobile operation\n\n### Human Gate Clustering\n\nWhen items need human approval:\n- Group at natural break points\n- Consider time zones\n- Notify in advance\n\n### First Human Gate Analysis\n\nImportant for async planning:\n- Position in queue where human needed\n- Estimated time until reached\n- Determines autonomous run length\n\n## Duration Calculation\n\n### Expected Duration Formula\n\n```typescript\nfunction calculateExpectedDuration(queue) {\n  let duration = 0;\n\n  for (const item of queue) {\n    // Work time\n    duration += item.estimated_hours;\n\n    // Auto-gate overhead (minimal)\n    duration += item.gates.auto * 0.1;\n\n    // Human gate wait time (significant)\n    duration += item.gates.human * AVG_HUMAN_GATE_WAIT;\n  }\n\n  return duration;\n}\n```\n\n### Wait Time Estimates\n\n| Scenario | Expected Wait |\n|----------|---------------|\n| Synchronous | 5 minutes |\n| Async (active) | 15-30 minutes |\n| Async (mobile) | 1-2 hours |\n| Overnight | 8+ hours |\n\n## Adjustment Strategies\n\n### Dynamic Reordering\n\nWhen execution reveals new info:\n- Blocker discovered → skip, reorder\n- Faster than expected → add more\n- Slower than expected → reduce scope\n\n### Partial Queue Execution\n\nCan execute portion of queue:\n- \"Execute until first human gate\"\n- \"Execute first N items\"\n- \"Execute for N hours\"\n\n## Async-Specific Optimizations\n\n### Mobile-Friendly Queue\n\nOptimize for phone-based approval:\n- Clear gate descriptions\n- One-tap approval options\n- Status visible in notification\n\n### Overnight Queue\n\nOptimize for unattended operation:\n- Only auto-gates\n- Conservative estimates\n- Clear pause points\n\n### Hybrid Queue\n\nMix of auto and human gates:\n- Auto work first\n- Pause at human gates\n- Notify when waiting\n"
    }
  ],
  "tags": [
    "async",
    "queue",
    "planning",
    "execution"
  ],
  "dependsOn": [
    "leverage-calculator"
  ]
}