{
  "id": "test-generation",
  "name": "test-generation",
  "version": "1.0.0",
  "description": "Generate comprehensive test suites for code. Creates unit tests, integration tests, and end-to-end tests. Identifies what to test, designs test cases, and produces readable, maintainable tests. Ensures adequate coverage of happy paths, edge cases, and error conditions.",
  "phase": "TEST",
  "category": "core",
  "content": "# Test Generation\n\nGenerate comprehensive tests for code.\n\n## When to Use\n\n- **New code** — Write tests alongside implementation\n- **Existing code** — Add tests before refactoring\n- **Bug fixes** — Write regression test first\n- **Code review** — Identify missing test coverage\n- **Increasing coverage** — Fill gaps in test suite\n- When you say: \"write tests for\", \"add test coverage\", \"create unit tests\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `unit-test-patterns.md` | Patterns for effective unit tests |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `integration-test-patterns.md` | When testing component interactions |\n| `e2e-test-patterns.md` | When testing full user flows |\n| `mocking-patterns.md` | When isolating dependencies |\n| `test-data-patterns.md` | When managing test fixtures |\n\n**Verification:** Ensure tests exist for all public functions at minimum.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Test files | `tests/` | Always |\n| Test coverage report | Console or file | When coverage tools available |\n\n## Core Concept\n\nTest generation answers: **\"How do I prove this code works correctly?\"**\n\nGood tests are:\n- **Fast** — Run in milliseconds (unit) to seconds (integration)\n- **Reliable** — Same result every time, no flakiness\n- **Independent** — Don't depend on other tests or order\n- **Readable** — Serve as documentation\n- **Maintainable** — Easy to update when code changes\n\nTests should NOT:\n- Test implementation details (test behavior)\n- Require manual setup or cleanup\n- Depend on external services (mock them)\n- Be brittle to refactoring\n\n## The Testing Pyramid\n\n```\n                    ┌───────────┐\n                   /   E2E      \\        Few, slow, expensive\n                  /   Tests      \\       Test full user journeys\n                 /─────────────────\\\n                /   Integration     \\    Some, medium speed\n               /      Tests          \\   Test component interaction\n              /───────────────────────\\\n             /        Unit             \\  Many, fast, cheap\n            /         Tests             \\ Test individual units\n           /─────────────────────────────\\\n```\n\n| Level | Speed | Scope | Count | Purpose |\n|-------|-------|-------|-------|---------|\n| **Unit** | <10ms | Single function/class | Many | Logic correctness |\n| **Integration** | <1s | Multiple components | Some | Component interaction |\n| **E2E** | >1s | Full system | Few | User journey validation |\n\n## The Test Generation Process\n\n```\n┌─────────────────────────────────────────────────────────┐\n│              TEST GENERATION PROCESS                    │\n│                                                         │\n│  1. UNDERSTAND THE CODE                                 │\n│     └─→ What does it do? What are inputs/outputs?       │\n│                                                         │\n│  2. IDENTIFY TEST CASES                                 │\n│     └─→ Happy paths, edge cases, error cases            │\n│                                                         │\n│  3. DETERMINE TEST TYPE                                 │\n│     └─→ Unit, integration, or E2E?                      │\n│                                                         │\n│  4. SET UP TEST STRUCTURE                               │\n│     └─→ Arrange-Act-Assert, describe/it blocks          │\n│                                                         │\n│  5. WRITE TEST CASES                                    │\n│     └─→ One assertion per test, clear names             │\n│                                                         │\n│  6. ADD EDGE CASES                                      │\n│     └─→ Boundaries, empty inputs, nulls                 │\n│                                                         │\n│  7. VERIFY COVERAGE                                     │\n│     └─→ All paths covered? Missing scenarios?           │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Step 1: Understand the Code\n\nBefore writing tests, analyze:\n\n```markdown\n## Code Analysis Checklist\n\n### Inputs\n- [ ] What parameters does it accept?\n- [ ] What are valid input ranges?\n- [ ] What inputs are invalid?\n- [ ] Are there optional parameters?\n\n### Outputs\n- [ ] What does it return?\n- [ ] What side effects does it have?\n- [ ] What errors can it throw?\n- [ ] What state does it modify?\n\n### Dependencies\n- [ ] What external services does it call?\n- [ ] What database operations does it perform?\n- [ ] What other modules does it use?\n\n### Business Logic\n- [ ] What are the business rules?\n- [ ] What conditions change behavior?\n- [ ] What are the edge cases?\n```\n\n### Example Analysis\n\n```typescript\n// Code to test\nasync function processOrder(order: Order): Promise<OrderResult> {\n  // Validate order\n  if (!order.items.length) {\n    throw new ValidationError('Order must have items');\n  }\n  \n  // Check inventory\n  for (const item of order.items) {\n    const stock = await inventory.check(item.sku);\n    if (stock < item.quantity) {\n      throw new OutOfStockError(item.sku);\n    }\n  }\n  \n  // Calculate total\n  const subtotal = order.items.reduce((sum, i) => sum + i.price * i.quantity, 0);\n  const tax = subtotal * 0.1;\n  const total = subtotal + tax;\n  \n  // Process payment\n  const payment = await paymentService.charge(order.customerId, total);\n  \n  // Create order record\n  const result = await orderRepository.create({\n    ...order,\n    total,\n    paymentId: payment.id,\n    status: 'confirmed'\n  });\n  \n  return result;\n}\n```\n\nAnalysis:\n```markdown\n## Inputs\n- order: Order object with items[], customerId\n\n## Outputs\n- Returns: OrderResult with total, paymentId, status\n- Throws: ValidationError, OutOfStockError, PaymentError\n- Side effects: Creates order in database, charges payment\n\n## Dependencies\n- inventory.check() - external service\n- paymentService.charge() - external service\n- orderRepository.create() - database\n\n## Business Logic\n- Orders must have at least one item\n- All items must be in stock\n- Tax is 10% of subtotal\n- Payment must succeed before order created\n```\n\n## Step 2: Identify Test Cases\n\n### Test Case Categories\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    TEST CATEGORIES                      │\n│                                                         │\n│  HAPPY PATH                                             │\n│  └─→ Normal successful operation                        │\n│      • Valid input, expected output                     │\n│      • Most common use case                             │\n│                                                         │\n│  EDGE CASES                                             │\n│  └─→ Boundary conditions                                │\n│      • Empty collections                                │\n│      • Single item                                      │\n│      • Maximum values                                   │\n│      • Zero values                                      │\n│                                                         │\n│  ERROR CASES                                            │\n│  └─→ Invalid inputs and failure conditions              │\n│      • Missing required fields                          │\n│      • Invalid data types                               │\n│      • External service failures                        │\n│      • Timeout/network errors                           │\n│                                                         │\n│  SECURITY CASES                                         │\n│  └─→ Malicious or unexpected inputs                     │\n│      • SQL injection attempts                           │\n│      • XSS payloads                                     │\n│      • Authorization bypass                             │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### MECE Failure Taxonomy (Required Coverage)\n\nEvery public function MUST have tests covering these mutually exclusive, collectively exhaustive categories:\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                    MECE FAILURE TAXONOMY                                     │\n│                                                                             │\n│  For each public function/capability, tests MUST cover:                     │\n│                                                                             │\n│  ┌──────────────────────────────────────────────────────────────────────┐   │\n│  │ 1. HAPPY PATH (at least 1 test)                                      │   │\n│  │    • Valid inputs produce expected outputs                           │   │\n│  │    • Normal successful operation                                     │   │\n│  └──────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│  ┌──────────────────────────────────────────────────────────────────────┐   │\n│  │ 2. ERROR CASES (1 test per distinct error type)                      │   │\n│  │    • Each exception/error the function can throw                     │   │\n│  │    • Validation errors (bad input format, missing required)          │   │\n│  │    • Business logic errors (insufficient funds, not found)           │   │\n│  │    • External failures (network, timeout, service unavailable)       │   │\n│  └──────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│  ┌──────────────────────────────────────────────────────────────────────┐   │\n│  │ 3. EDGE CASES (1 test per boundary)                                  │   │\n│  │    • Empty/null inputs (empty array, null optional)                  │   │\n│  │    • Boundary values (0, 1, max, min)                                │   │\n│  │    • Single vs multiple (1 item vs N items)                          │   │\n│  │    • Unicode/special characters (if string input)                    │   │\n│  └──────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│  ┌──────────────────────────────────────────────────────────────────────┐   │\n│  │ 4. STATE TRANSITIONS (if stateful)                                   │   │\n│  │    • Valid state transitions succeed                                 │   │\n│  │    • Invalid state transitions fail appropriately                    │   │\n│  │    • Idempotency (if applicable)                                     │   │\n│  └──────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│  These categories are:                                                      │\n│  • Mutually Exclusive: Each test belongs to exactly one category            │\n│  • Collectively Exhaustive: All failure modes are covered                   │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Minimum Test Requirements\n\n| Function Type | Happy | Errors | Edges | State | Total Min |\n|---------------|-------|--------|-------|-------|-----------|\n| Pure function | 1 | Per error type | 2+ | N/A | 4+ |\n| Service method | 1 | Per error type | 2+ | If stateful | 5+ |\n| API endpoint | 1 | Per HTTP error | 3+ | N/A | 6+ |\n| State machine | 1 | Per invalid transition | 2+ | All transitions | 8+ |\n\n### Coverage Verification\n\nBefore marking test-generation complete:\n\n```markdown\n## Test Coverage Checklist\n\nFor each public function:\n- [ ] Happy path test exists and passes\n- [ ] Every error type has a dedicated test\n- [ ] Empty/null inputs are tested\n- [ ] Boundary values are tested\n- [ ] State transitions tested (if applicable)\n- [ ] All tests have clear, descriptive names\n- [ ] No test depends on another test's state\n```\n\n### Test Case Template\n\n```markdown\n## Test Cases for: processOrder\n\n### Happy Path\n- [ ] Creates order with single item\n- [ ] Creates order with multiple items\n- [ ] Calculates correct total with tax\n- [ ] Returns confirmed status\n\n### Edge Cases\n- [ ] Handles item with quantity of 1\n- [ ] Handles item with quantity at max (9999)\n- [ ] Handles order with exactly available stock\n- [ ] Handles very small prices (0.01)\n- [ ] Handles very large totals\n\n### Error Cases\n- [ ] Rejects empty order\n- [ ] Rejects order with out-of-stock item\n- [ ] Handles payment failure\n- [ ] Handles database error\n- [ ] Handles inventory service timeout\n\n### Integration Points\n- [ ] Calls inventory service for each item\n- [ ] Charges correct amount to payment service\n- [ ] Creates order record in database\n```\n\n## Step 3: Determine Test Type\n\n| Scenario | Test Type | Reason |\n|----------|-----------|--------|\n| Pure calculation logic | Unit | No dependencies |\n| Function with mockable deps | Unit | Fast, isolated |\n| Multiple components together | Integration | Test interaction |\n| Database operations | Integration | Need real/test DB |\n| API endpoints | Integration | HTTP layer involved |\n| Full user workflow | E2E | End-to-end validation |\n| UI interactions | E2E | Browser automation |\n\n### Decision Tree\n\n```\nDoes it have external dependencies?\n├─ No → Unit Test\n└─ Yes → Can dependencies be mocked?\n         ├─ Yes, and logic is the focus → Unit Test with mocks\n         └─ No, or interaction is the focus → Integration Test\n                                              └─ Full user journey? → E2E Test\n```\n\n## Step 4: Set Up Test Structure\n\n### Arrange-Act-Assert Pattern\n\n```typescript\ndescribe('processOrder', () => {\n  it('creates order with correct total', async () => {\n    // ARRANGE: Set up test data and mocks\n    const order = createTestOrder({ items: [{ price: 100, quantity: 2 }] });\n    mockInventory.check.mockResolvedValue(10);\n    mockPayment.charge.mockResolvedValue({ id: 'pay_123' });\n    mockRepository.create.mockResolvedValue({ id: 'ord_123' });\n    \n    // ACT: Execute the code under test\n    const result = await processOrder(order);\n    \n    // ASSERT: Verify the results\n    expect(result.total).toBe(220); // 200 + 10% tax\n    expect(result.status).toBe('confirmed');\n  });\n});\n```\n\n### Given-When-Then (BDD Style)\n\n```typescript\ndescribe('Order Processing', () => {\n  describe('given a valid order with items in stock', () => {\n    const order = createTestOrder();\n    \n    beforeEach(() => {\n      mockInventory.check.mockResolvedValue(100);\n      mockPayment.charge.mockResolvedValue({ id: 'pay_123' });\n    });\n    \n    describe('when the order is processed', () => {\n      let result: OrderResult;\n      \n      beforeEach(async () => {\n        result = await processOrder(order);\n      });\n      \n      it('then the order status is confirmed', () => {\n        expect(result.status).toBe('confirmed');\n      });\n      \n      it('then the payment is charged', () => {\n        expect(mockPayment.charge).toHaveBeenCalled();\n      });\n    });\n  });\n});\n```\n\n## Step 5: Write Test Cases\n\n### Naming Conventions\n\n```typescript\n// Pattern: [unit]_[scenario]_[expected result]\ndescribe('calculateTotal', () => {\n  it('returns_zero_when_cart_is_empty', () => {});\n  it('sums_item_prices_for_single_item', () => {});\n  it('applies_discount_when_coupon_valid', () => {});\n  it('throws_error_when_items_null', () => {});\n});\n\n// Pattern: should [expected behavior] when [condition]\ndescribe('calculateTotal', () => {\n  it('should return zero when cart is empty', () => {});\n  it('should sum item prices for single item', () => {});\n  it('should apply discount when coupon is valid', () => {});\n  it('should throw error when items is null', () => {});\n});\n```\n\n### One Assertion Per Test\n\n```typescript\n// BAD: Multiple assertions testing different things\nit('processes order correctly', async () => {\n  const result = await processOrder(order);\n  expect(result.total).toBe(220);\n  expect(result.status).toBe('confirmed');\n  expect(mockPayment.charge).toHaveBeenCalledWith('cust_1', 220);\n  expect(mockRepository.create).toHaveBeenCalled();\n});\n\n// GOOD: Separate tests for each behavior\nit('calculates correct total with tax', async () => {\n  const result = await processOrder(order);\n  expect(result.total).toBe(220);\n});\n\nit('sets status to confirmed', async () => {\n  const result = await processOrder(order);\n  expect(result.status).toBe('confirmed');\n});\n\nit('charges payment with correct amount', async () => {\n  await processOrder(order);\n  expect(mockPayment.charge).toHaveBeenCalledWith('cust_1', 220);\n});\n```\n\n### Testing Errors\n\n```typescript\ndescribe('error handling', () => {\n  it('throws ValidationError for empty order', async () => {\n    const emptyOrder = createTestOrder({ items: [] });\n    \n    await expect(processOrder(emptyOrder))\n      .rejects\n      .toThrow(ValidationError);\n  });\n  \n  it('throws OutOfStockError when item unavailable', async () => {\n    mockInventory.check.mockResolvedValue(0);\n    \n    await expect(processOrder(order))\n      .rejects\n      .toThrow(OutOfStockError);\n  });\n  \n  it('includes SKU in OutOfStockError message', async () => {\n    mockInventory.check.mockResolvedValue(0);\n    \n    await expect(processOrder(order))\n      .rejects\n      .toThrow(/SKU-123/);\n  });\n});\n```\n\n→ See `references/unit-test-patterns.md`\n\n## Step 6: Add Edge Cases\n\n### Common Edge Cases\n\n| Category | Cases to Test |\n|----------|---------------|\n| **Numbers** | 0, 1, -1, MAX_INT, MIN_INT, decimals, NaN, Infinity |\n| **Strings** | Empty \"\", single char, very long, unicode, whitespace only |\n| **Arrays** | Empty [], single item, many items, duplicates |\n| **Objects** | Empty {}, missing fields, extra fields, null |\n| **Dates** | Now, past, future, leap years, timezone boundaries |\n| **Async** | Fast response, slow response, timeout, retry |\n\n### Boundary Testing\n\n```typescript\ndescribe('quantity validation', () => {\n  // Boundary: minimum valid value\n  it('accepts quantity of 1', () => {\n    expect(() => validateQuantity(1)).not.toThrow();\n  });\n  \n  // Boundary: just below minimum\n  it('rejects quantity of 0', () => {\n    expect(() => validateQuantity(0)).toThrow('Quantity must be positive');\n  });\n  \n  // Boundary: maximum valid value\n  it('accepts quantity of 9999', () => {\n    expect(() => validateQuantity(9999)).not.toThrow();\n  });\n  \n  // Boundary: just above maximum\n  it('rejects quantity of 10000', () => {\n    expect(() => validateQuantity(10000)).toThrow('Quantity exceeds maximum');\n  });\n});\n```\n\n### Null and Undefined\n\n```typescript\ndescribe('null handling', () => {\n  it('handles null input gracefully', () => {\n    expect(() => processUser(null)).toThrow('User is required');\n  });\n  \n  it('handles undefined input gracefully', () => {\n    expect(() => processUser(undefined)).toThrow('User is required');\n  });\n  \n  it('handles user with null email', () => {\n    const user = { name: 'Test', email: null };\n    expect(() => processUser(user)).toThrow('Email is required');\n  });\n});\n```\n\n## Step 7: Verify Coverage\n\n### Coverage Metrics\n\n| Metric | Description | Target |\n|--------|-------------|--------|\n| **Line** | Lines executed | >80% |\n| **Branch** | If/else paths taken | >80% |\n| **Function** | Functions called | >90% |\n| **Statement** | Statements executed | >80% |\n\n### Finding Coverage Gaps\n\n```bash\n# Generate coverage report\nnpm test -- --coverage\n\n# Look for:\n# - Red lines (not covered)\n# - Yellow branches (partial coverage)\n# - Files with low percentages\n```\n\n### Coverage vs Quality\n\n```markdown\n## High Coverage ≠ Good Tests\n\nCoverage tells you what code ran, not if it's tested correctly.\n\nBAD: 100% coverage, no assertions\n```typescript\nit('has coverage', () => {\n  processOrder(order); // Code runs but nothing verified\n});\n```\n\nGOOD: Meaningful coverage with assertions\n```typescript\nit('calculates tax correctly', () => {\n  const result = processOrder(order);\n  expect(result.tax).toBe(order.subtotal * 0.1);\n});\n```\n```\n\n## Test Organization\n\n### File Structure\n\n```\nsrc/\n├── services/\n│   └── orderService.ts\n├── __tests__/\n│   ├── unit/\n│   │   └── orderService.test.ts\n│   ├── integration/\n│   │   └── orderService.integration.test.ts\n│   └── e2e/\n│       └── checkout.e2e.test.ts\n```\n\n### Test File Template\n\n```typescript\nimport { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';\nimport { OrderService } from '../orderService';\nimport { createMockInventory, createMockPayment } from '../__mocks__';\n\ndescribe('OrderService', () => {\n  // Shared setup\n  let service: OrderService;\n  let mockInventory: jest.Mocked<InventoryService>;\n  let mockPayment: jest.Mocked<PaymentService>;\n  \n  beforeEach(() => {\n    mockInventory = createMockInventory();\n    mockPayment = createMockPayment();\n    service = new OrderService(mockInventory, mockPayment);\n  });\n  \n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  describe('processOrder', () => {\n    describe('happy path', () => {\n      it('creates order successfully', async () => {\n        // ...\n      });\n    });\n    \n    describe('validation', () => {\n      it('rejects empty order', async () => {\n        // ...\n      });\n    });\n    \n    describe('error handling', () => {\n      it('handles payment failure', async () => {\n        // ...\n      });\n    });\n  });\n});\n```\n\n## Mocking Strategies\n\n### When to Mock\n\n| Mock | Don't Mock |\n|------|------------|\n| External APIs | Pure functions |\n| Databases | Simple utilities |\n| File system | Value objects |\n| Time/dates | The code under test |\n| Randomness | |\n\n### Mock Types\n\n```typescript\n// Stub: Returns canned data\nconst stubInventory = {\n  check: jest.fn().mockResolvedValue(100)\n};\n\n// Mock: Verifies interactions\nconst mockPayment = {\n  charge: jest.fn().mockResolvedValue({ id: 'pay_1' })\n};\n// Later: expect(mockPayment.charge).toHaveBeenCalledWith(...)\n\n// Spy: Wraps real implementation\nconst spy = jest.spyOn(logger, 'error');\n// Later: expect(spy).toHaveBeenCalled();\n\n// Fake: Working implementation for tests\nclass FakeUserRepository implements UserRepository {\n  private users = new Map<string, User>();\n  \n  async save(user: User): Promise<void> {\n    this.users.set(user.id, user);\n  }\n  \n  async findById(id: string): Promise<User | null> {\n    return this.users.get(id) ?? null;\n  }\n}\n```\n\n→ See `references/mocking-patterns.md`\n\n## Test Data\n\n### Factory Functions\n\n```typescript\n// factories/order.ts\nexport function createTestOrder(overrides: Partial<Order> = {}): Order {\n  return {\n    id: 'ord_test_123',\n    customerId: 'cust_test_1',\n    items: [\n      { sku: 'SKU-1', name: 'Test Item', price: 100, quantity: 1 }\n    ],\n    status: 'pending',\n    createdAt: new Date(),\n    ...overrides\n  };\n}\n\n// Usage in tests\nit('handles multiple items', async () => {\n  const order = createTestOrder({\n    items: [\n      { sku: 'A', name: 'Item A', price: 50, quantity: 2 },\n      { sku: 'B', name: 'Item B', price: 30, quantity: 1 },\n    ]\n  });\n  \n  const result = await processOrder(order);\n  expect(result.subtotal).toBe(130);\n});\n```\n\n### Builder Pattern\n\n```typescript\nclass OrderBuilder {\n  private order: Partial<Order> = {};\n  \n  withCustomer(customerId: string): this {\n    this.order.customerId = customerId;\n    return this;\n  }\n  \n  withItem(item: OrderItem): this {\n    this.order.items = [...(this.order.items ?? []), item];\n    return this;\n  }\n  \n  withStatus(status: OrderStatus): this {\n    this.order.status = status;\n    return this;\n  }\n  \n  build(): Order {\n    return createTestOrder(this.order);\n  }\n}\n\n// Usage\nconst order = new OrderBuilder()\n  .withCustomer('cust_vip')\n  .withItem({ sku: 'PREMIUM', name: 'Premium', price: 500, quantity: 1 })\n  .withStatus('pending')\n  .build();\n```\n\n→ See `references/test-data-patterns.md`\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `implement` | Tests written alongside implementation |\n| `refactor` | Tests enable safe refactoring |\n| `code-verification` | Tests verify structural correctness |\n| `code-validation` | Tests validate semantic correctness |\n| `code-review` | Review checks for adequate tests |\n| `debug-assist` | Tests help isolate bugs |\n| `spec` | Specs define what to test |\n\n## Key Principles\n\n**Test behavior, not implementation.** Tests should survive refactoring.\n\n**One reason to fail.** Each test should test one thing.\n\n**Tests are documentation.** A reader should understand the code from tests.\n\n**Fast feedback.** Tests should run in seconds, not minutes.\n\n**Deterministic.** Same input, same result, every time.\n\n**Independent.** Tests shouldn't depend on each other or run order.\n\n## References\n\n- `references/unit-test-patterns.md`: Unit testing patterns and examples\n- `references/integration-test-patterns.md`: Integration testing approaches\n- `references/e2e-test-patterns.md`: End-to-end testing with Playwright\n- `references/mocking-patterns.md`: Mocking strategies and best practices\n- `references/test-data-patterns.md`: Test data generation patterns",
  "references": [
    {
      "name": "e2e-test-patterns.md",
      "path": "references/e2e-test-patterns.md",
      "content": "# E2E Test Patterns\n\nEnd-to-end testing patterns with Playwright.\n\n## E2E Test Characteristics\n\n| Characteristic | Description |\n|----------------|-------------|\n| **Scope** | Full user journey through real UI |\n| **Speed** | Slowest (seconds to minutes) |\n| **Confidence** | Highest (tests real user experience) |\n| **Maintenance** | Higher cost to maintain |\n| **Flakiness** | Most prone to intermittent failures |\n\n## Playwright Setup\n\n### Configuration\n\n```typescript\n// playwright.config.ts\nimport { defineConfig, devices } from '@playwright/test';\n\nexport default defineConfig({\n  testDir: './e2e',\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: 'html',\n  \n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n  },\n  \n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    },\n    {\n      name: 'firefox',\n      use: { ...devices['Desktop Firefox'] },\n    },\n    {\n      name: 'webkit',\n      use: { ...devices['Desktop Safari'] },\n    },\n    {\n      name: 'Mobile Chrome',\n      use: { ...devices['Pixel 5'] },\n    },\n  ],\n  \n  webServer: {\n    command: 'npm run start',\n    url: 'http://localhost:3000',\n    reuseExistingServer: !process.env.CI,\n  },\n});\n```\n\n## Basic E2E Patterns\n\n### Page Navigation\n\n```typescript\nimport { test, expect } from '@playwright/test';\n\ntest.describe('Navigation', () => {\n  test('navigates to home page', async ({ page }) => {\n    await page.goto('/');\n    \n    await expect(page).toHaveTitle(/My App/);\n    await expect(page.locator('h1')).toContainText('Welcome');\n  });\n  \n  test('navigates between pages', async ({ page }) => {\n    await page.goto('/');\n    \n    // Click navigation link\n    await page.click('nav >> text=About');\n    \n    // Verify navigation\n    await expect(page).toHaveURL('/about');\n    await expect(page.locator('h1')).toContainText('About Us');\n  });\n});\n```\n\n### Form Submission\n\n```typescript\ntest.describe('Contact Form', () => {\n  test('submits form successfully', async ({ page }) => {\n    await page.goto('/contact');\n    \n    // Fill form\n    await page.fill('[name=\"name\"]', 'John Doe');\n    await page.fill('[name=\"email\"]', 'john@example.com');\n    await page.fill('[name=\"message\"]', 'Hello, this is a test message.');\n    \n    // Submit\n    await page.click('button[type=\"submit\"]');\n    \n    // Verify success\n    await expect(page.locator('.success-message')).toContainText('Message sent!');\n  });\n  \n  test('shows validation errors', async ({ page }) => {\n    await page.goto('/contact');\n    \n    // Submit empty form\n    await page.click('button[type=\"submit\"]');\n    \n    // Verify errors\n    await expect(page.locator('[data-error=\"name\"]')).toContainText('Name is required');\n    await expect(page.locator('[data-error=\"email\"]')).toContainText('Email is required');\n  });\n  \n  test('validates email format', async ({ page }) => {\n    await page.goto('/contact');\n    \n    await page.fill('[name=\"email\"]', 'invalid-email');\n    await page.click('button[type=\"submit\"]');\n    \n    await expect(page.locator('[data-error=\"email\"]')).toContainText('Invalid email');\n  });\n});\n```\n\n### Authentication Flow\n\n```typescript\ntest.describe('Authentication', () => {\n  test('logs in successfully', async ({ page }) => {\n    await page.goto('/login');\n    \n    await page.fill('[name=\"email\"]', 'test@example.com');\n    await page.fill('[name=\"password\"]', 'password123');\n    await page.click('button[type=\"submit\"]');\n    \n    // Verify redirect to dashboard\n    await expect(page).toHaveURL('/dashboard');\n    await expect(page.locator('[data-testid=\"user-menu\"]')).toContainText('test@example.com');\n  });\n  \n  test('shows error for invalid credentials', async ({ page }) => {\n    await page.goto('/login');\n    \n    await page.fill('[name=\"email\"]', 'test@example.com');\n    await page.fill('[name=\"password\"]', 'wrongpassword');\n    await page.click('button[type=\"submit\"]');\n    \n    await expect(page.locator('.error-message')).toContainText('Invalid credentials');\n    await expect(page).toHaveURL('/login');\n  });\n  \n  test('logs out successfully', async ({ page }) => {\n    // Login first\n    await page.goto('/login');\n    await page.fill('[name=\"email\"]', 'test@example.com');\n    await page.fill('[name=\"password\"]', 'password123');\n    await page.click('button[type=\"submit\"]');\n    await expect(page).toHaveURL('/dashboard');\n    \n    // Logout\n    await page.click('[data-testid=\"user-menu\"]');\n    await page.click('text=Logout');\n    \n    // Verify logged out\n    await expect(page).toHaveURL('/');\n    await expect(page.locator('[data-testid=\"user-menu\"]')).not.toBeVisible();\n  });\n});\n```\n\n## Page Object Model\n\n### Page Objects\n\n```typescript\n// pages/LoginPage.ts\nimport { Page, Locator, expect } from '@playwright/test';\n\nexport class LoginPage {\n  readonly page: Page;\n  readonly emailInput: Locator;\n  readonly passwordInput: Locator;\n  readonly submitButton: Locator;\n  readonly errorMessage: Locator;\n  \n  constructor(page: Page) {\n    this.page = page;\n    this.emailInput = page.locator('[name=\"email\"]');\n    this.passwordInput = page.locator('[name=\"password\"]');\n    this.submitButton = page.locator('button[type=\"submit\"]');\n    this.errorMessage = page.locator('.error-message');\n  }\n  \n  async goto() {\n    await this.page.goto('/login');\n  }\n  \n  async login(email: string, password: string) {\n    await this.emailInput.fill(email);\n    await this.passwordInput.fill(password);\n    await this.submitButton.click();\n  }\n  \n  async expectError(message: string) {\n    await expect(this.errorMessage).toContainText(message);\n  }\n}\n\n// pages/DashboardPage.ts\nexport class DashboardPage {\n  readonly page: Page;\n  readonly userMenu: Locator;\n  readonly welcomeMessage: Locator;\n  \n  constructor(page: Page) {\n    this.page = page;\n    this.userMenu = page.locator('[data-testid=\"user-menu\"]');\n    this.welcomeMessage = page.locator('[data-testid=\"welcome\"]');\n  }\n  \n  async expectLoggedInAs(email: string) {\n    await expect(this.userMenu).toContainText(email);\n  }\n  \n  async logout() {\n    await this.userMenu.click();\n    await this.page.click('text=Logout');\n  }\n}\n```\n\n### Using Page Objects\n\n```typescript\nimport { test, expect } from '@playwright/test';\nimport { LoginPage } from './pages/LoginPage';\nimport { DashboardPage } from './pages/DashboardPage';\n\ntest.describe('Authentication with Page Objects', () => {\n  test('logs in successfully', async ({ page }) => {\n    const loginPage = new LoginPage(page);\n    const dashboardPage = new DashboardPage(page);\n    \n    await loginPage.goto();\n    await loginPage.login('test@example.com', 'password123');\n    \n    await expect(page).toHaveURL('/dashboard');\n    await dashboardPage.expectLoggedInAs('test@example.com');\n  });\n  \n  test('shows error for invalid credentials', async ({ page }) => {\n    const loginPage = new LoginPage(page);\n    \n    await loginPage.goto();\n    await loginPage.login('test@example.com', 'wrongpassword');\n    \n    await loginPage.expectError('Invalid credentials');\n  });\n});\n```\n\n## Complex User Journeys\n\n### E-Commerce Checkout\n\n```typescript\ntest.describe('Checkout Flow', () => {\n  test('completes purchase successfully', async ({ page }) => {\n    // Browse products\n    await page.goto('/products');\n    await expect(page.locator('[data-testid=\"product-grid\"]')).toBeVisible();\n    \n    // Add item to cart\n    await page.click('[data-testid=\"product-1\"] >> text=Add to Cart');\n    await expect(page.locator('[data-testid=\"cart-count\"]')).toContainText('1');\n    \n    // Add another item\n    await page.click('[data-testid=\"product-2\"] >> text=Add to Cart');\n    await expect(page.locator('[data-testid=\"cart-count\"]')).toContainText('2');\n    \n    // Go to cart\n    await page.click('[data-testid=\"cart-icon\"]');\n    await expect(page).toHaveURL('/cart');\n    \n    // Verify cart contents\n    await expect(page.locator('[data-testid=\"cart-item\"]')).toHaveCount(2);\n    \n    // Proceed to checkout\n    await page.click('text=Checkout');\n    await expect(page).toHaveURL('/checkout');\n    \n    // Fill shipping info\n    await page.fill('[name=\"firstName\"]', 'John');\n    await page.fill('[name=\"lastName\"]', 'Doe');\n    await page.fill('[name=\"address\"]', '123 Main St');\n    await page.fill('[name=\"city\"]', 'New York');\n    await page.fill('[name=\"zip\"]', '10001');\n    await page.click('text=Continue to Payment');\n    \n    // Fill payment info (test card)\n    await page.fill('[name=\"cardNumber\"]', '4242424242424242');\n    await page.fill('[name=\"expiry\"]', '12/25');\n    await page.fill('[name=\"cvc\"]', '123');\n    \n    // Place order\n    await page.click('text=Place Order');\n    \n    // Verify confirmation\n    await expect(page).toHaveURL(/\\/order\\/[a-z0-9]+/);\n    await expect(page.locator('[data-testid=\"confirmation\"]')).toContainText('Order Confirmed');\n    await expect(page.locator('[data-testid=\"order-number\"]')).toBeVisible();\n  });\n  \n  test('handles out of stock items', async ({ page }) => {\n    await page.goto('/cart');\n    \n    // Add out of stock item (via direct URL or API)\n    await page.goto('/products/out-of-stock-item');\n    \n    await expect(page.locator('text=Out of Stock')).toBeVisible();\n    await expect(page.locator('text=Add to Cart')).toBeDisabled();\n  });\n});\n```\n\n### Multi-Step Wizard\n\n```typescript\ntest.describe('Account Setup Wizard', () => {\n  test('completes all steps', async ({ page }) => {\n    await page.goto('/setup');\n    \n    // Step 1: Personal Info\n    await expect(page.locator('[data-step=\"1\"]')).toHaveAttribute('data-active', 'true');\n    await page.fill('[name=\"fullName\"]', 'John Doe');\n    await page.fill('[name=\"email\"]', 'john@example.com');\n    await page.click('text=Next');\n    \n    // Step 2: Preferences\n    await expect(page.locator('[data-step=\"2\"]')).toHaveAttribute('data-active', 'true');\n    await page.click('[data-testid=\"theme-dark\"]');\n    await page.check('[name=\"emailNotifications\"]');\n    await page.click('text=Next');\n    \n    // Step 3: Confirmation\n    await expect(page.locator('[data-step=\"3\"]')).toHaveAttribute('data-active', 'true');\n    await expect(page.locator('[data-testid=\"summary-name\"]')).toContainText('John Doe');\n    await expect(page.locator('[data-testid=\"summary-email\"]')).toContainText('john@example.com');\n    await page.click('text=Complete Setup');\n    \n    // Verify completion\n    await expect(page).toHaveURL('/dashboard');\n    await expect(page.locator('[data-testid=\"welcome\"]')).toContainText('Welcome, John');\n  });\n  \n  test('can go back and edit', async ({ page }) => {\n    await page.goto('/setup');\n    \n    // Complete step 1\n    await page.fill('[name=\"fullName\"]', 'John Doe');\n    await page.fill('[name=\"email\"]', 'john@example.com');\n    await page.click('text=Next');\n    \n    // Go back\n    await page.click('text=Back');\n    \n    // Verify data preserved\n    await expect(page.locator('[name=\"fullName\"]')).toHaveValue('John Doe');\n    \n    // Edit\n    await page.fill('[name=\"fullName\"]', 'Jane Doe');\n    await page.click('text=Next');\n    await page.click('text=Next');\n    \n    // Verify updated in summary\n    await expect(page.locator('[data-testid=\"summary-name\"]')).toContainText('Jane Doe');\n  });\n});\n```\n\n## API Mocking in E2E\n\n```typescript\ntest.describe('With Mocked API', () => {\n  test('displays products from API', async ({ page }) => {\n    // Mock API response\n    await page.route('**/api/products', async (route) => {\n      await route.fulfill({\n        status: 200,\n        contentType: 'application/json',\n        body: JSON.stringify([\n          { id: '1', name: 'Test Product', price: 1000 },\n          { id: '2', name: 'Another Product', price: 2000 },\n        ])\n      });\n    });\n    \n    await page.goto('/products');\n    \n    await expect(page.locator('[data-testid=\"product\"]')).toHaveCount(2);\n    await expect(page.locator('text=Test Product')).toBeVisible();\n  });\n  \n  test('handles API error', async ({ page }) => {\n    await page.route('**/api/products', async (route) => {\n      await route.fulfill({\n        status: 500,\n        contentType: 'application/json',\n        body: JSON.stringify({ error: 'Server error' })\n      });\n    });\n    \n    await page.goto('/products');\n    \n    await expect(page.locator('[data-testid=\"error-message\"]')).toContainText(\n      'Failed to load products'\n    );\n  });\n  \n  test('shows loading state', async ({ page }) => {\n    // Delay response\n    await page.route('**/api/products', async (route) => {\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      await route.fulfill({\n        status: 200,\n        contentType: 'application/json',\n        body: JSON.stringify([])\n      });\n    });\n    \n    await page.goto('/products');\n    \n    await expect(page.locator('[data-testid=\"loading\"]')).toBeVisible();\n    await expect(page.locator('[data-testid=\"loading\"]')).not.toBeVisible({ timeout: 2000 });\n  });\n});\n```\n\n## Visual Testing\n\n```typescript\ntest.describe('Visual Regression', () => {\n  test('homepage matches snapshot', async ({ page }) => {\n    await page.goto('/');\n    await expect(page).toHaveScreenshot('homepage.png');\n  });\n  \n  test('product card matches snapshot', async ({ page }) => {\n    await page.goto('/products');\n    \n    const productCard = page.locator('[data-testid=\"product-1\"]');\n    await expect(productCard).toHaveScreenshot('product-card.png');\n  });\n  \n  test('dark mode matches snapshot', async ({ page }) => {\n    await page.goto('/');\n    await page.click('[data-testid=\"theme-toggle\"]');\n    \n    await expect(page).toHaveScreenshot('homepage-dark.png');\n  });\n});\n```\n\n## Accessibility Testing\n\n```typescript\nimport AxeBuilder from '@axe-core/playwright';\n\ntest.describe('Accessibility', () => {\n  test('homepage has no accessibility violations', async ({ page }) => {\n    await page.goto('/');\n    \n    const accessibilityScanResults = await new AxeBuilder({ page }).analyze();\n    \n    expect(accessibilityScanResults.violations).toEqual([]);\n  });\n  \n  test('form has proper labels', async ({ page }) => {\n    await page.goto('/contact');\n    \n    const accessibilityScanResults = await new AxeBuilder({ page })\n      .include('form')\n      .analyze();\n    \n    expect(accessibilityScanResults.violations).toEqual([]);\n  });\n  \n  test('can navigate with keyboard only', async ({ page }) => {\n    await page.goto('/');\n    \n    // Tab through interactive elements\n    await page.keyboard.press('Tab');\n    await expect(page.locator(':focus')).toHaveAttribute('data-testid', 'nav-home');\n    \n    await page.keyboard.press('Tab');\n    await expect(page.locator(':focus')).toHaveAttribute('data-testid', 'nav-products');\n    \n    // Activate with Enter\n    await page.keyboard.press('Enter');\n    await expect(page).toHaveURL('/products');\n  });\n});\n```\n\n## Test Fixtures\n\n```typescript\n// fixtures.ts\nimport { test as base } from '@playwright/test';\nimport { LoginPage } from './pages/LoginPage';\nimport { DashboardPage } from './pages/DashboardPage';\n\ntype Fixtures = {\n  loginPage: LoginPage;\n  dashboardPage: DashboardPage;\n  authenticatedPage: Page;\n};\n\nexport const test = base.extend<Fixtures>({\n  loginPage: async ({ page }, use) => {\n    await use(new LoginPage(page));\n  },\n  \n  dashboardPage: async ({ page }, use) => {\n    await use(new DashboardPage(page));\n  },\n  \n  authenticatedPage: async ({ page }, use) => {\n    // Login before test\n    await page.goto('/login');\n    await page.fill('[name=\"email\"]', 'test@example.com');\n    await page.fill('[name=\"password\"]', 'password123');\n    await page.click('button[type=\"submit\"]');\n    await page.waitForURL('/dashboard');\n    \n    await use(page);\n    \n    // Cleanup: logout after test\n    await page.goto('/logout');\n  },\n});\n\n// Usage\ntest('dashboard shows user data', async ({ authenticatedPage }) => {\n  await expect(authenticatedPage.locator('[data-testid=\"welcome\"]')).toBeVisible();\n});\n```\n\n## Handling Flaky Tests\n\n```typescript\n// Retry configuration\ntest.describe('Flaky-Prone Tests', () => {\n  // Retry this specific test\n  test('eventually succeeds', async ({ page }) => {\n    test.info().annotations.push({ type: 'flaky', description: 'Network dependent' });\n    \n    await page.goto('/');\n    // Use explicit waits instead of implicit\n    await page.waitForSelector('[data-testid=\"loaded\"]', { timeout: 10000 });\n  });\n});\n\n// Wait for network idle\ntest('waits for all requests', async ({ page }) => {\n  await page.goto('/', { waitUntil: 'networkidle' });\n});\n\n// Wait for specific request\ntest('waits for API response', async ({ page }) => {\n  const responsePromise = page.waitForResponse('**/api/data');\n  await page.goto('/');\n  await responsePromise;\n});\n```\n"
    },
    {
      "name": "integration-test-patterns.md",
      "path": "references/integration-test-patterns.md",
      "content": "# Integration Test Patterns\n\nPatterns for testing component interactions.\n\n## Integration Test Characteristics\n\n| Characteristic | Description |\n|----------------|-------------|\n| **Scope** | Multiple components together |\n| **Speed** | Slower than unit (ms to seconds) |\n| **Dependencies** | May use real or test databases |\n| **Isolation** | Isolated from other tests via transactions/cleanup |\n\n## API Integration Tests\n\n### Express/Node.js API Testing\n\n```typescript\nimport request from 'supertest';\nimport { app } from '../app';\nimport { db } from '../database';\n\ndescribe('Users API', () => {\n  beforeAll(async () => {\n    await db.migrate.latest();\n  });\n  \n  beforeEach(async () => {\n    await db('users').truncate();\n  });\n  \n  afterAll(async () => {\n    await db.destroy();\n  });\n  \n  describe('POST /api/users', () => {\n    it('creates a new user', async () => {\n      const response = await request(app)\n        .post('/api/users')\n        .send({\n          email: 'test@example.com',\n          name: 'Test User',\n          password: 'password123'\n        })\n        .expect(201);\n      \n      expect(response.body).toMatchObject({\n        id: expect.any(String),\n        email: 'test@example.com',\n        name: 'Test User'\n      });\n      expect(response.body).not.toHaveProperty('password');\n    });\n    \n    it('returns 400 for invalid email', async () => {\n      const response = await request(app)\n        .post('/api/users')\n        .send({\n          email: 'invalid-email',\n          name: 'Test User',\n          password: 'password123'\n        })\n        .expect(400);\n      \n      expect(response.body.error.code).toBe('VALIDATION_ERROR');\n    });\n    \n    it('returns 409 for duplicate email', async () => {\n      // Create first user\n      await request(app)\n        .post('/api/users')\n        .send({\n          email: 'test@example.com',\n          name: 'First User',\n          password: 'password123'\n        });\n      \n      // Try to create duplicate\n      const response = await request(app)\n        .post('/api/users')\n        .send({\n          email: 'test@example.com',\n          name: 'Second User',\n          password: 'password123'\n        })\n        .expect(409);\n      \n      expect(response.body.error.code).toBe('EMAIL_EXISTS');\n    });\n  });\n  \n  describe('GET /api/users/:id', () => {\n    it('returns user by id', async () => {\n      // Create user\n      const createResponse = await request(app)\n        .post('/api/users')\n        .send({\n          email: 'test@example.com',\n          name: 'Test User',\n          password: 'password123'\n        });\n      \n      const userId = createResponse.body.id;\n      \n      // Fetch user\n      const response = await request(app)\n        .get(`/api/users/${userId}`)\n        .expect(200);\n      \n      expect(response.body).toMatchObject({\n        id: userId,\n        email: 'test@example.com',\n        name: 'Test User'\n      });\n    });\n    \n    it('returns 404 for non-existent user', async () => {\n      await request(app)\n        .get('/api/users/non-existent-id')\n        .expect(404);\n    });\n  });\n});\n```\n\n### Testing with Authentication\n\n```typescript\ndescribe('Protected Routes', () => {\n  let authToken: string;\n  let userId: string;\n  \n  beforeEach(async () => {\n    // Create user and get token\n    const userResponse = await request(app)\n      .post('/api/users')\n      .send({\n        email: 'test@example.com',\n        name: 'Test User',\n        password: 'password123'\n      });\n    \n    userId = userResponse.body.id;\n    \n    const loginResponse = await request(app)\n      .post('/api/auth/login')\n      .send({\n        email: 'test@example.com',\n        password: 'password123'\n      });\n    \n    authToken = loginResponse.body.token;\n  });\n  \n  describe('GET /api/profile', () => {\n    it('returns profile with valid token', async () => {\n      const response = await request(app)\n        .get('/api/profile')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n      \n      expect(response.body.id).toBe(userId);\n    });\n    \n    it('returns 401 without token', async () => {\n      await request(app)\n        .get('/api/profile')\n        .expect(401);\n    });\n    \n    it('returns 401 with invalid token', async () => {\n      await request(app)\n        .get('/api/profile')\n        .set('Authorization', 'Bearer invalid-token')\n        .expect(401);\n    });\n  });\n});\n```\n\n## Database Integration Tests\n\n### Repository Testing\n\n```typescript\nimport { UserRepository } from '../repositories/userRepository';\nimport { db } from '../database';\n\ndescribe('UserRepository', () => {\n  let repository: UserRepository;\n  \n  beforeAll(async () => {\n    await db.migrate.latest();\n    repository = new UserRepository(db);\n  });\n  \n  beforeEach(async () => {\n    await db('users').truncate();\n  });\n  \n  afterAll(async () => {\n    await db.destroy();\n  });\n  \n  describe('create', () => {\n    it('inserts user into database', async () => {\n      const user = await repository.create({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed'\n      });\n      \n      expect(user.id).toBeDefined();\n      expect(user.email).toBe('test@example.com');\n      expect(user.createdAt).toBeInstanceOf(Date);\n    });\n    \n    it('throws on duplicate email', async () => {\n      await repository.create({\n        email: 'test@example.com',\n        name: 'First',\n        passwordHash: 'hash1'\n      });\n      \n      await expect(repository.create({\n        email: 'test@example.com',\n        name: 'Second',\n        passwordHash: 'hash2'\n      })).rejects.toThrow(/duplicate/i);\n    });\n  });\n  \n  describe('findById', () => {\n    it('returns user when found', async () => {\n      const created = await repository.create({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed'\n      });\n      \n      const found = await repository.findById(created.id);\n      \n      expect(found).toMatchObject({\n        id: created.id,\n        email: 'test@example.com',\n        name: 'Test User'\n      });\n    });\n    \n    it('returns null when not found', async () => {\n      const found = await repository.findById('non-existent');\n      expect(found).toBeNull();\n    });\n  });\n  \n  describe('findByEmail', () => {\n    it('returns user by email', async () => {\n      await repository.create({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed'\n      });\n      \n      const found = await repository.findByEmail('test@example.com');\n      \n      expect(found?.email).toBe('test@example.com');\n    });\n    \n    it('is case-insensitive', async () => {\n      await repository.create({\n        email: 'Test@Example.com',\n        name: 'Test User',\n        passwordHash: 'hashed'\n      });\n      \n      const found = await repository.findByEmail('test@example.com');\n      \n      expect(found).not.toBeNull();\n    });\n  });\n});\n```\n\n### Transaction Testing\n\n```typescript\ndescribe('OrderService with transactions', () => {\n  let orderService: OrderService;\n  \n  beforeEach(async () => {\n    await db('orders').truncate();\n    await db('order_items').truncate();\n    await db('inventory').truncate();\n    \n    // Seed inventory\n    await db('inventory').insert([\n      { sku: 'SKU-1', quantity: 10 },\n      { sku: 'SKU-2', quantity: 5 },\n    ]);\n    \n    orderService = new OrderService(db);\n  });\n  \n  it('creates order and reduces inventory atomically', async () => {\n    const order = await orderService.createOrder({\n      customerId: 'cust-1',\n      items: [\n        { sku: 'SKU-1', quantity: 2 },\n        { sku: 'SKU-2', quantity: 1 },\n      ]\n    });\n    \n    expect(order.id).toBeDefined();\n    \n    // Verify inventory reduced\n    const sku1 = await db('inventory').where('sku', 'SKU-1').first();\n    const sku2 = await db('inventory').where('sku', 'SKU-2').first();\n    \n    expect(sku1.quantity).toBe(8);\n    expect(sku2.quantity).toBe(4);\n  });\n  \n  it('rolls back on inventory failure', async () => {\n    await expect(orderService.createOrder({\n      customerId: 'cust-1',\n      items: [\n        { sku: 'SKU-1', quantity: 2 },\n        { sku: 'SKU-2', quantity: 100 }, // More than available\n      ]\n    })).rejects.toThrow('Insufficient inventory');\n    \n    // Verify no partial changes\n    const sku1 = await db('inventory').where('sku', 'SKU-1').first();\n    expect(sku1.quantity).toBe(10); // Unchanged\n    \n    const orders = await db('orders').count('* as count');\n    expect(orders[0].count).toBe(0); // No order created\n  });\n});\n```\n\n## Service Integration Tests\n\n### Testing Service Composition\n\n```typescript\ndescribe('CheckoutService integration', () => {\n  let checkoutService: CheckoutService;\n  let inventoryService: InventoryService;\n  let paymentService: PaymentService;\n  let orderRepository: OrderRepository;\n  \n  beforeEach(async () => {\n    // Real services with test database\n    inventoryService = new InventoryService(db);\n    orderRepository = new OrderRepository(db);\n    \n    // Mock external payment service\n    paymentService = {\n      charge: jest.fn().mockResolvedValue({ id: 'pay_123', status: 'succeeded' }),\n      refund: jest.fn().mockResolvedValue({ id: 'ref_123' })\n    };\n    \n    checkoutService = new CheckoutService(\n      inventoryService,\n      paymentService,\n      orderRepository\n    );\n    \n    // Seed test data\n    await db('inventory').truncate();\n    await db('inventory').insert([\n      { sku: 'ITEM-1', quantity: 10, price: 1000 }\n    ]);\n  });\n  \n  it('completes checkout flow', async () => {\n    const result = await checkoutService.checkout({\n      customerId: 'cust-1',\n      items: [{ sku: 'ITEM-1', quantity: 2 }],\n      paymentMethod: 'pm_test'\n    });\n    \n    // Order created\n    expect(result.orderId).toBeDefined();\n    expect(result.status).toBe('confirmed');\n    \n    // Payment charged\n    expect(paymentService.charge).toHaveBeenCalledWith({\n      customerId: 'cust-1',\n      amount: 2000, // 2 * 1000\n      paymentMethod: 'pm_test'\n    });\n    \n    // Inventory reduced\n    const inventory = await db('inventory').where('sku', 'ITEM-1').first();\n    expect(inventory.quantity).toBe(8);\n    \n    // Order in database\n    const order = await orderRepository.findById(result.orderId);\n    expect(order.status).toBe('confirmed');\n    expect(order.total).toBe(2000);\n  });\n  \n  it('does not charge payment when inventory insufficient', async () => {\n    await expect(checkoutService.checkout({\n      customerId: 'cust-1',\n      items: [{ sku: 'ITEM-1', quantity: 100 }],\n      paymentMethod: 'pm_test'\n    })).rejects.toThrow('Insufficient inventory');\n    \n    expect(paymentService.charge).not.toHaveBeenCalled();\n  });\n  \n  it('refunds payment when order save fails', async () => {\n    // Make order save fail\n    jest.spyOn(orderRepository, 'create').mockRejectedValue(new Error('DB error'));\n    \n    await expect(checkoutService.checkout({\n      customerId: 'cust-1',\n      items: [{ sku: 'ITEM-1', quantity: 1 }],\n      paymentMethod: 'pm_test'\n    })).rejects.toThrow('DB error');\n    \n    // Payment was charged then refunded\n    expect(paymentService.charge).toHaveBeenCalled();\n    expect(paymentService.refund).toHaveBeenCalledWith('pay_123');\n  });\n});\n```\n\n## External Service Integration Tests\n\n### Testing with Real APIs (Controlled)\n\n```typescript\n// Only run these tests when INTEGRATION_TESTS=true\nconst describeIntegration = process.env.INTEGRATION_TESTS \n  ? describe \n  : describe.skip;\n\ndescribeIntegration('Stripe Integration', () => {\n  let stripeClient: StripeClient;\n  \n  beforeAll(() => {\n    stripeClient = new StripeClient(process.env.STRIPE_TEST_KEY!);\n  });\n  \n  it('creates payment intent', async () => {\n    const intent = await stripeClient.createPaymentIntent({\n      amount: 1000,\n      currency: 'usd'\n    });\n    \n    expect(intent.id).toMatch(/^pi_/);\n    expect(intent.status).toBe('requires_payment_method');\n  });\n  \n  it('handles invalid amount', async () => {\n    await expect(stripeClient.createPaymentIntent({\n      amount: -100,\n      currency: 'usd'\n    })).rejects.toThrow(/amount/i);\n  });\n});\n```\n\n### Contract Testing\n\n```typescript\n// Verify our mock matches real API behavior\ndescribe('Payment Service Contract', () => {\n  const mockPaymentService = createMockPaymentService();\n  const realPaymentService = new StripePaymentService(process.env.STRIPE_TEST_KEY!);\n  \n  describe('charge', () => {\n    it('mock matches real response structure', async () => {\n      const input = {\n        amount: 1000,\n        currency: 'usd',\n        paymentMethod: 'pm_card_visa'\n      };\n      \n      // Get real response structure\n      const realResponse = await realPaymentService.charge(input);\n      \n      // Configure mock\n      mockPaymentService.charge.mockResolvedValue({\n        id: 'pay_mock',\n        status: 'succeeded',\n        amount: input.amount\n      });\n      \n      const mockResponse = await mockPaymentService.charge(input);\n      \n      // Verify same shape\n      expect(Object.keys(mockResponse)).toEqual(\n        expect.arrayContaining(Object.keys(realResponse))\n      );\n    });\n  });\n});\n```\n\n## Test Database Management\n\n### Database Setup/Teardown\n\n```typescript\n// test/setup.ts\nimport { db } from '../database';\n\nbeforeAll(async () => {\n  // Run migrations\n  await db.migrate.latest();\n});\n\nafterAll(async () => {\n  // Close connection\n  await db.destroy();\n});\n\n// Per-test isolation\nbeforeEach(async () => {\n  // Option 1: Truncate tables\n  await db.raw('TRUNCATE users, orders, order_items CASCADE');\n  \n  // Option 2: Use transactions (faster)\n  // await db.raw('BEGIN');\n});\n\nafterEach(async () => {\n  // If using transactions\n  // await db.raw('ROLLBACK');\n});\n```\n\n### Test Data Seeding\n\n```typescript\n// test/seeds/testData.ts\nexport async function seedTestData(db: Knex) {\n  // Clear existing data\n  await db('order_items').del();\n  await db('orders').del();\n  await db('products').del();\n  await db('users').del();\n  \n  // Seed users\n  const [user1, user2] = await db('users')\n    .insert([\n      { id: 'user-1', email: 'alice@test.com', name: 'Alice' },\n      { id: 'user-2', email: 'bob@test.com', name: 'Bob' },\n    ])\n    .returning('*');\n  \n  // Seed products\n  const [product1, product2] = await db('products')\n    .insert([\n      { id: 'prod-1', name: 'Widget', price: 1000, stock: 100 },\n      { id: 'prod-2', name: 'Gadget', price: 2000, stock: 50 },\n    ])\n    .returning('*');\n  \n  return { users: [user1, user2], products: [product1, product2] };\n}\n\n// In tests\ndescribe('Order API', () => {\n  let testData: Awaited<ReturnType<typeof seedTestData>>;\n  \n  beforeEach(async () => {\n    testData = await seedTestData(db);\n  });\n  \n  it('creates order for existing user', async () => {\n    const response = await request(app)\n      .post('/api/orders')\n      .send({\n        userId: testData.users[0].id,\n        items: [{ productId: testData.products[0].id, quantity: 2 }]\n      });\n    \n    expect(response.status).toBe(201);\n  });\n});\n```\n\n## Testing Message Queues\n\n```typescript\ndescribe('Order Event Processing', () => {\n  let queue: TestQueue;\n  let orderEventHandler: OrderEventHandler;\n  \n  beforeEach(() => {\n    queue = new TestQueue();\n    orderEventHandler = new OrderEventHandler(db, emailService);\n    orderEventHandler.subscribe(queue);\n  });\n  \n  it('sends confirmation email on order.created', async () => {\n    const emailSpy = jest.spyOn(emailService, 'send');\n    \n    // Publish event\n    await queue.publish('order.created', {\n      orderId: 'ord-123',\n      customerEmail: 'test@example.com',\n      total: 5000\n    });\n    \n    // Wait for processing\n    await queue.waitForProcessing();\n    \n    expect(emailSpy).toHaveBeenCalledWith({\n      to: 'test@example.com',\n      template: 'order-confirmation',\n      data: expect.objectContaining({ orderId: 'ord-123' })\n    });\n  });\n  \n  it('updates inventory on order.confirmed', async () => {\n    // Setup initial inventory\n    await db('inventory').insert({ sku: 'SKU-1', quantity: 100 });\n    \n    await queue.publish('order.confirmed', {\n      orderId: 'ord-123',\n      items: [{ sku: 'SKU-1', quantity: 5 }]\n    });\n    \n    await queue.waitForProcessing();\n    \n    const inventory = await db('inventory').where('sku', 'SKU-1').first();\n    expect(inventory.quantity).toBe(95);\n  });\n});\n```\n"
    },
    {
      "name": "mocking-patterns.md",
      "path": "references/mocking-patterns.md",
      "content": "# Mocking Patterns\n\nStrategies for isolating code under test.\n\n## When to Mock\n\n### Mock These\n\n| Dependency | Why Mock |\n|------------|----------|\n| **External APIs** | Slow, unreliable, costs money |\n| **Databases** | Slow, requires setup |\n| **File system** | Side effects, slow |\n| **Network requests** | Unreliable, slow |\n| **Time/dates** | Non-deterministic |\n| **Random numbers** | Non-deterministic |\n| **Environment variables** | Varies between environments |\n\n### Don't Mock These\n\n| Dependency | Why Not |\n|------------|---------|\n| **Pure functions** | No side effects, fast |\n| **Value objects** | Simple, no behavior |\n| **The code under test** | Defeats purpose |\n| **Simple utilities** | More work than value |\n\n## Mock Types\n\n### Stub\n\nReturns canned data, no verification.\n\n```typescript\n// Simple stub\nconst userService = {\n  getUser: jest.fn().mockReturnValue({ id: '1', name: 'Test' })\n};\n\n// Async stub\nconst apiClient = {\n  fetch: jest.fn().mockResolvedValue({ data: [] })\n};\n\n// Stub with different returns\nconst counter = {\n  next: jest.fn()\n    .mockReturnValueOnce(1)\n    .mockReturnValueOnce(2)\n    .mockReturnValueOnce(3)\n};\n```\n\n### Mock\n\nRecords calls for verification.\n\n```typescript\nconst emailService = {\n  send: jest.fn().mockResolvedValue({ sent: true })\n};\n\n// Use in test\nawait orderService.completeOrder(order);\n\n// Verify interactions\nexpect(emailService.send).toHaveBeenCalledTimes(1);\nexpect(emailService.send).toHaveBeenCalledWith({\n  to: order.customerEmail,\n  subject: 'Order Confirmation',\n  body: expect.stringContaining(order.id)\n});\n```\n\n### Spy\n\nWraps real implementation, records calls.\n\n```typescript\nconst logger = new Logger();\nconst spy = jest.spyOn(logger, 'error');\n\n// Real method still executes\nservice.doSomething();\n\n// But we can verify it was called\nexpect(spy).toHaveBeenCalledWith('Something went wrong');\n\n// Restore original\nspy.mockRestore();\n```\n\n### Fake\n\nWorking implementation for tests.\n\n```typescript\n// Fake repository\nclass FakeUserRepository implements UserRepository {\n  private users = new Map<string, User>();\n  \n  async save(user: User): Promise<void> {\n    this.users.set(user.id, { ...user });\n  }\n  \n  async findById(id: string): Promise<User | null> {\n    return this.users.get(id) ?? null;\n  }\n  \n  async findByEmail(email: string): Promise<User | null> {\n    return [...this.users.values()].find(u => u.email === email) ?? null;\n  }\n  \n  // Test helper\n  clear(): void {\n    this.users.clear();\n  }\n}\n\n// Usage\ndescribe('UserService', () => {\n  let repository: FakeUserRepository;\n  let service: UserService;\n  \n  beforeEach(() => {\n    repository = new FakeUserRepository();\n    service = new UserService(repository);\n  });\n  \n  it('creates and retrieves user', async () => {\n    const user = await service.createUser({ email: 'test@example.com', name: 'Test' });\n    const found = await service.getUser(user.id);\n    expect(found).toEqual(user);\n  });\n});\n```\n\n## Jest Mocking Patterns\n\n### Module Mocking\n\n```typescript\n// Mock entire module\njest.mock('../database', () => ({\n  query: jest.fn().mockResolvedValue([]),\n  connect: jest.fn().mockResolvedValue(true),\n}));\n\n// Mock with factory\njest.mock('../emailService', () => {\n  return {\n    EmailService: jest.fn().mockImplementation(() => ({\n      send: jest.fn().mockResolvedValue({ sent: true }),\n    })),\n  };\n});\n\n// Partial mock (keep some real implementations)\njest.mock('../utils', () => ({\n  ...jest.requireActual('../utils'),\n  formatDate: jest.fn().mockReturnValue('2024-01-01'),\n}));\n```\n\n### Manual Mocks\n\n```typescript\n// __mocks__/axios.ts\nexport default {\n  get: jest.fn().mockResolvedValue({ data: {} }),\n  post: jest.fn().mockResolvedValue({ data: {} }),\n  create: jest.fn(() => ({\n    get: jest.fn().mockResolvedValue({ data: {} }),\n    post: jest.fn().mockResolvedValue({ data: {} }),\n  })),\n};\n\n// In test file\njest.mock('axios');\nimport axios from 'axios';\n\nit('fetches data', async () => {\n  (axios.get as jest.Mock).mockResolvedValue({ data: { id: '1' } });\n  // ...\n});\n```\n\n### Mock Reset and Restore\n\n```typescript\ndescribe('with mocks', () => {\n  const mockFn = jest.fn();\n  \n  beforeEach(() => {\n    // Clear call history, keep implementation\n    mockFn.mockClear();\n    \n    // Or reset everything including implementation\n    // mockFn.mockReset();\n  });\n  \n  afterAll(() => {\n    // Restore original (for spies)\n    // mockFn.mockRestore();\n  });\n});\n\n// Clear all mocks at once\nafterEach(() => {\n  jest.clearAllMocks();\n});\n```\n\n## Dependency Injection for Testing\n\n### Constructor Injection\n\n```typescript\n// Production code\nclass OrderService {\n  constructor(\n    private readonly repository: OrderRepository,\n    private readonly paymentService: PaymentService,\n    private readonly emailService: EmailService\n  ) {}\n  \n  async createOrder(data: CreateOrderData): Promise<Order> {\n    const order = await this.repository.create(data);\n    await this.paymentService.charge(order.total);\n    await this.emailService.sendConfirmation(order);\n    return order;\n  }\n}\n\n// Test\ndescribe('OrderService', () => {\n  let service: OrderService;\n  let mockRepository: jest.Mocked<OrderRepository>;\n  let mockPayment: jest.Mocked<PaymentService>;\n  let mockEmail: jest.Mocked<EmailService>;\n  \n  beforeEach(() => {\n    mockRepository = {\n      create: jest.fn().mockResolvedValue({ id: 'ord-1', total: 100 }),\n      findById: jest.fn(),\n    };\n    mockPayment = {\n      charge: jest.fn().mockResolvedValue({ success: true }),\n    };\n    mockEmail = {\n      sendConfirmation: jest.fn().mockResolvedValue(undefined),\n    };\n    \n    service = new OrderService(mockRepository, mockPayment, mockEmail);\n  });\n  \n  it('creates order and charges payment', async () => {\n    await service.createOrder({ items: [] });\n    \n    expect(mockPayment.charge).toHaveBeenCalledWith(100);\n  });\n});\n```\n\n### Factory Functions for Mocks\n\n```typescript\n// __mocks__/factories.ts\nexport function createMockOrderRepository(): jest.Mocked<OrderRepository> {\n  return {\n    create: jest.fn().mockResolvedValue({ id: 'ord-1', total: 100 }),\n    findById: jest.fn().mockResolvedValue(null),\n    findByCustomer: jest.fn().mockResolvedValue([]),\n    update: jest.fn().mockResolvedValue({ id: 'ord-1' }),\n    delete: jest.fn().mockResolvedValue(undefined),\n  };\n}\n\nexport function createMockPaymentService(): jest.Mocked<PaymentService> {\n  return {\n    charge: jest.fn().mockResolvedValue({ id: 'pay-1', success: true }),\n    refund: jest.fn().mockResolvedValue({ id: 'ref-1', success: true }),\n  };\n}\n\n// Usage\nbeforeEach(() => {\n  mockRepository = createMockOrderRepository();\n  mockPayment = createMockPaymentService();\n  service = new OrderService(mockRepository, mockPayment);\n});\n```\n\n## Mocking Specific Scenarios\n\n### Mocking HTTP Requests\n\n```typescript\n// With fetch\nglobal.fetch = jest.fn();\n\nbeforeEach(() => {\n  (fetch as jest.Mock).mockResolvedValue({\n    ok: true,\n    json: () => Promise.resolve({ data: 'test' }),\n  });\n});\n\nit('fetches data', async () => {\n  const result = await fetchData('/api/data');\n  \n  expect(fetch).toHaveBeenCalledWith('/api/data', expect.any(Object));\n  expect(result).toEqual({ data: 'test' });\n});\n\n// With axios\nimport axios from 'axios';\njest.mock('axios');\nconst mockedAxios = axios as jest.Mocked<typeof axios>;\n\nit('posts data', async () => {\n  mockedAxios.post.mockResolvedValue({ data: { id: '1' } });\n  \n  const result = await createUser({ name: 'Test' });\n  \n  expect(mockedAxios.post).toHaveBeenCalledWith('/api/users', { name: 'Test' });\n});\n```\n\n### Mocking Timers\n\n```typescript\ndescribe('with timers', () => {\n  beforeEach(() => {\n    jest.useFakeTimers();\n  });\n  \n  afterEach(() => {\n    jest.useRealTimers();\n  });\n  \n  it('debounces function calls', async () => {\n    const callback = jest.fn();\n    const debounced = debounce(callback, 1000);\n    \n    debounced();\n    debounced();\n    debounced();\n    \n    expect(callback).not.toHaveBeenCalled();\n    \n    jest.advanceTimersByTime(1000);\n    \n    expect(callback).toHaveBeenCalledTimes(1);\n  });\n  \n  it('retries with exponential backoff', async () => {\n    const failingFn = jest.fn()\n      .mockRejectedValueOnce(new Error('Fail 1'))\n      .mockRejectedValueOnce(new Error('Fail 2'))\n      .mockResolvedValue('success');\n    \n    const promise = retryWithBackoff(failingFn, { maxRetries: 3 });\n    \n    // First attempt fails immediately\n    await jest.advanceTimersByTimeAsync(0);\n    expect(failingFn).toHaveBeenCalledTimes(1);\n    \n    // Wait for first backoff (1s)\n    await jest.advanceTimersByTimeAsync(1000);\n    expect(failingFn).toHaveBeenCalledTimes(2);\n    \n    // Wait for second backoff (2s)\n    await jest.advanceTimersByTimeAsync(2000);\n    expect(failingFn).toHaveBeenCalledTimes(3);\n    \n    await expect(promise).resolves.toBe('success');\n  });\n});\n```\n\n### Mocking Date/Time\n\n```typescript\ndescribe('with dates', () => {\n  beforeEach(() => {\n    jest.useFakeTimers();\n    jest.setSystemTime(new Date('2024-01-15T10:00:00Z'));\n  });\n  \n  afterEach(() => {\n    jest.useRealTimers();\n  });\n  \n  it('formats current date', () => {\n    expect(formatCurrentDate()).toBe('January 15, 2024');\n  });\n  \n  it('calculates days until expiry', () => {\n    const expiry = new Date('2024-01-20T10:00:00Z');\n    expect(daysUntil(expiry)).toBe(5);\n  });\n});\n```\n\n### Mocking Environment Variables\n\n```typescript\ndescribe('with env vars', () => {\n  const originalEnv = process.env;\n  \n  beforeEach(() => {\n    process.env = { ...originalEnv };\n  });\n  \n  afterEach(() => {\n    process.env = originalEnv;\n  });\n  \n  it('uses production API in production', () => {\n    process.env.NODE_ENV = 'production';\n    process.env.API_URL = 'https://api.example.com';\n    \n    expect(getApiUrl()).toBe('https://api.example.com');\n  });\n  \n  it('uses localhost in development', () => {\n    process.env.NODE_ENV = 'development';\n    delete process.env.API_URL;\n    \n    expect(getApiUrl()).toBe('http://localhost:3000');\n  });\n});\n```\n\n### Mocking File System\n\n```typescript\nimport fs from 'fs';\nimport path from 'path';\n\njest.mock('fs');\nconst mockFs = fs as jest.Mocked<typeof fs>;\n\ndescribe('FileReader', () => {\n  it('reads file content', () => {\n    mockFs.readFileSync.mockReturnValue('file content');\n    \n    const result = readConfig('/path/to/config.json');\n    \n    expect(mockFs.readFileSync).toHaveBeenCalledWith(\n      '/path/to/config.json',\n      'utf-8'\n    );\n    expect(result).toBe('file content');\n  });\n  \n  it('handles file not found', () => {\n    mockFs.readFileSync.mockImplementation(() => {\n      const error = new Error('ENOENT') as NodeJS.ErrnoException;\n      error.code = 'ENOENT';\n      throw error;\n    });\n    \n    expect(() => readConfig('/nonexistent')).toThrow('Config file not found');\n  });\n});\n```\n\n## Verifying Mock Interactions\n\n```typescript\ndescribe('interaction verification', () => {\n  it('verifies call count', () => {\n    expect(mock).toHaveBeenCalledTimes(3);\n    expect(mock).toHaveBeenCalled(); // At least once\n    expect(mock).not.toHaveBeenCalled();\n  });\n  \n  it('verifies call arguments', () => {\n    expect(mock).toHaveBeenCalledWith('arg1', 'arg2');\n    expect(mock).toHaveBeenCalledWith(expect.any(String));\n    expect(mock).toHaveBeenCalledWith(expect.objectContaining({ id: '1' }));\n    expect(mock).toHaveBeenLastCalledWith('final call');\n    expect(mock).toHaveBeenNthCalledWith(1, 'first call');\n  });\n  \n  it('verifies call order', () => {\n    const mock1 = jest.fn();\n    const mock2 = jest.fn();\n    \n    // ... code that calls mock1 then mock2\n    \n    const mock1Order = mock1.mock.invocationCallOrder[0];\n    const mock2Order = mock2.mock.invocationCallOrder[0];\n    expect(mock1Order).toBeLessThan(mock2Order);\n  });\n  \n  it('accesses call arguments', () => {\n    mock('call1');\n    mock('call2');\n    \n    expect(mock.mock.calls[0][0]).toBe('call1');\n    expect(mock.mock.calls[1][0]).toBe('call2');\n  });\n});\n```\n\n## Common Mistakes\n\n### Over-Mocking\n\n```typescript\n// BAD: Mocking everything\nit('processes order', () => {\n  const mockOrder = { id: '1', total: 100 };\n  const mockResult = { success: true };\n  \n  jest.spyOn(orderService, 'process').mockReturnValue(mockResult);\n  \n  const result = orderService.process(mockOrder);\n  \n  expect(result).toBe(mockResult); // Tests nothing!\n});\n\n// GOOD: Mock only external dependencies\nit('processes order', () => {\n  mockPaymentService.charge.mockResolvedValue({ success: true });\n  mockRepository.save.mockResolvedValue({ id: '1' });\n  \n  const result = await orderService.process(testOrder);\n  \n  expect(result.success).toBe(true);\n  expect(mockPaymentService.charge).toHaveBeenCalledWith(testOrder.total);\n});\n```\n\n### Forgetting to Reset Mocks\n\n```typescript\n// BAD: Mocks leak between tests\nconst mock = jest.fn();\n\nit('first test', () => {\n  mock('first');\n  expect(mock).toHaveBeenCalledTimes(1);\n});\n\nit('second test', () => {\n  mock('second');\n  expect(mock).toHaveBeenCalledTimes(1); // FAILS! Called twice total\n});\n\n// GOOD: Reset between tests\nbeforeEach(() => {\n  mock.mockClear();\n});\n```\n\n### Mock Implementation vs Return Value\n\n```typescript\n// mockReturnValue - simple return\nmock.mockReturnValue(42);\n\n// mockImplementation - custom logic\nmock.mockImplementation((x) => x * 2);\n\n// For async\nmock.mockResolvedValue(42);\nmock.mockImplementation(async (x) => {\n  await delay(100);\n  return x * 2;\n});\n\n// For errors\nmock.mockRejectedValue(new Error('Failed'));\nmock.mockImplementation(() => {\n  throw new Error('Sync error');\n});\n```\n"
    },
    {
      "name": "test-data-patterns.md",
      "path": "references/test-data-patterns.md",
      "content": "# Test Data Patterns\n\nStrategies for creating and managing test data.\n\n## Principles\n\n1. **Minimal** — Include only what's needed for the test\n2. **Readable** — Easy to understand at a glance\n3. **Isolated** — Each test controls its own data\n4. **Realistic** — Similar enough to production to catch bugs\n5. **Maintainable** — Easy to update when requirements change\n\n## Factory Functions\n\n### Basic Factory\n\n```typescript\n// factories/user.ts\nexport function createTestUser(overrides: Partial<User> = {}): User {\n  return {\n    id: `usr_${Math.random().toString(36).substring(7)}`,\n    email: 'test@example.com',\n    name: 'Test User',\n    role: 'user',\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    ...overrides,\n  };\n}\n\n// Usage\nit('updates user name', async () => {\n  const user = createTestUser({ name: 'Original Name' });\n  \n  const updated = await service.updateUser(user.id, { name: 'New Name' });\n  \n  expect(updated.name).toBe('New Name');\n});\n```\n\n### Factory with Sequences\n\n```typescript\n// factories/user.ts\nlet userSequence = 0;\n\nexport function createTestUser(overrides: Partial<User> = {}): User {\n  const seq = ++userSequence;\n  return {\n    id: `usr_${seq}`,\n    email: `user${seq}@example.com`,\n    name: `User ${seq}`,\n    role: 'user',\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    ...overrides,\n  };\n}\n\nexport function resetUserSequence(): void {\n  userSequence = 0;\n}\n\n// In test setup\nbeforeEach(() => {\n  resetUserSequence();\n});\n```\n\n### Nested Factories\n\n```typescript\n// factories/order.ts\nexport function createTestOrder(overrides: Partial<Order> = {}): Order {\n  return {\n    id: `ord_${Math.random().toString(36).substring(7)}`,\n    customerId: createTestUser().id,\n    items: [createTestOrderItem()],\n    status: 'pending',\n    total: 0,\n    createdAt: new Date(),\n    ...overrides,\n  };\n}\n\nexport function createTestOrderItem(overrides: Partial<OrderItem> = {}): OrderItem {\n  return {\n    id: `item_${Math.random().toString(36).substring(7)}`,\n    productId: createTestProduct().id,\n    quantity: 1,\n    unitPrice: 1000,\n    ...overrides,\n  };\n}\n\n// Usage with custom nested data\nconst order = createTestOrder({\n  items: [\n    createTestOrderItem({ quantity: 2, unitPrice: 500 }),\n    createTestOrderItem({ quantity: 1, unitPrice: 1500 }),\n  ],\n});\n```\n\n### Factory with Traits\n\n```typescript\n// factories/user.ts\ntype UserTrait = 'admin' | 'verified' | 'premium' | 'banned';\n\nconst traits: Record<UserTrait, Partial<User>> = {\n  admin: { role: 'admin', permissions: ['all'] },\n  verified: { emailVerified: true, verifiedAt: new Date() },\n  premium: { tier: 'premium', subscriptionEndsAt: addDays(new Date(), 30) },\n  banned: { status: 'banned', bannedAt: new Date() },\n};\n\nexport function createTestUser(\n  overrides: Partial<User> = {},\n  ...userTraits: UserTrait[]\n): User {\n  const traitOverrides = userTraits.reduce(\n    (acc, trait) => ({ ...acc, ...traits[trait] }),\n    {}\n  );\n  \n  return {\n    id: `usr_${Math.random().toString(36).substring(7)}`,\n    email: 'test@example.com',\n    name: 'Test User',\n    role: 'user',\n    createdAt: new Date(),\n    ...traitOverrides,\n    ...overrides,\n  };\n}\n\n// Usage\nconst adminUser = createTestUser({}, 'admin');\nconst premiumVerifiedUser = createTestUser({}, 'premium', 'verified');\nconst bannedUser = createTestUser({ name: 'Bad Actor' }, 'banned');\n```\n\n## Builder Pattern\n\n### Fluent Builder\n\n```typescript\n// builders/OrderBuilder.ts\nexport class OrderBuilder {\n  private order: Partial<Order> = {\n    status: 'pending',\n    items: [],\n  };\n  \n  withId(id: string): this {\n    this.order.id = id;\n    return this;\n  }\n  \n  forCustomer(customerId: string): this {\n    this.order.customerId = customerId;\n    return this;\n  }\n  \n  withItem(item: OrderItem): this {\n    this.order.items = [...(this.order.items ?? []), item];\n    return this;\n  }\n  \n  withItems(items: OrderItem[]): this {\n    this.order.items = items;\n    return this;\n  }\n  \n  withStatus(status: OrderStatus): this {\n    this.order.status = status;\n    return this;\n  }\n  \n  confirmed(): this {\n    this.order.status = 'confirmed';\n    this.order.confirmedAt = new Date();\n    return this;\n  }\n  \n  shipped(): this {\n    this.order.status = 'shipped';\n    this.order.shippedAt = new Date();\n    return this;\n  }\n  \n  build(): Order {\n    const total = (this.order.items ?? []).reduce(\n      (sum, item) => sum + item.unitPrice * item.quantity,\n      0\n    );\n    \n    return {\n      id: this.order.id ?? `ord_${Math.random().toString(36).substring(7)}`,\n      customerId: this.order.customerId ?? 'cust_default',\n      items: this.order.items ?? [],\n      status: this.order.status ?? 'pending',\n      total,\n      createdAt: new Date(),\n      ...this.order,\n    } as Order;\n  }\n}\n\n// Usage\nconst order = new OrderBuilder()\n  .forCustomer('cust_123')\n  .withItem({ productId: 'prod_1', quantity: 2, unitPrice: 500 })\n  .withItem({ productId: 'prod_2', quantity: 1, unitPrice: 1000 })\n  .confirmed()\n  .build();\n```\n\n### Builder with Presets\n\n```typescript\nexport class OrderBuilder {\n  // ... existing methods\n  \n  static simple(): OrderBuilder {\n    return new OrderBuilder()\n      .withItem({ productId: 'prod_1', quantity: 1, unitPrice: 1000 });\n  }\n  \n  static withMultipleItems(): OrderBuilder {\n    return new OrderBuilder()\n      .withItem({ productId: 'prod_1', quantity: 2, unitPrice: 500 })\n      .withItem({ productId: 'prod_2', quantity: 1, unitPrice: 1500 })\n      .withItem({ productId: 'prod_3', quantity: 3, unitPrice: 250 });\n  }\n  \n  static completedOrder(): OrderBuilder {\n    return OrderBuilder.simple()\n      .confirmed()\n      .shipped()\n      .withStatus('delivered');\n  }\n}\n\n// Usage\nconst simpleOrder = OrderBuilder.simple().build();\nconst complexOrder = OrderBuilder.withMultipleItems().forCustomer('vip_1').build();\n```\n\n## Mother Pattern\n\nCentralized test data definitions.\n\n```typescript\n// testData/ObjectMother.ts\nexport const ObjectMother = {\n  users: {\n    alice: () => createTestUser({\n      id: 'usr_alice',\n      email: 'alice@example.com',\n      name: 'Alice Smith',\n    }),\n    \n    bob: () => createTestUser({\n      id: 'usr_bob',\n      email: 'bob@example.com',\n      name: 'Bob Jones',\n    }),\n    \n    admin: () => createTestUser({\n      id: 'usr_admin',\n      email: 'admin@example.com',\n      name: 'Admin User',\n      role: 'admin',\n    }),\n  },\n  \n  products: {\n    widget: () => createTestProduct({\n      id: 'prod_widget',\n      name: 'Widget',\n      price: 1000,\n      stock: 100,\n    }),\n    \n    gadget: () => createTestProduct({\n      id: 'prod_gadget',\n      name: 'Gadget',\n      price: 2500,\n      stock: 50,\n    }),\n    \n    outOfStock: () => createTestProduct({\n      id: 'prod_oos',\n      name: 'Out of Stock Item',\n      price: 500,\n      stock: 0,\n    }),\n  },\n  \n  orders: {\n    pending: () => new OrderBuilder()\n      .forCustomer(ObjectMother.users.alice().id)\n      .withItem({ productId: ObjectMother.products.widget().id, quantity: 1, unitPrice: 1000 })\n      .build(),\n    \n    confirmed: () => new OrderBuilder()\n      .forCustomer(ObjectMother.users.alice().id)\n      .withItem({ productId: ObjectMother.products.widget().id, quantity: 1, unitPrice: 1000 })\n      .confirmed()\n      .build(),\n  },\n};\n\n// Usage\nit('sends email when order confirmed', async () => {\n  const alice = ObjectMother.users.alice();\n  const order = ObjectMother.orders.pending();\n  \n  await service.confirmOrder(order.id);\n  \n  expect(emailService.send).toHaveBeenCalledWith({\n    to: alice.email,\n    subject: expect.stringContaining('confirmed'),\n  });\n});\n```\n\n## Fixtures\n\n### JSON Fixtures\n\n```json\n// fixtures/users.json\n{\n  \"validUser\": {\n    \"email\": \"test@example.com\",\n    \"name\": \"Test User\",\n    \"password\": \"password123\"\n  },\n  \"adminUser\": {\n    \"email\": \"admin@example.com\",\n    \"name\": \"Admin User\",\n    \"password\": \"adminpass\",\n    \"role\": \"admin\"\n  }\n}\n```\n\n```typescript\n// In tests\nimport fixtures from './fixtures/users.json';\n\nit('creates user from valid data', async () => {\n  const user = await service.createUser(fixtures.validUser);\n  expect(user.email).toBe(fixtures.validUser.email);\n});\n```\n\n### Fixture Files\n\n```typescript\n// fixtures/sampleInvoice.pdf - actual PDF file\n// fixtures/largeImage.jpg - test image\n\nimport fs from 'fs';\nimport path from 'path';\n\nexport function loadFixture(filename: string): Buffer {\n  return fs.readFileSync(path.join(__dirname, 'fixtures', filename));\n}\n\n// Usage\nit('processes PDF invoice', async () => {\n  const pdfBuffer = loadFixture('sampleInvoice.pdf');\n  const result = await invoiceProcessor.process(pdfBuffer);\n  expect(result.total).toBe(1500);\n});\n```\n\n## Parameterized Test Data\n\n### Test Tables\n\n```typescript\ndescribe('calculateDiscount', () => {\n  const testCases = [\n    { total: 50, customerType: 'regular', expected: 0 },\n    { total: 100, customerType: 'regular', expected: 0 },\n    { total: 100, customerType: 'gold', expected: 10 },\n    { total: 100, customerType: 'platinum', expected: 20 },\n    { total: 500, customerType: 'regular', expected: 25 },\n    { total: 500, customerType: 'gold', expected: 75 },\n    { total: 1000, customerType: 'platinum', expected: 250 },\n  ];\n  \n  it.each(testCases)(\n    'returns $expected for $total total with $customerType customer',\n    ({ total, customerType, expected }) => {\n      expect(calculateDiscount(total, customerType)).toBe(expected);\n    }\n  );\n});\n```\n\n### Edge Case Sets\n\n```typescript\nconst invalidEmails = [\n  '',\n  'plaintext',\n  '@nodomain.com',\n  'spaces in@email.com',\n  'missing@.com',\n  'double@@at.com',\n];\n\nconst validEmails = [\n  'simple@example.com',\n  'with.dots@example.com',\n  'with+plus@example.com',\n  'numbers123@example.com',\n];\n\ndescribe('email validation', () => {\n  it.each(invalidEmails)('rejects invalid email: %s', (email) => {\n    expect(validateEmail(email)).toBe(false);\n  });\n  \n  it.each(validEmails)('accepts valid email: %s', (email) => {\n    expect(validateEmail(email)).toBe(true);\n  });\n});\n```\n\n## Database Test Data\n\n### Seeding Functions\n\n```typescript\n// testData/seeders.ts\nexport async function seedUsers(db: Database): Promise<User[]> {\n  const users = [\n    createTestUser({ id: 'usr_1', email: 'user1@test.com' }),\n    createTestUser({ id: 'usr_2', email: 'user2@test.com' }),\n    createTestUser({ id: 'usr_admin', email: 'admin@test.com' }, 'admin'),\n  ];\n  \n  await db('users').insert(users);\n  return users;\n}\n\nexport async function seedProducts(db: Database): Promise<Product[]> {\n  const products = [\n    createTestProduct({ id: 'prod_1', stock: 100 }),\n    createTestProduct({ id: 'prod_2', stock: 50 }),\n    createTestProduct({ id: 'prod_3', stock: 0 }),\n  ];\n  \n  await db('products').insert(products);\n  return products;\n}\n\nexport async function seedTestData(db: Database) {\n  await db.raw('TRUNCATE users, products, orders CASCADE');\n  \n  const users = await seedUsers(db);\n  const products = await seedProducts(db);\n  \n  return { users, products };\n}\n```\n\n### Per-Test Data Setup\n\n```typescript\ndescribe('OrderService', () => {\n  let testData: { users: User[]; products: Product[] };\n  \n  beforeEach(async () => {\n    testData = await seedTestData(db);\n  });\n  \n  it('creates order for existing user', async () => {\n    const order = await service.createOrder({\n      customerId: testData.users[0].id,\n      items: [{ productId: testData.products[0].id, quantity: 1 }],\n    });\n    \n    expect(order.customerId).toBe(testData.users[0].id);\n  });\n});\n```\n\n## Randomized Test Data\n\n### Faker.js\n\n```typescript\nimport { faker } from '@faker-js/faker';\n\nexport function createRandomUser(): User {\n  return {\n    id: faker.string.uuid(),\n    email: faker.internet.email(),\n    name: faker.person.fullName(),\n    phone: faker.phone.number(),\n    address: {\n      street: faker.location.streetAddress(),\n      city: faker.location.city(),\n      state: faker.location.state(),\n      zip: faker.location.zipCode(),\n    },\n    createdAt: faker.date.past(),\n  };\n}\n\nexport function createRandomOrder(): Order {\n  return {\n    id: faker.string.uuid(),\n    customerId: faker.string.uuid(),\n    items: Array.from({ length: faker.number.int({ min: 1, max: 5 }) }, () => ({\n      productId: faker.string.uuid(),\n      quantity: faker.number.int({ min: 1, max: 10 }),\n      unitPrice: faker.number.int({ min: 100, max: 10000 }),\n    })),\n    status: faker.helpers.arrayElement(['pending', 'confirmed', 'shipped']),\n    createdAt: faker.date.past(),\n  };\n}\n\n// Seeded for reproducibility\nexport function createSeededData(seed: number) {\n  faker.seed(seed);\n  return {\n    user: createRandomUser(),\n    order: createRandomOrder(),\n  };\n}\n```\n\n### Property-Based Testing\n\n```typescript\nimport fc from 'fast-check';\n\ndescribe('calculateTotal', () => {\n  it('always returns non-negative value', () => {\n    fc.assert(\n      fc.property(\n        fc.array(fc.record({\n          quantity: fc.integer({ min: 0, max: 100 }),\n          price: fc.integer({ min: 0, max: 100000 }),\n        })),\n        (items) => {\n          const total = calculateTotal(items);\n          return total >= 0;\n        }\n      )\n    );\n  });\n  \n  it('is commutative (order of items does not matter)', () => {\n    fc.assert(\n      fc.property(\n        fc.array(fc.record({\n          quantity: fc.integer({ min: 1, max: 10 }),\n          price: fc.integer({ min: 100, max: 10000 }),\n        }), { minLength: 2 }),\n        (items) => {\n          const total1 = calculateTotal(items);\n          const total2 = calculateTotal([...items].reverse());\n          return total1 === total2;\n        }\n      )\n    );\n  });\n});\n```\n\n## Anti-Patterns\n\n### Shared Mutable State\n\n```typescript\n// BAD: Tests can affect each other\nconst testUser = createTestUser();\n\nit('test 1', () => {\n  testUser.name = 'Modified';\n  // ...\n});\n\nit('test 2', () => {\n  // testUser.name is still 'Modified'!\n});\n\n// GOOD: Fresh data per test\nlet testUser: User;\n\nbeforeEach(() => {\n  testUser = createTestUser();\n});\n```\n\n### Over-Specified Data\n\n```typescript\n// BAD: Too much irrelevant detail\nconst user = {\n  id: 'usr_123',\n  email: 'john.smith@example.com',\n  firstName: 'John',\n  lastName: 'Smith',\n  phone: '+1-555-123-4567',\n  address: { street: '123 Main St', city: 'NYC', zip: '10001' },\n  createdAt: new Date('2024-01-15T10:30:00Z'),\n  // ... 20 more fields\n};\n\n// GOOD: Only relevant fields\nconst user = createTestUser({ role: 'admin' }); // Only role matters for this test\n```\n\n### Magic Values\n\n```typescript\n// BAD: What does '42' mean?\nexpect(calculateDiscount(42, 'gold')).toBe(4.2);\n\n// GOOD: Named constants\nconst STANDARD_ORDER_TOTAL = 100;\nconst GOLD_DISCOUNT_RATE = 0.10;\nconst EXPECTED_DISCOUNT = STANDARD_ORDER_TOTAL * GOLD_DISCOUNT_RATE;\n\nexpect(calculateDiscount(STANDARD_ORDER_TOTAL, 'gold')).toBe(EXPECTED_DISCOUNT);\n```\n"
    },
    {
      "name": "unit-test-patterns.md",
      "path": "references/unit-test-patterns.md",
      "content": "# Unit Test Patterns\n\nPatterns and examples for effective unit tests.\n\n## Unit Test Characteristics\n\n| Characteristic | Description |\n|----------------|-------------|\n| **Fast** | Runs in <10ms |\n| **Isolated** | No external dependencies |\n| **Repeatable** | Same result every run |\n| **Self-validating** | Pass or fail, no manual inspection |\n| **Timely** | Written with or before the code |\n\n## Basic Patterns\n\n### Simple Function Test\n\n```typescript\n// Code under test\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Tests\ndescribe('add', () => {\n  it('adds two positive numbers', () => {\n    expect(add(2, 3)).toBe(5);\n  });\n  \n  it('adds negative numbers', () => {\n    expect(add(-2, -3)).toBe(-5);\n  });\n  \n  it('adds zero', () => {\n    expect(add(5, 0)).toBe(5);\n  });\n});\n```\n\n### Class Method Test\n\n```typescript\n// Code under test\nclass Calculator {\n  private memory: number = 0;\n  \n  add(value: number): number {\n    this.memory += value;\n    return this.memory;\n  }\n  \n  clear(): void {\n    this.memory = 0;\n  }\n  \n  getMemory(): number {\n    return this.memory;\n  }\n}\n\n// Tests\ndescribe('Calculator', () => {\n  let calculator: Calculator;\n  \n  beforeEach(() => {\n    calculator = new Calculator();\n  });\n  \n  describe('add', () => {\n    it('adds value to memory', () => {\n      calculator.add(5);\n      expect(calculator.getMemory()).toBe(5);\n    });\n    \n    it('accumulates multiple additions', () => {\n      calculator.add(5);\n      calculator.add(3);\n      expect(calculator.getMemory()).toBe(8);\n    });\n    \n    it('returns new memory value', () => {\n      const result = calculator.add(5);\n      expect(result).toBe(5);\n    });\n  });\n  \n  describe('clear', () => {\n    it('resets memory to zero', () => {\n      calculator.add(10);\n      calculator.clear();\n      expect(calculator.getMemory()).toBe(0);\n    });\n  });\n});\n```\n\n### Async Function Test\n\n```typescript\n// Code under test\nasync function fetchUser(id: string): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  if (!response.ok) {\n    throw new Error('User not found');\n  }\n  return response.json();\n}\n\n// Tests\ndescribe('fetchUser', () => {\n  beforeEach(() => {\n    global.fetch = jest.fn();\n  });\n  \n  it('returns user data on success', async () => {\n    const mockUser = { id: '1', name: 'Alice' };\n    (fetch as jest.Mock).mockResolvedValue({\n      ok: true,\n      json: () => Promise.resolve(mockUser)\n    });\n    \n    const result = await fetchUser('1');\n    \n    expect(result).toEqual(mockUser);\n  });\n  \n  it('throws error when user not found', async () => {\n    (fetch as jest.Mock).mockResolvedValue({ ok: false });\n    \n    await expect(fetchUser('999')).rejects.toThrow('User not found');\n  });\n  \n  it('calls correct endpoint', async () => {\n    (fetch as jest.Mock).mockResolvedValue({\n      ok: true,\n      json: () => Promise.resolve({})\n    });\n    \n    await fetchUser('123');\n    \n    expect(fetch).toHaveBeenCalledWith('/api/users/123');\n  });\n});\n```\n\n## Testing Patterns\n\n### Testing Validation\n\n```typescript\n// Code under test\nfunction validateEmail(email: string): ValidationResult {\n  if (!email) {\n    return { valid: false, error: 'Email is required' };\n  }\n  if (!email.includes('@')) {\n    return { valid: false, error: 'Invalid email format' };\n  }\n  if (email.length > 254) {\n    return { valid: false, error: 'Email too long' };\n  }\n  return { valid: true };\n}\n\n// Tests\ndescribe('validateEmail', () => {\n  describe('valid emails', () => {\n    it.each([\n      'user@example.com',\n      'user.name@example.com',\n      'user+tag@example.com',\n      'a@b.co',\n    ])('accepts %s', (email) => {\n      expect(validateEmail(email).valid).toBe(true);\n    });\n  });\n  \n  describe('invalid emails', () => {\n    it('rejects empty string', () => {\n      const result = validateEmail('');\n      expect(result.valid).toBe(false);\n      expect(result.error).toBe('Email is required');\n    });\n    \n    it('rejects missing @', () => {\n      const result = validateEmail('userexample.com');\n      expect(result.valid).toBe(false);\n      expect(result.error).toBe('Invalid email format');\n    });\n    \n    it('rejects too long email', () => {\n      const longEmail = 'a'.repeat(250) + '@b.com';\n      const result = validateEmail(longEmail);\n      expect(result.valid).toBe(false);\n      expect(result.error).toBe('Email too long');\n    });\n  });\n});\n```\n\n### Testing State Machines\n\n```typescript\n// Code under test\nclass OrderStateMachine {\n  private state: OrderState = 'pending';\n  \n  getState(): OrderState {\n    return this.state;\n  }\n  \n  confirm(): void {\n    if (this.state !== 'pending') {\n      throw new Error('Can only confirm pending orders');\n    }\n    this.state = 'confirmed';\n  }\n  \n  ship(): void {\n    if (this.state !== 'confirmed') {\n      throw new Error('Can only ship confirmed orders');\n    }\n    this.state = 'shipped';\n  }\n  \n  cancel(): void {\n    if (this.state === 'shipped') {\n      throw new Error('Cannot cancel shipped orders');\n    }\n    this.state = 'cancelled';\n  }\n}\n\n// Tests\ndescribe('OrderStateMachine', () => {\n  let machine: OrderStateMachine;\n  \n  beforeEach(() => {\n    machine = new OrderStateMachine();\n  });\n  \n  describe('initial state', () => {\n    it('starts in pending state', () => {\n      expect(machine.getState()).toBe('pending');\n    });\n  });\n  \n  describe('confirm', () => {\n    it('transitions from pending to confirmed', () => {\n      machine.confirm();\n      expect(machine.getState()).toBe('confirmed');\n    });\n    \n    it('throws when already confirmed', () => {\n      machine.confirm();\n      expect(() => machine.confirm()).toThrow('Can only confirm pending orders');\n    });\n  });\n  \n  describe('ship', () => {\n    it('transitions from confirmed to shipped', () => {\n      machine.confirm();\n      machine.ship();\n      expect(machine.getState()).toBe('shipped');\n    });\n    \n    it('throws when pending', () => {\n      expect(() => machine.ship()).toThrow('Can only ship confirmed orders');\n    });\n  });\n  \n  describe('cancel', () => {\n    it('can cancel pending order', () => {\n      machine.cancel();\n      expect(machine.getState()).toBe('cancelled');\n    });\n    \n    it('can cancel confirmed order', () => {\n      machine.confirm();\n      machine.cancel();\n      expect(machine.getState()).toBe('cancelled');\n    });\n    \n    it('cannot cancel shipped order', () => {\n      machine.confirm();\n      machine.ship();\n      expect(() => machine.cancel()).toThrow('Cannot cancel shipped orders');\n    });\n  });\n});\n```\n\n### Testing Callbacks and Events\n\n```typescript\n// Code under test\nclass EventEmitter {\n  private listeners = new Map<string, Set<Function>>();\n  \n  on(event: string, callback: Function): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(callback);\n  }\n  \n  emit(event: string, data?: any): void {\n    const callbacks = this.listeners.get(event);\n    if (callbacks) {\n      callbacks.forEach(cb => cb(data));\n    }\n  }\n}\n\n// Tests\ndescribe('EventEmitter', () => {\n  let emitter: EventEmitter;\n  \n  beforeEach(() => {\n    emitter = new EventEmitter();\n  });\n  \n  it('calls listener when event emitted', () => {\n    const listener = jest.fn();\n    emitter.on('test', listener);\n    \n    emitter.emit('test');\n    \n    expect(listener).toHaveBeenCalled();\n  });\n  \n  it('passes data to listener', () => {\n    const listener = jest.fn();\n    emitter.on('test', listener);\n    \n    emitter.emit('test', { value: 42 });\n    \n    expect(listener).toHaveBeenCalledWith({ value: 42 });\n  });\n  \n  it('calls multiple listeners', () => {\n    const listener1 = jest.fn();\n    const listener2 = jest.fn();\n    emitter.on('test', listener1);\n    emitter.on('test', listener2);\n    \n    emitter.emit('test');\n    \n    expect(listener1).toHaveBeenCalled();\n    expect(listener2).toHaveBeenCalled();\n  });\n  \n  it('does not call listeners for other events', () => {\n    const listener = jest.fn();\n    emitter.on('other', listener);\n    \n    emitter.emit('test');\n    \n    expect(listener).not.toHaveBeenCalled();\n  });\n});\n```\n\n### Testing Time-Dependent Code\n\n```typescript\n// Code under test\nclass TokenExpiry {\n  constructor(private expiresAt: Date) {}\n  \n  isExpired(): boolean {\n    return new Date() > this.expiresAt;\n  }\n  \n  timeRemaining(): number {\n    const remaining = this.expiresAt.getTime() - Date.now();\n    return Math.max(0, remaining);\n  }\n}\n\n// Tests\ndescribe('TokenExpiry', () => {\n  beforeEach(() => {\n    jest.useFakeTimers();\n  });\n  \n  afterEach(() => {\n    jest.useRealTimers();\n  });\n  \n  describe('isExpired', () => {\n    it('returns false when token not expired', () => {\n      jest.setSystemTime(new Date('2024-01-01T12:00:00Z'));\n      const token = new TokenExpiry(new Date('2024-01-01T13:00:00Z'));\n      \n      expect(token.isExpired()).toBe(false);\n    });\n    \n    it('returns true when token expired', () => {\n      jest.setSystemTime(new Date('2024-01-01T14:00:00Z'));\n      const token = new TokenExpiry(new Date('2024-01-01T13:00:00Z'));\n      \n      expect(token.isExpired()).toBe(true);\n    });\n    \n    it('returns true exactly at expiry time', () => {\n      const expiryTime = new Date('2024-01-01T13:00:00Z');\n      jest.setSystemTime(expiryTime);\n      const token = new TokenExpiry(expiryTime);\n      \n      // Advance 1ms past expiry\n      jest.advanceTimersByTime(1);\n      \n      expect(token.isExpired()).toBe(true);\n    });\n  });\n  \n  describe('timeRemaining', () => {\n    it('returns remaining milliseconds', () => {\n      jest.setSystemTime(new Date('2024-01-01T12:00:00Z'));\n      const token = new TokenExpiry(new Date('2024-01-01T13:00:00Z'));\n      \n      expect(token.timeRemaining()).toBe(3600000); // 1 hour in ms\n    });\n    \n    it('returns 0 when expired', () => {\n      jest.setSystemTime(new Date('2024-01-01T14:00:00Z'));\n      const token = new TokenExpiry(new Date('2024-01-01T13:00:00Z'));\n      \n      expect(token.timeRemaining()).toBe(0);\n    });\n  });\n});\n```\n\n### Testing Random/Non-Deterministic Code\n\n```typescript\n// Code under test\nclass IdGenerator {\n  constructor(private randomFn: () => number = Math.random) {}\n  \n  generate(): string {\n    const timestamp = Date.now().toString(36);\n    const random = this.randomFn().toString(36).substring(2, 8);\n    return `${timestamp}-${random}`;\n  }\n}\n\n// Tests\ndescribe('IdGenerator', () => {\n  it('generates id with timestamp prefix', () => {\n    jest.useFakeTimers();\n    jest.setSystemTime(new Date('2024-01-01'));\n    \n    const generator = new IdGenerator(() => 0.123456);\n    const id = generator.generate();\n    \n    expect(id).toMatch(/^[a-z0-9]+-/);\n    jest.useRealTimers();\n  });\n  \n  it('generates unique ids', () => {\n    let counter = 0;\n    const mockRandom = () => ++counter / 1000000;\n    const generator = new IdGenerator(mockRandom);\n    \n    const ids = new Set([\n      generator.generate(),\n      generator.generate(),\n      generator.generate(),\n    ]);\n    \n    expect(ids.size).toBe(3);\n  });\n  \n  it('uses injected random function', () => {\n    const mockRandom = jest.fn().mockReturnValue(0.5);\n    const generator = new IdGenerator(mockRandom);\n    \n    generator.generate();\n    \n    expect(mockRandom).toHaveBeenCalled();\n  });\n});\n```\n\n## Parameterized Tests\n\n### Using it.each\n\n```typescript\ndescribe('isEven', () => {\n  it.each([\n    [0, true],\n    [1, false],\n    [2, true],\n    [3, false],\n    [-2, true],\n    [-1, false],\n  ])('isEven(%i) returns %s', (input, expected) => {\n    expect(isEven(input)).toBe(expected);\n  });\n});\n\n// With named parameters\ndescribe('calculateDiscount', () => {\n  it.each`\n    total    | customerType  | expected\n    ${100}   | ${'regular'}  | ${0}\n    ${100}   | ${'gold'}     | ${10}\n    ${100}   | ${'platinum'} | ${20}\n    ${500}   | ${'regular'}  | ${25}\n    ${500}   | ${'gold'}     | ${75}\n  `('calculates $expected discount for $customerType with $total total',\n    ({ total, customerType, expected }) => {\n      expect(calculateDiscount(total, customerType)).toBe(expected);\n    }\n  );\n});\n```\n\n## Test Doubles Comparison\n\n| Type | Purpose | Example |\n|------|---------|---------|\n| **Dummy** | Fill parameters, never used | `processOrder(order, dummyLogger)` |\n| **Stub** | Return canned data | `stub.getUser.mockReturnValue(testUser)` |\n| **Spy** | Record calls, use real impl | `jest.spyOn(service, 'save')` |\n| **Mock** | Verify interactions | `expect(mock.save).toHaveBeenCalledWith(...)` |\n| **Fake** | Working simplified impl | `new InMemoryRepository()` |\n\n## Anti-Patterns to Avoid\n\n### Testing Implementation Details\n\n```typescript\n// BAD: Tests internal state\nit('sets internal flag', () => {\n  service.process(data);\n  expect((service as any)._processed).toBe(true); // Accessing private\n});\n\n// GOOD: Tests observable behavior\nit('marks item as processed', () => {\n  service.process(data);\n  expect(service.isProcessed(data.id)).toBe(true);\n});\n```\n\n### Over-Mocking\n\n```typescript\n// BAD: Mocking the thing under test\nconst mockCalculator = { add: jest.fn().mockReturnValue(5) };\nexpect(mockCalculator.add(2, 3)).toBe(5); // Tests nothing!\n\n// GOOD: Mock dependencies, not the subject\nconst mockRepository = { save: jest.fn() };\nconst service = new OrderService(mockRepository);\nservice.createOrder(data);\nexpect(mockRepository.save).toHaveBeenCalled();\n```\n\n### Test Interdependence\n\n```typescript\n// BAD: Tests depend on each other\nlet user: User;\n\nit('creates user', () => {\n  user = createUser({ name: 'Test' });\n  expect(user.id).toBeDefined();\n});\n\nit('updates user', () => {\n  updateUser(user.id, { name: 'Updated' }); // Depends on previous test!\n});\n\n// GOOD: Independent tests\nit('creates user', () => {\n  const user = createUser({ name: 'Test' });\n  expect(user.id).toBeDefined();\n});\n\nit('updates user', () => {\n  const user = createUser({ name: 'Test' }); // Creates own test data\n  updateUser(user.id, { name: 'Updated' });\n  expect(getUser(user.id).name).toBe('Updated');\n});\n```\n"
    }
  ],
  "tags": [
    "quality",
    "testing",
    "core-workflow"
  ],
  "dependsOn": [
    "implement"
  ]
}