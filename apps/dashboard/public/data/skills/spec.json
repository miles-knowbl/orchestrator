{
  "id": "spec",
  "name": "spec",
  "version": "1.0.0",
  "description": "Compile requirements into production-ready technical specifications. Transforms requirements documents into comprehensive 18-section FeatureSpecs (~2000+ lines) with full code, SQL migrations, UI components, feedback timing, and senior engineer audit. Maintains Process Map as system-of-record. The primary driver of the implementation process.",
  "phase": "INIT",
  "category": "engineering",
  "content": "# Spec\n\nCompile requirements into production-ready technical specifications.\n\n## When to Use\n\n- **After requirements are gathered** — Requirements doc is approved, ready for technical spec\n- **Before implementation** — Need production-ready specification with full code\n- **Complex feature** — Multiple entities, services, UI components\n- **Team handoff** — Spec becomes the implementation contract\n- When you say: \"compile this spec\", \"write the technical spec\", \"create a FeatureSpec\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `18-section-template.md` | Defines all required sections and format |\n| `capability-format.md` | Structure for each capability definition |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `feedback-framework.md` | For UI-heavy features requiring timing/haptics |\n| `process-map-template.md` | When maintaining cross-spec tracking |\n| `memory-axioms.md` | For state management patterns |\n\n**Verification:** Ensure your FeatureSpec has all 18 sections before marking complete.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `FEATURESPEC.md` | Project root | Always (1500+ lines minimum) |\n| Process Map update | `domain-memory/{domain}/process-map.md` | If Process Map exists |\n\n## Core Concept\n\nSpec compilation answers: **\"How exactly do we build this?\"**\n\nA compiled FeatureSpec is:\n- **Complete** — 18 sections covering all aspects of implementation\n- **Production-ready** — Full code, not pseudocode or placeholders\n- **Audited** — Senior engineer review with issues resolved\n- **Traceable** — Numbered capabilities, entities, and specs\n\nA FeatureSpec is NOT:\n- Requirements (that's `requirements`)\n- High-level architecture (that's `architect`)\n- The actual implementation (that's `implement`)\n\n## The Compilation Loop\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                    SPEC COMPILATION LOOP                        │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│   ┌──────────────┐     ┌──────────────┐     ┌──────────────┐   │\n│   │Requirements  │     │  Compiler    │     │FeatureSpec   │   │\n│   │v1.0 (PM)     │────▶│  Process     │────▶│ v1.1         │   │\n│   │~200-500 lines│     │  (Claude)    │     │ ~2000+ lines │   │\n│   └──────────────┘     └──────────────┘     └──────────────┘   │\n│                               │                     │           │\n│                               │                     │           │\n│                               ▼                     ▼           │\n│                        ┌─────────────────────────────────┐     │\n│                        │         Process Map             │     │\n│                        │  • Entities registry            │     │\n│                        │  • Coverage tracking            │     │\n│                        │  • Compiled specs list          │     │\n│                        │  • Architecture diagram         │     │\n│                        └─────────────────────────────────┘     │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Compilation Workflow\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                  TEMPLATE-BASED COMPILATION                             │\n├─────────────────────────────────────────────────────────────────────────┤\n│                                                                         │\n│  INPUT                                                                  │\n│  ─────                                                                  │\n│  • Requirements document (from `requirements` skill)                    │\n│  • This compilation process                                             │\n│  • Exemplar specs (previous compilations)                               │\n│  • Process Map (current version)                                        │\n│                                                                         │\n│                          ▼                                              │\n│                                                                         │\n│  STEP 1: Structure Against Template                                     │\n│  ──────────────────────────────────                                     │\n│  • Create all 18 sections from template                                 │\n│  • Assign Spec ID (SPEC-###)                                            │\n│  • Number capabilities (CAP-001, CAP-002, ...)                          │\n│  • Fill header with compilation summary table                           │\n│  • Reference exemplar specs for format/style                            │\n│                                                                         │\n│                          ▼                                              │\n│                                                                         │\n│  STEP 2: Apply Feedback Framework                                       │\n│  ────────────────────────────────                                       │\n│  • Add Feedback Timing Requirements section                             │\n│  • Add feedback block to each capability                                │\n│  • Add haptic patterns, timing bands, animations                        │\n│  • Implement optimistic UI in all service layer code                    │\n│  • Apply Paintbrush Test to every interaction                           │\n│                                                                         │\n│                          ▼                                              │\n│                                                                         │\n│  STEP 3: Apply Production Framework                                     │\n│  ─────────────────────────────────                                      │\n│  • Senior Engineer Audit (document issues found)                        │\n│  • Integrate ALL fixes into spec (not comments)                         │\n│  • Add observability (metrics, logs, alerts)                            │\n│  • Add test scenarios (security, concurrency, failure, load)            │\n│  • Add feature flags and rollback plan                                  │\n│                                                                         │\n│                          ▼                                              │\n│                                                                         │\n│  STEP 4: Validate Template Compliance                                   │\n│  ────────────────────────────────────                                   │\n│  • Check all 18 sections present                                        │\n│  • Verify minimum 1,500 lines (target 2,000+)                           │\n│  • Verify numbered capabilities with feedback                           │\n│  • Verify full code (not placeholders)                                  │\n│  • Verify complete SQL migrations                                       │\n│  • Run compatibility check against Process Map                          │\n│                                                                         │\n│                          ▼                                              │\n│                                                                         │\n│  STEP 5: Update Process Map                                             │\n│  ──────────────────────────                                             │\n│  • Add to Compiled Specs Registry                                       │\n│  • Update coverage percentages                                          │\n│  • Add new entities to registry                                         │\n│  • Increment Process Map version                                        │\n│                                                                         │\n│  OUTPUT                                                                 │\n│  ──────                                                                 │\n│  • Compiled FeatureSpec v1.x                                            │\n│  • Updated Process Map                                                  │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n## The 18 Required Sections\n\nEvery compiled spec includes:\n\n| # | Section | Purpose | Minimum Content |\n|---|---------|---------|-----------------|\n| 1 | **Header** | Identity & summary | Spec ID, version, compilation summary table |\n| 2 | **Feature Overview** | Business context | User stories, scope, key principles |\n| 3 | **Architecture Overview** | System diagram | Layer descriptions, data flow |\n| 4 | **Feedback Timing Requirements** | UX timing | Timing bands, haptic patterns |\n| 5 | **Entities** | Database tables | NEW tables + EXTENSIONS with full SQL |\n| 6 | **Capabilities** | Numbered features | CAP-### with feedback specs |\n| 7 | **Service Layer** | Business logic | Full code with optimistic patterns |\n| 8 | **UI Components** | Frontend code | Full components with all states |\n| 9 | **Database Migrations** | Schema changes | Complete SQL with indexes, triggers |\n| 10 | **API Layer** | Endpoints/functions | Production-ready, not stubs |\n| 11 | **Authorization** | Permissions/policies | Granular, role-based |\n| 12 | **Observability** | Monitoring | Metrics, logs, alerts with runbooks |\n| 13 | **Feature Flags** | Rollout controls | Flags with scope and defaults |\n| 14 | **Test Scenarios** | Quality assurance | Security, concurrency, failure, load |\n| 15 | **Verification Checklist** | Implementation validation | Checklist for implementers |\n| 16 | **Implementation Priority** | Phased delivery | Priority order, dependencies |\n| 17 | **Files to Create/Modify** | Directory structure | Full file paths |\n| 18 | **Compilation Summary** | Audit results | Senior Engineer issues & resolutions |\n\n→ See `references/18-section-template.md` for detailed section guidance\n\n## Minimum Requirements\n\n```yaml\ntemplate_compliance:\n  lines: \n    minimum: 1500\n    target: 2000+\n    exemplar: 3000+\n    \n  sections:\n    required: 18\n    all_present: true\n    \n  capabilities:\n    numbered: true  # CAP-001, CAP-002, ...\n    feedback_block: true  # Each has timing/haptic/visual/optimistic specs\n    \n  code:\n    service_layer: \"Full implementation, not pseudocode\"\n    ui_components: \"Full components, not wireframes\"\n    migrations: \"Complete SQL, not schema descriptions\"\n    api_layer: \"Production-ready, not stubs\"\n    \n  quality:\n    spec_id: \"SPEC-### assigned\"\n    compilation_summary: \"Senior Engineer audit table with resolutions\"\n    test_scenarios: \"Minimum 3 per category\"\n```\n\n## Code Completeness Rules\n\n**Never write:**\n- `// TODO: implement`\n- `... rest of implementation`\n- Pseudocode or placeholders\n- Truncated functions\n\n**Always write:**\n- Full, working implementations\n- All edge cases handled\n- Error handling included\n- TypeScript/language types complete\n\n## Capability Format\n\nEach capability MUST have:\n\n```yaml\ncapability: capability_name\nid: CAP-###\ndescription: What it does\nactor: Who triggers it\ntrigger: What triggers it\n\ninput:\n  field1: type\n  field2: type\n\noutput:\n  result: type\n\nvalidation:\n  - Rule 1\n  - Rule 2\n\nside_effects:\n  - Effect 1\n  - Effect 2\n\nfeedback:\n  timing:\n    input_acknowledgment: 0ms\n    local_render: <50ms\n    server_confirm: background\n  haptic:\n    on_action: light_impact\n    on_error: error_pattern\n  visual:\n    pending: Description\n    success: Description\n    error: Description\n  optimistic:\n    strategy: Description\n    rollback: Description\n\nerror_handling:\n  ERROR_CODE_1: \"User message\"\n  ERROR_CODE_2: \"User message\"\n```\n\n→ See `references/capability-format.md` for detailed examples\n\n## Feedback Framework\n\n### The Paintbrush Principle\n\nA paintbrush feels instantaneous because feedback arrives **before you consciously expect it**. The brain takes ~100ms to form \"did that work?\" — anything under 50ms feels like cause-and-effect.\n\n**Goal:** Every interaction should pass the Paintbrush Test.\n\n### Timing Bands\n\n| Band | Target | Perception | Use For |\n|------|--------|------------|---------|\n| **0ms** | At input event | Extension of body | Haptic, press state, selection |\n| **<16ms** | Every frame | Fluid tracking | Cursor, drag, scroll |\n| **<50ms** | Perceived instant | Cause-and-effect | Optimistic UI, count update |\n| **<150ms** | Animated | Smooth transition | Dropdown, modal appear |\n| **<300ms** | Spring settle | Physics-based | Drop into place, reorder |\n| **Background** | Never blocks UI | Invisible | Network calls, sync |\n\n→ See `references/feedback-framework.md` for the Four Gaps and interaction patterns\n\n## Senior Engineer Audit\n\nEvery compiled spec includes an audit table:\n\n```markdown\n| Issue | Category | Resolution |\n|-------|----------|------------|\n| No rate limiting | Security | Added 100 req/min limit |\n| Race condition on update | Concurrency | Added optimistic locking |\n| Missing index | Performance | Added composite index |\n```\n\n### Audit Categories\n\n| Category | What to Check |\n|----------|---------------|\n| **Security** | Input validation, auth checks, rate limiting, injection prevention |\n| **Concurrency** | Optimistic locking, idempotency, race conditions, deadlocks |\n| **Reliability** | Retry logic, graceful degradation, timeouts, circuit breakers |\n| **Scalability** | Batch processing, indexes, N+1 queries, unbounded queries |\n| **Observability** | Metrics, structured logging, alerts, runbooks |\n| **Data Model** | Constraints, triggers, soft delete, state machines |\n\n→ See `references/senior-engineer-audit.md` for full checklist\n\n## Process Map\n\nThe Process Map is the **single source of truth** for:\n- All entities and their schemas\n- All services/hooks and their purposes\n- Coverage percentages per process\n- Compiled specs registry\n\n### After Every Compilation\n\n1. Add new entities to Entity Registry\n2. Update coverage percentages\n3. Add to Compiled Specs Registry\n4. Increment version number\n5. Add changelog entry\n\n→ See `references/process-map-template.md` for blank template\n\n## Stack Adaptation\n\nMap generic sections to your stack:\n\n| Generic Section | React/Supabase | Django/Postgres | Rails/Postgres |\n|-----------------|----------------|-----------------|----------------|\n| Service Layer | React Hooks | Services/Managers | Service Objects |\n| UI Components | TSX Components | Django Templates | ERB Views |\n| API Layer | Edge Functions | Views/Viewsets | Controllers |\n| Authorization | RLS Policies | Permissions | Pundit Policies |\n| Realtime | Supabase Realtime | Django Channels | ActionCable |\n\n## Output Format\n\n### Header Template\n\n```markdown\n# [Feature] FeatureSpec v1.1\n\n| Property | Value |\n|----------|-------|\n| **Spec ID** | SPEC-### |\n| **Version** | 1.1 (Compiled) |\n| **Status** | Ready for Implementation |\n| **Target Project** | [Project Name] |\n| **Compilation Date** | [Date] |\n| **Lines** | [Count] |\n| **Capabilities** | [Count] |\n```\n\n### Compilation Summary Template\n\n```markdown\n## Compilation Summary\n\n| Pass | Focus | Key Additions |\n|------|-------|---------------|\n| 1 | Compatibility Alignment | Entity verification, FK references |\n| 2 | Feedback Framework | Timing bands, haptic patterns, optimistic UI |\n| 3 | Senior Engineer Review | Security, concurrency, reliability fixes |\n| 4 | Process Map Update | Coverage %, entity registry |\n\n### Senior Engineer Audit Results\n\n| Category | Issues Found | Issues Resolved | Status |\n|----------|--------------|-----------------|--------|\n| Security | X | X | ✅ |\n| Concurrency | X | X | ✅ |\n| Reliability | X | X | ✅ |\n| **Total** | **Y** | **Y** | ✅ |\n```\n\n## Quality Checklist\n\nBefore presenting a compiled spec:\n\n```markdown\n- [ ] Spec ID assigned (SPEC-###)\n- [ ] All 18 sections present\n- [ ] 1,500+ lines minimum\n- [ ] All capabilities numbered (CAP-###)\n- [ ] All capabilities have feedback block\n- [ ] All code is complete (no TODOs)\n- [ ] Senior Engineer audit table filled\n- [ ] Test scenarios: 3+ per category\n- [ ] Process Map updated\n```\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `requirements` | Requirements feed into spec compilation |\n| `architect` | Spec includes architecture; architect provides high-level design |\n| `frontend-design` | (Frontend systems) UI/UX section becomes DESIGN.md |\n| `implement` | Spec is the implementation contract |\n| `code-verification` | Verification checks against spec patterns |\n| `code-validation` | Validation checks against spec requirements |\n| `code-review` | Review verifies spec was implemented correctly |\n\n## Key Principles\n\n**Complete, not partial.** Every section is filled. Every code block works. No placeholders.\n\n**Audited, not assumed.** Senior engineer review catches issues before implementation.\n\n**Traceable, not ad-hoc.** Spec IDs, capability numbers, entity references create audit trail.\n\n**Living document.** Specs version. Updates increment version. Old versions are preserved.\n\n**Process Map is truth.** Always check it first. Always update it after.\n\n## References\n\n- `references/18-section-template.md`: Detailed section-by-section guidance\n- `references/feedback-framework.md`: Timing bands, haptics, optimistic UI patterns\n- `references/capability-format.md`: How to write capability specifications\n- `references/senior-engineer-audit.md`: Full audit checklist by category\n- `references/process-map-template.md`: Blank Process Map template\n- `references/memory-axioms.md`: Principles for maintaining project memory",
  "references": [
    {
      "name": "18-section-template.md",
      "path": "references/18-section-template.md",
      "content": "# 18-Section Template\n\nDetailed guidance for each section of a compiled FeatureSpec.\n\n## Section 1: Header\n\n```markdown\n# [Feature Name] FeatureSpec v1.1\n\n| Property | Value |\n|----------|-------|\n| **Spec ID** | SPEC-### |\n| **Version** | 1.1 (Compiled) |\n| **Status** | Ready for Implementation |\n| **Target Project** | [Project Name] |\n| **Dependencies** | [List of dependent specs/systems] |\n| **Part Of** | [System Name] (X of Y) |\n| **Compilation Date** | [Date] |\n| **Compilation** | Pass 1 ✅ | Pass 2 ✅ | Pass 3 ✅ | Pass 4 ✅ |\n```\n\n**Required elements:**\n- Spec ID (SPEC-001, SPEC-002, etc.)\n- Version (v1.0 = original, v1.1+ = compiled)\n- Dependencies on other specs\n- Pass indicators showing compilation stages\n\n---\n\n## Section 2: Feature Overview\n\n```markdown\n## Feature Overview\n\n**What this feature does:** [Comprehensive description of functionality]\n\n**Core value proposition:** [Business value and user benefit]\n\n**Key user stories:**\n1. As a [user type], I can [action] so that [benefit]\n2. As a [user type], I can [action] so that [benefit]\n3. As the system, I [automated action] so that [outcome]\n```\n\n**Include:**\n- Clear problem statement\n- Business justification\n- 5-10 user stories covering main scenarios\n- System-initiated actions (automations)\n\n---\n\n## Section 3: Architecture Overview\n\n```markdown\n## Architecture Overview\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                    [FEATURE NAME] ARCHITECTURE v1.X                          │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                             │\n│  UI LAYER                                                                   │\n│  ────────                                                                   │\n│  [Component boxes with responsibilities]                                    │\n│                                                                             │\n│  SERVICE LAYER                                                              │\n│  ─────────────                                                              │\n│  [Hook/service boxes with data flow arrows]                                 │\n│                                                                             │\n│  DATA LAYER                                                                 │\n│  ──────────                                                                 │\n│  [Entity boxes with relationships]                                          │\n│                                                                             │\n│  EXECUTION LAYER (if applicable)                                            │\n│  ───────────────                                                            │\n│  [Cron jobs, background tasks, edge functions]                              │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n```\n\n**Include:**\n- ASCII diagram showing all layers\n- Data flow arrows\n- Component responsibilities\n- State machine diagrams (if applicable)\n\n---\n\n## Section 4: Feedback Timing Requirements\n\n```markdown\n## Feedback Timing Requirements\n\n### Timing Bands\n\n| Band | Target | Use For |\n|------|--------|---------|\n| 0ms | At input | Haptic, press state |\n| <50ms | Instant | Optimistic updates |\n| <150ms | Animated | Transitions |\n| <300ms | Spring | Physics-based settle |\n| Background | Never blocks | Network calls |\n\n### Interaction Patterns\n\n| Action | 0ms | <50ms | <150ms | <300ms |\n|--------|-----|-------|--------|--------|\n| [Action 1] | [Feedback] | [Feedback] | — | — |\n| [Action 2] | [Feedback] | [Feedback] | [Feedback] | — |\n```\n\n**Include:**\n- Timing bands for this feature\n- Haptic patterns\n- Animation specifications\n- Optimistic UI strategies\n\n---\n\n## Section 5: Entities\n\n```markdown\n## Entities\n\n### EXISTING Entities (Referenced)\n\n```yaml\nentity: [EntityName]  # EXISTS\ntable_name: [table_name]\nrelevant_attributes:\n  - id: uuid (PK)\n  - [other relevant fields]\n```\n\n### NEW Entities\n\n```yaml\nentity: [EntityName]  # NEW\ndescription: [Purpose of this entity]\ntable_name: [table_name]\nattributes:\n  # ─── Identity ───\n  - id: uuid (PK) DEFAULT gen_random_uuid()\n  - business_id: uuid (→ businesses) NOT NULL ON DELETE CASCADE\n  \n  # ─── Core Fields ───\n  - [field]: [type] [constraints]\n  \n  # ─── Soft Delete ───\n  - deleted_at: timestamptz?\n  - deleted_by: uuid? (→ profiles)\n  \n  # ─── Audit ───\n  - created_by: uuid? (→ profiles)\n  - created_at: timestamptz DEFAULT NOW()\n  - updated_at: timestamptz DEFAULT NOW()\n\nindexes:\n  - idx_[name]: ([columns]) WHERE [condition]\n\nconstraints:\n  - CHECK: [constraint]\n  - UNIQUE: [constraint]\n```\n```\n\n**Include:**\n- EXISTING entities with only relevant attributes\n- NEW entities with full schema\n- All indexes\n- All constraints\n- Foreign key relationships\n\n---\n\n## Section 6: Capabilities\n\n```markdown\n## Capabilities\n\n### CAP-001: [Capability Name]\n\n```yaml\ncapability: [capability_name]\nid: CAP-001\ndescription: [What it does]\nactor: [Who triggers it]\ntrigger: [What triggers it]\n\ninput:\n  [field]: [type]\n\noutput:\n  [field]: [type]\n\nvalidation:\n  - [Rule 1]\n  - [Rule 2]\n\nside_effects:\n  - [Effect 1]\n  - [Effect 2]\n\nfeedback:\n  timing:\n    input_acknowledgment: 0ms\n    local_render: <50ms\n    server_confirm: background\n  haptic:\n    on_action: light_impact\n    on_error: error_pattern\n  visual:\n    pending: [Description]\n    success: [Description]\n    error: [Description]\n  optimistic:\n    strategy: [How to show success before confirm]\n    rollback: [How to revert on failure]\n\nerror_handling:\n  [ERROR_CODE]: \"[User message]\"\n```\n```\n\n**Every capability must have:**\n- Unique ID (CAP-###)\n- Complete input/output specification\n- Validation rules\n- Side effects\n- Full feedback block\n- Error handling with user messages\n\n---\n\n## Section 7: Service Layer\n\n```markdown\n## Service Layer\n\n### use[FeatureName].ts\n\n```typescript\n// Full implementation - no placeholders\nexport function use[FeatureName]() {\n  // Query with proper error handling\n  const query = useQuery({\n    queryKey: ['feature', id],\n    queryFn: async () => {\n      // Complete implementation\n    },\n  });\n\n  // Mutation with optimistic UI\n  const mutation = useMutation({\n    mutationFn: async (input: InputType) => {\n      // Complete implementation\n    },\n    onMutate: async (input) => {\n      // Optimistic update\n      await queryClient.cancelQueries({ queryKey });\n      const previous = queryClient.getQueryData(queryKey);\n      queryClient.setQueryData(queryKey, (old) => /* update */);\n      return { previous };\n    },\n    onError: (err, _, context) => {\n      // Rollback\n      queryClient.setQueryData(queryKey, context?.previous);\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey });\n    },\n  });\n\n  return { query, mutation };\n}\n```\n```\n\n**Requirements:**\n- Full TypeScript types\n- Complete error handling\n- Optimistic UI pattern\n- No TODOs or placeholders\n\n---\n\n## Section 8: UI Components\n\n```markdown\n## UI Components\n\n### [ComponentName].tsx\n\n```tsx\ninterface [ComponentName]Props {\n  // Full prop types\n}\n\nexport function [ComponentName]({ props }: [ComponentName]Props) {\n  // State\n  const [state, setState] = useState();\n  \n  // Hooks\n  const { query, mutation } = use[Feature]();\n  \n  // Loading state\n  if (query.isLoading) {\n    return <Skeleton />;\n  }\n  \n  // Error state\n  if (query.isError) {\n    return <ErrorState error={query.error} />;\n  }\n  \n  // Empty state\n  if (!query.data?.length) {\n    return <EmptyState />;\n  }\n  \n  // Main render\n  return (\n    // Complete JSX\n  );\n}\n```\n```\n\n**Requirements:**\n- All state variations (loading, error, empty, populated)\n- Full TypeScript props\n- Responsive design\n- Accessibility attributes\n- Complete animations\n\n---\n\n## Section 9: Database Migrations\n\n```markdown\n## Database Migrations\n\n### Migration: [YYYYMMDD]_create_[feature]_tables.sql\n\n```sql\n-- Create tables\nCREATE TABLE [table_name] (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  -- All columns with types and constraints\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\n-- Indexes\nCREATE INDEX idx_[name] ON [table]([columns]) WHERE [condition];\n\n-- Triggers\nCREATE TRIGGER [trigger_name]\n  BEFORE UPDATE ON [table]\n  FOR EACH ROW\n  EXECUTE FUNCTION update_updated_at();\n\n-- RLS\nALTER TABLE [table] ENABLE ROW LEVEL SECURITY;\n```\n```\n\n**Requirements:**\n- Complete CREATE TABLE statements\n- All indexes\n- All triggers\n- RLS enablement\n\n---\n\n## Section 10: API Layer\n\n```markdown\n## API Layer\n\n### [function-name]/index.ts\n\n```typescript\nimport { serve } from 'https://deno.land/std/http/server.ts';\nimport { createClient } from '@supabase/supabase-js';\n\nserve(async (req) => {\n  // CORS handling\n  if (req.method === 'OPTIONS') {\n    return new Response(null, { headers: corsHeaders });\n  }\n\n  try {\n    // Authentication\n    const authHeader = req.headers.get('Authorization');\n    // ... validation\n\n    // Business logic\n    const result = await processRequest(body);\n\n    // Structured logging\n    console.log(JSON.stringify({\n      timestamp: new Date().toISOString(),\n      event: 'request_processed',\n      // ... context\n    }));\n\n    return new Response(JSON.stringify(result), {\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    });\n  } catch (error) {\n    // Error handling with logging\n    return new Response(JSON.stringify({ error: error.message }), {\n      status: 500,\n      headers: corsHeaders,\n    });\n  }\n});\n```\n```\n\n**Requirements:**\n- Full implementation\n- Authentication handling\n- Structured logging\n- Error handling\n- CORS handling\n\n---\n\n## Section 11: Authorization\n\n```markdown\n## Authorization\n\n### RLS Policies\n\n```sql\n-- SELECT: Business users (respecting soft delete)\nCREATE POLICY \"[table]_select\" ON [table] FOR SELECT\nUSING (\n  business_id IN (SELECT business_id FROM profiles WHERE id = auth.uid())\n  AND deleted_at IS NULL\n);\n\n-- INSERT: Role-restricted\nCREATE POLICY \"[table]_insert\" ON [table] FOR INSERT\nWITH CHECK (\n  business_id IN (SELECT business_id FROM profiles WHERE id = auth.uid())\n  AND EXISTS (\n    SELECT 1 FROM profiles \n    WHERE id = auth.uid() AND role IN ('admin', 'owner')\n  )\n);\n\n-- UPDATE: Author or elevated role\nCREATE POLICY \"[table]_update\" ON [table] FOR UPDATE\nUSING (\n  business_id IN (SELECT business_id FROM profiles WHERE id = auth.uid())\n  AND deleted_at IS NULL\n  AND (\n    created_by = auth.uid() \n    OR EXISTS (\n      SELECT 1 FROM profiles \n      WHERE id = auth.uid() AND role IN ('admin', 'owner')\n    )\n  )\n);\n\n-- DELETE: Admin/owner only\nCREATE POLICY \"[table]_delete\" ON [table] FOR DELETE\nUSING (\n  business_id IN (SELECT business_id FROM profiles WHERE id = auth.uid())\n  AND EXISTS (\n    SELECT 1 FROM profiles \n    WHERE id = auth.uid() AND role = 'owner'\n  )\n);\n```\n```\n\n**Requirements:**\n- Granular policies (not \"FOR ALL\")\n- Soft delete filtering\n- Role-based access\n- Business isolation\n\n---\n\n## Section 12: Observability\n\n```markdown\n## Observability\n\n### Metrics\n\n| Metric | Type | Description |\n|--------|------|-------------|\n| [feature]_created_total | Counter | Total items created |\n| [feature]_operation_duration_ms | Histogram | Operation latency |\n| [feature]_errors_total | Counter | Error count by type |\n\n### Log Events\n\n| Event | Level | Context |\n|-------|-------|---------|\n| [feature]_created | info | id, user_id, business_id |\n| [feature]_failed | error | error, context |\n\n### Alerts\n\n```yaml\nalerts:\n  - name: [Feature]HighErrorRate\n    condition: |\n      rate([feature]_errors_total[5m]) > 0.1\n    severity: warning\n    runbook: |\n      1. Check function logs\n      2. Review recent deployments\n      3. Check database connectivity\n```\n```\n\n---\n\n## Section 13: Feature Flags\n\n```markdown\n## Feature Flags\n\n| Flag | Description | Default | Scope |\n|------|-------------|---------|-------|\n| [FEATURE]_ENABLED | Master kill switch | true | global |\n| [FEATURE]_NEW_UI | New UI variant | false | business |\n| [FEATURE]_BETA | Beta features | false | user |\n```\n\n---\n\n## Section 14: Test Scenarios\n\n```markdown\n## Test Scenarios\n\n### Security Tests\n1. Unauthorized user cannot access [resource]\n2. Cross-tenant data isolation verified\n3. Input sanitization prevents injection\n\n### Concurrency Tests\n1. Simultaneous creates don't cause duplicates\n2. Optimistic locking prevents lost updates\n3. Distributed lock prevents race conditions\n\n### Failure Mode Tests\n1. Database timeout handled gracefully\n2. Partial failure rolls back correctly\n3. Network error shows user-friendly message\n\n### Load Tests\n1. System handles 1000 concurrent operations\n2. Response time < 200ms at p95 under load\n3. No memory leaks over extended operation\n```\n\n---\n\n## Section 15: Verification Checklist\n\n```markdown\n## Verification Checklist\n\n### Pre-Implementation\n- [ ] Schema review completed\n- [ ] RLS policies reviewed\n- [ ] API contracts agreed\n\n### Implementation\n- [ ] All entities created\n- [ ] All hooks implemented\n- [ ] All components built\n- [ ] All tests passing\n\n### Pre-Release\n- [ ] Security audit passed\n- [ ] Performance validated\n- [ ] Feature flags configured\n- [ ] Monitoring in place\n```\n\n---\n\n## Section 16: Implementation Priority\n\n```markdown\n## Implementation Priority\n\n### Phase 1: Foundation (Day 1-2)\n1. Database migrations\n2. Core entities\n3. Basic CRUD hooks\n\n### Phase 2: Features (Day 3-5)\n4. Full capability implementation\n5. UI components\n6. API endpoints\n\n### Phase 3: Polish (Day 6-7)\n7. Optimistic UI\n8. Error handling\n9. Observability\n10. Testing\n```\n\n---\n\n## Section 17: Files to Create/Modify\n\n```markdown\n## Files to Create/Modify\n\n### New Files\n```\nsrc/\n├── hooks/\n│   └── use[Feature].ts\n├── components/\n│   └── [Feature]/\n│       ├── [Component1].tsx\n│       └── [Component2].tsx\n└── types/\n    └── [feature].ts\n\nsupabase/\n├── migrations/\n│   └── [timestamp]_create_[feature].sql\n└── functions/\n    └── [function-name]/\n        └── index.ts\n```\n\n### Modified Files\n- `src/types/database.ts` - Add new table types\n- `src/lib/constants.ts` - Add feature flags\n```\n\n---\n\n## Section 18: Compilation Summary\n\n```markdown\n## Compilation Summary\n\n| Pass | Focus | Key Additions |\n|------|-------|---------------|\n| 1 | Structure | 18 sections, entity schemas, capability specs |\n| 2 | Feedback | Timing bands, haptics, optimistic UI |\n| 3 | Production | Security, concurrency, observability |\n| 4 | Process Map | Entity registry, coverage update |\n\n### Senior Engineer Audit Results\n\n| Category | Issues Found | Issues Resolved | Status |\n|----------|--------------|-----------------|--------|\n| Security | X | X | ✅ |\n| Concurrency | X | X | ✅ |\n| Reliability | X | X | ✅ |\n| Scalability | X | X | ✅ |\n| **Total** | **Y** | **Y** | ✅ |\n\n### Critical Fixes Applied\n\n| # | Category | Issue | Resolution |\n|---|----------|-------|------------|\n| 1 | [Category] | [Issue description] | [How it was fixed] |\n```\n"
    },
    {
      "name": "capability-format.md",
      "path": "references/capability-format.md",
      "content": "# Capability Format\n\nHow to write complete capability specifications.\n\n## Why Capabilities Matter\n\nCapabilities are the atomic units of functionality. Each capability is a complete specification of one thing the system can do. Well-specified capabilities make implementation straightforward and testing obvious.\n\n## Capability Structure\n\nEvery capability MUST include all of these sections:\n\n```yaml\ncapability: [snake_case_name]\nid: CAP-###\ndescription: [One sentence: what it does]\nactor: [Who/what triggers this]\ntrigger: [What event triggers this]\n\ninput:\n  [field]: [type]\n  [field]: [type]\n\noutput:\n  [field]: [type]\n\npreconditions:\n  - [Condition that must be true before]\n\nvalidation:\n  - [Rule that input must satisfy]\n\nside_effects:\n  - [State change or external effect]\n\nfeedback:\n  timing:\n    input_acknowledgment: [timing]\n    local_render: [timing]\n    server_confirm: [timing]\n  haptic:\n    on_action: [pattern]\n    on_success: [pattern]\n    on_error: [pattern]\n  visual:\n    pending: [description]\n    success: [description]\n    error: [description]\n  optimistic:\n    strategy: [how to show success before confirm]\n    rollback: [how to revert on failure]\n\nerror_handling:\n  [ERROR_CODE]: \"[User-facing message]\"\n```\n\n## Section Details\n\n### Identity\n\n```yaml\ncapability: create_subscription\nid: CAP-003\ndescription: Create a new subscription for a customer\nactor: Admin user\ntrigger: Submit subscription form\n```\n\n- **capability**: Snake case, verb-first (`create_`, `update_`, `delete_`, `list_`, `get_`)\n- **id**: Sequential within spec (CAP-001, CAP-002, ...)\n- **description**: One sentence, no jargon\n- **actor**: Who performs this (Admin, Customer, System, API)\n- **trigger**: What initiates it (click, submit, cron, webhook)\n\n### Input/Output\n\n```yaml\ninput:\n  customer_id: uuid (required)\n  plan_id: uuid (required)\n  start_date: date (optional, default: today)\n  assigned_to: uuid? (optional)\n  notes: string? (optional, max: 1000 chars)\n\noutput:\n  subscription: Subscription\n  subscription_number: string (format: SUB-YYYY-NNNN)\n  first_job_date: date\n```\n\n- Use types: `uuid`, `string`, `number`, `boolean`, `date`, `datetime`, `json`\n- Mark required vs optional explicitly\n- Include constraints (max length, format, range)\n- Output should match what the UI needs\n\n### Preconditions\n\n```yaml\npreconditions:\n  - User is authenticated\n  - User has 'admin' or 'owner' role\n  - Customer exists and is not deleted\n  - Plan exists and is active\n  - Customer does not have existing active subscription for this plan\n```\n\nThings that must be true BEFORE the capability can execute. These are checked at the start and result in immediate failure if not met.\n\n### Validation\n\n```yaml\nvalidation:\n  - customer_id must reference existing customer in same business\n  - plan_id must reference active service plan\n  - start_date cannot be in the past\n  - start_date cannot be more than 1 year in future\n  - assigned_to must be profile in same business with technician role\n```\n\nRules that the input must satisfy. Different from preconditions: validation is about the input data, preconditions are about system state.\n\n### Side Effects\n\n```yaml\nside_effects:\n  - Subscription record created in database\n  - Subscription number sequence incremented\n  - First job scheduled based on plan frequency\n  - subscription_created event recorded\n  - Notification sent to assigned technician (if assigned)\n  - Customer portal access enabled for this subscription\n```\n\nEverything that changes as a result of this capability. Be exhaustive — this is the contract.\n\n### Feedback Block\n\n```yaml\nfeedback:\n  timing:\n    input_acknowledgment: 0ms    # Button press state\n    local_render: <50ms          # Optimistic subscription appears in list\n    server_confirm: background   # Actual database write\n    \n  haptic:\n    on_action: light_impact      # When submit clicked\n    on_success: none             # Silent on success\n    on_error: error_pattern      # Vibrate on failure\n    \n  visual:\n    pending: |\n      Submit button shows spinner.\n      Form fields disabled.\n      New subscription row appears in list with pending indicator.\n    success: |\n      Modal closes.\n      Subscription row shows confirmed state.\n      Toast: \"Subscription created successfully\"\n    error: |\n      Submit button returns to normal.\n      Form fields re-enabled.\n      Error message appears below form.\n      Specific field errors highlighted.\n      \n  optimistic:\n    strategy: |\n      Immediately add subscription to list with temp ID.\n      Show pending state (opacity, spinner).\n      Disable edit/delete until confirmed.\n    rollback: |\n      Remove temp subscription from list.\n      Re-open form with previous values.\n      Show error message.\n```\n\nThis is the UX contract. Frontend developers should be able to implement the interaction purely from this spec.\n\n### Error Handling\n\n```yaml\nerror_handling:\n  CUSTOMER_NOT_FOUND: \"Customer not found. Please refresh and try again.\"\n  PLAN_NOT_FOUND: \"Service plan no longer available.\"\n  PLAN_INACTIVE: \"This service plan is no longer active.\"\n  DUPLICATE_SUBSCRIPTION: \"Customer already has an active subscription for this plan.\"\n  INVALID_START_DATE: \"Start date must be today or in the future.\"\n  ASSIGNMENT_INVALID: \"Selected technician is not available.\"\n  SUBSCRIPTION_LIMIT_REACHED: \"Maximum subscription limit reached for this customer.\"\n```\n\n- Use SCREAMING_SNAKE_CASE for error codes\n- Messages should be user-friendly, not technical\n- Include recovery guidance where possible\n\n## Complete Example\n\n```yaml\ncapability: skip_subscription_visit\nid: CAP-007\ndescription: Skip the next scheduled visit for a subscription\nactor: Customer (via portal) or Admin\ntrigger: Click \"Skip Next Visit\" button\n\ninput:\n  subscription_id: uuid (required)\n  schedule_id: uuid (required)\n  reason: string? (optional, max: 500 chars)\n\noutput:\n  schedule: SubscriptionSchedule (with status: 'skipped')\n  next_schedule: SubscriptionSchedule (the new next visit)\n  skip_count: number (total skips this year)\n\npreconditions:\n  - User is authenticated\n  - User is customer who owns subscription OR admin in same business\n  - Subscription is active (not paused, cancelled, or expired)\n  - Schedule exists and status is 'scheduled'\n  - Schedule date is at least 24 hours in future\n\nvalidation:\n  - subscription_id must reference subscription user has access to\n  - schedule_id must belong to specified subscription\n  - Cannot skip if already at max skips for period (default: 2 per quarter)\n  - Cannot skip if would result in 3+ consecutive skips\n\nside_effects:\n  - Schedule status updated to 'skipped'\n  - Schedule.skipped_at set to NOW()\n  - Schedule.skipped_by set to auth.uid()\n  - Schedule.skip_reason set if provided\n  - Schedule.version incremented\n  - subscription_visit_skipped event recorded\n  - Next visit recalculated if needed\n  - Notification sent to assigned technician\n  - Notification sent to business admin (if configured)\n\nfeedback:\n  timing:\n    input_acknowledgment: 0ms\n    local_render: <50ms\n    server_confirm: background\n    \n  haptic:\n    on_action: light_impact\n    on_success: success_pattern\n    on_error: error_pattern\n    \n  visual:\n    pending: |\n      Skip button shows spinner.\n      Schedule row shows pending state.\n    success: |\n      Schedule row updates to show \"Skipped\" badge.\n      Next visit date updates to show new date.\n      Toast: \"Visit skipped. Next visit: [date]\"\n      Skip count badge increments.\n    error: |\n      Skip button returns to normal.\n      Error toast with specific message.\n      Schedule row unchanged.\n      \n  optimistic:\n    strategy: |\n      Immediately update schedule to 'skipped' state.\n      Immediately calculate and show new next visit.\n      Mark both as pending.\n    rollback: |\n      Revert schedule to 'scheduled' state.\n      Revert next visit display.\n      Show error message.\n\nerror_handling:\n  SUBSCRIPTION_NOT_FOUND: \"Subscription not found.\"\n  SCHEDULE_NOT_FOUND: \"This visit is no longer available.\"\n  ALREADY_SKIPPED: \"This visit has already been skipped.\"\n  TOO_LATE_TO_SKIP: \"Cannot skip within 24 hours of scheduled visit. Please contact us.\"\n  MAX_SKIPS_REACHED: \"Maximum skips reached for this period. Please contact us to discuss options.\"\n  CONSECUTIVE_SKIP_LIMIT: \"Cannot skip 3 or more visits in a row. Please contact us.\"\n  SUBSCRIPTION_NOT_ACTIVE: \"Cannot skip visits for inactive subscriptions.\"\n  CONCURRENT_MODIFICATION: \"This schedule was modified. Please refresh and try again.\"\n```\n\n## Capability Naming Conventions\n\n| Pattern | Use For | Examples |\n|---------|---------|----------|\n| `create_[entity]` | Creating new records | `create_subscription`, `create_job` |\n| `update_[entity]` | Modifying existing records | `update_subscription`, `update_profile` |\n| `delete_[entity]` | Removing records (soft or hard) | `delete_subscription`, `delete_comment` |\n| `list_[entities]` | Fetching multiple records | `list_subscriptions`, `list_customers` |\n| `get_[entity]` | Fetching single record | `get_subscription`, `get_customer` |\n| `[verb]_[entity]` | Domain-specific actions | `skip_visit`, `pause_subscription`, `approve_quote` |\n| `[verb]_[entity]_[detail]` | Specific operations | `update_subscription_status`, `generate_subscription_jobs` |\n\n## Capability Checklist\n\nBefore finalizing a capability:\n\n```markdown\n- [ ] Unique ID assigned (CAP-###)\n- [ ] Name follows conventions (verb_noun)\n- [ ] Description is one clear sentence\n- [ ] Actor and trigger specified\n- [ ] All input fields documented with types\n- [ ] Required vs optional clearly marked\n- [ ] Output matches what UI needs\n- [ ] Preconditions are system state checks\n- [ ] Validation rules cover all input\n- [ ] Side effects are exhaustive\n- [ ] Feedback block has all four sections (timing, haptic, visual, optimistic)\n- [ ] Error codes are SCREAMING_SNAKE_CASE\n- [ ] Error messages are user-friendly\n```\n\n## Common Mistakes\n\n### Vague Side Effects\n\n❌ \"Updates the database\"\n✅ \"Subscription.status updated to 'paused'. Subscription.paused_at set to NOW(). subscription_paused event recorded.\"\n\n### Missing Optimistic Strategy\n\n❌ No optimistic block\n✅ Full strategy and rollback plan\n\n### Technical Error Messages\n\n❌ \"FOREIGN_KEY_CONSTRAINT_VIOLATION\"\n✅ \"The selected customer no longer exists. Please refresh and try again.\"\n\n### Incomplete Feedback\n\n❌ Just timing, no visual/haptic\n✅ All four feedback sections complete\n"
    },
    {
      "name": "feedback-framework.md",
      "path": "references/feedback-framework.md",
      "content": "# Feedback Framework\n\nTiming bands, haptics, and optimistic UI patterns for responsive interfaces.\n\n## The Paintbrush Principle\n\nA paintbrush feels instantaneous because feedback arrives **before you consciously expect it**. The brain takes ~100ms to form the question \"did that work?\" — anything under 50ms feels like cause-and-effect, anything at 0ms feels like an extension of your body.\n\n**Goal:** Every interaction should pass the Paintbrush Test.\n\n## Timing Bands Reference\n\n| Band | Target | Perception | Use For |\n|------|--------|------------|---------|\n| **0ms** | At input event | Extension of body | Haptic, press state, selection toggle |\n| **<16ms** | Every frame | Fluid tracking | Cursor position, drag follow, scroll |\n| **<50ms** | Perceived instant | Cause-and-effect | Optimistic add, chip appear, count update |\n| **<150ms** | Animated | Smooth transition | Dropdown open, filter apply, modal appear |\n| **<300ms** | Spring settle | Physics-based | Drop into place, card flip, reorder settle |\n| **Background** | Never blocks UI | Invisible | Network calls, heavy computation, sync |\n\n## The Four Gaps to Eliminate\n\nEvery interaction has potential gaps where users lose confidence:\n\n### Gap 1: Input Gap — \"Did the system hear me?\"\n\n| Technique | Timing | Implementation |\n|-----------|--------|----------------|\n| **Haptic on touch** | 0ms | `Haptics.impactAsync(ImpactFeedbackStyle.Light)` |\n| **Press state** | 0ms | `:active` style, scale 0.98, opacity change |\n| **Cursor attachment** | <16ms | Dragged item follows pointer exactly |\n| **Selection highlight** | 0ms | Border/background change on touch, not release |\n\n**Anti-patterns:**\n- Waiting for server before any visual feedback\n- Press state only on mouseup\n- Drag item that lags behind cursor\n\n### Gap 2: Thinking Gap — \"What will this do?\"\n\n| Technique | Timing | Implementation |\n|-----------|--------|----------------|\n| **Hover preview** | 0ms | Show outcome on hover before click |\n| **Drag placeholders** | <16ms | Ghost shows exactly where item will land |\n| **Live preview** | <16ms | See effect as slider moves, not on release |\n| **Affordance hints** | 0ms | Visual cues that invite interaction |\n\n**Anti-patterns:**\n- Click and pray\n- Drag with no drop target indicators\n- Settings that require \"Apply\" button\n\n### Gap 3: Wait Gap — \"Is it still working?\"\n\n| Technique | Timing | Implementation |\n|-----------|--------|----------------|\n| **Optimistic mutation** | 0ms | Show success immediately, rollback on error |\n| **Skeleton shimmer** | <50ms | Content shape appears before data loads |\n| **Staggered reveal** | 50ms intervals | First items show while rest load |\n| **Spring physics** | 150-300ms | Animation implies settling, not loading |\n\n**Anti-patterns:**\n- Spinners for anything under 500ms\n- Full-screen loading states\n- \"Please wait...\" messages\n\n### Gap 4: Completion Gap — \"Did it work?\"\n\n| Technique | Timing | Implementation |\n|-----------|--------|----------------|\n| **State change** | <50ms | Visual confirms new state |\n| **Checkmark/animation** | <150ms | Brief success indicator |\n| **Toast (sparingly)** | <300ms | Only for non-obvious completions |\n\n**Anti-patterns:**\n- Toast for every action\n- No visual confirmation of change\n- Success message that blocks interaction\n\n## Interaction Patterns Quick Reference\n\n| Action Type | 0ms | <50ms | <150ms | <300ms |\n|-------------|-----|-------|--------|--------|\n| **Tap/Select** | Haptic + highlight | — | — | — |\n| **Toggle** | Haptic + state flip | Count update | — | — |\n| **Add to list** | Haptic | Item appears | — | Settle |\n| **Delete** | Haptic | Item fades | List reflows | — |\n| **Drag start** | Haptic + lift | — | Scale + shadow | — |\n| **Drop** | Haptic (medium) | — | — | Spring settle |\n| **Submit** | Haptic + button state | Optimistic success | — | Redirect |\n| **Open modal** | — | — | Fade + scale | — |\n| **Close modal** | — | — | Fade out | — |\n| **Filter** | — | Results update | — | — |\n| **Search** | — | — | Results appear | — |\n| **Sort** | — | — | List reorders | Settle |\n\n## Capability Feedback Block Template\n\nEvery capability must include:\n\n```yaml\nfeedback:\n  timing:\n    input_acknowledgment: 0ms  # Haptic/visual on trigger\n    local_render: <50ms        # Optimistic UI update\n    server_confirm: background # Actual mutation\n    \n  haptic:\n    on_action: light_impact    # When user triggers\n    on_success: none           # Usually silent\n    on_error: error_pattern    # Only on failure\n    \n  visual:\n    pending: \"What user sees while waiting\"\n    success: \"What user sees on success\"\n    error: \"What user sees on failure\"\n    \n  optimistic:\n    strategy: \"How to show success before server confirms\"\n    rollback: \"How to revert if server fails\"\n```\n\n## Optimistic UI Pattern\n\n### React Query Implementation\n\n```typescript\nconst mutation = useMutation({\n  mutationFn: async (input) => {\n    return await api.createItem(input);\n  },\n  \n  onMutate: async (input) => {\n    // 1. Cancel in-flight queries\n    await queryClient.cancelQueries({ queryKey: ['items'] });\n    \n    // 2. Snapshot previous state\n    const previous = queryClient.getQueryData(['items']);\n    \n    // 3. Optimistically update\n    queryClient.setQueryData(['items'], (old) => [\n      ...old,\n      { ...input, id: 'temp-' + Date.now(), isPending: true }\n    ]);\n    \n    // 4. Return rollback context\n    return { previous };\n  },\n  \n  onError: (err, input, context) => {\n    // Rollback on error\n    queryClient.setQueryData(['items'], context?.previous);\n    \n    // Show error feedback\n    toast.error('Failed to create item');\n    Haptics.notificationAsync(NotificationFeedbackType.Error);\n  },\n  \n  onSuccess: (data, input) => {\n    // Replace temp item with real item\n    queryClient.setQueryData(['items'], (old) =>\n      old.map(item => \n        item.id.startsWith('temp-') ? data : item\n      )\n    );\n  },\n  \n  onSettled: () => {\n    // Refetch to ensure consistency\n    queryClient.invalidateQueries({ queryKey: ['items'] });\n  },\n});\n```\n\n### Key Principles\n\n1. **Immediate visual feedback** — Don't wait for server\n2. **Graceful rollback** — Revert cleanly on error\n3. **Temp IDs** — Mark optimistic items clearly\n4. **Eventual consistency** — Invalidate after settle\n\n## Haptic Patterns\n\n| Pattern | When to Use | iOS | Android |\n|---------|-------------|-----|---------|\n| **Light impact** | Selection, toggle | `ImpactFeedbackStyle.Light` | `HapticFeedbackConstants.VIRTUAL_KEY` |\n| **Medium impact** | Confirm action, drop | `ImpactFeedbackStyle.Medium` | `HapticFeedbackConstants.CONTEXT_CLICK` |\n| **Heavy impact** | Important action | `ImpactFeedbackStyle.Heavy` | `HapticFeedbackConstants.LONG_PRESS` |\n| **Success** | Completion | `NotificationFeedbackType.Success` | Custom pattern |\n| **Error** | Failure | `NotificationFeedbackType.Error` | Custom pattern |\n| **Selection** | Picker change | `SelectionFeedback` | `HapticFeedbackConstants.CLOCK_TICK` |\n\n## Animation Timing\n\n| Animation | Duration | Easing |\n|-----------|----------|--------|\n| Button press | 100ms | ease-out |\n| Fade in | 150ms | ease-out |\n| Fade out | 100ms | ease-in |\n| Slide in | 200ms | ease-out |\n| Slide out | 150ms | ease-in |\n| Scale up | 150ms | spring |\n| Reorder | 200ms | spring |\n| Drop settle | 300ms | spring (damping: 0.7) |\n\n## Anti-Pattern Checklist\n\n```markdown\n### Input Gap\n- [ ] No haptic on touch\n- [ ] Press state waits for server\n- [ ] Drag lags behind cursor\n\n### Thinking Gap\n- [ ] No preview of action\n- [ ] No drop target indicators\n- [ ] Unclear what will happen\n\n### Wait Gap\n- [ ] Spinner for short operations\n- [ ] Full-screen loading\n- [ ] No optimistic update\n\n### Completion Gap\n- [ ] No visual state change\n- [ ] Toast for every action\n- [ ] No way to know it worked\n```\n\n## Testing Feedback\n\n### Manual Testing\n\n1. **Slow network simulation** — Does optimistic UI work?\n2. **Error injection** — Does rollback work smoothly?\n3. **Rapid interaction** — Does it handle fast repeated actions?\n4. **Device testing** — Do haptics feel right?\n\n### Automated Testing\n\n```typescript\ntest('optimistic update shows immediately', async () => {\n  const { result } = renderHook(() => useCreateItem());\n  \n  act(() => {\n    result.current.mutate({ name: 'Test' });\n  });\n  \n  // Should appear immediately, not after server response\n  expect(queryClient.getQueryData(['items'])).toContainEqual(\n    expect.objectContaining({ name: 'Test', isPending: true })\n  );\n});\n\ntest('rollback on error', async () => {\n  server.use(\n    rest.post('/api/items', (req, res, ctx) => {\n      return res(ctx.status(500));\n    })\n  );\n  \n  const { result } = renderHook(() => useCreateItem());\n  const previous = queryClient.getQueryData(['items']);\n  \n  await act(async () => {\n    await result.current.mutateAsync({ name: 'Test' }).catch(() => {});\n  });\n  \n  // Should rollback to previous state\n  expect(queryClient.getQueryData(['items'])).toEqual(previous);\n});\n```\n"
    },
    {
      "name": "memory-axioms.md",
      "path": "references/memory-axioms.md",
      "content": "# Memory Axioms for Spec Compilation\n\nPrinciples for developing and maintaining project memory across sessions.\n\n---\n\n## The Three-Layer Memory Model\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                    PROJECT MEMORY LAYERS                        │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  LAYER 3: SESSION CONTEXT (Ephemeral)                          │\n│  ─────────────────────────────────────                          │\n│  • Current task state                                           │\n│  • Decisions made this session                                  │\n│  • User preferences observed                                    │\n│  • Compilation progress                                         │\n│  │                                                              │\n│  │ survives via                                                 │\n│  ▼                                                              │\n│  LAYER 2: COMPILED SPECS (Reference)                           │\n│  ────────────────────────────────────                          │\n│  • Exemplar implementations                                     │\n│  • Patterns for similar features                                │\n│  • Senior Engineer audit resolutions                            │\n│  • Stack-specific adaptations                                   │\n│  │                                                              │\n│  │ indexed by                                                   │\n│  ▼                                                              │\n│  LAYER 1: PROCESS MAP (Ground Truth)                           │\n│  ───────────────────────────────────                           │\n│  • All entities and their schemas                               │\n│  • All services/hooks/components                                │\n│  • Coverage percentages                                         │\n│  • Architecture diagrams                                        │\n│  • Changelog history                                            │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Core Axioms\n\n### Axiom 1: The Process Map Never Lies\n\nThe Process Map is the single source of truth for:\n- What entities exist\n- What their columns are\n- What hooks/services reference them\n- What coverage has been achieved\n\n**Implication:** Always read the Process Map before making claims about the system.\n\n### Axiom 2: Compiled Specs Are Immutable\n\nOnce a spec is compiled at version X.Y, it doesn't change. If updates are needed:\n- Create version X.(Y+1)\n- Document what changed\n- Update Process Map changelog\n\n**Implication:** You can safely reference \"Subscriptions v1.2\" knowing it won't drift.\n\n### Axiom 3: Patterns Emerge From Repetition\n\nAfter compiling 3+ specs, patterns become visible:\n- Common entity structures\n- Recurring capability shapes\n- Consistent feedback timings\n- Typical error handling\n\n**Implication:** Reference exemplar specs when compiling new ones.\n\n### Axiom 4: Coverage Is Measurable\n\nEvery process has a coverage percentage:\n- 0%: Not started\n- 25%: Schema exists\n- 50%: Basic CRUD\n- 75%: Full features\n- 95%: Production-ready with edge cases\n- 100%: Complete with observability\n\n**Implication:** Track progress numerically, not vaguely.\n\n### Axiom 5: Decisions Deserve Documentation\n\nWhen making non-obvious choices:\n- Log the decision in the Compilation Summary\n- Explain the reasoning\n- Note alternatives considered\n\n**Implication:** Future sessions can understand why choices were made.\n\n---\n\n## Memory Accumulation Strategies\n\n### Strategy 1: Entity Registry\n\nMaintain a running list of all entities:\n\n```markdown\n## Entity Registry\n\n| Entity | Table | Spec | Purpose |\n|--------|-------|------|---------|\n| Conversation | `conversations` | SPEC-008 | Message threads |\n| Message | `messages` | SPEC-008 | Individual messages |\n| Subscription | `subscriptions` | SPEC-004 | Recurring service plans |\n```\n\n### Strategy 2: Pattern Library\n\nDocument recurring patterns:\n\n```markdown\n## Pattern: Optimistic Mutation\n\nUsed in: SPEC-004, SPEC-006, SPEC-008\n\n```typescript\nconst mutation = useMutation({\n  mutationFn: async (input) => { /* ... */ },\n  onMutate: async (input) => {\n    // 1. Cancel in-flight queries\n    await queryClient.cancelQueries({ queryKey });\n    // 2. Snapshot previous\n    const previous = queryClient.getQueryData(queryKey);\n    // 3. Optimistically update\n    queryClient.setQueryData(queryKey, (old) => /* ... */);\n    // 4. Return rollback context\n    return { previous };\n  },\n  onError: (err, _, context) => {\n    // Rollback on error\n    queryClient.setQueryData(queryKey, context?.previous);\n  },\n});\n```\n```\n\n### Strategy 3: Decision Log\n\nTrack significant decisions:\n\n```markdown\n## Decision Log\n\n### 2026-01-11: XOR Constraints for Sender Identity\n\n**Context:** Messages can be sent by either a profile (team member) or a customer.\n\n**Decision:** Use XOR CHECK constraint: `(sender_profile_id IS NOT NULL) != (sender_customer_id IS NOT NULL)`\n\n**Rationale:** \n- Prevents invalid states at database level\n- Clearer than nullable foreign keys\n- Matches participant pattern\n\n**Alternatives Considered:**\n- Single polymorphic sender_id with sender_type: Rejected (loses FK integrity)\n- Separate message tables: Rejected (duplicates schema)\n```\n\n### Strategy 4: Coverage Snapshots\n\nTrack coverage over time:\n\n```markdown\n## Coverage History\n\n| Date | Version | U01 | U02 | U03 | ... | Total |\n|------|---------|-----|-----|-----|-----|-------|\n| Jan 9 | v4.0 | 75% | 80% | 85% | ... | 72% |\n| Jan 10 | v4.1 | 75% | 80% | 95% | ... | 76% |\n| Jan 11 | v4.3 | 75% | 80% | 95% | ... | 79% |\n```\n\n---\n\n## Anti-Patterns to Avoid\n\n### Anti-Pattern 1: Memory in Comments\n\n❌ Bad:\n```typescript\n// NOTE: We decided to use XOR constraints because...\n```\n\n✅ Good:\nDocument in Compilation Summary or Decision Log, not in code comments.\n\n### Anti-Pattern 2: Implicit Dependencies\n\n❌ Bad:\n```markdown\nThis feature requires the customer table.\n```\n\n✅ Good:\n```markdown\n**Dependencies:** \n- `customers` table (SPEC-001)\n- `useCustomers` hook (SPEC-001)\n```\n\n### Anti-Pattern 3: Vague Coverage\n\n❌ Bad:\n```markdown\nCoverage: Good progress on messaging.\n```\n\n✅ Good:\n```markdown\nCoverage: 60% → 80% (+20%)\n- Added: conversations, messages, participants tables\n- Missing: attachment processing, push notifications\n```\n\n### Anti-Pattern 4: Orphaned Entities\n\n❌ Bad: Entity exists in code but not in Process Map.\n\n✅ Good: Every entity in code is registered in Process Map with its source spec.\n\n---\n\n## Session Handoff Protocol\n\nWhen ending a session, ensure:\n\n1. **Process Map is current**\n   - All new entities added\n   - Coverage updated\n   - Changelog entry added\n\n2. **Compiled specs are saved**\n   - Version number correct\n   - All 18 sections complete\n\n3. **Context is captured**\n   - What was accomplished\n   - What's next\n   - Any open decisions\n\n### Handoff Template\n\n```markdown\n## Session Summary: [Date]\n\n### Completed\n- Compiled SPEC-008 (TeamMessaging v1.1, 4,215 lines)\n- Updated Process Map to v4.3\n- Added MESSAGING system to architecture\n\n### Process Map Changes\n- Support Systems: 10 → 11\n- New tables: 5\n- New hooks: 3\n\n### Next Priority\n- Alignment audit for TranscriptToRequest\n- Or: Start new feature spec\n\n### Open Decisions\n- None pending\n```\n\n---\n\n## Memory Recovery\n\nIf starting fresh without context:\n\n1. **Read Process Map first** - Gives you the full picture\n2. **Scan Compiled Specs Registry** - Shows what's been done\n3. **Check Changelog** - Shows recent activity\n4. **Review latest compiled spec** - Shows current style/patterns\n\nThis gets you to 90% context in ~2 minutes of reading.\n\n---\n\n## Version History\n\n| Version | Date | Changes |\n|---------|------|---------|\n| 1.0 | Jan 2026 | Initial axioms, extracted from ServiceGrid experience |\n"
    },
    {
      "name": "process-map-template.md",
      "path": "references/process-map-template.md",
      "content": "# [Project Name] Process Map v1.0\n\n**Version:** 1.0 (Initial)  \n**Date:** [Date]  \n**Core Processes:** [Count]  \n**Support Systems:** [Count]  \n**Audit Status:** ⏳ Not yet audited  \n**Last Spec Compiled:** None\n\n---\n\n## Process Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────────────────────┐\n│                                    VALUE CHAIN                                           │\n│                                                                                         │\n│  ╔═══════════════╗    ╔═══════════════╗    ╔═══════════════╗    ╔═══════════════╗     │\n│  ║   [PHASE 1]   ║───▶║   [PHASE 2]   ║───▶║   [PHASE 3]   ║───▶║   [PHASE 4]   ║     │\n│  ║  # Processes  ║    ║  # Processes  ║    ║  # Processes  ║    ║  # Processes  ║     │\n│  ╚═══════════════╝    ╚═══════════════╝    ╚═══════════════╝    ╚═══════════════╝     │\n│                                                                                         │\n├─────────────────────────────────────────────────────────────────────────────────────────┤\n│                                  SUPPORT SYSTEMS                                         │\n│                                                                                         │\n│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐           │\n│  │  [SYSTEM 1]   │  │  [SYSTEM 2]   │  │  [SYSTEM 3]   │  │  [SYSTEM 4]   │           │\n│  │               │  │               │  │               │  │               │           │\n│  │ • Feature 1   │  │ • Feature 1   │  │ • Feature 1   │  │ • Feature 1   │           │\n│  │ • Feature 2   │  │ • Feature 2   │  │ • Feature 2   │  │ • Feature 2   │           │\n│  │ • Feature 3   │  │ • Feature 3   │  │ • Feature 3   │  │ • Feature 3   │           │\n│  └───────────────┘  └───────────────┘  └───────────────┘  └───────────────┘           │\n│                                                                                         │\n└─────────────────────────────────────────────────────────────────────────────────────────┘\n```\n\n> **Instructions:** Replace [PHASE X] with your value chain phases (e.g., ACQUIRE → QUALIFY → DELIVER → COLLECT). Replace [SYSTEM X] with your support systems (e.g., AUTH, BILLING, NOTIFICATIONS).\n\n---\n\n## Phase 1: [PHASE NAME]\n\n> **Mission:** [What this phase accomplishes]\n\n### U01 - [Process Name]\n\n| Attribute | Value |\n|-----------|-------|\n| **Status** | ⏳ Not Started |\n| **Trigger** | [What starts this process] |\n| **Completion** | [What marks it complete] |\n| **Owner** | [Who/what is responsible] |\n| **Coverage** | 0% |\n\n**Entities:**\n- (None yet)\n\n**Services/Hooks:**\n- (None yet)\n\n**Components:**\n- (None yet)\n\n---\n\n## Entity Registry\n\n| Entity | Table | Spec | Purpose |\n|--------|-------|------|---------|\n| (None yet) | — | — | — |\n\n---\n\n## Compiled Specs Registry\n\n| Spec | Version | Compiled | Template | Lines | Status |\n|------|---------|----------|----------|-------|--------|\n| (None yet) | — | — | — | — | — |\n\n### Template Standard\n\n**Minimum Requirements:**\n- 1,500+ lines (target 2,000+)\n- 18 required sections\n- Numbered capabilities (CAP-###)\n- Full service layer code with optimistic UI\n- Full UI components with animations\n- Complete SQL migrations\n- Feedback specs (timing, haptics, animations)\n- Senior Engineer audit table with resolutions\n- Test scenarios (security, concurrency, failure, load)\n\n---\n\n## Coverage Summary\n\n| Process | Coverage | Notes |\n|---------|----------|-------|\n| U01 | 0% | Not started |\n| U02 | 0% | Not started |\n| ... | ... | ... |\n\n---\n\n## Compilation Queue\n\n### Priority 1: Core Features\n```\n1. [Feature Name]  → Foundation for everything\n2. [Feature Name]  → Depends on #1\n```\n\n### Priority 2: Enhancement\n```\n3. [Feature Name]  → Nice to have\n```\n\n### Deferred\n```\n[Feature Name]     → Post-launch\n```\n\n---\n\n## Changelog\n\n### v1.0 ([Date])\n- Initial Process Map created\n- [X] processes identified\n- [Y] support systems mapped\n\n---\n\n## Stack Configuration\n\n> **Instructions:** Document your tech stack here for reference.\n\n```yaml\nstack:\n  frontend:\n    framework: [React/Vue/Svelte/etc.]\n    styling: [Tailwind/CSS Modules/etc.]\n    state: [React Query/Redux/Zustand/etc.]\n    \n  backend:\n    framework: [Node/Django/Rails/Go/etc.]\n    orm: [Prisma/Django ORM/ActiveRecord/etc.]\n    \n  database:\n    primary: [Postgres/MySQL/MongoDB/etc.]\n    cache: [Redis/Memcached/none]\n    \n  auth:\n    provider: [Supabase/Auth0/Custom/etc.]\n    \n  hosting:\n    frontend: [Vercel/Netlify/etc.]\n    backend: [AWS/GCP/Railway/etc.]\n    database: [Supabase/RDS/PlanetScale/etc.]\n    \n  realtime:\n    provider: [Supabase Realtime/Pusher/Socket.io/etc.]\n```\n\n---\n\n## Section Mapping\n\n> **Instructions:** Map the generic template sections to your stack.\n\n| Generic Section | Your Stack Equivalent |\n|-----------------|----------------------|\n| Service Layer | [e.g., React Hooks / Django Services] |\n| UI Components | [e.g., TSX Components / Django Templates] |\n| API Layer | [e.g., Edge Functions / DRF Viewsets] |\n| Authorization | [e.g., RLS Policies / Django Permissions] |\n| Realtime | [e.g., Supabase Realtime / Django Channels] |\n"
    },
    {
      "name": "senior-engineer-audit.md",
      "path": "references/senior-engineer-audit.md",
      "content": "# Senior Engineer Audit\n\nComprehensive checklist for production-readiness review.\n\n## Why Audit Matters\n\nEvery compiled spec undergoes a Senior Engineer audit. This catches issues that are expensive to fix after implementation: security vulnerabilities, race conditions, scalability bottlenecks, and operational blind spots.\n\n**All issues must be resolved in the spec itself**, not noted as comments. The compiled spec should be production-ready.\n\n## Audit Process\n\n1. **Review each category** using the checklists below\n2. **Document issues found** with category and description\n3. **Resolve each issue** by updating the spec\n4. **Record resolution** in the Compilation Summary table\n\n## Audit Categories\n\n### 1. Security\n\n| Check | What to Look For |\n|-------|------------------|\n| **Input validation** | All user inputs validated before processing |\n| **Authentication** | All endpoints require appropriate auth |\n| **Authorization** | Granular RLS policies, not \"FOR ALL\" |\n| **Rate limiting** | Public endpoints have rate limits |\n| **SQL injection** | Parameterized queries, no string interpolation |\n| **XSS prevention** | Output encoding, Content Security Policy |\n| **Secrets handling** | No hardcoded secrets, proper env vars |\n| **Data exposure** | Only necessary fields returned to client |\n| **Audit logging** | Sensitive operations logged |\n\n**Common Issues:**\n\n| Issue | Resolution Pattern |\n|-------|-------------------|\n| RLS policy missing INSERT | Add explicit INSERT policy with business_id check |\n| No rate limiting on API | Add rate limit: 100 req/min per user |\n| Portal function lacks ownership check | Add business_id validation in RPC |\n| Events could contain PII | Define explicit schema with IDs only |\n\n### 2. Concurrency\n\n| Check | What to Look For |\n|-------|------------------|\n| **Race conditions** | Check-then-act patterns protected |\n| **Optimistic locking** | Version fields on frequently updated records |\n| **Distributed locking** | Cron jobs and batch operations use locks |\n| **Idempotency** | Mutations can be safely retried |\n| **Deadlock prevention** | Consistent lock ordering |\n| **Transaction boundaries** | Related operations in single transaction |\n\n**Common Issues:**\n\n| Issue | Resolution Pattern |\n|-------|-------------------|\n| Duplicate job race condition | Add unique constraint + SELECT FOR UPDATE SKIP LOCKED |\n| Counter drift on denormalized fields | Add reconciliation job + trigger-based updates |\n| Cron job overlap | Add cron_locks table with distributed locking |\n| Skip race condition | Add optimistic locking with version field |\n| Missing transaction | Wrap related operations in stored procedure |\n\n### 3. Reliability\n\n| Check | What to Look For |\n|-------|------------------|\n| **Retry logic** | Failed operations can be retried with backoff |\n| **Graceful degradation** | Feature fails gracefully, doesn't crash system |\n| **Timeout handling** | All external calls have timeouts |\n| **Circuit breakers** | Failing dependencies don't cascade |\n| **Error recovery** | Clear recovery path for partial failures |\n| **Idempotency keys** | One-time operations are idempotent |\n\n**Common Issues:**\n\n| Issue | Resolution Pattern |\n|-------|-------------------|\n| No retry logic | Add retry with exponential backoff (3 attempts, 1s/2s/4s) |\n| Missing timeout | Add 30s timeout to all external calls |\n| Partial failure unhandled | Add transaction with rollback on error |\n| No idempotency | Add idempotency_key column, check before processing |\n\n### 4. Scalability\n\n| Check | What to Look For |\n|-------|------------------|\n| **Unbounded queries** | All list queries have limits/pagination |\n| **Batch processing** | Large operations processed in batches |\n| **N+1 queries** | No loops that make N database calls |\n| **Missing indexes** | Frequently queried columns are indexed |\n| **Denormalization** | Counters/aggregates updated efficiently |\n| **Connection pooling** | Database connections properly pooled |\n\n**Common Issues:**\n\n| Issue | Resolution Pattern |\n|-------|-------------------|\n| Unbounded query | Add LIMIT with pagination (default 100, max 1000) |\n| N+1 query in batch | Replace loop with bulk operation or JOIN |\n| Missing index | Add composite index on (business_id, status, created_at) |\n| Counter requires COUNT(*) | Add denormalized counter with trigger updates |\n\n### 5. Observability\n\n| Check | What to Look For |\n|-------|------------------|\n| **Metrics defined** | Key operations have counters/histograms |\n| **Structured logging** | JSON logs with consistent schema |\n| **Log levels** | Appropriate use of info/warn/error |\n| **Alerts defined** | Thresholds and runbooks for alerts |\n| **Request tracing** | Request IDs propagate through calls |\n| **Error context** | Errors include enough context to debug |\n\n**Common Issues:**\n\n| Issue | Resolution Pattern |\n|-------|-------------------|\n| No structured logging | Add JSON logging with timestamp, event, context |\n| No metrics | Add counters for success/failure, histograms for duration |\n| No alerts | Add alert for error rate > 1% with runbook |\n| Missing request ID | Add request_id to all logs in same request |\n\n### 6. Data Model\n\n| Check | What to Look For |\n|-------|------------------|\n| **Constraints** | CHECK constraints for valid values |\n| **Foreign keys** | All references have FK constraints |\n| **Default values** | Sensible defaults for optional fields |\n| **NOT NULL** | Required fields are NOT NULL |\n| **Soft delete** | Deleted records preserved with deleted_at |\n| **Audit fields** | created_at, updated_at, created_by tracked |\n| **State machines** | Status transitions validated |\n\n**Common Issues:**\n\n| Issue | Resolution Pattern |\n|-------|-------------------|\n| No state machine validation | Add CHECK constraint or trigger for valid transitions |\n| updated_at not maintained | Add trigger: `BEFORE UPDATE ... SET updated_at = NOW()` |\n| Number collision | Add advisory locks for sequence generation |\n| Missing payment failure tracking | Add failure_count, failure_reason, last_failure_at |\n\n### 7. API Design\n\n| Check | What to Look For |\n|-------|------------------|\n| **Consistent naming** | Endpoint names follow conventions |\n| **Error responses** | Consistent error format with codes |\n| **Pagination** | List endpoints support pagination |\n| **Filtering** | List endpoints support filtering |\n| **Versioning** | API version strategy defined |\n| **Documentation** | OpenAPI/Swagger spec or equivalent |\n\n### 8. Authorization Patterns\n\n| Check | What to Look For |\n|-------|------------------|\n| **Business isolation** | All queries filter by business_id |\n| **Role-based access** | Different capabilities for different roles |\n| **Owner vs admin** | Authors can edit their own, admins can edit all |\n| **Soft delete filtering** | RLS includes `deleted_at IS NULL` |\n| **INSERT policies** | Explicit INSERT policies, not just SELECT |\n\n**RLS Policy Template:**\n\n```sql\n-- SELECT: Business users (respecting soft delete)\nCREATE POLICY \"{table}_select\" ON {table} FOR SELECT\nUSING (\n  business_id IN (SELECT business_id FROM profiles WHERE id = auth.uid())\n  AND deleted_at IS NULL\n);\n\n-- INSERT: Role-restricted\nCREATE POLICY \"{table}_insert\" ON {table} FOR INSERT\nWITH CHECK (\n  business_id IN (SELECT business_id FROM profiles WHERE id = auth.uid())\n  AND EXISTS (\n    SELECT 1 FROM profiles \n    WHERE id = auth.uid() AND role IN ('admin', 'owner')\n  )\n);\n\n-- UPDATE: Author or elevated role\nCREATE POLICY \"{table}_update\" ON {table} FOR UPDATE\nUSING (\n  business_id IN (SELECT business_id FROM profiles WHERE id = auth.uid())\n  AND deleted_at IS NULL\n  AND (\n    created_by = auth.uid() \n    OR EXISTS (\n      SELECT 1 FROM profiles \n      WHERE id = auth.uid() AND role IN ('admin', 'owner')\n    )\n  )\n);\n\n-- DELETE: Owner only (prefer soft delete)\nCREATE POLICY \"{table}_delete\" ON {table} FOR DELETE\nUSING (\n  business_id IN (SELECT business_id FROM profiles WHERE id = auth.uid())\n  AND EXISTS (\n    SELECT 1 FROM profiles \n    WHERE id = auth.uid() AND role = 'owner'\n  )\n);\n```\n\n## Audit Documentation\n\n### Issues Table Format\n\n```markdown\n| # | Category | Issue | Resolution |\n|---|----------|-------|------------|\n| 1 | Security | RLS INSERT gap | Added explicit INSERT policies |\n| 2 | Concurrency | Race condition on skip | Added optimistic locking |\n| 3 | Scalability | Missing index | Added composite index |\n```\n\n### Summary Table Format\n\n```markdown\n| Category | Issues Found | Issues Resolved | Status |\n|----------|--------------|-----------------|--------|\n| Security | 3 | 3 | ✅ |\n| Concurrency | 2 | 2 | ✅ |\n| Reliability | 1 | 1 | ✅ |\n| Scalability | 2 | 2 | ✅ |\n| Observability | 1 | 1 | ✅ |\n| Data Model | 3 | 3 | ✅ |\n| **Total** | **12** | **12** | ✅ |\n```\n\n## Test Scenarios\n\nEvery audit must verify test scenarios exist:\n\n### Security Tests (minimum 3)\n\n```yaml\nsecurity_tests:\n  - Unauthorized user cannot access endpoint\n  - Cross-tenant data isolation verified\n  - Input sanitization prevents injection\n  - Rate limiting blocks excessive requests\n```\n\n### Concurrency Tests (minimum 3)\n\n```yaml\nconcurrency_tests:\n  - Simultaneous creates don't cause duplicates\n  - Optimistic locking prevents lost updates\n  - Distributed lock prevents cron overlap\n  - Race condition in check-then-act handled\n```\n\n### Failure Mode Tests (minimum 3)\n\n```yaml\nfailure_tests:\n  - Database timeout handled gracefully\n  - Partial failure rolls back correctly\n  - Network error shows user-friendly message\n  - Invalid state transition rejected\n```\n\n### Load Tests (minimum 1)\n\n```yaml\nload_tests:\n  - System handles 1000 concurrent users\n  - Response time < 200ms at p95\n  - No memory leaks over 24h operation\n  - Batch processing completes in < 5min for 10K records\n```\n\n## Audit Checklist\n\n```markdown\n### Security\n- [ ] All inputs validated\n- [ ] Auth required on all endpoints\n- [ ] RLS policies granular (not FOR ALL)\n- [ ] Rate limiting on public endpoints\n- [ ] No SQL injection vectors\n- [ ] Secrets in env vars only\n\n### Concurrency\n- [ ] Race conditions protected\n- [ ] Optimistic locking on contested resources\n- [ ] Cron jobs use distributed locks\n- [ ] Idempotency keys where needed\n- [ ] Transactions for related operations\n\n### Reliability\n- [ ] Retry with backoff for failures\n- [ ] Timeouts on all external calls\n- [ ] Graceful degradation paths\n- [ ] Clear error recovery\n\n### Scalability\n- [ ] All queries bounded (LIMIT)\n- [ ] Batch processing for large operations\n- [ ] No N+1 query patterns\n- [ ] Indexes on query columns\n\n### Observability\n- [ ] Metrics for key operations\n- [ ] Structured logging throughout\n- [ ] Alerts with runbooks\n- [ ] Request tracing\n\n### Data Model\n- [ ] CHECK constraints for valid values\n- [ ] FK constraints on references\n- [ ] Audit fields (created_at, updated_at)\n- [ ] State machine validation\n\n### Test Coverage\n- [ ] 3+ security tests\n- [ ] 3+ concurrency tests\n- [ ] 3+ failure mode tests\n- [ ] 1+ load test\n```\n"
    }
  ],
  "tags": [
    "planning",
    "specification",
    "requirements"
  ],
  "dependsOn": [
    "architect"
  ]
}