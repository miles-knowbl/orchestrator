{
  "id": "stack-analyzer",
  "name": "stack-analyzer",
  "version": "1.0.0",
  "description": "Evaluate a target tech stack and map architectural concepts to stack-specific idioms, patterns, and libraries. Produces STACK-MAP.md with concept mapping, gap analysis, and risk assessment. Bridges the gap between source architecture and target implementation.",
  "phase": "MAP",
  "category": "engineering",
  "content": "# Stack Analyzer\n\nEvaluate a target tech stack and map architecture concepts to stack-specific idioms.\n\n## When to Use\n\n- **Architecture transposition** --- Source architecture extracted, target stack chosen, need to map concepts\n- **Stack evaluation** --- Determining if a stack can express a given architecture\n- **Technology comparison** --- Mapping the same architecture to multiple stacks to compare fit\n- **Gap analysis** --- Identifying where a stack lacks direct equivalents for architectural concepts\n- When you say: \"map this to Next.js\", \"how would this architecture look in Go?\", \"can this stack handle this architecture?\"\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `STACK-MAP.md` | Project root | Always |\n\n## Core Concept\n\nStack analysis answers: **\"How does each architectural concept translate to this specific tech stack?\"**\n\n```\nARCHITECTURE.md          Target Stack\n(what we're building)    (what we're building with)\n        │                        │\n        └───────────┬────────────┘\n                    │\n                    ▼\n            ┌──────────────┐\n            │ Stack        │\n            │ Analyzer     │\n            │              │\n            │ concept →    │\n            │   idiom      │\n            └──────┬───────┘\n                   │\n                   ▼\n            STACK-MAP.md\n            (how each concept maps)\n```\n\nStack analysis is NOT:\n- Architecture design (that's `architect`)\n- Technology selection from scratch (that's also `architect`)\n- Implementation (that's `spec` and `implement`)\n\n## The Analysis Process\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                 STACK ANALYSIS PROCESS                   │\n│                                                         │\n│  1. INVENTORY THE STACK                                 │\n│     └─→ What technologies? Versions? Roles?             │\n│                                                         │\n│  2. MAP CONCEPTS                                        │\n│     └─→ Architecture concept → stack equivalent         │\n│                                                         │\n│  3. TRANSLATE IDIOMS                                    │\n│     └─→ Source patterns → target patterns               │\n│                                                         │\n│  4. IDENTIFY GAPS                                       │\n│     └─→ What has no direct equivalent?                  │\n│                                                         │\n│  5. SELECT LIBRARIES                                    │\n│     └─→ Fill gaps with ecosystem libraries              │\n│                                                         │\n│  6. ASSESS RISKS                                        │\n│     └─→ Where is the transposition weakest?             │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Step 1: Inventory the Stack\n\nDocument every technology in the target stack:\n\n```markdown\n### Stack Inventory\n\n| Technology | Version | Role | Category |\n|-----------|---------|------|----------|\n| [e.g., Next.js] | 14 | Application framework | Framework |\n| [e.g., PostgreSQL] | 16 | Primary database | Storage |\n| [e.g., Prisma] | 5.x | ORM / query builder | Data access |\n| [e.g., Tailwind CSS] | 3.x | Styling | Presentation |\n| [e.g., tRPC] | 11 | Type-safe API layer | Communication |\n| [e.g., Redis] | 7 | Cache / pub-sub | Infrastructure |\n```\n\n**Categories:** Framework, Storage, Data Access, Communication, Presentation, Infrastructure, Auth, Monitoring, Testing\n\n## Step 2: Map Concepts\n\nFor each architectural concept from ARCHITECTURE.md, identify the stack equivalent:\n\n```markdown\n### Concept Mapping\n\n| Source Concept | Source Implementation | Target Stack Equivalent | Confidence |\n|---------------|---------------------|------------------------|------------|\n| Service layer | Express route handlers | Next.js Server Actions | High |\n| Data model | Sequelize models | Prisma schema | High |\n| Authentication | Passport.js + JWT | NextAuth.js | High |\n| Real-time updates | Socket.io | Server-Sent Events via Route Handlers | Medium |\n| Background jobs | Bull queue + Redis | Inngest or QStash | Medium |\n| File storage | Local disk + S3 | Vercel Blob or S3 | High |\n| Full-text search | Elasticsearch | PostgreSQL tsvector or Meilisearch | Low |\n```\n\n### Mapping Confidence\n\n| Level | Meaning | Action Required |\n|-------|---------|-----------------|\n| **High** | Direct equivalent exists, well-documented | Straightforward implementation |\n| **Medium** | Equivalent exists but requires adaptation | Document the adaptation in detail |\n| **Low** | No direct equivalent, workaround needed | Flag in gap analysis, propose solution |\n\n## Step 3: Translate Idioms\n\nSource and target stacks express the same concepts differently. Document the translation:\n\n```markdown\n### Idiom Translation\n\n| Pattern | Source Expression | Target Expression | Notes |\n|---------|------------------|-------------------|-------|\n| Data fetching | REST API + useEffect | Server Components + RSC | Shift from client to server |\n| State management | Redux store | React Context + Server State | Less client state needed |\n| Form handling | Formik + Yup | React Hook Form + Zod | Similar pattern, different libs |\n| Error boundaries | Express error middleware | Next.js error.tsx files | Route-level in target |\n| Database transactions | Sequelize.transaction() | Prisma.$transaction() | Nearly identical API |\n| Authorization | Middleware chain | Middleware.ts + Server Action checks | Two enforcement points |\n```\n\n### Common Idiom Shifts\n\n| Shift | From | To | Impact |\n|-------|------|-----|--------|\n| **Server-first** | SPA with API calls | Server Components / Server Actions | Major restructure |\n| **Edge computing** | Single-region server | Edge functions + CDN | Data access patterns change |\n| **Type-first** | Runtime validation | Compile-time type safety | Add type definitions everywhere |\n| **Convention-based** | Explicit configuration | File-system routing, naming conventions | Directory structure matters |\n| **Serverless** | Long-running process | Request-scoped functions | No persistent state |\n\n## Step 4: Identify Gaps\n\nFlag architectural concepts that have no direct stack equivalent:\n\n```markdown\n### Gap Analysis\n\n| Source Concept | Gap Type | Severity | Proposed Solution |\n|---------------|----------|----------|-------------------|\n| [concept] | Missing | High/Medium/Low | [workaround or library] |\n| [concept] | Partial | | [what's missing and how to fill it] |\n| [concept] | Different | | [concept exists but works differently] |\n```\n\n**Gap types:**\n\n| Type | Meaning | Example |\n|------|---------|---------|\n| **Missing** | No equivalent in stack | WebSocket server in serverless stack |\n| **Partial** | Equivalent covers some but not all | ORM missing specific query patterns |\n| **Different** | Equivalent exists but works fundamentally differently | Event-driven to request-response |\n| **Scale** | Works at current scale but not at source scale | In-memory cache vs distributed cache |\n\n## Step 5: Select Libraries\n\nFor each gap, recommend a library or approach:\n\n```markdown\n### Library Recommendations\n\n| Gap | Library / Approach | Maturity | Maintenance | Integration |\n|-----|-------------------|----------|-------------|-------------|\n| [gap] | [library name] | Stable/Growing/New | Active/Maintained/Stale | Native/Adapter/Custom |\n```\n\n**Selection criteria:**\n\n| Criterion | Weight | What to Check |\n|-----------|--------|---------------|\n| **Ecosystem fit** | High | Does it work well with the target stack? |\n| **Maintenance** | High | Active maintainers? Recent releases? |\n| **Type support** | Medium | TypeScript types? Quality of types? |\n| **Bundle size** | Medium | Acceptable for the deployment target? |\n| **Community** | Medium | Documentation? Stack Overflow? GitHub issues? |\n| **Alternatives** | Low | What if this library dies? |\n\n## Step 6: Assess Risks\n\nRate each mapping by transposition risk:\n\n```markdown\n### Risk Assessment\n\n| Mapping | Risk | Impact | Likelihood | Mitigation |\n|---------|------|--------|------------|------------|\n| [concept → equivalent] | High/Medium/Low | [what goes wrong] | [why it might] | [how to reduce risk] |\n```\n\n**Risk factors:**\n\n| Factor | Increases Risk |\n|--------|---------------|\n| Low confidence mapping | Concept translation is uncertain |\n| Gap with no mature library | Custom implementation needed |\n| Fundamental idiom shift | Architecture restructuring required |\n| Performance-critical path | Stack may not match source performance |\n| Security-critical path | Auth/authz model differs significantly |\n\n## STACK-MAP.md Template\n\n```markdown\n# Stack Map: [Source System] → [Target Stack]\n\n## Target Stack Inventory\n[Table from Step 1]\n\n## Concept Mapping\n[Table from Step 2]\n\n## Idiom Translation\n[Table from Step 3]\n\n## Gap Analysis\n[Table from Step 4]\n\n## Library Recommendations\n[Table from Step 5]\n\n## Risk Assessment\n[Table from Step 6]\n\n## Transposition Summary\n\n| Metric | Value |\n|--------|-------|\n| Concepts mapped | [N] |\n| High confidence | [N] (X%) |\n| Medium confidence | [N] (X%) |\n| Low confidence | [N] (X%) |\n| Gaps identified | [N] |\n| High-risk mappings | [N] |\n| Libraries needed | [N] |\n\n## Recommendation\n[Overall assessment: is this transposition feasible? What are the biggest risks?\n What should the spec pay special attention to?]\n```\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `architecture-extractor` | Extractor produces ARCHITECTURE.md that stack-analyzer consumes |\n| `architect` | Architect makes ADR decisions informed by stack-map gaps and risks |\n| `spec` | Spec uses stack-map to write stack-specific implementation code |\n| `implement` | Implementation follows the concept mapping and idiom translations |\n\n## Key Principles\n\n**Map, don't force.** If a concept doesn't translate cleanly, document the gap rather than forcing a bad mapping. Gaps inform better decisions downstream.\n\n**Idioms over libraries.** Prefer stack-native idioms over bolting on libraries. A Next.js app should feel like Next.js, not like Express wearing a Next.js costume.\n\n**Confidence is information.** Low-confidence mappings aren't failures — they're signals that the spec needs extra attention in those areas.\n\n**The stack has opinions.** Respect them. Fighting a framework's conventions creates maintenance burden. When the source architecture conflicts with target stack idioms, adapt the architecture.\n\n**Risk compounds.** Multiple medium-risk mappings in the same data flow become high-risk. Assess risk at the flow level, not just per-concept.",
  "references": [],
  "tags": [
    "stack",
    "analysis",
    "mapping",
    "technology",
    "transposition"
  ],
  "dependsOn": [
    "architecture-extractor"
  ]
}