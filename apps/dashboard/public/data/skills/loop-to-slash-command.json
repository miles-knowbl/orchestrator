{
  "id": "loop-to-slash-command",
  "name": "loop-to-slash-command",
  "version": "1.0.0",
  "description": "Generate Claude Code slash command .md files from loop definitions. Transforms loop.json into executable CLI commands with state management, gate procedures, and skill integration instructions.",
  "phase": "SHIP",
  "category": "meta",
  "content": "# Loop to Slash Command\n\nGenerate Claude Code slash command `.md` files from loop definitions.\n\n## When to Use\n\n- **A new loop has been composed** --- The loop-composer has produced a `loop.json` and now needs a user-facing CLI entry point\n- **An existing loop's phases or gates changed** --- The loop definition evolved and the slash command must be regenerated to match\n- **Porting a loop to a new environment** --- The loop exists but lacks a Claude Code slash command for invocation\n- **Standardizing command format across loops** --- Multiple loops exist with inconsistent command files and you need uniform structure\n- **Auditing command-to-loop alignment** --- Verifying that an existing slash command accurately reflects its loop.json source of truth\n- When you say: \"generate the slash command\", \"create the loop command\", \"make this loop executable\", \"update the command file\", \"turn this loop into a CLI command\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `command-template.md` | The canonical slash command template with all standard sections and formatting rules |\n| `naming-conventions.md` | Naming rules for commands, flags, state files, and deliverables --- deviations break discoverability |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `state-schema.md` | When generating state file schemas for loops with complex gate or phase structures |\n| `gate-prompts.md` | When customizing gate approval prompts beyond the default templates |\n| `existing-commands.md` | When checking precedent --- how existing commands handle edge cases like resume, skip, brownfield modes |\n\n**Verification:** The generated `.md` file must pass structural validation: all standard sections present, state schema matches loop.json phases and gates, every phase has skill invocation instructions, and every gate has an approval prompt template.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `{loop-id}.md` | `~/.claude/commands/` | Always --- the primary slash command file |\n| `{name}-state.json` schema | Documented within the command `.md` | Always --- the state file structure for the generated loop |\n| Generation report | Stdout / conversation | Always --- summary of phases mapped, gates configured, skills integrated |\n\n## Core Concept\n\nLoop to Slash Command answers: **\"How do we transform a loop.json definition into an executable Claude Code slash command?\"**\n\nLoop to Slash Command is:\n- **A code generator for CLI entry points** --- Takes structured loop data and produces a human-readable, machine-parseable markdown command file\n- **Template-driven** --- Every generated command follows the same section structure, ensuring consistency across all loops\n- **Bidirectionally faithful** --- The generated command is a precise reflection of the loop.json; no phases invented, no gates omitted\n- **State-management-aware** --- Generates state file schemas, cold-start detection, and resume flow for every command\n- **Gate-integration-complete** --- Every gate gets an approval prompt template, deliverable checklist, and skip-with-reason logic\n\nLoop to Slash Command is NOT:\n- Loop composition (that is `loop-composer` --- designing which phases, skills, and gates a loop should have)\n- Skill authoring (that is `skill-design` --- creating the SKILL.md files that phases reference)\n- Deployment automation (that is `deploy` --- shipping artifacts to production)\n- Command execution (the generated command itself runs; this skill generates, not executes)\n- Hook configuration (hooks are configured separately in `~/.claude/hooks.json`)\n- State file runtime management (that is `loop-controller` --- managing state during execution)\n\n## The Loop to Slash Command Process\n\n```\n+-----------------------------------------------------------------------+\n|                  LOOP TO SLASH COMMAND PROCESS                          |\n|                                                                        |\n|  1. LOOP ANALYSIS                                                      |\n|     +---> Read loop.json, extract phases/skills/gates/defaults/UI      |\n|                                                                        |\n|  2. COMMAND NAMING                                                     |\n|     +---> Derive command name, state file name, flag set               |\n|                                                                        |\n|  3. SECTION GENERATION                                                 |\n|     +---> Generate all standard sections from extracted data           |\n|                                                                        |\n|  4. SKILL INTEGRATION                                                  |\n|     +---> Per-phase skill load/execute/verify instructions             |\n|                                                                        |\n|  5. GATE INTEGRATION                                                   |\n|     +---> Approval prompts, deliverable checklists, skip logic         |\n|                                                                        |\n|  6. STATE MANAGEMENT                                                   |\n|     +---> State file schema, cold start, resume, phase tracking        |\n|                                                                        |\n|  7. OUTPUT AND PLACEMENT                                               |\n|     +---> Write to ~/.claude/commands/, validate, report               |\n|                                                                        |\n+-----------------------------------------------------------------------+\n```\n\n## Step 1: Loop Analysis\n\nRead the source `loop.json` and extract all structural elements. This step produces a normalized data model that all subsequent steps consume.\n\n### Required Extractions\n\n| Element | Source Path | Used In |\n|---------|------------|---------|\n| Loop ID | `$.id` | Command naming, state file naming |\n| Loop name | `$.name` | Title section, branding text |\n| Loop description | `$.description` | Purpose section, tagline |\n| Phases array | `$.phases[*]` | Execution flow, per-phase sections |\n| Phase skills | `$.phases[*].skills` | Skill integration (Step 4) |\n| Phase required flag | `$.phases[*].required` | Skip logic |\n| Gates array | `$.gates[*]` | Gate integration (Step 5) |\n| Gate afterPhase | `$.gates[*].afterPhase` | Execution flow ordering |\n| Gate approvalType | `$.gates[*].approvalType` | Prompt type selection |\n| Gate deliverables | `$.gates[*].deliverables` | Deliverable checklists |\n| Defaults | `$.defaults` | Mode and autonomy defaults |\n| UI branding | `$.ui.branding` | Title and subtitle in prompts |\n\n### Phase-Gate Mapping\n\nBuild the relationship table that drives execution flow:\n\n```markdown\n| Phase | Skills | Gate After | Gate Name | Gate Required |\n|-------|--------|------------|-----------|---------------|\n| INIT  | [spec] | spec-gate  | Specification Approval | true |\n| SCAFFOLD | [architect, scaffold] | architecture-gate | Architecture Approval | true |\n| IMPLEMENT | [implement] | (none) | --- | --- |\n```\n\nPhases with no gate after them flow directly to the next phase.\n\n### Analysis Checklist\n\n```markdown\n- [ ] loop.json read and parsed successfully\n- [ ] All phases extracted with skills and required flags\n- [ ] All gates extracted with afterPhase, approvalType, deliverables\n- [ ] Phase-gate mapping validated (every gate.afterPhase references a valid phase)\n- [ ] Defaults and UI branding extracted\n```\n\n## Step 2: Command Naming\n\nDerive all names from the loop ID using consistent conventions. Naming is mechanical, not creative --- deviations break discoverability. See `references/naming-conventions.md` for full rules.\n\n### Naming Rules\n\n| Element | Convention | Example |\n|---------|-----------|---------|\n| **Command name** | Loop ID directly (e.g., `engineering-loop`) | `proposal-loop` |\n| **Command file** | `{loop-id}.md` | `proposal-loop.md` |\n| **State file** | `{domain}-state.json` | `proposal-state.json` |\n| **H1 title** | `/{loop-id} Command` | `/proposal-loop Command` |\n\n### Flag Derivation\n\n| Flag | Source | Always Present |\n|------|--------|---------------|\n| `--resume` | Any loop with state file | Yes |\n| `--phase=PHASE` | `$.phases[*].name` enum | Yes |\n| `--mode=MODE` | `$.defaults.mode` | Only if loop has mode detection |\n| `--skip-gate=GATE` | `$.gates[*].id` enum | Only if any gate has `required: false` |\n\n## Step 3: Section Generation\n\nGenerate the complete `.md` file with all standard sections. See `references/command-template.md` for the canonical template.\n\n### Standard Section Map\n\n| # | Section | Content Source | Required |\n|---|---------|---------------|----------|\n| 1 | H1 Title + tagline | Loop name, description | Yes |\n| 2 | Purpose | Loop description, phase/gate counts | Yes |\n| 3 | Usage | Command name, derived flags | Yes |\n| 4 | Execution Flow | Phases, gates, state management | Yes |\n| 5 | Gate Enforcement | Gate prompts, deliverable checks | Yes |\n| 6 | Commands During Execution | Standard command table | Yes |\n| 7 | State Files | State schema, deliverable files | Yes |\n| 8 | Example Session | Realistic walkthrough | Yes |\n| 9 | Resuming a Session | Resume flow example | Yes |\n| 10 | Skill Invocation Sequence | Skill-to-reference mapping | Yes |\n| 11 | Hook Integration | Applicable hooks | If hooks exist |\n| 12 | References | MCP skill fetch instructions | Yes |\n\n### Tagline Derivation\n\nTake `$.description`, extract the core action, rephrase in imperative voice under 20 words:\n\n| Loop Description | Generated Tagline |\n|-----------------|-------------------|\n| \"Complete engineering loop for building production-quality software...\" | \"Full engineering loop with phases, gates, and systems.\" |\n| \"Create compelling proposals by ingesting context...\" | \"Orchestrate the full proposal creation loop with enforced gates.\" |\n\n### Section Templates\n\n**Purpose:**\n```markdown\n## Purpose\nThis command is the **single entry point** for the {loop name}. It handles everything:\n{key capabilities derived from phases}.\n\n**The flow you want:** {one-sentence user journey}.\n```\n\n**Usage:**\n```markdown\n## Usage\n/{command-name} [--resume] [--phase=PHASE] {additional flags}\n```\n\n**Commands table (always include these standard commands):**\n\n| Command | Action |\n|---------|--------|\n| `go` | Continue execution / proceed to next phase |\n| `status` | Show current phase, gate status, progress |\n| `approved` | Pass current gate |\n| `changes: [feedback]` | Request changes at gate |\n| `pause` | Stop after current phase |\n| `show [deliverable]` | Display a deliverable |\n\n## Step 4: Skill Integration\n\nFor each phase, generate instructions for loading and executing skills. Without these, Claude Code cannot execute the phase.\n\n### Per-Phase Skill Block\n\n```markdown\n### Phase: {PHASE_NAME}\n**Skills:** {skill list}  |  **Required:** {true/false}\n\n1. Load skill: `mcp__skills-library__get_skill(name: \"{skill}\", includeReferences: true)`\n2. Read required references from SKILL.md Reference Requirements table\n3. Execute skill following SKILL.md process steps\n4. Verify deliverables:\n   - [ ] {deliverable 1} exists and has content\n   - [ ] {deliverable 2} exists and has content\n5. Update state: phases.{PHASE}.status = \"complete\"\n```\n\n### Skill Invocation Sequence\n\nGenerate the full skill tree for the Skill Invocation Sequence section:\n\n```\n1. {skill-name}\n   +-- Read: {reference-1}.md\n   +-- Read: {reference-2}.md\n   +-- Output: {DELIVERABLE-1}.md, {DELIVERABLE-2}.md\n\n2. {skill-name}\n   +-- Read: {reference-1}.md\n   +-- Output: {DELIVERABLE}.md\n```\n\n### Multi-Skill Phase Handling\n\n| Scenario | Handling |\n|----------|---------|\n| Phase has 1 skill | Direct execution |\n| Phase has 2+ skills | Sequential execution in array order |\n| Skills share deliverables | Later skill can read earlier skill's output |\n| Skill fails | Phase marked as failed, gate not reached |\n\n## Step 5: Gate Integration\n\nFor each gate, generate approval prompt templates, deliverable checklists, and skip logic. See `references/gate-prompts.md` for full templates.\n\n### Gate Prompt Template\n\n```\n====================================================================\n|  {GATE NAME}                                                      |\n|                                                                   |\n|  {Deliverable} is ready for review.                               |\n|                                                                   |\n|  Deliverables:                                                    |\n|    {check} {deliverable-1} ({status})                             |\n|    {check} {deliverable-2} ({status})                             |\n|                                                                   |\n|  Commands:                                                        |\n|    approved     --- Pass gate, continue to {next phase}           |\n|    changes: ... --- Request modifications                         |\n|    show {item}  --- Display deliverable                           |\n====================================================================\n```\n\n### Gate Type Handling\n\n| Approval Type | Behavior | Prompt Style |\n|--------------|----------|-------------|\n| `human` | Blocks until user says `approved` | Full prompt with commands |\n| `conditional` | Blocks only if condition met | Conditional prompt with auto-pass |\n| `auto` | Passes automatically after deliverable check | Notification only |\n\n### Skip Logic\n\n```\nskip-gate {gate-id} --reason \"{justification}\"\n\nRules:\n- Required gates: emit warning before allowing skip\n- Reason is logged in state file (gates.{id}.skippedReason)\n- Skipped gates marked as \"skipped\" not \"passed\"\n- --reason flag is mandatory (>10 characters)\n```\n\n## Step 6: State Management\n\nGenerate the state file schema that tracks loop execution. See `references/state-schema.md` for full field definitions.\n\n### State File Schema\n\n```json\n{\n  \"loop\": \"{loop-id}\",\n  \"version\": \"{loop-version}\",\n  \"mode\": \"{default-mode}\",\n  \"phase\": \"{current-phase}\",\n  \"status\": \"active\",\n  \"gates\": {\n    \"{gate-id}\": {\n      \"status\": \"pending\",\n      \"required\": true,\n      \"approvalType\": \"human\",\n      \"deliverables\": [\"{FILE}.md\"],\n      \"passedAt\": null,\n      \"skippedReason\": null\n    }\n  },\n  \"phases\": {\n    \"{PHASE_NAME}\": {\n      \"status\": \"pending\",\n      \"required\": true,\n      \"skills\": [\"{skill-names}\"],\n      \"deliverables\": [],\n      \"startedAt\": null,\n      \"completedAt\": null\n    }\n  },\n  \"metrics\": {},\n  \"started_at\": \"ISO-timestamp\",\n  \"last_updated\": \"ISO-timestamp\"\n}\n```\n\n### Cold Start Detection\n\n```\nif {state-file} exists:\n  -> Read state, show current phase and progress\n  -> Show gate status summary\n  -> Ask: \"Resume from {current-phase}? [Y/n]\"\nelse:\n  -> Fresh start, initialize state with all phases pending\n  -> Set first phase to \"active\"\n  -> Proceed to first phase\n```\n\n### Generation Rules\n\n| Rule | Implementation |\n|------|---------------|\n| One phase entry per `$.phases[*]` | Iterate phases array, create entry for each |\n| One gate entry per `$.gates[*]` | Iterate gates array, create entry for each |\n| Phase skills from `$.phases[*].skills` | Copy skill array into phase entry |\n| Gate deliverables from `$.gates[*].deliverables` | Copy into gate entry |\n| Timestamps | ISO 8601; started_at on creation, last_updated on mutation |\n\n## Step 7: Output and Placement\n\nWrite the generated command file, validate structure, and report results.\n\n### Output Location\n\n| Destination | Path | When |\n|-------------|------|------|\n| **Primary** | `~/.claude/commands/{command-name}.md` | Always |\n| **Project override** | `{project}/.claude/commands/{command-name}.md` | When project-specific version needed |\n\n### Structural Validation\n\n```markdown\n**Section presence:**\n- [ ] H1 title with /{name} Command format\n- [ ] Purpose, Usage, Execution Flow sections present\n- [ ] Gate Enforcement with prompt templates\n- [ ] Commands table, State Files table\n- [ ] Example Session and Resume Session\n- [ ] Skill Invocation Sequence and References\n\n**Data integrity:**\n- [ ] Phase count matches loop.json\n- [ ] Gate count matches loop.json\n- [ ] All skill names exist in skills library\n- [ ] State schema phases/gates match loop.json exactly\n- [ ] Flag enum values match loop.json phase names\n\n**Formatting:**\n- [ ] Code blocks use triple backticks\n- [ ] Tables have header rows\n- [ ] ASCII diagrams render in monospace\n- [ ] No placeholder text (TODO, TBD)\n- [ ] Line count 300-500 (target: 400)\n```\n\n### Generation Report\n\n```markdown\n**Source:** {loop.json path}\n**Output:** ~/.claude/commands/{command-name}.md\n\nMapped: {phase-count} phases, {gate-count} gates, {skill-count} skills\nState file: {state-file-name}\nValidation: {PASS / FAIL}\n```\n\n## Output Formats\n\n### Quick Format\n\nFor simple loops (4 or fewer phases, no complex modes). ~150-200 lines. Includes: title, purpose, usage, execution flow with phase diagram, gate table, commands table, state files, and references.\n\n```markdown\n# /{command-name} Command\n{Tagline}\n\n## Purpose | ## Usage | ## Execution Flow | ## Commands | ## State Files | ## References\n```\n\n### Full Format\n\nFor complex loops (5+ phases, multiple modes, conditional gates). ~350-500 lines. Adds: mode-specific behavior, codebase analysis steps, detailed example session, resume example, hook integration, and loop update protocol.\n\n```markdown\n# /{command-name} Command\n{Tagline}\n\n## Purpose | ## Usage | ## Execution Flow (with mode detection, scope discovery)\n## Mode-Specific Behavior | ## Commands | ## State Files\n## Example Session | ## Resuming a Session | ## Skill Invocation Sequence\n## Hook Integration | ## References | ## Loop Update Protocol\n```\n\n## Common Patterns\n\n### Simple Linear Loop\n\nSequential phases, no mode detection, all-human gates. The proposal-loop command is the canonical example.\n\n**Use when:** Loop has 3-6 phases, all gates are human-approval, single mode. Generate using Quick Format.\n\n### Multi-Mode Engineering Loop\n\nMode detection, conditional phases, mixed gate types, extensive skill trees. The engineering-loop command is the canonical example.\n\n**Use when:** Loop has 7+ phases, mode detection, conditional gates/phases. Generate using Full Format.\n\n### Regeneration After Loop Change\n\nLoop.json modified and existing command must be updated. Diff old/new loop.json, regenerate changed sections, preserve manual customizations.\n\n**Use when:** Existing command file needs updating. Read existing command first, identify manual additions, regenerate standard sections, re-insert customizations.\n\n### First-Time Loop Bootstrap\n\nBrand-new loop needs everything: command file, state schema, documentation. Full 7-step process with no prior command to reference.\n\n**Use when:** `loop-composer` just produced a new loop.json and no corresponding command exists. Generate Full Format with detailed example session.\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `loop-composer` | Upstream: produces the loop.json that this skill consumes; must run first |\n| `skill-design` | Parallel: designs SKILL.md files that generated commands reference |\n| `loop-controller` | Downstream: manages runtime state that generated commands initialize |\n| `deploy` | Adjacent in SHIP phase: deploy ships artifacts, this skill generates commands |\n| `scaffold` | Analogous: scaffold creates project structure, this creates command structure |\n| `document` | Shared standards: generated commands are documentation artifacts |\n| `code-review` | Validates: reviews command files for completeness against loop.json |\n| `spec` | Upstream context: feature specs inform loop design which informs commands |\n\n## Key Principles\n\n**The loop.json is the single source of truth.** Every element in the generated command must trace back to loop.json. If it is not in the definition, it does not appear. If it is in the definition, it must appear. No exceptions.\n\n**Naming is mechanical, not creative.** Command names, state files, and flag enums are derived algorithmically. Consistent naming enables discoverability across all loops.\n\n**Every gate gets a prompt.** No gate passes silently. Human gates get full approval prompts. Conditional gates explain their condition. Auto gates notify. Visibility is non-negotiable.\n\n**State schemas are generated, not handcrafted.** The state file structure is a direct projection of the loop.json. Handcrafted schemas drift. Generated schemas stay synchronized.\n\n**Commands are documentation.** A slash command `.md` file is simultaneously an instruction set for Claude Code and documentation for the user. It must be readable by both.\n\n**Regeneration must be safe.** When updating after loop changes, detect and preserve manual customizations. Blindly overwriting destroys user work.\n\n## References\n\n- `references/command-template.md`: The canonical slash command template with all standard sections, formatting rules, and section-by-section authoring guidance\n- `references/naming-conventions.md`: Naming rules for commands, flags, state files, and deliverables with derivation algorithms and conflict resolution\n- `references/state-schema.md`: State file structure for loop execution: phase tracking, gate statuses, deliverable paths, timestamps, and resume logic\n- `references/gate-prompts.md`: Templates for gate approval prompts, deliverable checklists, skip-with-reason logic, and gate type handling\n- `references/existing-commands.md`: Analysis of engineering-loop.md and proposal-loop.md as reference implementations with extracted patterns",
  "references": [
    {
      "name": "command-template.md",
      "path": "references/command-template.md",
      "content": "# Command Template\n\nThe canonical template for Claude Code slash command `.md` files. Every generated command must follow this structure. Sections must appear in the order listed below.\n\n## Template Structure\n\nThe following sections are required for every slash command file. Optional sections are marked.\n\n```\n# /{command-name} Command                    <- Section 1: Title\n{tagline}                                    <- One-line summary\n\n## Purpose                                   <- Section 2: Purpose\n## Usage                                     <- Section 3: Usage\n## Execution Flow                            <- Section 4: Flow\n  ### Step 1: Cold Start Detection\n  ### Step 2: Mode Detection (optional)\n  ### Step 3: Initialize Loop State\n  ### Step 4: Execute Phases\n  ### Step 5: Gate Enforcement\n  ### Step 6: Loop Completion\n## Commands During Execution                 <- Section 5: Commands\n## State Files                               <- Section 6: State\n## Example Session                           <- Section 7: Example\n## Resuming a Session                        <- Section 8: Resume\n## Skill Invocation Sequence                 <- Section 9: Skills\n## Hook Integration (optional)               <- Section 10: Hooks\n## References                                <- Section 11: References\n## Loop Update Protocol (optional)             <- Section 12: Updates\n```\n\n## Section 1: Title and Tagline\n\n```markdown\n# /{command-name} Command\n\n{Tagline: imperative voice, under 20 words, summarizes the loop's purpose.}\n```\n\nRules:\n- H1 heading must start with `/` prefix\n- Command name uses kebab-case\n- Tagline must not start with \"This command...\"\n- Tagline should convey value, not mechanics\n\n## Section 2: Purpose\n\n```markdown\n## Purpose\n\nThis command is the **single entry point** for the {loop name}. It handles\neverything: {2-3 key capabilities}.\n\n**The flow you want:** {one-sentence user journey from invocation to result}.\n\nWorks for:\n- **{Use case 1}** --- {description}\n- **{Use case 2}** --- {description}\n```\n\nRules:\n- Always include \"single entry point\" phrasing for consistency\n- Bold the user flow sentence start\n- List 2-4 use cases with bold labels and em-dash descriptions\n\n## Section 3: Usage\n\n```markdown\n## Usage\n\n\\```\n/{command-name} [--resume] [--phase=PHASE] [--additional-flags]\n\\```\n\n**Options:**\n- `--resume`: Resume from existing {state-file-name}\n- `--phase=PHASE`: Start from specific phase ({PHASE_1} | {PHASE_2} | ...)\n- `--{flag}`: {description}\n```\n\nRules:\n- Usage block must be in a code fence (no language hint)\n- Every flag must have a description\n- Phase enum must list all valid phase names from loop.json\n- Optional flags use `[brackets]`\n\n## Section 4: Execution Flow\n\nThis is the largest section. It contains numbered sub-steps as H3 headings.\n\n### Cold Start Detection (always present)\n\n```markdown\n### Step 1: Cold Start Detection\n\n\\```\nif {state-file} exists:\n  -> Show current phase, pending gates, progress\n  -> Ask: \"Resume from {phase}? [Y/n]\"\nelse:\n  -> Fresh start, proceed to initialization\n\\```\n```\n\n### Phase Execution Diagram (always present)\n\nUse ASCII art to show the phase flow with gates:\n\n```\nPHASE_1 ---------> PHASE_2 ---------> PHASE_3\n   |                  |                  |\n   | [gate-1]         |                  | [gate-2]\n   v                  v                  v\nskill-a            skill-b            skill-c\n   |                  |                  |\n   v                  v                  v\nDELIVERABLE.md     DELIVERABLE.md     DELIVERABLE.md\n```\n\nRules:\n- Arrows show flow direction (left to right, top to bottom)\n- Gates appear between phases in [brackets]\n- Skills appear below their phase\n- Deliverables appear below their skill\n\n### Gate Enforcement Table (always present)\n\n```markdown\n| Gate | Triggers After | Blocks Until | Deliverable Required |\n|------|----------------|--------------|---------------------|\n| `{gate-id}` | {phase} complete | User says `approved` | {FILE}.md |\n```\n\n## Section 5: Commands During Execution\n\nStandard command table that every command must include:\n\n```markdown\n## Commands During Execution\n\n| Command | Action |\n|---------|--------|\n| `go` | Continue execution / proceed to next phase |\n| `status` | Show current phase, gate status, progress |\n| `approved` | Pass current gate |\n| `changes: [feedback]` | Request changes at gate |\n| `pause` | Stop after current phase |\n| `skip [system]` | Skip a system (requires reason) |\n| `skip-gate [gate]` | Skip a gate (requires reason) |\n| `show [deliverable]` | Display a deliverable |\n```\n\nAdd domain-specific commands below the standard set.\n\n## Section 6: State Files\n\n```markdown\n## State Files\n\n| File | Purpose |\n|------|---------|\n| `{state-file}` | Current phase, gate status, progress |\n| `{DELIVERABLE}.md` | {description} |\n```\n\n## Section 7: Example Session\n\nMust show a realistic invocation walkthrough covering at minimum:\n- Initial invocation\n- State detection (fresh start)\n- First phase execution\n- First gate prompt\n- Gate approval\n- Next phase starting\n\nUse code fences for the entire session. Include `User:` and `{Loop}:` labels.\n\n## Section 8: Resuming a Session\n\nMust show:\n- Invocation with existing state\n- State summary display\n- Resume prompt\n- Continuation from mid-loop\n\n## Section 9: Skill Invocation Sequence\n\n```markdown\n## Skill Invocation Sequence\n\n\\```\n1. {skill-name}\n   +-- Read: {reference-1}.md\n   +-- Read: {reference-2}.md\n   +-- Output: {DELIVERABLE-1}.md\n\n2. {skill-name}\n   +-- Read: {reference-1}.md\n   +-- Output: {DELIVERABLE}.md\n\\```\n```\n\n## Section 10: References\n\n```markdown\n## References\n\nThis command uses the **skills-library MCP server** for skill definitions:\n\n\\```\nmcp__skills-library__get_skill(name: \"{skill-name}\", includeReferences: true)\n\\```\n```\n\n## Quick Reference Checklist\n\n```markdown\n- [ ] H1 title with / prefix\n- [ ] Tagline under 20 words, imperative voice\n- [ ] Purpose with \"single entry point\" and use case list\n- [ ] Usage block with all flags documented\n- [ ] Execution flow with cold start, phase diagram, gate table\n- [ ] Standard commands table\n- [ ] State files table\n- [ ] Example session (fresh start through first gate)\n- [ ] Resume session example\n- [ ] Skill invocation sequence tree\n- [ ] References with MCP fetch instructions\n- [ ] No placeholder text (TODO, TBD, [fill in])\n- [ ] Line count 300-500\n```\n"
    },
    {
      "name": "existing-commands.md",
      "path": "references/existing-commands.md",
      "content": "# Existing Commands\n\nAnalysis of the two existing slash commands --- `engineering-loop.md` and `proposal-loop.md` --- as reference implementations. These are the canonical examples of what loop-to-slash-command generates.\n\n## Command Inventory\n\n| Command | Loop Source | Phases | Gates | Lines | State File |\n|---------|-----------|--------|-------|-------|------------|\n| `engineering-loop` | `engineering-loop` | 9 (INIT through COMPLETE) | 4 (spec, architecture, review, deploy) | ~489 | `loop-state.json` |\n| `proposal-loop` | `proposal-loop` | 4 (INIT through COMPLETE) | 4 (references, synthesis, alignment, final) | ~432 | `proposal-state.json` |\n\n## Structural Comparison\n\n### Section Presence\n\n| Section | engineering-loop | proposal-loop | Standard |\n|---------|----------------|-----------------|----------|\n| H1 Title + tagline | Yes | Yes | Required |\n| Purpose | Yes | Yes | Required |\n| Usage | Yes | Yes | Required |\n| Execution Flow | Yes (9 steps) | Yes (7 steps) | Required |\n| Gate Enforcement | Yes (table + prompts) | Yes (table + prompts) | Required |\n| Commands Table | Yes (12 commands) | Yes (10 commands) | Required |\n| State Files | Yes (8 files) | Yes (9 files) | Required |\n| Example Session | Yes (full walkthrough) | Yes (full walkthrough) | Required |\n| Resuming a Session | Yes | Yes | Required |\n| Skill Invocation | Implicit in flow | Yes (explicit tree) | Required |\n| Hook Integration | No (in CLAUDE.md) | Yes (3 hooks) | Optional |\n| References | Yes (MCP + table) | Yes (MCP calls) | Required |\n| Update Protocol | Yes | No | Optional |\n| Mode-Specific Behavior | Yes (3 modes) | No | If applicable |\n| Brownfield Adaptations | Yes | No | If applicable |\n\n### Key Differences\n\n| Aspect | engineering-loop | proposal-loop |\n|--------|----------------|-----------------|\n| **Modes** | 3 (greenfield, brownfield-polish, brownfield-enterprise) | 1 (proposal) |\n| **Mode detection** | Yes (directory analysis) | No |\n| **Scope discovery** | Yes (gap analysis) | No |\n| **Codebase analysis** | Yes | No |\n| **Phase diagram style** | Multi-row ASCII with skill lists | Single-row ASCII with deliverables |\n| **Gate prompts** | Box-drawing characters | Box-drawing characters |\n| **Completion display** | Standard summary | Large ASCII art banner |\n| **Hook documentation** | Deferred to CLAUDE.md | Inline (3 hooks) |\n| **Skill references** | MCP table with 8 references | MCP call list for 4 skills |\n\n## Extracted Patterns\n\n### Pattern 1: Cold Start Detection\n\nBoth commands use identical cold start logic:\n\n```\nif {state-file} exists:\n  -> Show current phase, pending gates, progress\n  -> Ask: \"Resume from {phase}? [Y/n]\"\nelse:\n  -> Fresh start, proceed to initialization\n```\n\n**Rule:** Always generate cold start detection as Step 1 of Execution Flow.\n\n### Pattern 2: Gate Prompt Format\n\nBoth commands use the same box-drawing prompt format:\n\n```\n====================================================================\n|  {GATE NAME}                                                      |\n|                                                                   |\n|  {Context}                                                        |\n|                                                                   |\n|  Commands:                                                        |\n|    approved     --- Pass gate, continue to {next phase}           |\n|    changes: ... --- Request modifications                         |\n|    show {item}  --- Display deliverable                           |\n====================================================================\n```\n\n**Rule:** All generated gate prompts must follow this visual format.\n\n### Pattern 3: State Schema Structure\n\nBoth commands use the same state schema pattern:\n\n```json\n{\n  \"mode\": \"{mode}\",\n  \"phase\": \"{current-phase}\",\n  \"status\": \"active\",\n  \"gates\": { \"{gate-id}\": { \"status\": \"pending\", \"required\": true } },\n  \"phases\": { \"{PHASE}\": { \"status\": \"pending\" } },\n  \"started_at\": \"ISO-timestamp\",\n  \"last_updated\": \"ISO-timestamp\"\n}\n```\n\nDifferences:\n- Engineering adds `systems` arrays to phases\n- Proposal adds `deliverables` arrays to phases and a `metrics` object\n\n**Rule:** Generate base schema from pattern, add domain-specific extensions.\n\n### Pattern 4: Standard Command Table\n\nBoth commands include these standard commands:\n\n| Command | Present In Both |\n|---------|----------------|\n| `go` | Yes |\n| `status` | Yes |\n| `approved` | Yes |\n| `changes: [feedback]` | Yes |\n| `pause` | Yes |\n| `show [deliverable]` | Yes |\n\nAdditional commands vary:\n- Engineering: `skip [system]`, `skip-gate [gate]`, `handoff`, `phase [name]`\n- Proposal: `skip-gate [gate] --reason`, `show metrics`, `improve: [feedback]`\n\n**Rule:** Always include the 6 standard commands. Add domain-specific commands below.\n\n### Pattern 5: Example Session Depth\n\nBoth commands include:\n1. Initial invocation showing fresh start\n2. State detection or initialization\n3. First phase execution with progress indicators\n4. First gate prompt with deliverable summary\n5. Gate approval and transition to next phase\n\n**Rule:** Example sessions must cover at least these 5 beats.\n\n### Pattern 6: Resume Example\n\nBoth commands show:\n1. Invocation finding existing state\n2. Progress summary (completed phases, gate status)\n3. Resume prompt\n4. Continuation message\n\n**Rule:** Resume examples must show all 4 elements.\n\n## Section Length Analysis\n\n| Section | engineering-loop | proposal-loop | Recommended |\n|---------|----------------|-----------------|-------------|\n| Title + tagline | 3 lines | 3 lines | 3 lines |\n| Purpose | 15 lines | 10 lines | 10-15 lines |\n| Usage | 10 lines | 8 lines | 8-12 lines |\n| Execution Flow | 180 lines | 120 lines | Scale with phases |\n| Gate Enforcement | 50 lines | 30 lines | Scale with gates |\n| Commands Table | 15 lines | 15 lines | 12-18 lines |\n| State Files | 12 lines | 12 lines | 10-15 lines |\n| Example Session | 80 lines | 70 lines | 60-100 lines |\n| Resume Example | 30 lines | 30 lines | 25-35 lines |\n| References | 20 lines | 15 lines | 15-25 lines |\n\n## Anti-Patterns Found\n\n| Anti-Pattern | Where Found | Correction |\n|-------------|------------|-----------|\n| Phase list in execution flow does not match loop.json | engineering-loop lists 10 phases, loop.json has 9 | Always derive from loop.json |\n| Implicit skill invocation | engineering-loop embeds skills in phase diagram | Always provide explicit skill invocation sequence |\n| Missing hook documentation | engineering-loop defers to CLAUDE.md | Include hook section if hooks exist |\n| Inconsistent state schema | Engineering uses `systems`, Proposal uses `deliverables` | Standardize on `deliverables` in phase entries |\n\n## Generation Implications\n\nWhen generating a new command, use these implementations as templates:\n\n| Loop Complexity | Reference Command | Format |\n|----------------|------------------|--------|\n| Simple (3-6 phases, no modes) | `proposal-loop` | Quick Format |\n| Complex (7+ phases, modes, conditional) | `engineering-loop` | Full Format |\n| Domain-specific (non-engineering) | `proposal-loop` | Quick Format + domain sections |\n\n## Quick Reference\n\n```markdown\nStructural requirements extracted from existing commands:\n- Cold start detection as Step 1 (always)\n- Box-drawing gate prompts (always)\n- Standard 6-command table (always)\n- Example session covering 5 beats (always)\n- Resume example with 4 elements (always)\n- Mode sections (only if multi-mode)\n- Hook documentation (only if hooks configured)\n- ASCII phase diagram (always, complexity varies)\n- MCP skill fetch instructions in References (always)\n```\n"
    },
    {
      "name": "gate-prompts.md",
      "path": "references/gate-prompts.md",
      "content": "# Gate Prompts\n\nTemplates for gate approval prompts, deliverable checklists, skip-with-reason logic, and approval type handling. Gates are the human-in-the-loop enforcement mechanism that ensures quality at each phase transition.\n\n## Prompt Structure\n\nEvery gate prompt follows the same visual structure:\n\n```\n====================================================================\n|  {GATE NAME}                                                      |\n|                                                                   |\n|  {Context line: what is ready for review}                         |\n|                                                                   |\n|  Deliverables:                                                    |\n|    {check/cross} {deliverable-1} ({status})                       |\n|    {check/cross} {deliverable-2} ({status})                       |\n|                                                                   |\n|  Commands:                                                        |\n|    approved     --- Pass gate, continue to {next phase}           |\n|    changes: ... --- Request modifications                         |\n|    show {item}  --- Display deliverable                           |\n====================================================================\n```\n\nUnicode box-drawing characters create the border. Use `=` for top/bottom, `|` for sides. This renders consistently in all terminal environments.\n\n## Gate Type Templates\n\n### Human Approval Gate\n\nThe most common type. Blocks until the user explicitly says `approved`.\n\n```markdown\n====================================================================\n|  {GATE_NAME} GATE                                                 |\n|                                                                   |\n|  {DELIVERABLE}.md is ready for review.                            |\n|                                                                   |\n|  Deliverables:                                                    |\n|    [check] {DELIVERABLE-1}.md (created, {size} bytes)             |\n|    [check] {DELIVERABLE-2}.md (created, {size} bytes)             |\n|                                                                   |\n|  Commands:                                                        |\n|    approved     --- Pass gate, continue to {NEXT_PHASE}           |\n|    changes: ... --- Request modifications                         |\n|    show {name}  --- Display a deliverable                         |\n====================================================================\n```\n\n**Generation rule:** Used when `gate.approvalType === \"human\"`.\n\n### Conditional Gate\n\nBlocks only when a condition is met. If the condition is not met, the gate passes automatically with a notification.\n\n```markdown\n====================================================================\n|  {GATE_NAME} GATE                                                 |\n|                                                                   |\n|  Condition: {condition description}                               |\n|                                                                   |\n|  {IF CONDITION MET}                                               |\n|  Deliverables require review:                                     |\n|    [check] {DELIVERABLE}.md (created)                             |\n|                                                                   |\n|  Commands:                                                        |\n|    approved     --- Pass gate, continue to {NEXT_PHASE}           |\n|    changes: ... --- Request modifications                         |\n|                                                                   |\n|  {IF CONDITION NOT MET}                                           |\n|  Condition not met --- gate auto-passed.                          |\n|  Continuing to {NEXT_PHASE}...                                    |\n====================================================================\n```\n\n**Generation rule:** Used when `gate.approvalType === \"conditional\"`. The condition description must be derived from the gate context (e.g., \"backend infrastructure present\").\n\n### Auto Gate\n\nPasses automatically after deliverable verification. No user action required, but a notification is shown.\n\n```markdown\n====================================================================\n|  {GATE_NAME} GATE                                                 |\n|                                                                   |\n|  Verifying deliverables...                                        |\n|                                                                   |\n|    [check] {DELIVERABLE-1}.md exists (verified)                   |\n|    [check] {DELIVERABLE-2}.md exists (verified)                   |\n|    [check] Content validation passed                              |\n|                                                                   |\n|  Gate auto-passed. Continuing to {NEXT_PHASE}...                  |\n====================================================================\n```\n\n**Generation rule:** Used when `gate.approvalType === \"auto\"` or when the gate only checks for file existence.\n\n## Deliverable Checklist Generation\n\nFor each gate, generate a deliverable checklist from `gate.deliverables`:\n\n```\nDeliverable check for gate \"{gate.id}\":\n\nFor each file in gate.deliverables:\n  1. Check file exists\n  2. Check file has content (> 0 bytes)\n  3. Check file has expected structure (if known)\n\nStatus indicators:\n  [check]  = file exists and validated\n  [cross]  = file missing or empty\n  [warn]   = file exists but validation failed\n```\n\n### Checklist Template\n\n```markdown\nDeliverables:\n  {status} {FILE-1}.md ({detail})\n  {status} {FILE-2}.md ({detail})\n\nWhere:\n  {status} = checkmark (exists + valid) | cross (missing) | warning (exists, invalid)\n  {detail} = \"created, 2,450 bytes\" | \"MISSING\" | \"exists, validation failed\"\n```\n\n## Skip Logic\n\nGates can be skipped with explicit justification. The skip syntax and rules differ based on whether the gate is required.\n\n### Skip Syntax\n\n```\nskip-gate {gate-id} --reason \"{justification}\"\n```\n\n### Required Gate Skip\n\nWhen a required gate is skipped, emit a warning:\n\n```markdown\nWARNING: {GATE_NAME} is a REQUIRED gate.\n\nSkipping required gates may compromise quality assurance.\nThe skip reason will be logged in the state file.\n\nReason provided: \"{justification}\"\n\nProceeding to {NEXT_PHASE}...\n\nState updated:\n  gates.{gate-id}.status = \"skipped\"\n  gates.{gate-id}.skippedReason = \"{justification}\"\n```\n\n### Optional Gate Skip\n\nWhen an optional gate is skipped:\n\n```markdown\nGate {GATE_NAME} skipped.\n\nReason: \"{justification}\"\nProceeding to {NEXT_PHASE}...\n```\n\n### Skip Validation Rules\n\n| Rule | Enforcement |\n|------|------------|\n| `--reason` flag is required | Skip fails without a reason |\n| Reason must be >10 characters | Prevents empty or trivial reasons |\n| Required gate skip logs a warning | Warning is visible in output |\n| Skip is recorded in state file | `skippedReason` field populated |\n| Skip cannot be undone | Once skipped, gate status is permanent |\n\n## Gate Ordering\n\nGates are ordered by their `afterPhase` field. The generation process must place gate prompts in the execution flow at the correct position:\n\n```\nPhase execution order from loop.json:\n  INIT -> SCAFFOLD -> IMPLEMENT -> TEST -> VERIFY -> REVIEW -> SHIP -> COMPLETE\n\nGate placement:\n  After INIT     -> spec-gate prompt\n  After SCAFFOLD -> architecture-gate prompt\n  After REVIEW   -> review-gate prompt\n  After SHIP     -> deploy-gate prompt (if required)\n```\n\n### No-Gate Phases\n\nPhases without a gate after them flow directly to the next phase with a transition notification:\n\n```markdown\nPhase {CURRENT} complete. Proceeding to {NEXT}...\n```\n\n## Contextual Enrichment\n\nGate prompts should include contextual information when available:\n\n| Context | Source | Example |\n|---------|--------|---------|\n| Deliverable size | File system check | \"2,450 bytes\" |\n| Section count | Content parsing | \"18 sections\" |\n| Capability count | Content parsing | \"3 capabilities defined\" |\n| Coverage metric | Skill output | \"92% coverage achieved\" |\n| Warning count | Validation | \"2 non-blocking warnings\" |\n\n## Quick Reference\n\n```markdown\nGate prompt generation:\n1. Determine gate type (human / conditional / auto)\n2. Select template based on type\n3. Insert gate name, deliverables, next phase\n4. Generate deliverable checklist\n5. Add contextual enrichment if available\n6. Add skip-gate instructions\n\nGate types:\n  human       -> Full prompt, blocks for \"approved\"\n  conditional -> Checks condition, blocks or auto-passes\n  auto        -> Checks deliverables, auto-passes\n\nSkip rules:\n  --reason is always required\n  Required gates emit warnings\n  Skips are permanent and logged\n```\n"
    },
    {
      "name": "naming-conventions.md",
      "path": "references/naming-conventions.md",
      "content": "# Naming Conventions\n\nRules and algorithms for deriving command names, file names, flags, and identifiers from loop definitions. Consistency in naming enables discoverability and prevents collisions.\n\n## Command Name Derivation\n\nThe command name IS the loop ID. No transformation needed.\n\n```\nAlgorithm:\n1. Take $.id from loop.json (e.g., \"engineering-loop\")\n2. Use it directly as the command name\n```\n\n### Derivation Table\n\n| Loop ID | Command Name |\n|---------|-------------|\n| `engineering-loop` | `engineering-loop` |\n| `proposal-loop` | `proposal-loop` |\n| `content-pipeline` | `content-pipeline` |\n| `review-loop` | `review-loop` |\n| `sales` | `sales` |\n\nAll loops use the loop ID directly as the command name.\n\n### Display Override\n\nIf `$.ui.branding.title` exists and differs from the loop ID, use it for display purposes only. The file name always follows the loop ID convention:\n\n| Branding Title | File Name | Display Name |\n|---------------|-----------|-------------|\n| \"Engineering Loop\" | `engineering-loop.md` | \"Engineering Loop\" |\n| \"Proposal Builder\" | `proposal-loop.md` | \"Proposal Builder\" |\n| \"Sales Pipeline\" | `sales.md` | \"Sales Pipeline\" |\n\n## File Name Conventions\n\n| File Type | Convention | Example |\n|-----------|-----------|---------|\n| Command file | `{loop-id}.md` | `proposal-loop.md` |\n| State file | `{domain}-state.json` | `proposal-state.json` |\n| Deliverable | `UPPER-CASE.md` | `FEATURESPEC.md` |\n| Config | `lowercase-kebab.json` | `loop-state.json` |\n| Log | `lowercase-kebab.jsonl` | `journey-log.jsonl` |\n\n### State File Naming\n\nThe state file name uses the domain (loop ID minus `-loop` suffix, if present):\n\n```\nAlgorithm:\n1. Take $.id from loop.json\n2. Strip \"-loop\" suffix if present to get the domain\n3. Append \"-state.json\"\n4. Special case: engineering-loop uses \"loop-state.json\" (legacy)\n```\n\n| Loop ID | Domain | State File |\n|---------|--------|------------|\n| `engineering-loop` | `engineering` | `loop-state.json`* |\n| `proposal-loop` | `proposal` | `proposal-state.json` |\n| `review-loop` | `review` | `review-state.json` |\n\n*Legacy convention. New loops should use `{domain}-state.json`.\n\n## Flag Conventions\n\n### Standard Flags (always present)\n\n| Flag | Format | Values |\n|------|--------|--------|\n| `--resume` | Boolean (no value) | Present or absent |\n| `--phase` | `--phase=VALUE` | Phase names from loop.json, UPPER_CASE |\n\n### Conditional Flags\n\n| Flag | Present When | Format |\n|------|-------------|--------|\n| `--mode` | Loop has `$.defaults.mode` and mode detection | `--mode=VALUE` |\n| `--skip-analysis` | Loop has a codebase analysis step | Boolean |\n| `--skip-gate` | Any gate has `required: false` | `--skip-gate=GATE_ID` |\n\n### Flag Value Enums\n\nPhase flag values are derived from `$.phases[*].name`:\n\n```\nLoop phases: [INIT, SCAFFOLD, IMPLEMENT, TEST, VERIFY]\nFlag usage: --phase=INIT | --phase=SCAFFOLD | --phase=IMPLEMENT | ...\n```\n\nGate skip values are derived from `$.gates[*].id`:\n\n```\nLoop gates: [spec-gate, architecture-gate, deploy-gate]\nFlag usage: --skip-gate=spec-gate | --skip-gate=architecture-gate | ...\n```\n\n## Identifier Conventions\n\n| Identifier Type | Convention | Example |\n|----------------|-----------|---------|\n| Phase name | UPPER_CASE | `INIT`, `SCAFFOLD`, `IMPLEMENT` |\n| Gate ID | lowercase-kebab | `spec-gate`, `architecture-gate` |\n| Skill name | lowercase-kebab | `context-ingestion`, `code-review` |\n| Deliverable name | UPPER-KEBAB.md | `FEATURESPEC.md`, `CODE-REVIEW.md` |\n| State field | camelCase | `passedAt`, `skippedReason`, `startedAt` |\n| JSON key (top-level) | snake_case | `started_at`, `last_updated` |\n\n## Conflict Resolution\n\nWhen a derived command name conflicts with an existing command:\n\n| Conflict Type | Resolution |\n|--------------|-----------|\n| Same name, different loop | Append loop version: `review-loop-v2` |\n| Same name, same loop (update) | Overwrite with confirmation |\n| Name too long (>30 chars) | Use abbreviation: `content-pipeline` -> `cp-loop` |\n| Reserved name collision | Prefix with `custom-`: `custom-review-loop` |\n\n### Checking for Conflicts\n\n```bash\n# List existing commands\nls ~/.claude/commands/*.md\n\n# Check for name collision\nls ~/.claude/commands/{proposed-name}.md 2>/dev/null && echo \"CONFLICT\" || echo \"AVAILABLE\"\n```\n\n## Quick Reference\n\n```markdown\nCommand name:  {loop-id} (used directly, no transformation)\nCommand file:  ~/.claude/commands/{loop-id}.md\nState file:    {domain}-state.json (domain = loop ID minus \"-loop\" suffix)\nH1 title:      /{loop-id} Command\nPhase values:  UPPER_CASE from $.phases[*].name\nGate IDs:      lowercase-kebab from $.gates[*].id\nDeliverables:  UPPER-CASE.md from $.gates[*].deliverables\n```\n"
    },
    {
      "name": "state-schema.md",
      "path": "references/state-schema.md",
      "content": "# State Schema\n\nComplete state file structure for loop execution. The state file is the runtime source of truth for loop progress, gate status, and deliverable tracking. Generated from loop.json, not handcrafted.\n\n## Full Schema\n\n```json\n{\n  \"loop\": \"{loop-id}\",\n  \"version\": \"{loop-version}\",\n  \"mode\": \"{default-mode or detected-mode}\",\n  \"phase\": \"{current-phase-name}\",\n  \"status\": \"{loop-status}\",\n  \"gates\": {\n    \"{gate-id}\": {\n      \"status\": \"{gate-status}\",\n      \"required\": true,\n      \"approvalType\": \"{approval-type}\",\n      \"deliverables\": [\"{FILE}.md\"],\n      \"passedAt\": null,\n      \"skippedReason\": null\n    }\n  },\n  \"phases\": {\n    \"{PHASE_NAME}\": {\n      \"status\": \"{phase-status}\",\n      \"required\": true,\n      \"skills\": [\"{skill-name}\"],\n      \"deliverables\": [],\n      \"startedAt\": null,\n      \"completedAt\": null\n    }\n  },\n  \"metrics\": {},\n  \"started_at\": \"{ISO-8601}\",\n  \"last_updated\": \"{ISO-8601}\"\n}\n```\n\n## Field Definitions\n\n### Top-Level Fields\n\n| Field | Type | Values | Source |\n|-------|------|--------|--------|\n| `loop` | string | Loop ID | `$.id` |\n| `version` | string | Semver | `$.version` |\n| `mode` | string | Default or detected mode | `$.defaults.mode` |\n| `phase` | string | Current active phase name | Runtime |\n| `status` | enum | `active`, `paused`, `complete`, `failed` | Runtime |\n| `started_at` | string | ISO 8601 timestamp | Set on creation |\n| `last_updated` | string | ISO 8601 timestamp | Set on every mutation |\n\n### Loop Status Transitions\n\n```\nactive ----> paused    (user says \"pause\")\nactive ----> complete  (all phases done, final gate passed)\nactive ----> failed    (unrecoverable error)\npaused ----> active    (user resumes with --resume)\n```\n\n### Gate Fields\n\n| Field | Type | Values | Source |\n|-------|------|--------|--------|\n| `status` | enum | `pending`, `passed`, `skipped`, `failed` | Runtime |\n| `required` | boolean | true/false | `$.gates[*].required` |\n| `approvalType` | enum | `human`, `conditional`, `auto` | `$.gates[*].approvalType` |\n| `deliverables` | string[] | File names | `$.gates[*].deliverables` |\n| `passedAt` | string/null | ISO 8601 or null | Set when gate passes |\n| `skippedReason` | string/null | Reason text or null | Set when gate is skipped |\n\n### Gate Status Transitions\n\n```\npending ----> passed   (user says \"approved\" or auto-check passes)\npending ----> skipped  (user says \"skip-gate {id} --reason ...\")\npending ----> failed   (deliverable check fails, user must fix)\nfailed  ----> pending  (user fixes deliverable, retries)\nfailed  ----> skipped  (user explicitly skips after failure)\n```\n\n### Phase Fields\n\n| Field | Type | Values | Source |\n|-------|------|--------|--------|\n| `status` | enum | `pending`, `active`, `complete`, `skipped` | Runtime |\n| `required` | boolean | true/false | `$.phases[*].required` |\n| `skills` | string[] | Skill names | `$.phases[*].skills` |\n| `deliverables` | string[] | Produced file names | Runtime (populated during execution) |\n| `startedAt` | string/null | ISO 8601 or null | Set when phase begins |\n| `completedAt` | string/null | ISO 8601 or null | Set when phase completes |\n\n### Phase Status Transitions\n\n```\npending  ----> active    (previous phase + gate complete)\nactive   ----> complete  (all skills executed, deliverables verified)\npending  ----> skipped   (phase not required, user or auto skips)\nactive   ----> pending   (phase reset after failure)\n```\n\n## Generation Algorithm\n\nTransform loop.json into state schema:\n\n```\nINPUT: loop.json\nOUTPUT: {state-file}.json\n\n1. Set top-level fields:\n   loop     = $.id\n   version  = $.version\n   mode     = $.defaults.mode\n   phase    = $.phases[0].name  (first phase)\n   status   = \"active\"\n\n2. For each gate in $.gates:\n   gates[gate.id] = {\n     status: \"pending\",\n     required: gate.required,\n     approvalType: gate.approvalType,\n     deliverables: gate.deliverables,\n     passedAt: null,\n     skippedReason: null\n   }\n\n3. For each phase in $.phases:\n   phases[phase.name] = {\n     status: \"pending\",\n     required: phase.required,\n     skills: phase.skills,\n     deliverables: [],\n     startedAt: null,\n     completedAt: null\n   }\n\n4. Set first phase status to \"active\"\n\n5. Set timestamps:\n   started_at = now()\n   last_updated = now()\n```\n\n## Metrics Object\n\nThe metrics object is domain-specific. It is empty by default and populated during execution based on the loop's domain.\n\n### Engineering Loop Metrics\n\n```json\n\"metrics\": {\n  \"systems_built\": 0,\n  \"tests_written\": 0,\n  \"coverage_percent\": 0,\n  \"lint_errors\": 0,\n  \"type_errors\": 0\n}\n```\n\n### Proposal Loop Metrics\n\n```json\n\"metrics\": {\n  \"sources_processed\": 0,\n  \"requirements_extracted\": 0,\n  \"patterns_identified\": 0,\n  \"gaps_found\": 0,\n  \"priorities_ranked\": 0,\n  \"claims_with_evidence\": 0\n}\n```\n\n### Custom Loop Metrics\n\nFor new loops, the metrics object starts empty. Skills populate it during execution:\n\n```json\n\"metrics\": {}\n```\n\n## Resume Logic\n\nWhen reading an existing state file to resume:\n\n```\n1. Read {state-file}.json\n2. Check status:\n   - \"complete\" -> Inform user, ask if they want to restart\n   - \"failed\"   -> Show error, ask if they want to retry from failed phase\n   - \"paused\"   -> Resume from current phase\n   - \"active\"   -> Resume from current phase (session interrupted)\n3. Find current phase: first phase with status \"active\" or first \"pending\"\n4. Check gate before current phase:\n   - If gate \"pending\" and \"required\" -> Present gate prompt\n   - If gate \"passed\" or \"skipped\"   -> Continue to phase\n   - If no gate before this phase    -> Continue to phase\n5. Update last_updated timestamp\n```\n\n## Validation Rules\n\n```markdown\n- [ ] Every phase in loop.json appears in state phases object\n- [ ] Every gate in loop.json appears in state gates object\n- [ ] Phase names in state match loop.json exactly (case-sensitive)\n- [ ] Gate IDs in state match loop.json exactly (case-sensitive)\n- [ ] All gate deliverable arrays match loop.json\n- [ ] All phase skill arrays match loop.json\n- [ ] Timestamps are ISO 8601 format\n- [ ] Initial status is \"active\"\n- [ ] Initial phase is first phase name\n- [ ] All gate statuses start as \"pending\"\n- [ ] All phase statuses start as \"pending\" except first (\"active\")\n```\n"
    }
  ],
  "tags": [
    "meta",
    "loops",
    "cli",
    "commands",
    "generation"
  ],
  "dependsOn": [
    "loop-composer"
  ]
}