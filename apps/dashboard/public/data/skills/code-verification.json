{
  "id": "code-verification",
  "name": "code-verification",
  "version": "1.0.0",
  "description": "Fast structural correctness checks for code generation loops. Use after every code generation to catch complexity issues, security vulnerabilities, resource leaks, and error handling gaps before they compound. Supports two strictness levels: 'fast' for tight iteration loops, 'thorough' for pre-PR checks. Outputs pass/fail per category with specific issues.",
  "phase": "VERIFY",
  "category": "engineering",
  "content": "# Code Verification\n\nStructural correctness checks designed for agentic code generation loops. Fast, automatable, binary pass/fail orientation.\n\n## When to Use\n\n- **Every code generation** in agentic workflows (fast mode)\n- **Before committing** or creating a PR (thorough mode)\n- **After refactoring** to ensure no regressions\n- When you say: \"verify this\", \"check this code\", \"is this safe to ship?\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `complexity-patterns.md` | Identify O(n²) and other complexity issues |\n| `error-handling-patterns.md` | Proper error handling verification |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `concurrency-patterns.md` | When verifying concurrent code |\n| `memory-patterns.md` | When checking for memory issues |\n| `resource-patterns.md` | When verifying resource cleanup |\n\n**Verification:** All categories should have PASS/FAIL status with evidence.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `VERIFICATION.md` | Project root | Always |\n\n## Core Concept\n\nVerification answers: **\"Did we build it correctly?\"**\n\nThis is distinct from validation (\"Did we build the right thing?\"). Verification is structural—it catches bugs that exist regardless of requirements. It should be:\n\n- **Fast**: Seconds, not minutes\n- **Automatable**: Can run without human judgment\n- **Binary**: Pass or fail, with specific issues listed\n- **Composable**: Part of every generation loop\n\n## Strictness Levels\n\n| Level | When to Use | Categories Checked | Time Budget |\n|-------|-------------|-------------------|-------------|\n| **Fast** | Every iteration in agentic loop | Complexity, Security, Error Handling | <30 seconds |\n| **Thorough** | Before PR, before shipping | All categories, deeper analysis | 2-5 minutes |\n\nDefault to **fast** unless explicitly requested otherwise or at a shipping checkpoint.\n\n## Verification Categories\n\nSix categories, each with specific patterns to detect:\n\n### 1. Complexity (Fast + Thorough)\n\n**Question**: Will this perform acceptably at production scale?\n\n**Check for**:\n- Nested loops over same data structure → O(n²)\n- `.find()`, `.filter()`, `.includes()` inside loops → hidden O(n²)\n- Recursive calls that branch → potential O(2ⁿ)\n- String concatenation in loops → O(n²) in many languages\n- Sorting inside loops → O(n² log n)\n\n**Pass criteria**: No unintentional quadratic or worse complexity in hot paths.\n\n→ See `references/complexity-patterns.md`\n\n### 2. Memory (Thorough only)\n\n**Question**: Will this leak memory or blow the stack?\n\n**Check for**:\n- Event listeners without cleanup\n- Closures capturing more than needed\n- Recursive calls without depth limits\n- Growing collections without bounds\n- Circular references preventing GC\n\n**Pass criteria**: No obvious memory leaks, bounded resource usage.\n\n→ See `references/memory-patterns.md`\n\n### 3. Concurrency (Thorough only)\n\n**Question**: Is this safe when multiple things run at once?\n\n**Check for**:\n- Shared mutable state without synchronization\n- Check-then-act patterns (TOCTOU)\n- Sequential awaits that should be parallel\n- Missing Promise.all for independent operations\n- Callback hell or unhandled promise rejections\n\n**Pass criteria**: No race conditions, appropriate use of async patterns.\n\n→ See `references/concurrency-patterns.md`\n\n### 4. Security (Fast + Thorough)\n\n**Question**: Could this be exploited?\n\n**Check for**:\n- String concatenation in SQL/queries → injection\n- Unescaped user input in HTML → XSS\n- Missing authentication/authorization checks\n- Sensitive data in logs or error messages\n- Hardcoded secrets or credentials\n- Insecure direct object references\n\n**Pass criteria**: No injection vectors, no auth bypasses, no data exposure.\n\n→ See `references/security-patterns.md`\n\n### 5. Error Handling (Fast + Thorough)\n\n**Question**: What happens when things fail?\n\n**Check for**:\n- Missing try/catch around I/O operations\n- Swallowed exceptions (empty catch blocks)\n- Error messages that expose internals\n- Missing null/undefined checks\n- Assumptions about external service responses\n\n**Pass criteria**: All failure paths handled, errors propagate appropriately.\n\n→ See `references/error-handling-patterns.md`\n\n### 6. Resource Management (Thorough only)\n\n**Question**: Are resources properly acquired and released?\n\n**Check for**:\n- Database connections not returned to pool\n- File handles not closed\n- Missing cleanup in finally blocks\n- Timeout absence on external calls\n- Unbounded queues or buffers\n\n**Pass criteria**: All resources have cleanup paths, timeouts on external dependencies.\n\n→ See `references/resource-patterns.md`\n\n## Workflow\n\n### Fast Mode (Every Iteration)\n\n```\n1. Scan for complexity anti-patterns\n2. Scan for security anti-patterns  \n3. Scan for error handling gaps\n4. Report: PASS or FAIL with specific issues\n```\n\nTime budget: <30 seconds. If you find issues, stop and report—don't continue checking.\n\n### Thorough Mode (Pre-PR)\n\n```\n1. Run all Fast mode checks\n2. Analyze memory patterns\n3. Analyze concurrency patterns\n4. Analyze resource management\n5. Cross-reference: Do error handlers leak resources?\n6. Report: Full assessment with severity levels\n```\n\nTime budget: 2-5 minutes. Complete all categories before reporting.\n\n## Output Format\n\n### Fast Mode Output\n\n```json\n{\n  \"mode\": \"fast\",\n  \"result\": \"FAIL\",\n  \"issues\": [\n    {\n      \"category\": \"complexity\",\n      \"severity\": \"high\",\n      \"location\": \"processOrders():15\",\n      \"issue\": \"O(n²) - .find() inside .map() loop\",\n      \"suggestion\": \"Build lookup Map before loop for O(n) total\"\n    }\n  ],\n  \"categories_checked\": [\"complexity\", \"security\", \"error_handling\"],\n  \"pass_count\": 2,\n  \"fail_count\": 1\n}\n```\n\n### Thorough Mode Output\n\n```json\n{\n  \"mode\": \"thorough\",\n  \"result\": \"PASS\",\n  \"summary\": \"All checks passed. Minor suggestions below.\",\n  \"categories\": {\n    \"complexity\": {\"status\": \"pass\", \"issues\": []},\n    \"memory\": {\"status\": \"pass\", \"issues\": []},\n    \"concurrency\": {\"status\": \"pass\", \"issues\": []},\n    \"security\": {\"status\": \"pass\", \"issues\": []},\n    \"error_handling\": {\"status\": \"pass\", \"issues\": []},\n    \"resource_management\": {\"status\": \"pass\", \"issues\": []}\n  },\n  \"suggestions\": [\n    {\n      \"category\": \"concurrency\",\n      \"severity\": \"low\",\n      \"note\": \"Consider Promise.all for independent fetches at line 42\"\n    }\n  ]\n}\n```\n\n### Conversational Output\n\nWhen context is conversational (not part of automated loop), report naturally:\n\n> **Verification: PASS** (fast mode)\n> \n> Checked complexity, security, and error handling. No issues found. \n> Ready for next iteration or thorough check before PR.\n\nOr:\n\n> **Verification: FAIL** (fast mode)\n> \n> Found 1 issue:\n> - **Complexity** (high): `processOrders():15` has O(n²) complexity—`.find()` inside `.map()`. Build a lookup Map before the loop.\n>\n> Fix this before continuing.\n\n## Integration with Agentic Loops\n\nThis skill is designed to run after every code generation:\n\n```\n[User request]\n     ↓\n[Agent generates code]\n     ↓\n[engineering-verification: fast] ← automatic\n     ↓\n   PASS? → continue or deliver\n   FAIL? → fix issues, regenerate, re-verify\n```\n\nFor PR-ready code:\n\n```\n[Feature complete]\n     ↓\n[engineering-verification: thorough]\n     ↓\n   PASS? → ready for human review\n   FAIL? → address issues first\n```\n\n## Key Principles\n\n**Speed over comprehensiveness in fast mode.** The goal is catching obvious issues quickly, not exhaustive analysis. Save thorough analysis for checkpoints.\n\n**Binary outcomes.** Resist \"maybe\" or \"probably fine.\" Either it passes or it doesn't. Ambiguous cases are failures that need investigation.\n\n**Specific locations.** Every issue must point to a specific line or function. \"There might be a memory leak somewhere\" is not actionable.\n\n**Suggestions, not just problems.** Every issue should include a suggested fix or investigation path.\n\n**Severity matters.** High severity = must fix before continuing. Low severity = note for later or optional improvement.\n\n## Severity Definitions\n\n| Severity | Definition | Action |\n|----------|------------|--------|\n| **Critical** | Will break in production or security vulnerability | Stop. Fix immediately. |\n| **High** | Significant bug or performance issue | Fix before continuing. |\n| **Medium** | Code smell or potential issue | Fix before PR. |\n| **Low** | Improvement opportunity | Note for later. |\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `implement` | Verification runs automatically (fast mode) after each code generation |\n| `code-validation` | Verification checks structure; validation checks semantics. Both needed. |\n| `code-review` | Invokes verification (thorough mode) as first pass |\n| `security-audit` | Verification catches common vulnerabilities; security-audit does threat modeling |\n| `perf-analysis` | Verification catches O(n²); perf-analysis profiles and identifies bottlenecks |\n\n**Verification answers:** \"Is this code structurally sound?\"\n**Validation answers:** \"Does this code solve the right problem?\"\n\n## References\n\n- `references/complexity-patterns.md`: Detailed complexity anti-patterns and fixes\n- `references/memory-patterns.md`: Memory leak patterns and detection\n- `references/concurrency-patterns.md`: Race conditions and async patterns\n- `references/security-patterns.md`: Security vulnerability patterns\n- `references/error-handling-patterns.md`: Error handling anti-patterns\n- `references/resource-patterns.md`: Resource management patterns",
  "references": [
    {
      "name": "complexity-patterns.md",
      "path": "references/complexity-patterns.md",
      "content": "# Complexity Patterns\n\nPatterns that indicate problematic time or space complexity. These are the most common issues in AI-generated code.\n\n## Why This Matters\n\nAI code generators optimize for correctness and readability, not performance. They frequently produce O(n²) solutions where O(n) is possible. At small scale (n < 100), this doesn't matter. At production scale (n > 10,000), it's catastrophic.\n\nYour job: Catch these before they reach production.\n\n## Detection Patterns\n\n### Pattern 1: Nested Loop Over Same Data\n\n**Anti-pattern:**\n```javascript\n// O(n²) - for each user, scan all orders\nusers.forEach(user => {\n  const userOrders = orders.filter(o => o.userId === user.id);\n});\n```\n\n**Detection signal:** Loop inside loop over related data structures.\n\n**Fix:**\n```javascript\n// O(n) - build index once, lookup in constant time\nconst ordersByUser = new Map();\norders.forEach(o => {\n  if (!ordersByUser.has(o.userId)) ordersByUser.set(o.userId, []);\n  ordersByUser.get(o.userId).push(o);\n});\n\nusers.forEach(user => {\n  const userOrders = ordersByUser.get(user.id) || [];\n});\n```\n\n### Pattern 2: Search Inside Loop\n\n**Anti-pattern:**\n```javascript\n// O(n²) - .find() is O(n), called n times\nitems.map(item => {\n  const category = categories.find(c => c.id === item.categoryId);\n  return { ...item, categoryName: category?.name };\n});\n```\n\n**Detection signal:** `.find()`, `.filter()`, `.includes()`, `.indexOf()` inside `.map()`, `.forEach()`, `for` loop.\n\n**Fix:**\n```javascript\n// O(n) - build Map once\nconst categoryMap = new Map(categories.map(c => [c.id, c]));\n\nitems.map(item => {\n  const category = categoryMap.get(item.categoryId);\n  return { ...item, categoryName: category?.name };\n});\n```\n\n### Pattern 3: String Concatenation in Loop\n\n**Anti-pattern:**\n```javascript\n// O(n²) in many languages - strings are immutable, each += copies\nlet result = '';\nfor (const item of items) {\n  result += item.toString() + ',';\n}\n```\n\n**Detection signal:** String `+=` or `+` inside a loop.\n\n**Why it's O(n²):** Each concatenation creates a new string, copying all previous characters. First iteration copies 1 char, second copies 2, etc. Total: 1 + 2 + 3 + ... + n = O(n²).\n\n**Fix:**\n```javascript\n// O(n) - join handles this efficiently\nconst result = items.map(item => item.toString()).join(',');\n\n// Or use array accumulation\nconst parts = [];\nfor (const item of items) {\n  parts.push(item.toString());\n}\nconst result = parts.join(',');\n```\n\n### Pattern 4: Sorting Inside Loop\n\n**Anti-pattern:**\n```javascript\n// O(n² log n) - sorting is O(n log n), done n times\nusers.forEach(user => {\n  const sorted = user.transactions.sort((a, b) => b.date - a.date);\n  // ...\n});\n```\n\n**Detection signal:** `.sort()` inside any loop construct.\n\n**Fix:** Sort once outside the loop if possible, or question whether sorting is needed at all.\n\n### Pattern 5: Recursive Branching\n\n**Anti-pattern:**\n```javascript\n// O(2ⁿ) - exponential, will hang for n > 30\nfunction fib(n) {\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);  // Two recursive calls\n}\n```\n\n**Detection signal:** Function that calls itself twice (or more) per invocation without memoization.\n\n**Fix:**\n```javascript\n// O(n) with memoization\nfunction fib(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);\n  return memo[n];\n}\n\n// Or O(n) iterative\nfunction fib(n) {\n  if (n <= 1) return n;\n  let prev = 0, curr = 1;\n  for (let i = 2; i <= n; i++) {\n    [prev, curr] = [curr, prev + curr];\n  }\n  return curr;\n}\n```\n\n### Pattern 6: Repeated Array Operations\n\n**Anti-pattern:**\n```javascript\n// O(n²) - unshift is O(n), done n times\nconst reversed = [];\nfor (const item of items) {\n  reversed.unshift(item);  // Shifts all elements each time\n}\n```\n\n**Detection signal:** `.unshift()`, `.splice(0, ...)` inside a loop.\n\n**Fix:**\n```javascript\n// O(n) - push is O(1) amortized\nconst reversed = [];\nfor (const item of items) {\n  reversed.push(item);\n}\nreversed.reverse();\n\n// Or just use built-in\nconst reversed = [...items].reverse();\n```\n\n### Pattern 7: Uniqueness Check via Array\n\n**Anti-pattern:**\n```javascript\n// O(n²) - includes is O(n), called n times\nconst unique = [];\nfor (const item of items) {\n  if (!unique.includes(item)) {\n    unique.push(item);\n  }\n}\n```\n\n**Detection signal:** `.includes()` on an array that's being built in the same loop.\n\n**Fix:**\n```javascript\n// O(n) - Set has O(1) lookup\nconst unique = [...new Set(items)];\n\n// Or if you need more control\nconst seen = new Set();\nconst unique = [];\nfor (const item of items) {\n  if (!seen.has(item)) {\n    seen.add(item);\n    unique.push(item);\n  }\n}\n```\n\n### Pattern 8: Cartesian Product (Intentional but Dangerous)\n\n**Not always wrong, but flag for review:**\n```javascript\n// O(n × m) - intentional but verify this is necessary\nfor (const a of listA) {\n  for (const b of listB) {\n    if (shouldMatch(a, b)) {\n      // ...\n    }\n  }\n}\n```\n\n**Question to ask:** Is this actually necessary, or can we index one side?\n\n## Quick Reference Table\n\n| Pattern | Complexity | Detection Signal | Fix Strategy |\n|---------|------------|------------------|--------------|\n| Nested loop, same data | O(n²) | Loop in loop | Build index/Map |\n| Search in loop | O(n²) | find/filter/includes in loop | Pre-build Map |\n| String concat in loop | O(n²) | += string in loop | Array + join |\n| Sort in loop | O(n² log n) | .sort() in loop | Sort once outside |\n| Recursive branching | O(2ⁿ) | Multiple recursive calls | Memoization/iteration |\n| Unshift in loop | O(n²) | .unshift() in loop | Push + reverse |\n| Includes on growing array | O(n²) | .includes() on accumulator | Use Set |\n\n## When Complexity is Acceptable\n\nNot all O(n²) is bad. Consider:\n\n- **n is bounded and small**: If n is always < 50, O(n²) is 2500 operations max. Fine.\n- **It's not in a hot path**: If this runs once at startup, not per request, less critical.\n- **Readability tradeoff**: Sometimes the O(n) version is significantly less readable.\n\nBut in verification, **flag it anyway**. The human or the next iteration can decide if it's acceptable. Don't pre-optimize the warning away.\n\n## Verification Checklist\n\nFor every code block, scan for:\n\n1. [ ] Loops inside loops over related data\n2. [ ] `.find()`, `.filter()`, `.includes()` inside loops\n3. [ ] String concatenation with `+=` inside loops\n4. [ ] `.sort()` inside loops\n5. [ ] Recursive functions with multiple self-calls\n6. [ ] `.unshift()` or `.splice(0, ...)` inside loops\n7. [ ] `.includes()` on an array being built in same loop\n\nIf any found: **FAIL** with location and suggested fix.\n"
    },
    {
      "name": "concurrency-patterns.md",
      "path": "references/concurrency-patterns.md",
      "content": "# Concurrency Patterns\n\nPatterns that indicate race conditions, deadlocks, or inefficient async handling. These cause intermittent bugs—the hardest kind to debug.\n\n## Why This Matters\n\nConcurrency bugs are quantum bugs—they exist in superposition until observed, then collapse into \"works on my machine.\" AI-generated code especially struggles here because correctness and concurrency are orthogonal: code can be functionally correct but completely broken under concurrent access.\n\nYour job: Ask \"what if two of these run at the same time?\" for every operation.\n\n## Detection Patterns\n\n### Pattern 1: Check-Then-Act (TOCTOU)\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - race between check and act\nasync function withdrawMoney(userId, amount) {\n  const balance = await getBalance(userId);\n  if (balance >= amount) {\n    // Another request could modify balance here!\n    await setBalance(userId, balance - amount);\n  }\n}\n\n// VULNERABLE - file check then operation\nif (await fileExists(path)) {\n  // File could be deleted between check and read\n  const content = await readFile(path);\n}\n```\n\n**Detection signal:** \n- Read followed by conditional followed by write, without atomicity\n- Existence check followed by operation on the resource\n\n**Why it's dangerous:** Two simultaneous requests both read balance=100, both see balance >= 50, both subtract, result is -50 instead of 0.\n\n**Fix:**\n```javascript\n// SAFE - atomic operation\nasync function withdrawMoney(userId, amount) {\n  const result = await db.query(\n    'UPDATE accounts SET balance = balance - $1 WHERE user_id = $2 AND balance >= $1 RETURNING balance',\n    [amount, userId]\n  );\n  if (result.rowCount === 0) {\n    throw new InsufficientFundsError();\n  }\n}\n\n// SAFE - optimistic locking\nasync function withdrawMoney(userId, amount) {\n  const account = await getAccount(userId);\n  const result = await db.query(\n    'UPDATE accounts SET balance = $1, version = $2 WHERE user_id = $3 AND version = $4',\n    [account.balance - amount, account.version + 1, userId, account.version]\n  );\n  if (result.rowCount === 0) {\n    throw new ConcurrencyError('Account modified by another request');\n  }\n}\n\n// SAFE - try and catch instead of check\ntry {\n  const content = await readFile(path);\n} catch (err) {\n  if (err.code === 'ENOENT') {\n    // Handle missing file\n  }\n  throw err;\n}\n```\n\n### Pattern 2: Sequential Awaits That Should Be Parallel\n\n**Anti-pattern:**\n```javascript\n// SLOW - waits for each in sequence\nasync function loadDashboard(userId) {\n  const user = await fetchUser(userId);\n  const orders = await fetchOrders(userId);\n  const notifications = await fetchNotifications(userId);\n  return { user, orders, notifications };\n}\n// Total time: user + orders + notifications\n```\n\n**Detection signal:** Multiple independent `await` calls in sequence.\n\n**Fix:**\n```javascript\n// FAST - parallel execution\nasync function loadDashboard(userId) {\n  const [user, orders, notifications] = await Promise.all([\n    fetchUser(userId),\n    fetchOrders(userId),\n    fetchNotifications(userId)\n  ]);\n  return { user, orders, notifications };\n}\n// Total time: max(user, orders, notifications)\n```\n\n**Caveat:** Only parallelize if operations are truly independent. If order B depends on result of A, they must be sequential.\n\n### Pattern 3: Shared Mutable State Without Synchronization\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - shared counter without lock\nlet requestCount = 0;\n\nasync function handleRequest(req) {\n  requestCount++;  // Not atomic!\n  // Read-modify-write can interleave\n}\n\n// VULNERABLE - shared object mutation\nconst cache = {};\n\nasync function getOrCreate(key) {\n  if (!cache[key]) {\n    cache[key] = await createExpensive(key);  // Two calls might both create\n  }\n  return cache[key];\n}\n```\n\n**Detection signal:** Module-level or shared variables modified by async functions.\n\n**Fix:**\n```javascript\n// SAFE - use atomic operations (where available)\nconst { Atomics } = require('worker_threads');\n// Or use database/Redis for shared state\n\n// SAFE - use a mutex for complex operations\nconst mutex = new Mutex();\n\nasync function getOrCreate(key) {\n  return await mutex.runExclusive(async () => {\n    if (!cache[key]) {\n      cache[key] = await createExpensive(key);\n    }\n    return cache[key];\n  });\n}\n\n// SAFE - use Map's atomic get-or-set pattern\nconst pending = new Map();\n\nasync function getOrCreate(key) {\n  if (cache[key]) return cache[key];\n  \n  if (!pending.has(key)) {\n    pending.set(key, createExpensive(key).finally(() => pending.delete(key)));\n  }\n  \n  cache[key] = await pending.get(key);\n  return cache[key];\n}\n```\n\n### Pattern 4: Missing Promise.all Error Handling\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - partial failure leaves inconsistent state\nasync function updateAll(items) {\n  await Promise.all(items.map(item => updateItem(item)));\n  // If one fails, others might have succeeded - inconsistent state\n}\n```\n\n**Detection signal:** `Promise.all` over mutation operations without transaction or rollback.\n\n**Fix:**\n```javascript\n// SAFE - use allSettled and handle partial failure\nasync function updateAll(items) {\n  const results = await Promise.allSettled(items.map(item => updateItem(item)));\n  \n  const failures = results.filter(r => r.status === 'rejected');\n  if (failures.length > 0) {\n    // Log failures, potentially retry or alert\n    logger.error('Partial failure', { failures: failures.map(f => f.reason) });\n    throw new PartialUpdateError(failures);\n  }\n}\n\n// SAFE - use database transaction for atomicity\nasync function updateAll(items) {\n  await db.transaction(async (trx) => {\n    await Promise.all(items.map(item => updateItem(item, trx)));\n  });\n  // Either all succeed or all fail\n}\n```\n\n### Pattern 5: Callback vs. Promise Confusion\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - mixing callbacks and promises\nasync function processFile(path) {\n  fs.readFile(path, (err, data) => {\n    if (err) throw err;  // This throw goes nowhere!\n    return data;  // This return goes nowhere!\n  });\n}\n\n// VULNERABLE - not awaiting inside callback\nitems.forEach(async (item) => {\n  await processItem(item);  // forEach doesn't await this!\n});\n```\n\n**Detection signal:** \n- `async` function using callback-based APIs without promisification\n- `async` callback inside `.forEach()`, `.map()`, etc. without handling the promises\n\n**Fix:**\n```javascript\n// SAFE - use promise version\nconst { readFile } = require('fs/promises');\n\nasync function processFile(path) {\n  const data = await readFile(path);\n  return data;\n}\n\n// SAFE - collect and await promises\nawait Promise.all(items.map(async (item) => {\n  await processItem(item);\n}));\n\n// SAFE - use for...of for sequential async\nfor (const item of items) {\n  await processItem(item);\n}\n```\n\n### Pattern 6: Deadlock Potential\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - lock ordering inconsistency\nasync function transferA(from, to, amount) {\n  await from.lock.acquire();\n  await to.lock.acquire();  // If another transfer does to→from, deadlock\n  // ... transfer ...\n}\n```\n\n**Detection signal:** Multiple lock acquisitions in a function without consistent ordering.\n\n**Fix:**\n```javascript\n// SAFE - consistent lock ordering\nasync function transfer(from, to, amount) {\n  // Always lock lower ID first\n  const [first, second] = from.id < to.id ? [from, to] : [to, from];\n  \n  await first.lock.acquire();\n  try {\n    await second.lock.acquire();\n    try {\n      // ... transfer ...\n    } finally {\n      second.lock.release();\n    }\n  } finally {\n    first.lock.release();\n  }\n}\n\n// SAFE - use try-lock with retry\nasync function transfer(from, to, amount, retries = 3) {\n  for (let i = 0; i < retries; i++) {\n    if (await from.lock.tryAcquire()) {\n      if (await to.lock.tryAcquire()) {\n        try {\n          // ... transfer ...\n          return;\n        } finally {\n          to.lock.release();\n          from.lock.release();\n        }\n      }\n      from.lock.release();\n    }\n    await sleep(Math.random() * 100);  // Random backoff\n  }\n  throw new Error('Could not acquire locks');\n}\n```\n\n### Pattern 7: Unhandled Promise Rejection in Background Task\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - error crashes process in newer Node\nfunction startBackgroundJob() {\n  setInterval(() => {\n    processQueue();  // If this returns rejected promise, unhandled!\n  }, 5000);\n}\n\n// VULNERABLE - fire and forget\nbutton.onclick = () => {\n  submitForm();  // Promise rejection goes nowhere\n};\n```\n\n**Detection signal:** Promise-returning function called without `await` or `.catch()`, especially in event handlers or timers.\n\n**Fix:**\n```javascript\n// SAFE - handle errors in background tasks\nfunction startBackgroundJob() {\n  setInterval(async () => {\n    try {\n      await processQueue();\n    } catch (error) {\n      logger.error('Background job failed', error);\n      // Decide: stop the job? Alert? Continue?\n    }\n  }, 5000);\n}\n\n// SAFE - handle in event handler\nbutton.onclick = async () => {\n  try {\n    await submitForm();\n  } catch (error) {\n    showErrorMessage(error);\n  }\n};\n```\n\n### Pattern 8: Async Initialization Race\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - multiple calls might initialize multiple times\nclass Service {\n  async getClient() {\n    if (!this.client) {\n      this.client = await createClient();  // Race: two calls both see !client\n    }\n    return this.client;\n  }\n}\n```\n\n**Detection signal:** Lazy initialization of async resources without synchronization.\n\n**Fix:**\n```javascript\n// SAFE - store the promise, not the result\nclass Service {\n  getClient() {\n    if (!this.clientPromise) {\n      this.clientPromise = createClient();\n    }\n    return this.clientPromise;  // All callers await same promise\n  }\n}\n\n// SAFE - use mutex for complex initialization\nclass Service {\n  async getClient() {\n    if (!this.client) {\n      await this.initMutex.runExclusive(async () => {\n        if (!this.client) {  // Double-check after acquiring lock\n          this.client = await createClient();\n        }\n      });\n    }\n    return this.client;\n  }\n}\n```\n\n## Quick Reference Table\n\n| Pattern | Detection Signal | Severity | Fix Strategy |\n|---------|------------------|----------|--------------|\n| TOCTOU | Read → check → write sequence | High | Atomic operations or locking |\n| Sequential awaits | Multiple independent awaits | Low | Promise.all for parallelism |\n| Shared mutable state | Module vars in async functions | High | Mutex or atomic operations |\n| Promise.all mutations | Promise.all over write operations | Medium | allSettled or transactions |\n| Callback/Promise mix | async with callback APIs | High | Use promise APIs |\n| Deadlock | Multiple locks without ordering | High | Consistent lock ordering |\n| Unhandled background | Promise without await/catch | High | try/catch in handlers |\n| Async init race | Lazy async init without sync | Medium | Store promise, not result |\n\n## Verification Checklist\n\nFor every code block, scan for:\n\n1. [ ] Read-check-write sequences without atomicity guarantees\n2. [ ] Multiple independent awaits that could be parallelized\n3. [ ] Module-level variables modified by async functions\n4. [ ] Promise.all over mutation operations without transaction\n5. [ ] Callback-based APIs used in async functions without promisification\n6. [ ] forEach/map with async callback without awaiting results\n7. [ ] Multiple lock acquisitions without consistent ordering\n8. [ ] Promise-returning functions called without await or .catch()\n9. [ ] Lazy async initialization without synchronization\n\nIf any found: **FAIL** (High/Medium severity) with location and fix.\n"
    },
    {
      "name": "error-handling-patterns.md",
      "path": "references/error-handling-patterns.md",
      "content": "# Error Handling Patterns\n\nPatterns that indicate missing or improper error handling. These cause silent failures, data corruption, and difficult-to-debug production issues.\n\n## Why This Matters\n\nAI code generators focus on the happy path. They write code that works when everything goes right, but production is where everything goes wrong. A function without error handling is a function waiting to fail silently.\n\nYour job: Ensure every failure path is handled.\n\n## Detection Patterns\n\n### Pattern 1: Unhandled Promise Rejection\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - no catch, no await in try\nasync function processUser(id) {\n  const user = await fetchUser(id);  // What if this fails?\n  await updateStats(user);\n  return user;\n}\n\n// Worse - fire and forget\nfunction handleClick() {\n  submitData();  // Promise ignored entirely\n}\n```\n\n**Detection signal:** \n- `async` function without try/catch around await\n- Promise-returning function call without `.catch()` or `await` in try block\n- Calling async function without `await`\n\n**Fix:**\n```javascript\n// SAFE - explicit error handling\nasync function processUser(id) {\n  try {\n    const user = await fetchUser(id);\n    await updateStats(user);\n    return user;\n  } catch (error) {\n    logger.error('Failed to process user', { id, error });\n    throw new ProcessingError('User processing failed', { cause: error });\n  }\n}\n\n// SAFE - handle the promise\nfunction handleClick() {\n  submitData().catch(error => {\n    showErrorToast('Submission failed');\n    logger.error('Submit failed', error);\n  });\n}\n```\n\n### Pattern 2: Empty Catch Block\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - swallowed exception\ntry {\n  await riskyOperation();\n} catch (e) {\n  // Silently ignored\n}\n\ntry {\n  parseConfig();\n} catch {\n  // \"It's fine\"\n}\n```\n\n**Detection signal:** `catch` block that is empty or contains only a comment.\n\n**Why it's dangerous:** Failures happen silently. You won't know something broke until much later (or never).\n\n**Fix:**\n```javascript\n// SAFE - at minimum, log it\ntry {\n  await riskyOperation();\n} catch (error) {\n  logger.error('Risky operation failed', error);\n  // Then decide: rethrow, return default, or recover\n}\n\n// SAFE - intentional ignore with documentation\ntry {\n  await optionalCleanup();\n} catch (error) {\n  // Intentionally ignored: cleanup failure shouldn't block main flow\n  // But still log for observability\n  logger.debug('Optional cleanup failed', error);\n}\n```\n\n### Pattern 3: Missing Null/Undefined Checks\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - assumes user exists\nfunction getDisplayName(user) {\n  return user.firstName + ' ' + user.lastName;\n}\n\n// VULNERABLE - assumes nested property exists\nconst city = response.data.user.address.city;\n```\n\n**Detection signal:** Property access on values that could be null/undefined, especially from:\n- Function parameters\n- API responses\n- Database queries\n- Optional chaining candidates\n\n**Fix:**\n```javascript\n// SAFE - explicit check\nfunction getDisplayName(user) {\n  if (!user) {\n    throw new ArgumentError('User is required');\n  }\n  return `${user.firstName ?? ''} ${user.lastName ?? ''}`.trim();\n}\n\n// SAFE - optional chaining with fallback\nconst city = response?.data?.user?.address?.city ?? 'Unknown';\n\n// SAFE - validation at boundary\nif (!response?.data?.user) {\n  throw new ApiError('Invalid response: missing user');\n}\n```\n\n### Pattern 4: Catching Too Broadly\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - catches everything, including bugs\ntry {\n  const data = JSON.parse(input);\n  processData(data);\n  saveToDatabase(data);\n} catch (e) {\n  return { error: 'Something went wrong' };  // What went wrong??\n}\n```\n\n**Detection signal:** Single try/catch around multiple operations with generic error handling.\n\n**Why it's dangerous:** Programming errors (typos, null references) get treated like data errors. You lose stack traces and specificity.\n\n**Fix:**\n```javascript\n// SAFE - catch specific errors, let bugs bubble\ntry {\n  const data = JSON.parse(input);\n  processData(data);\n  await saveToDatabase(data);\n} catch (error) {\n  if (error instanceof SyntaxError) {\n    return { error: 'Invalid JSON input' };\n  }\n  if (error instanceof ValidationError) {\n    return { error: error.message };\n  }\n  if (error instanceof DatabaseError) {\n    logger.error('Database save failed', error);\n    return { error: 'Failed to save data' };\n  }\n  // Unknown error - rethrow to crash (it's probably a bug)\n  throw error;\n}\n```\n\n### Pattern 5: Error Information Leakage\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - exposes internals\napp.use((err, req, res, next) => {\n  res.status(500).json({\n    error: err.message,\n    stack: err.stack,\n    query: err.sql  // Exposes database schema!\n  });\n});\n```\n\n**Detection signal:** Error objects, stack traces, or internal details in API responses.\n\n**Why it's dangerous:** Attackers learn about your system's internals—file paths, database schema, library versions.\n\n**Fix:**\n```javascript\n// SAFE - generic external message, detailed internal logging\napp.use((err, req, res, next) => {\n  // Log full details internally\n  logger.error('Request failed', {\n    error: err.message,\n    stack: err.stack,\n    requestId: req.id,\n    path: req.path\n  });\n  \n  // Return generic message externally\n  const status = err.status || 500;\n  res.status(status).json({\n    error: status >= 500 ? 'Internal server error' : err.message,\n    requestId: req.id  // For support correlation\n  });\n});\n```\n\n### Pattern 6: No Timeout on External Calls\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - waits forever\nconst response = await fetch('https://external-api.com/data');\nconst result = await db.query('SELECT * FROM large_table');\n```\n\n**Detection signal:** HTTP requests, database queries, or other I/O without explicit timeout.\n\n**Why it's dangerous:** If external service hangs, your service hangs. Resource exhaustion follows.\n\n**Fix:**\n```javascript\n// SAFE - explicit timeout\nconst controller = new AbortController();\nconst timeout = setTimeout(() => controller.abort(), 5000);\n\ntry {\n  const response = await fetch('https://external-api.com/data', {\n    signal: controller.signal\n  });\n} finally {\n  clearTimeout(timeout);\n}\n\n// SAFE - database timeout\nconst result = await db.query('SELECT * FROM large_table', {\n  timeout: 10000  // 10 seconds\n});\n```\n\n### Pattern 7: Inadequate Finally Block\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - connection not released on error\nasync function queryData() {\n  const conn = await pool.getConnection();\n  const result = await conn.query('SELECT * FROM users');\n  conn.release();  // Never reached if query throws\n  return result;\n}\n```\n\n**Detection signal:** Resource acquisition followed by operations, with cleanup only in the success path.\n\n**Fix:**\n```javascript\n// SAFE - cleanup in finally\nasync function queryData() {\n  const conn = await pool.getConnection();\n  try {\n    return await conn.query('SELECT * FROM users');\n  } finally {\n    conn.release();  // Always runs\n  }\n}\n\n// SAFE - use patterns that handle cleanup\nconst result = await pool.query('SELECT * FROM users');  // Pool handles connection\n```\n\n### Pattern 8: Assumptions About External Data\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - assumes API returns expected shape\nconst response = await fetch('/api/user');\nconst data = await response.json();\nconst userName = data.user.name;  // What if data.user is undefined?\n```\n\n**Detection signal:** Parsing external responses and immediately accessing nested properties.\n\n**Fix:**\n```javascript\n// SAFE - validate response shape\nconst response = await fetch('/api/user');\nif (!response.ok) {\n  throw new ApiError(`API returned ${response.status}`);\n}\n\nconst data = await response.json();\nif (!data?.user?.name) {\n  throw new ApiError('Invalid response: missing user.name');\n}\nconst userName = data.user.name;\n\n// Or use schema validation\nconst data = UserResponseSchema.parse(await response.json());\n```\n\n### Pattern 9: Error in Error Handler\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - error handler can throw\ntry {\n  await processData();\n} catch (error) {\n  await logToExternalService(error);  // What if this fails?\n  throw error;\n}\n```\n\n**Detection signal:** Async operations or potentially-throwing code inside catch blocks.\n\n**Fix:**\n```javascript\n// SAFE - error handler is defensive\ntry {\n  await processData();\n} catch (error) {\n  try {\n    await logToExternalService(error);\n  } catch (loggingError) {\n    console.error('Failed to log error', loggingError);\n    // Don't let logging failure mask original error\n  }\n  throw error;\n}\n```\n\n### Pattern 10: Non-Atomic Check-Then-Act\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - race condition in error handling\nif (await fileExists(path)) {\n  const content = await readFile(path);  // File might be deleted between check and read\n}\n```\n\n**Detection signal:** Existence check followed by operation on the same resource.\n\n**Fix:**\n```javascript\n// SAFE - just try it and handle failure\ntry {\n  const content = await readFile(path);\n} catch (error) {\n  if (error.code === 'ENOENT') {\n    // File doesn't exist - handle gracefully\n    return null;\n  }\n  throw error;  // Some other error\n}\n```\n\n## Quick Reference Table\n\n| Pattern | Detection Signal | Severity | Fix Strategy |\n|---------|------------------|----------|--------------|\n| Unhandled Promise | await without try/catch | High | Add try/catch or .catch() |\n| Empty Catch | Empty catch block | High | Log and handle or rethrow |\n| Missing Null Check | Property access on uncertain values | Medium | Optional chaining + validation |\n| Broad Catch | Single catch for multiple ops | Medium | Catch specific error types |\n| Error Leakage | Error details in response | Medium | Generic external, detailed internal |\n| No Timeout | External calls without timeout | High | Add explicit timeouts |\n| Missing Finally | Cleanup only in success path | High | Move cleanup to finally |\n| Assumed Shape | Nested access on external data | Medium | Validate before access |\n| Error in Handler | Async ops in catch | Medium | Defensive error handler |\n| Check-Then-Act | Existence check then operation | Medium | Try and catch instead |\n\n## Verification Checklist\n\nFor every code block, scan for:\n\n1. [ ] Async functions without try/catch around awaits\n2. [ ] Promise-returning calls without await or .catch()\n3. [ ] Empty or comment-only catch blocks\n4. [ ] Property access on values that could be null/undefined\n5. [ ] Single catch block around multiple distinct operations\n6. [ ] Error objects or stack traces in API responses\n7. [ ] External HTTP/database calls without timeouts\n8. [ ] Resource acquisition without finally cleanup\n9. [ ] External API responses accessed without shape validation\n10. [ ] Existence checks followed by operations (check-then-act)\n\nIf any found: **FAIL** with location and fix.\n"
    },
    {
      "name": "memory-patterns.md",
      "path": "references/memory-patterns.md",
      "content": "# Memory Patterns\n\nPatterns that indicate memory leaks, unbounded growth, or stack overflow risks. These cause slow degradation and eventual crashes—the worst kind of production issue.\n\n## Why This Matters\n\nMemory issues are insidious. They don't fail immediately—they fail after hours or days in production. AI-generated code often creates closures and event handlers without considering cleanup. By the time you notice memory growing, the damage is done.\n\nYour job: Catch memory leaks before they reach production.\n\n## Detection Patterns\n\n### Pattern 1: Event Listener Without Cleanup\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - listener never removed\nfunction MyComponent() {\n  useEffect(() => {\n    window.addEventListener('resize', handleResize);\n    // No cleanup!\n  }, []);\n}\n\nclass Tracker {\n  start() {\n    document.addEventListener('click', this.onClick);\n    // Never removed\n  }\n}\n```\n\n**Detection signal:** `addEventListener` without corresponding `removeEventListener` in cleanup/destructor.\n\n**Why it leaks:** Each component mount adds a new listener. Listeners hold references to component closures, preventing garbage collection.\n\n**Fix:**\n```javascript\n// SAFE - cleanup in useEffect return\nfunction MyComponent() {\n  useEffect(() => {\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n}\n\n// SAFE - cleanup in class destructor\nclass Tracker {\n  start() {\n    document.addEventListener('click', this.onClick);\n  }\n  stop() {\n    document.removeEventListener('click', this.onClick);\n  }\n}\n```\n\n### Pattern 2: Closure Capturing Too Much\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - closure captures entire large object\nfunction createHandler(hugeData) {\n  return () => {\n    console.log(hugeData.items[0].name);  // Only needs one property\n  };\n  // hugeData stays in memory as long as handler exists\n}\n\n// VULNERABLE - closure in long-lived callback\nfunction setup(config) {\n  setInterval(() => {\n    // This closure keeps 'config' alive forever\n    ping(config.endpoint);\n  }, 60000);\n}\n```\n\n**Detection signal:** Functions returned or passed as callbacks that reference outer scope variables, especially large objects or objects containing large objects.\n\n**Fix:**\n```javascript\n// SAFE - extract only what's needed\nfunction createHandler(hugeData) {\n  const name = hugeData.items[0].name;\n  return () => {\n    console.log(name);  // Only captures the string\n  };\n}\n\n// SAFE - extract needed values\nfunction setup(config) {\n  const endpoint = config.endpoint;\n  setInterval(() => {\n    ping(endpoint);  // Only captures string\n  }, 60000);\n}\n```\n\n### Pattern 3: Unbounded Cache or Collection\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - cache grows forever\nconst cache = {};\nfunction getData(id) {\n  if (!cache[id]) {\n    cache[id] = fetchData(id);\n  }\n  return cache[id];\n}\n\n// VULNERABLE - history grows forever\nconst history = [];\nfunction recordAction(action) {\n  history.push(action);\n}\n```\n\n**Detection signal:** Objects/arrays that only have additions (push, set) without removals or size limits.\n\n**Fix:**\n```javascript\n// SAFE - bounded cache with LRU eviction\nconst cache = new Map();\nconst MAX_CACHE_SIZE = 1000;\n\nfunction getData(id) {\n  if (cache.has(id)) {\n    const value = cache.get(id);\n    // Move to end (most recently used)\n    cache.delete(id);\n    cache.set(id, value);\n    return value;\n  }\n  \n  const value = fetchData(id);\n  cache.set(id, value);\n  \n  // Evict oldest if over limit\n  if (cache.size > MAX_CACHE_SIZE) {\n    const oldest = cache.keys().next().value;\n    cache.delete(oldest);\n  }\n  \n  return value;\n}\n\n// SAFE - bounded history\nconst MAX_HISTORY = 100;\nfunction recordAction(action) {\n  history.push(action);\n  if (history.length > MAX_HISTORY) {\n    history.shift();  // Remove oldest\n  }\n}\n```\n\n### Pattern 4: Subscription Without Unsubscribe\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - subscription never cancelled\nuseEffect(() => {\n  const subscription = eventBus.subscribe('update', handleUpdate);\n  // No unsubscribe!\n}, []);\n\n// VULNERABLE - observable subscription leak\nfunction loadData() {\n  dataService.getData().subscribe(data => {\n    this.data = data;\n  });\n  // Subscription lives forever\n}\n```\n\n**Detection signal:** `.subscribe()`, `.on()`, or similar subscription patterns without corresponding cleanup.\n\n**Fix:**\n```javascript\n// SAFE - unsubscribe in cleanup\nuseEffect(() => {\n  const subscription = eventBus.subscribe('update', handleUpdate);\n  return () => subscription.unsubscribe();\n}, []);\n\n// SAFE - store and clean up subscription\nclass DataComponent {\n  private subscription: Subscription;\n  \n  loadData() {\n    this.subscription = dataService.getData().subscribe(data => {\n      this.data = data;\n    });\n  }\n  \n  destroy() {\n    this.subscription?.unsubscribe();\n  }\n}\n```\n\n### Pattern 5: Timer Without Cleanup\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - interval never cleared\nfunction startPolling() {\n  setInterval(() => {\n    checkForUpdates();\n  }, 5000);\n}\n\n// VULNERABLE - component creates interval without cleanup\nuseEffect(() => {\n  setInterval(tick, 1000);\n}, []);\n```\n\n**Detection signal:** `setInterval` or `setTimeout` (in loops/recursion) without `clearInterval`/`clearTimeout`.\n\n**Fix:**\n```javascript\n// SAFE - store and clear interval\nfunction startPolling() {\n  const intervalId = setInterval(() => {\n    checkForUpdates();\n  }, 5000);\n  \n  return () => clearInterval(intervalId);  // Return cleanup function\n}\n\n// SAFE - cleanup in useEffect\nuseEffect(() => {\n  const intervalId = setInterval(tick, 1000);\n  return () => clearInterval(intervalId);\n}, []);\n```\n\n### Pattern 6: Circular References\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - circular reference\nconst parent = { name: 'parent' };\nconst child = { name: 'child', parent: parent };\nparent.child = child;  // Circular\n\n// VULNERABLE - self-referential closure\nfunction createNode() {\n  const node = {\n    process: () => {\n      return node.value * 2;  // Closure references node\n    }\n  };\n  return node;\n}\n```\n\n**Detection signal:** Object A references B, B references A. Or closure references the object it's attached to.\n\n**Why it matters:** Modern GCs handle this, but it can prevent cleanup in some contexts (WeakMap, certain frameworks) and makes debugging harder.\n\n**Fix:**\n```javascript\n// SAFE - break circular reference when done\nfunction cleanup() {\n  parent.child = null;\n  child.parent = null;\n}\n\n// SAFE - pass value explicitly\nfunction createNode() {\n  const node = {\n    process: function() {\n      return this.value * 2;  // Uses 'this' instead of closure\n    }\n  };\n  return node;\n}\n```\n\n### Pattern 7: Deep Recursion Without Limit\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - can overflow stack\nfunction processTree(node) {\n  process(node);\n  for (const child of node.children) {\n    processTree(child);  // No depth limit\n  }\n}\n\n// VULNERABLE - recursive with user input\nfunction parse(input, depth = 0) {\n  // No maximum depth check\n  return input.children.map(c => parse(c, depth + 1));\n}\n```\n\n**Detection signal:** Recursive functions without explicit depth limit, especially when processing user input or external data.\n\n**Why it's dangerous:** Stack size is limited (typically 10-20K frames). Malicious or malformed input can crash the process.\n\n**Fix:**\n```javascript\n// SAFE - explicit depth limit\nconst MAX_DEPTH = 100;\n\nfunction processTree(node, depth = 0) {\n  if (depth > MAX_DEPTH) {\n    throw new Error('Maximum tree depth exceeded');\n  }\n  process(node);\n  for (const child of node.children) {\n    processTree(child, depth + 1);\n  }\n}\n\n// SAFE - iterative approach for arbitrary depth\nfunction processTree(root) {\n  const stack = [root];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    process(node);\n    stack.push(...node.children);\n  }\n}\n```\n\n### Pattern 8: Held References in Static/Global Scope\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - static reference to instance\nclass Service {\n  static instance = null;\n  static lastRequest = null;  // Holds reference to potentially large request\n  \n  handleRequest(req) {\n    Service.lastRequest = req;  // Stored forever\n    // ...\n  }\n}\n```\n\n**Detection signal:** Static class properties or module-level variables that store instance references.\n\n**Fix:**\n```javascript\n// SAFE - use WeakRef for optional caching\nclass Service {\n  static lastRequestRef = null;\n  \n  handleRequest(req) {\n    Service.lastRequestRef = new WeakRef(req);  // Can be GC'd\n    // ...\n  }\n  \n  getLastRequest() {\n    return Service.lastRequestRef?.deref();  // May return undefined\n  }\n}\n\n// Or just don't store it statically if not needed\n```\n\n## Quick Reference Table\n\n| Pattern | Detection Signal | Severity | Fix Strategy |\n|---------|------------------|----------|--------------|\n| Event listener leak | addEventListener without remove | High | Remove in cleanup/destructor |\n| Closure capture | Callback referencing large objects | Medium | Extract needed values |\n| Unbounded cache | Collection without size limit | High | Add max size + eviction |\n| Subscription leak | .subscribe() without unsubscribe | High | Store and cleanup subscription |\n| Timer leak | setInterval without clear | High | Store ID, clear on cleanup |\n| Circular reference | Object A ↔ B | Low | Break refs when done |\n| Deep recursion | Recursive fn without depth limit | High | Add limit or use iteration |\n| Static references | Module/static vars holding instances | Medium | WeakRef or scoped storage |\n\n## Verification Checklist\n\nFor every code block, scan for:\n\n1. [ ] addEventListener without matching removeEventListener in cleanup\n2. [ ] Closures passed to long-lived callbacks (timers, event handlers) that capture large objects\n3. [ ] Objects/arrays with push/set but no removal or size limits\n4. [ ] .subscribe(), .on() without corresponding cleanup\n5. [ ] setInterval without clearInterval in cleanup path\n6. [ ] Mutual object references (A.b = B; B.a = A)\n7. [ ] Recursive functions without maximum depth enforcement\n8. [ ] Static/module-level variables that store instance references\n\nIf any found: **FAIL** with location and fix.\n"
    },
    {
      "name": "resource-patterns.md",
      "path": "references/resource-patterns.md",
      "content": "# Resource Patterns\n\nPatterns that indicate improper resource management—connections, files, handles, and external dependencies. These cause exhaustion and cascading failures.\n\n## Why This Matters\n\nEvery external resource is limited. Database connections, file handles, HTTP sockets, memory—all have caps. AI-generated code often acquires resources without releasing them, or holds them longer than necessary. At low load, this works. At production load, you run out.\n\nYour job: Ensure every acquisition has a release, and every external call has a timeout.\n\n## Detection Patterns\n\n### Pattern 1: Database Connection Not Released\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - connection never returned to pool\nasync function getUser(id) {\n  const conn = await pool.getConnection();\n  const result = await conn.query('SELECT * FROM users WHERE id = ?', [id]);\n  return result[0];  // Connection leaked if error or just... forgotten\n}\n\n// VULNERABLE - released only on success path\nasync function updateUser(id, data) {\n  const conn = await pool.getConnection();\n  const result = await conn.query('UPDATE users SET ...', [...]);\n  conn.release();  // Never reached if query throws\n  return result;\n}\n```\n\n**Detection signal:** `pool.getConnection()` without `release()` in a `finally` block.\n\n**Why it's dangerous:** Pool exhaustion. New requests wait for connections that will never return. Eventually, everything times out.\n\n**Fix:**\n```javascript\n// SAFE - finally guarantees cleanup\nasync function getUser(id) {\n  const conn = await pool.getConnection();\n  try {\n    const result = await conn.query('SELECT * FROM users WHERE id = ?', [id]);\n    return result[0];\n  } finally {\n    conn.release();\n  }\n}\n\n// BETTER - use pool.query() which handles this\nasync function getUser(id) {\n  const result = await pool.query('SELECT * FROM users WHERE id = ?', [id]);\n  return result[0];\n}\n\n// BEST - use a wrapper that ensures cleanup\nasync function withConnection(fn) {\n  const conn = await pool.getConnection();\n  try {\n    return await fn(conn);\n  } finally {\n    conn.release();\n  }\n}\n\nconst user = await withConnection(conn => \n  conn.query('SELECT * FROM users WHERE id = ?', [id])\n);\n```\n\n### Pattern 2: File Handle Not Closed\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - file handle leaked\nasync function readConfig(path) {\n  const file = await fs.open(path, 'r');\n  const content = await file.readFile();\n  return JSON.parse(content);\n  // file.close() never called\n}\n\n// VULNERABLE - stream not closed on error\nfunction processLargeFile(path) {\n  const stream = fs.createReadStream(path);\n  stream.on('data', chunk => {\n    process(chunk);  // If this throws, stream stays open\n  });\n}\n```\n\n**Detection signal:** `fs.open()` or `createReadStream/WriteStream` without corresponding `close()` or error handling.\n\n**Fix:**\n```javascript\n// SAFE - finally cleanup\nasync function readConfig(path) {\n  const file = await fs.open(path, 'r');\n  try {\n    const content = await file.readFile();\n    return JSON.parse(content);\n  } finally {\n    await file.close();\n  }\n}\n\n// SAFE - use convenience methods that handle cleanup\nasync function readConfig(path) {\n  const content = await fs.readFile(path, 'utf8');\n  return JSON.parse(content);\n}\n\n// SAFE - proper stream error handling\nfunction processLargeFile(path) {\n  return new Promise((resolve, reject) => {\n    const stream = fs.createReadStream(path);\n    \n    stream.on('data', chunk => {\n      try {\n        process(chunk);\n      } catch (err) {\n        stream.destroy();\n        reject(err);\n      }\n    });\n    \n    stream.on('end', resolve);\n    stream.on('error', reject);\n  });\n}\n```\n\n### Pattern 3: HTTP Client Without Timeout\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - waits forever\nconst response = await fetch('https://external-api.com/data');\n\nconst response = await axios.get('https://external-api.com/data');\n\n// VULNERABLE - timeout only on connect, not read\nconst response = await fetch(url, {\n  timeout: 5000  // This isn't even a real option in standard fetch!\n});\n```\n\n**Detection signal:** HTTP client calls (`fetch`, `axios`, `got`, `request`) without explicit timeout configuration.\n\n**Fix:**\n```javascript\n// SAFE - AbortController with timeout\nasync function fetchWithTimeout(url, timeoutMs = 5000) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n  \n  try {\n    const response = await fetch(url, { signal: controller.signal });\n    return response;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n// SAFE - axios with timeout\nconst response = await axios.get('https://external-api.com/data', {\n  timeout: 5000  // Axios actually supports this\n});\n\n// SAFE - got with timeout (best support)\nconst response = await got('https://external-api.com/data', {\n  timeout: {\n    lookup: 100,\n    connect: 500,\n    secureConnect: 500,\n    socket: 1000,\n    send: 5000,\n    response: 5000\n  }\n});\n```\n\n### Pattern 4: Missing Circuit Breaker\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - keeps hitting failing service\nasync function getRecommendations(userId) {\n  const response = await fetch('https://recommendation-service/api/' + userId);\n  return response.json();\n}\n// Service is down → every request tries → every request waits → cascade\n```\n\n**Detection signal:** External service calls without failure detection or fallback.\n\n**Fix:**\n```javascript\n// SAFE - circuit breaker pattern\nclass CircuitBreaker {\n  constructor(options = {}) {\n    this.failureThreshold = options.failureThreshold || 5;\n    this.resetTimeout = options.resetTimeout || 30000;\n    this.failures = 0;\n    this.lastFailure = null;\n    this.state = 'CLOSED';\n  }\n\n  async call(fn) {\n    if (this.state === 'OPEN') {\n      if (Date.now() - this.lastFailure > this.resetTimeout) {\n        this.state = 'HALF-OPEN';\n      } else {\n        throw new CircuitOpenError('Circuit breaker is open');\n      }\n    }\n\n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  onSuccess() {\n    this.failures = 0;\n    this.state = 'CLOSED';\n  }\n\n  onFailure() {\n    this.failures++;\n    this.lastFailure = Date.now();\n    if (this.failures >= this.failureThreshold) {\n      this.state = 'OPEN';\n    }\n  }\n}\n\nconst recommendationBreaker = new CircuitBreaker();\n\nasync function getRecommendations(userId) {\n  try {\n    return await recommendationBreaker.call(() =>\n      fetch('https://recommendation-service/api/' + userId).then(r => r.json())\n    );\n  } catch (error) {\n    if (error instanceof CircuitOpenError) {\n      return getDefaultRecommendations();  // Fallback\n    }\n    throw error;\n  }\n}\n```\n\n### Pattern 5: Unbounded Queue or Buffer\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - queue grows without limit\nconst jobQueue = [];\n\nfunction enqueue(job) {\n  jobQueue.push(job);\n}\n\n// Producer is faster than consumer → memory exhaustion\n```\n\n**Detection signal:** Array or collection used as queue without size limit or backpressure.\n\n**Fix:**\n```javascript\n// SAFE - bounded queue with backpressure\nclass BoundedQueue {\n  constructor(maxSize = 1000) {\n    this.maxSize = maxSize;\n    this.queue = [];\n  }\n\n  enqueue(item) {\n    if (this.queue.length >= this.maxSize) {\n      throw new QueueFullError('Queue at capacity');\n      // Or: return false, or block, or drop oldest\n    }\n    this.queue.push(item);\n  }\n\n  dequeue() {\n    return this.queue.shift();\n  }\n}\n\n// SAFE - use proper job queue library\nconst Queue = require('bull');\nconst jobQueue = new Queue('jobs', {\n  limiter: {\n    max: 1000,\n    duration: 60000\n  }\n});\n```\n\n### Pattern 6: Connection Pool Misconfiguration\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - new connection per request\nasync function query(sql) {\n  const conn = await mysql.createConnection({...});\n  const result = await conn.query(sql);\n  await conn.end();\n  return result;\n}\n\n// VULNERABLE - pool too small for load\nconst pool = mysql.createPool({\n  connectionLimit: 5  // But you have 50 concurrent requests\n});\n```\n\n**Detection signal:** \n- `createConnection` instead of pool\n- Pool with suspiciously small `connectionLimit`\n\n**Fix:**\n```javascript\n// SAFE - properly sized pool\nconst pool = mysql.createPool({\n  connectionLimit: 20,  // Based on expected concurrency\n  queueLimit: 0,  // Unlimited queue (or set reasonable limit)\n  waitForConnections: true,\n  acquireTimeout: 10000  // Don't wait forever\n});\n\n// Rule of thumb: connectionLimit ≈ max_concurrent_requests / 2\n// Because connections can handle multiple queries via pipelining\n```\n\n### Pattern 7: Transaction Not Committed or Rolled Back\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - transaction left open\nasync function updateData(data) {\n  const trx = await db.transaction();\n  await trx.query('UPDATE ...');\n  // No commit or rollback!\n  // Transaction stays open, locks held\n}\n\n// VULNERABLE - commit only on success path\nasync function updateData(data) {\n  const trx = await db.transaction();\n  await trx.query('UPDATE ...');\n  await trx.commit();  // Never reached if query throws\n}\n```\n\n**Detection signal:** `db.transaction()` without `commit()` and `rollback()` in try/catch/finally.\n\n**Fix:**\n```javascript\n// SAFE - explicit try/finally\nasync function updateData(data) {\n  const trx = await db.transaction();\n  try {\n    await trx.query('UPDATE ...');\n    await trx.commit();\n  } catch (error) {\n    await trx.rollback();\n    throw error;\n  }\n}\n\n// BETTER - use callback pattern that handles this\nasync function updateData(data) {\n  await db.transaction(async (trx) => {\n    await trx.query('UPDATE ...');\n    // Auto-commits on success, auto-rollbacks on error\n  });\n}\n```\n\n### Pattern 8: Missing Retry with Backoff\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - immediate retry hammers failing service\nasync function fetchData() {\n  for (let i = 0; i < 3; i++) {\n    try {\n      return await fetch(url);\n    } catch (err) {\n      // Immediately retry\n    }\n  }\n  throw new Error('Failed after 3 attempts');\n}\n```\n\n**Detection signal:** Retry loops without delay or with fixed delay.\n\n**Fix:**\n```javascript\n// SAFE - exponential backoff\nasync function fetchWithRetry(url, options = {}) {\n  const { maxRetries = 3, baseDelay = 1000 } = options;\n  \n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fetch(url);\n    } catch (error) {\n      if (attempt === maxRetries) throw error;\n      \n      const delay = baseDelay * Math.pow(2, attempt);\n      const jitter = Math.random() * delay * 0.1;\n      await sleep(delay + jitter);\n    }\n  }\n}\n\n// SAFE - use retry library\nconst retry = require('async-retry');\n\nconst result = await retry(\n  async () => {\n    const response = await fetch(url);\n    if (!response.ok) throw new Error('Request failed');\n    return response.json();\n  },\n  {\n    retries: 3,\n    minTimeout: 1000,\n    maxTimeout: 10000,\n    randomize: true\n  }\n);\n```\n\n## Quick Reference Table\n\n| Pattern | Detection Signal | Severity | Fix Strategy |\n|---------|------------------|----------|--------------|\n| Connection leak | getConnection without release in finally | High | finally cleanup or use pool.query |\n| File handle leak | fs.open without close | High | finally cleanup or convenience methods |\n| Missing timeout | HTTP calls without timeout option | High | AbortController or library timeout |\n| No circuit breaker | External calls without failure handling | Medium | Implement circuit breaker + fallback |\n| Unbounded queue | Collection as queue without limit | High | Bounded queue with backpressure |\n| Pool misconfigured | createConnection or tiny connectionLimit | Medium | Use pool with appropriate size |\n| Transaction leak | transaction without commit/rollback | High | try/finally or callback pattern |\n| Retry without backoff | Retry loop without delay | Medium | Exponential backoff with jitter |\n\n## Verification Checklist\n\nFor every code block, scan for:\n\n1. [ ] pool.getConnection() without release() in finally\n2. [ ] fs.open() or createReadStream without close\n3. [ ] HTTP client calls (fetch, axios) without timeout\n4. [ ] External service calls without circuit breaker or fallback\n5. [ ] Arrays/collections used as queues without size limits\n6. [ ] createConnection() instead of connection pool\n7. [ ] Connection pools with suspiciously small limits\n8. [ ] db.transaction() without commit/rollback in try/catch\n9. [ ] Retry loops without exponential backoff\n\nIf any found: **FAIL** with location and fix.\n"
    },
    {
      "name": "security-patterns.md",
      "path": "references/security-patterns.md",
      "content": "# Security Patterns\n\nPatterns that indicate security vulnerabilities. These are critical failures—security issues must be fixed before code leaves the development loop.\n\n## Why This Matters\n\nAI code generators produce functionally correct code that often has security holes. They generate the \"obvious\" solution without considering adversarial input. A working login form with SQL injection is worse than no login form at all.\n\nYour job: Catch these before they become breach headlines.\n\n## Detection Patterns\n\n### Pattern 1: SQL Injection\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - string interpolation in SQL\nconst query = `SELECT * FROM users WHERE id = ${userId}`;\nconst query = \"SELECT * FROM users WHERE name = '\" + userName + \"'\";\n```\n\n**Detection signal:** Template literals or string concatenation containing SQL keywords (`SELECT`, `INSERT`, `UPDATE`, `DELETE`, `WHERE`, `FROM`).\n\n**Why it's dangerous:** User input like `'; DROP TABLE users; --` becomes part of the query.\n\n**Fix:**\n```javascript\n// SAFE - parameterized query\nconst query = 'SELECT * FROM users WHERE id = $1';\nconst result = await db.query(query, [userId]);\n\n// Or with ORM\nconst user = await User.findOne({ where: { id: userId } });\n```\n\n### Pattern 2: NoSQL Injection\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - user input directly in query object\nconst user = await User.findOne({ \n  email: req.body.email,\n  password: req.body.password  // Could be { $gt: \"\" }\n});\n```\n\n**Detection signal:** Request body or query params used directly in MongoDB/NoSQL query objects.\n\n**Why it's dangerous:** User can pass `{ \"$gt\": \"\" }` as password, which matches any non-empty password.\n\n**Fix:**\n```javascript\n// SAFE - explicit string coercion\nconst user = await User.findOne({ \n  email: String(req.body.email),\n  password: String(req.body.password)\n});\n\n// Or validate input types explicitly\nif (typeof req.body.password !== 'string') {\n  throw new ValidationError('Invalid password format');\n}\n```\n\n### Pattern 3: Cross-Site Scripting (XSS)\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - unescaped user content in HTML\nelement.innerHTML = userInput;\ndocument.write(userInput);\nreturn `<div>${userComment}</div>`;  // Server-side rendering\n```\n\n**Detection signal:** User-derived values assigned to `innerHTML`, `outerHTML`, `document.write()`, or interpolated into HTML strings server-side.\n\n**Why it's dangerous:** User input like `<script>stealCookies()</script>` executes in other users' browsers.\n\n**Fix:**\n```javascript\n// SAFE - use textContent for text\nelement.textContent = userInput;\n\n// SAFE - use framework escaping (React does this automatically)\nreturn <div>{userComment}</div>;\n\n// SAFE - explicit sanitization if HTML needed\nimport DOMPurify from 'dompurify';\nelement.innerHTML = DOMPurify.sanitize(userInput);\n```\n\n### Pattern 4: Command Injection\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - user input in shell command\nconst exec = require('child_process').exec;\nexec(`convert ${filename} output.png`);\nexec('grep ' + searchTerm + ' /var/log/app.log');\n```\n\n**Detection signal:** User-derived values in `exec()`, `execSync()`, `spawn()` with `shell: true`, or any system command string.\n\n**Why it's dangerous:** User input like `; rm -rf /` becomes part of the command.\n\n**Fix:**\n```javascript\n// SAFE - use spawn with argument array (no shell)\nconst { spawn } = require('child_process');\nspawn('convert', [filename, 'output.png']);\n\n// SAFE - use library that handles escaping\n// Or avoid shell entirely—use native libraries instead\n```\n\n### Pattern 5: Path Traversal\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - user controls file path\nconst filePath = `./uploads/${req.params.filename}`;\nconst content = fs.readFileSync(filePath);\n\napp.get('/files/:path', (req, res) => {\n  res.sendFile(req.params.path);\n});\n```\n\n**Detection signal:** User-derived values used in file paths, especially with `../` potential.\n\n**Why it's dangerous:** User input like `../../../etc/passwd` accesses files outside intended directory.\n\n**Fix:**\n```javascript\n// SAFE - validate and normalize path\nconst path = require('path');\n\nconst safePath = path.normalize(req.params.filename).replace(/^(\\.\\.(\\/|\\\\|$))+/, '');\nconst fullPath = path.join(__dirname, 'uploads', safePath);\n\n// Verify it's still within allowed directory\nif (!fullPath.startsWith(path.join(__dirname, 'uploads'))) {\n  throw new ForbiddenError('Invalid path');\n}\n```\n\n### Pattern 6: Missing Authentication\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - no auth check on sensitive endpoint\napp.delete('/api/users/:id', async (req, res) => {\n  await User.destroy({ where: { id: req.params.id } });\n  res.json({ success: true });\n});\n```\n\n**Detection signal:** Mutation endpoints (POST, PUT, DELETE) without authentication middleware or checks.\n\n**Why it's dangerous:** Anyone can delete any user.\n\n**Fix:**\n```javascript\n// SAFE - authentication required\napp.delete('/api/users/:id', requireAuth, async (req, res) => {\n  // Plus authorization check\n  if (req.user.id !== req.params.id && !req.user.isAdmin) {\n    throw new ForbiddenError('Cannot delete other users');\n  }\n  await User.destroy({ where: { id: req.params.id } });\n  res.json({ success: true });\n});\n```\n\n### Pattern 7: Insecure Direct Object Reference (IDOR)\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - no ownership check\napp.get('/api/orders/:orderId', requireAuth, async (req, res) => {\n  const order = await Order.findById(req.params.orderId);\n  res.json(order);  // Returns ANY order, not just user's\n});\n```\n\n**Detection signal:** Resource lookup by ID without filtering by current user's ownership.\n\n**Why it's dangerous:** User can access other users' data by guessing/incrementing IDs.\n\n**Fix:**\n```javascript\n// SAFE - include ownership in query\napp.get('/api/orders/:orderId', requireAuth, async (req, res) => {\n  const order = await Order.findOne({\n    where: { \n      id: req.params.orderId,\n      userId: req.user.id  // Only return if owned by current user\n    }\n  });\n  if (!order) throw new NotFoundError('Order not found');\n  res.json(order);\n});\n```\n\n### Pattern 8: Sensitive Data Exposure\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - password hash in response\napp.get('/api/users/:id', async (req, res) => {\n  const user = await User.findById(req.params.id);\n  res.json(user);  // Includes passwordHash, maybe SSN, etc.\n});\n\n// VULNERABLE - sensitive data in logs\nconsole.log('Login attempt:', { email, password });\nlogger.info('Payment processed', { cardNumber, cvv });\n```\n\n**Detection signal:** \n- Model objects returned directly without field filtering\n- Logging statements containing auth credentials, PII, or payment info\n\n**Fix:**\n```javascript\n// SAFE - explicit field selection\napp.get('/api/users/:id', async (req, res) => {\n  const user = await User.findById(req.params.id, {\n    attributes: ['id', 'name', 'email', 'createdAt']  // Whitelist\n  });\n  res.json(user);\n});\n\n// SAFE - redact sensitive fields\nconst { password, ...safeUser } = user.toJSON();\nres.json(safeUser);\n\n// SAFE - structured logging without sensitive data\nlogger.info('Payment processed', { \n  userId, \n  amount, \n  last4: cardNumber.slice(-4) \n});\n```\n\n### Pattern 9: Hardcoded Secrets\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - secrets in code\nconst API_KEY = 'sk_live_abc123xyz789';\nconst dbPassword = 'production_password_123';\nconst jwtSecret = 'my-secret-key';\n```\n\n**Detection signal:** Strings that look like API keys, passwords, or secrets assigned to variables. Patterns:\n- `sk_live_`, `sk_test_`, `pk_live_` (Stripe)\n- `AKIA` prefix (AWS)\n- Long alphanumeric strings assigned to variables named `key`, `secret`, `password`, `token`\n\n**Fix:**\n```javascript\n// SAFE - environment variables\nconst API_KEY = process.env.STRIPE_API_KEY;\nconst jwtSecret = process.env.JWT_SECRET;\n\n// And validate they exist\nif (!process.env.JWT_SECRET) {\n  throw new Error('JWT_SECRET environment variable required');\n}\n```\n\n### Pattern 10: Insufficient Input Validation\n\n**Anti-pattern:**\n```javascript\n// VULNERABLE - no validation\napp.post('/api/transfer', async (req, res) => {\n  const { amount, toAccount } = req.body;\n  await transfer(req.user.id, toAccount, amount);\n});\n```\n\n**Detection signal:** Request body/params used without type checking or validation.\n\n**Why it's dangerous:** User can pass negative amounts, wrong types, or extreme values.\n\n**Fix:**\n```javascript\n// SAFE - explicit validation\napp.post('/api/transfer', async (req, res) => {\n  const { amount, toAccount } = req.body;\n  \n  if (typeof amount !== 'number' || amount <= 0 || amount > 1000000) {\n    throw new ValidationError('Invalid amount');\n  }\n  if (typeof toAccount !== 'string' || !/^\\d{10}$/.test(toAccount)) {\n    throw new ValidationError('Invalid account number');\n  }\n  \n  await transfer(req.user.id, toAccount, amount);\n});\n\n// Or use validation library\nimport { z } from 'zod';\nconst TransferSchema = z.object({\n  amount: z.number().positive().max(1000000),\n  toAccount: z.string().regex(/^\\d{10}$/)\n});\n```\n\n## Quick Reference Table\n\n| Vulnerability | Detection Signal | Severity | Fix Strategy |\n|--------------|------------------|----------|--------------|\n| SQL Injection | String concat with SQL keywords | Critical | Parameterized queries |\n| NoSQL Injection | Request body in query objects | Critical | Type coercion/validation |\n| XSS | User input in innerHTML/HTML strings | Critical | textContent or sanitization |\n| Command Injection | User input in exec/spawn | Critical | Argument arrays, no shell |\n| Path Traversal | User input in file paths | High | Normalize + validate prefix |\n| Missing Auth | Mutation without auth middleware | High | Add auth middleware |\n| IDOR | Resource lookup without ownership | High | Include user ID in query |\n| Data Exposure | Full model objects in response | Medium | Explicit field selection |\n| Hardcoded Secrets | Key-like strings in code | High | Environment variables |\n| Input Validation | Unvalidated request data | Medium | Schema validation |\n\n## Verification Checklist\n\nFor every code block, scan for:\n\n1. [ ] String concatenation/interpolation in database queries\n2. [ ] Request body/params used directly in NoSQL query objects\n3. [ ] User input assigned to innerHTML or interpolated in HTML\n4. [ ] User input in shell commands (exec, spawn with shell)\n5. [ ] User input in file paths without normalization\n6. [ ] Mutation endpoints without auth middleware\n7. [ ] Resource lookups without ownership filtering\n8. [ ] Full model objects returned in API responses\n9. [ ] Hardcoded strings that look like keys/secrets\n10. [ ] Request data used without type/value validation\n\nIf any found: **FAIL** (Critical/High severity) with location and fix.\n"
    }
  ],
  "tags": [
    "quality",
    "verification",
    "core-workflow"
  ],
  "dependsOn": [
    "implement"
  ]
}