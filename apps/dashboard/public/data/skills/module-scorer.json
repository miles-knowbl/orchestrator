{
  "id": "module-scorer",
  "name": "module-scorer",
  "version": "1.0.0",
  "description": "Scores available modules for async queue prioritization. Calculates leverage scores using dream state alignment, downstream impact, and execution likelihood.",
  "phase": "SCORE",
  "category": "async",
  "content": "# Module Scorer\n\nCalculates leverage scores for available modules to prioritize the async work queue.\n\n## When to Use\n\n- During async-loop SCORE phase\n- After context gathering is complete\n- To determine which modules to work on during async operation\n\n## Scoring Model\n\n### Leverage Equation\n\n```\nV = (DSA × 0.40) + (Downstream × 0.25) + (Likelihood × 0.15)\n    ─────────────────────────────────────────────────────────\n                (Time × 0.10) + (Effort × 0.10)\n```\n\n### Dimensions\n\n| Dimension | Weight | Range | Meaning |\n|-----------|--------|-------|---------|\n| Dream State Alignment | 40% | 0-10 | How directly does this advance the dream state? |\n| Downstream Unlock | 25% | 0-10 | How many subsequent modules does this unblock? |\n| Likelihood | 15% | 0-10 | How likely is successful completion? |\n| Time | 10% | 0-10 | Inverse: faster is better |\n| Effort | 10% | 0-10 | Inverse: lower friction is better |\n\n## Workflow\n\n### Step 1: Get Available Modules\n\n```typescript\nconst modules = await roadmapService.getModulesNeedingAttention();\nconst available = modules.filter(m =>\n  m.status !== 'complete' &&\n  m.status !== 'deferred' &&\n  m.blockedBy.length === 0\n);\n```\n\n### Step 2: Score Each Module\n\nFor each available module:\n\n```typescript\nconst score = {\n  dsa: calculateDreamStateAlignment(module, dreamContext),\n  downstream: calculateDownstreamImpact(module, roadmap),\n  likelihood: calculateLikelihood(module, history, patterns),\n  time: estimateTime(module, calibration),\n  effort: estimateEffort(module, patterns)\n};\n\nconst leverage = (\n  (score.dsa * 0.40) +\n  (score.downstream * 0.25) +\n  (score.likelihood * 0.15)\n) / (\n  (score.time * 0.10) +\n  (score.effort * 0.10)\n);\n```\n\n### Step 3: Rank Modules\n\n```typescript\nconst ranked = modules\n  .map(m => ({ module: m, score: calculateLeverage(m) }))\n  .sort((a, b) => b.score - a.score);\n```\n\n### Step 4: Build Score Report\n\n```json\n{\n  \"module_scores\": {\n    \"scored_at\": \"ISO-timestamp\",\n    \"available_count\": 5,\n    \"ranked\": [\n      {\n        \"module\": \"auth-service\",\n        \"leverage_score\": 8.2,\n        \"components\": {\n          \"dsa\": 9,\n          \"downstream\": 8,\n          \"likelihood\": 7,\n          \"time\": 5,\n          \"effort\": 4\n        },\n        \"reasoning\": \"Unblocks 3 dependent modules\"\n      }\n    ]\n  }\n}\n```\n\n## Output\n\nUpdates `memory/module-scores.json`:\n\n```json\n{\n  \"scored_at\": \"ISO-timestamp\",\n  \"model_version\": \"1.0.0\",\n  \"available_modules\": 5,\n  \"ranked_modules\": [\n    {\n      \"name\": \"auth-service\",\n      \"leverage_score\": 8.2,\n      \"rank\": 1,\n      \"components\": { ... },\n      \"recommended_loop\": \"engineering-loop\",\n      \"estimated_duration_hours\": 3.5,\n      \"reasoning\": \"...\"\n    }\n  ],\n  \"deferred\": [\n    { \"name\": \"...\", \"reason\": \"...\" }\n  ]\n}\n```\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Module scores file | `memory/module-scores.json` | Always |\n\n## Component Calculations\n\n### Dream State Alignment (DSA)\n\n```typescript\nconst dsa = (\n  moduleInDreamState ? 5 : 0 +\n  moduleHasChecklistItems ? 3 : 0 +\n  moduleAdvancesVision ? 2 : 0\n);\n```\n\n### Downstream Impact\n\n```typescript\nconst downstream = countDependentModules(module) * 2;\n// Capped at 10\n```\n\n### Likelihood\n\n```typescript\nconst likelihood = (\n  hasSuccessfulPriorAttempts ? 3 : 0 +\n  patternsExist ? 2 : 0 +\n  noKnownBlockers ? 3 : 0 +\n  clearRequirements ? 2 : 0\n);\n```\n\n## References\n\n- [scoring-algorithm.md](references/scoring-algorithm.md) — Detailed scoring algorithm",
  "references": [
    {
      "name": "scoring-algorithm.md",
      "path": "references/scoring-algorithm.md",
      "content": "# Scoring Algorithm\n\nDetailed algorithm for calculating module leverage scores.\n\n## Input Data\n\n### From Dream State\n- Module list with status\n- Completion algebra (dependencies)\n- Progress percentage\n\n### From Roadmap\n- Dependency graph\n- Module descriptions\n- Layer information\n\n### From History\n- Previous attempt outcomes\n- Execution durations\n- Success/failure patterns\n\n### From Calibration\n- Personal multipliers\n- Loop-specific adjustments\n\n## Component Algorithms\n\n### Dream State Alignment (DSA)\n\n**Range:** 0-10\n\n```typescript\nfunction calculateDSA(module: Module, dreamState: DreamState): number {\n  let score = 0;\n\n  // Is module explicitly in dream state checklist?\n  if (dreamState.modules.includes(module.name)) {\n    score += 5;\n  }\n\n  // Does module have specific checklist items?\n  if (module.checklistItems?.length > 0) {\n    score += 3;\n  }\n\n  // Does module description align with vision keywords?\n  const visionMatch = countKeywordMatches(\n    module.description,\n    dreamState.vision\n  );\n  score += Math.min(visionMatch, 2);\n\n  return Math.min(score, 10);\n}\n```\n\n### Downstream Impact\n\n**Range:** 0-10\n\n```typescript\nfunction calculateDownstream(module: Module, roadmap: Roadmap): number {\n  // Count modules that depend on this one\n  const directDependents = roadmap.modules.filter(m =>\n    m.blockedBy?.includes(module.name)\n  ).length;\n\n  // Count transitive dependents (modules that would be unblocked)\n  const transitiveDependents = countTransitiveDependents(module, roadmap);\n\n  // Score: 2 points per direct, 1 per transitive\n  const score = (directDependents * 2) + (transitiveDependents * 1);\n\n  return Math.min(score, 10);\n}\n```\n\n### Likelihood\n\n**Range:** 0-10\n\n```typescript\nfunction calculateLikelihood(\n  module: Module,\n  history: ExecutionHistory,\n  patterns: Pattern[]\n): number {\n  let score = 5; // Base neutral\n\n  // Prior success on this module\n  const priorAttempts = history.filter(e =>\n    e.scope?.includes(module.name)\n  );\n  if (priorAttempts.some(a => a.outcome === 'success')) {\n    score += 2;\n  }\n  if (priorAttempts.some(a => a.outcome === 'failed')) {\n    score -= 1;\n  }\n\n  // Relevant patterns exist\n  const relevantPatterns = patterns.filter(p =>\n    p.categories.includes(module.category)\n  );\n  if (relevantPatterns.length > 2) {\n    score += 2;\n  }\n\n  // Clear requirements\n  if (module.description?.length > 100) {\n    score += 1;\n  }\n\n  return Math.max(0, Math.min(score, 10));\n}\n```\n\n### Time Estimate\n\n**Range:** 0-10 (inverse: higher = faster)\n\n```typescript\nfunction estimateTime(module: Module, calibration: Calibration): number {\n  const baseHours = MODULE_BASE_HOURS[module.category] || 3;\n  const calibratedHours = baseHours * calibration.multiplier;\n\n  // Score inversely: 1 hour = 10, 10 hours = 1\n  const score = 11 - Math.min(calibratedHours, 10);\n\n  return Math.max(1, score);\n}\n```\n\n### Effort Estimate\n\n**Range:** 0-10 (inverse: higher = easier)\n\n```typescript\nfunction estimateEffort(module: Module, patterns: Pattern[]): number {\n  let score = 5; // Base neutral\n\n  // Similar work done before\n  if (patterns.some(p => p.type === 'implementation' &&\n      p.scope === module.category)) {\n    score += 2;\n  }\n\n  // Has existing scaffolding\n  if (module.status === 'in-progress') {\n    score += 2;\n  }\n\n  // Small scope\n  if (module.functions?.length < 5) {\n    score += 1;\n  }\n\n  return Math.min(score, 10);\n}\n```\n\n## Final Score Calculation\n\n```typescript\nfunction calculateLeverage(components: ScoreComponents): number {\n  const numerator = (\n    (components.dsa * 0.40) +\n    (components.downstream * 0.25) +\n    (components.likelihood * 0.15)\n  );\n\n  const denominator = (\n    (components.time * 0.10) +\n    (components.effort * 0.10)\n  );\n\n  // Avoid division by zero\n  if (denominator === 0) return numerator;\n\n  return numerator / denominator;\n}\n```\n\n## Score Interpretation\n\n| Score Range | Interpretation |\n|-------------|----------------|\n| 8.0+ | High leverage, prioritize |\n| 6.0-7.9 | Good candidate |\n| 4.0-5.9 | Moderate priority |\n| 2.0-3.9 | Low priority |\n| < 2.0 | Consider deferring |\n"
    }
  ],
  "tags": [
    "async",
    "scoring",
    "leverage",
    "prioritization"
  ],
  "dependsOn": [
    "dream-sync",
    "pattern-collector",
    "calibration-sync"
  ]
}