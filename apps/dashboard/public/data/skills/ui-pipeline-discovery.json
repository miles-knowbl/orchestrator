{
  "id": "ui-pipeline-discovery",
  "name": "ui-pipeline-discovery",
  "version": "1.0.0",
  "description": "Identify client-side UI pipelines (U-series) in the codebase. Discovers interaction flows involving chat, tool handlers, context synchronization, and real-time updates. Foundation for UI-specific failure mode analysis.",
  "phase": "INIT",
  "category": "engineering",
  "content": "# UI Pipeline Discovery\n\nIdentify client-side UI pipelines (U-series).\n\n## When to Use\n\n- **Starting an audit** — Runs in INIT phase to map UI flows\n- **Understanding user interactions** — Document how users interact with the system\n- **Preparing for UI failure mode analysis** — Identify what can break in the UI\n- When you say: \"find the UI flows\", \"map the frontend\", \"what interactions exist?\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `ui-pipeline-identification.md` | How to find UI pipelines in code |\n| `ui-pipeline-template.md` | How to document each UI pipeline |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `ui-patterns.md` | Recognize common UI interaction patterns |\n\n**Verification:** All major user interaction flows are documented with triggers and outcomes.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| UI pipeline inventory | `AUDIT-SCOPE.md` | Always (U-series section) |\n| State update | `audit-state.json` | Always (ui_pipelines array) |\n\n## Core Concept\n\nUI Pipeline Discovery answers: **\"What are the major user interaction flows?\"**\n\nA UI pipeline is:\n- **Triggered** by user interaction (click, type, gesture)\n- **Involves** state changes, API calls, or visual updates\n- **Produces** a user-visible outcome\n\nExamples:\n- U1: Chat-to-Edit (user describes edit → artifact updated)\n- U2: Chat-to-Generate (user requests in chat → new artifact appears)\n- U3: Selection-to-Context (user selects sources → context updated)\n\n## UI Pipeline vs Backend Pipeline\n\n| Aspect | Backend (P-series) | UI (U-series) |\n|--------|-------------------|---------------|\n| Location | Server | Client/Browser |\n| Trigger | API call, job | User interaction |\n| Focus | Data transformation | User experience |\n| Failures | Data, logic, infra | State, feedback, interaction |\n\n## Discovery Process\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│             UI PIPELINE DISCOVERY PROCESS                   │\n│                                                             │\n│  1. FIND INTERACTION ENTRY POINTS                           │\n│     ├─→ Chat/agent interfaces                              │\n│     ├─→ Form submissions                                   │\n│     ├─→ Button clicks                                      │\n│     └─→ Gesture handlers                                   │\n│                                                             │\n│  2. TRACE STATE FLOW                                        │\n│     ├─→ Context updates                                    │\n│     ├─→ API calls triggered                                │\n│     ├─→ Response handling                                  │\n│     └─→ UI updates                                         │\n│                                                             │\n│  3. DOCUMENT EACH PIPELINE                                  │\n│     ├─→ Trigger (user action)                              │\n│     ├─→ Context required                                   │\n│     ├─→ Steps (what happens)                               │\n│     └─→ Outcome (what user sees)                           │\n│                                                             │\n│  4. ASSIGN U-SERIES IDS                                     │\n│     └─→ U1, U2, U3... in order of discovery                │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Where to Look\n\n### Chat/Agent Interfaces\n```typescript\n// Chat components\ncomponents/chat/*.tsx\nChatPanel.tsx\nChatInput.tsx\nChatContext.tsx\n```\n\n### Tool Handlers\n```typescript\n// Tool execution\nlib/tools/*.ts\ntoolHandlers.ts\nuseToolExecution.ts\n```\n\n### Context Providers\n```typescript\n// State management\ncontext/*.tsx\nproviders/*.tsx\n*Context.tsx\n```\n\n### Real-time Subscriptions\n```typescript\n// Supabase channels, WebSocket, SSE\nsupabase.channel()\nuseSubscription()\nEventSource\n```\n\n### Modal/Form Flows\n```typescript\n// Modal components\ncomponents/modals/*.tsx\n*Modal.tsx\n*Dialog.tsx\n```\n\n## UI Pipeline Documentation Format\n\n```markdown\n### U1: Chat-to-Edit\n\n**Trigger:** User types edit instruction in chat while artifact is open\n**Context Required:** artifact_id must be set in ChatContext\n\n**Steps:**\n1. User opens artifact in artifact-editor view\n2. Canvas.tsx sets context.artifact_id (`Canvas.tsx:120-122`)\n3. ChatPanel displays \"Editing: [artifact title]\"\n4. User types edit instruction and submits\n5. ChatContext.sendMessage() initiates SSE stream (`ChatContext.tsx:89`)\n6. Agent invokes edit_artifact tool\n7. toolHandlers.ts:edit_artifact calls Supabase function (`toolHandlers.ts:145`)\n8. Function returns { success, version, change_summary }\n9. React Query cache invalidated (`hooks/useArtifact.ts:34`)\n10. ToolCallBubble displays change_summary\n11. Artifact re-renders with new content\n\n**Outcome:**\n- Artifact content updated\n- Version incremented\n- Change summary displayed in chat\n- UI reflects new content\n\n**Key Files:**\n- `components/chat/ChatContext.tsx`\n- `lib/toolHandlers.ts`\n- `components/artifacts/Canvas.tsx`\n```\n\n## Output Format\n\n### In AUDIT-SCOPE.md\n\n```markdown\n## UI Pipelines (U-series)\n\n| ID | Name | Trigger | Outcome |\n|----|------|---------|---------|\n| U1 | Chat-to-Edit | Edit instruction in chat | Artifact updated |\n| U2 | Chat-to-Generate | Generate request in chat | New artifact created |\n| U3 | Selection-to-Context | Source selection | Context updated |\n\n### U1: Chat-to-Edit\n[detailed documentation]\n\n### U2: Chat-to-Generate\n[detailed documentation]\n```\n\n### In audit-state.json\n\n```json\n{\n  \"ui_pipelines\": [\n    {\n      \"id\": \"U1\",\n      \"name\": \"Chat-to-Edit\",\n      \"trigger\": \"Edit instruction in chat while artifact open\",\n      \"context_required\": [\"artifact_id\"],\n      \"outcome\": \"Artifact updated, change summary shown\",\n      \"key_files\": [\"ChatContext.tsx\", \"toolHandlers.ts\"],\n      \"step_count\": 11\n    }\n  ]\n}\n```\n\n## Common UI Pipeline Patterns\n\n| Pattern | Example | Key Components |\n|---------|---------|----------------|\n| Chat-to-Action | \"Generate a tweet\" | Chat → Tool → Result |\n| Selection-to-Context | Click sources | List → Context → Sidebar |\n| Modal Flow | Create new source | Button → Modal → Form → Submit |\n| Inline Edit | Edit title | Click → Input → Save |\n| Real-time Sync | New message appears | Subscription → State → Render |\n| Drag-and-Drop | Reorder items | Drag → Drop → Reorder → Save |\n\n## Discovery Checklist\n\n- [ ] Chat/agent interaction flows mapped\n- [ ] Tool handler flows documented\n- [ ] Context provider flows traced\n- [ ] Modal/form flows identified\n- [ ] Real-time subscription flows documented\n- [ ] Each pipeline has trigger, steps, outcome\n- [ ] U-series IDs assigned consistently\n\n## Validation\n\nBefore completing, verify:\n\n- [ ] All major user interactions are documented\n- [ ] Each pipeline has a unique U-series ID\n- [ ] Triggers are user-observable actions\n- [ ] Context requirements are specified\n- [ ] Outcomes are user-visible results\n- [ ] Key files are identified for each pipeline",
  "references": [
    {
      "name": "ui-patterns.md",
      "path": "references/ui-patterns.md",
      "content": "# UI Patterns\n\nCommon UI interaction patterns to recognize.\n\n## Chat/Agent Patterns\n\n### Chat-to-Action\nUser sends message → Agent processes → Tool executes → Result displayed\n\n```\nUser: \"Generate a tweet about AI\"\n  → ChatContext.sendMessage()\n    → SSE stream to agent\n      → generate_tweet tool called\n        → Result in ToolCallBubble\n```\n\n**Components:** ChatInput, ChatContext, ToolCallBubble\n\n### Chat-to-Edit\nUser describes edit → Agent applies → Artifact updated\n\n```\nUser: \"Make it shorter\"\n  → Context has artifact_id\n    → edit_artifact tool\n      → Artifact re-renders\n```\n\n**Components:** ChatContext, toolHandlers, ArtifactEditor\n\n## Selection Patterns\n\n### Multi-Select-to-Context\nUser selects items → Selection stored → Actions enabled\n\n```\nUser clicks checkbox\n  → SelectionContext.toggle(id)\n    → Selected count updates\n      → Action buttons enable\n```\n\n**Components:** SelectionProvider, ItemCheckbox, ActionBar\n\n### Selection-to-Detail\nUser clicks item → Detail view loads\n\n```\nUser clicks source\n  → Router navigates\n    → Detail component mounts\n      → Data fetched\n```\n\n**Components:** ListView, Router, DetailView\n\n## Modal Patterns\n\n### Modal-to-Create\nUser opens modal → Fills form → Submits → Item created\n\n```\nUser clicks \"New Source\"\n  → Modal opens\n    → Form filled\n      → Submit creates source\n        → Modal closes, list updates\n```\n\n**Components:** CreateButton, Modal, Form, ListView\n\n### Modal-to-Configure\nUser opens settings → Changes values → Saves\n\n```\nUser clicks gear icon\n  → Settings modal opens\n    → Values changed\n      → Save updates preferences\n```\n\n**Components:** SettingsButton, SettingsModal, usePreferences\n\n## Form Patterns\n\n### Inline Edit\nUser clicks text → Input appears → User edits → Blur saves\n\n```\nUser clicks title\n  → Span becomes input\n    → User types\n      → Blur triggers save\n        → Input becomes span\n```\n\n**Components:** EditableText, useInlineEdit\n\n### Form Wizard\nUser progresses through steps → Validates each → Submits at end\n\n```\nStep 1: Basic info\n  → Next validates\n    → Step 2: Details\n      → Next validates\n        → Submit all data\n```\n\n**Components:** Wizard, WizardStep, WizardNavigation\n\n## Real-time Patterns\n\n### Subscription-to-Update\nData changes elsewhere → Subscription receives → UI updates\n\n```\nAnother user edits\n  → Supabase channel receives\n    → Local state updates\n      → Component re-renders\n```\n\n**Components:** SubscriptionProvider, useSubscription\n\n### Optimistic Update\nUser acts → UI updates immediately → Server confirms/reverts\n\n```\nUser clicks like\n  → Count increments immediately\n    → API call made\n      → Success: keep change\n      → Failure: revert\n```\n\n**Components:** useMutation with optimistic option\n\n## Drag-and-Drop Patterns\n\n### Reorder\nUser drags item → Drops in new position → Order saved\n\n```\nUser drags card\n  → Drop zone highlights\n    → Drop triggers reorder\n      → API saves new order\n```\n\n**Components:** DragProvider, DraggableItem, DropZone\n\n### Transfer\nUser drags item → Drops in different container → Item moves\n\n```\nUser drags source\n  → Drops in folder\n    → Source moved to folder\n```\n\n**Components:** DragSource, DropTarget, useTransfer\n\n## Pattern Indicators\n\n| Pattern | Code Indicators |\n|---------|----------------|\n| Chat-to-Action | sendMessage(), tool handlers |\n| Selection | useState<Set>(), toggle(), isSelected |\n| Modal | isOpen state, onClose, Dialog component |\n| Inline Edit | contentEditable, onBlur save |\n| Real-time | useSubscription, channel.on() |\n| Drag-and-Drop | useDrag, useDrop, DndContext |\n"
    },
    {
      "name": "ui-pipeline-identification.md",
      "path": "references/ui-pipeline-identification.md",
      "content": "# UI Pipeline Identification\n\nHow to find UI pipelines in a codebase.\n\n## What Qualifies as a UI Pipeline\n\nA UI pipeline must have:\n\n1. **User Trigger** — Interaction that starts the flow\n2. **State Changes** — Context or component state updates\n3. **User Outcome** — Visible result to the user\n\n## Discovery Strategy\n\n### 1. Start with User Entry Points\n\nLook for:\n- onClick handlers\n- onSubmit handlers\n- Chat send functions\n- Selection change handlers\n\n### 2. Trace State Flow\n\nFollow the state through:\n```\nUser Action → Context Update → API Call → Response → UI Update\n```\n\n### 3. Identify Feedback Points\n\nWhere does the user see results?\n- Toast notifications\n- Inline updates\n- New elements appearing\n- Loading/success states\n\n## Code Patterns to Search\n\n### Event Handlers\n```typescript\nonClick={() => handleEdit()}\nonSubmit={handleSubmit}\nonChange={(e) => setSelection(e.target.value)}\n```\n\n### Context Actions\n```typescript\nconst { sendMessage, setArtifact } = useChat()\ncontext.updateSelection()\ndispatch({ type: 'SET_ACTIVE' })\n```\n\n### API Mutations\n```typescript\nconst mutation = useMutation(...)\nawait supabase.functions.invoke()\nfetch('/api/...', { method: 'POST' })\n```\n\n### Subscriptions\n```typescript\nsupabase.channel('changes').on('*', handler)\nconst { data } = useSubscription(query)\nnew EventSource('/api/stream')\n```\n\n## UI-Specific Indicators\n\n### Chat/Agent Flows\n```typescript\n// Look for message handling\nsendMessage()\nhandleToolCall()\nparseToolResult()\n```\n\n### Context Synchronization\n```typescript\n// Look for context consumers\nconst { artifact_id } = useContext(ChatContext)\nif (!artifact_id) return null\n```\n\n### Real-time Updates\n```typescript\n// Look for subscriptions\nuseEffect(() => {\n  const channel = supabase.channel('updates')\n  return () => channel.unsubscribe()\n}, [])\n```\n\n## Non-Pipeline Patterns\n\nDon't document these as UI pipelines:\n\n| Pattern | Why Not |\n|---------|---------|\n| Pure display | No state change |\n| Styling logic | Visual only |\n| Route guards | Access control |\n| Error boundaries | Error handling |\n| Lazy loading | Performance |\n\n## UI Pipeline Naming Convention\n\n```\nU{N}: {Noun}-to-{Action}\n\nU1: Chat-to-Edit\nU2: Chat-to-Generate\nU3: Selection-to-Context\nU4: Modal-to-Create\nU5: Drag-to-Reorder\n```\n\n## Minimum Documentation\n\nEach UI pipeline needs at minimum:\n1. ID (U1, U2, etc.)\n2. Name (descriptive)\n3. Trigger (user action)\n4. Context required (what state is needed)\n5. Outcome (what user sees)\n6. Key files (main components)\n"
    },
    {
      "name": "ui-pipeline-template.md",
      "path": "references/ui-pipeline-template.md",
      "content": "# UI Pipeline Template\n\nStandard format for documenting a UI pipeline.\n\n## Full Template\n\n```markdown\n### U{N}: {Pipeline Name}\n\n**Trigger:** {User action that starts this pipeline}\n**Context Required:** {State that must exist for this to work}\n\n**Steps:**\n1. {User action} (`{component}:{line}`)\n2. {State change} (`{file}:{line}`)\n3. {API call if any} (`{file}:{line}`)\n4. {Response handling} (`{file}:{line}`)\n5. {UI update} (`{component}:{line}`)\n\n**Outcome:**\n- {What user sees}\n- {What state changed}\n\n**Key Files:**\n- `{primary component}`\n- `{context/hook file}`\n- `{handler file}`\n\n**Feedback Points:**\n- Loading: {how loading is shown}\n- Success: {how success is shown}\n- Error: {how error is shown}\n\n**Notes:**\n- {Any important context}\n```\n\n## Example: Chat-to-Edit\n\n```markdown\n### U1: Chat-to-Edit\n\n**Trigger:** User types edit instruction while artifact is open in editor\n**Context Required:** artifact_id, artifact title in ChatContext\n\n**Steps:**\n1. User opens artifact via sidebar click (`Sidebar.tsx:45`)\n2. Canvas.tsx mounts, sets context.artifact_id (`Canvas.tsx:120`)\n3. ChatPanel shows \"Editing: {title}\" badge (`ChatPanel.tsx:34`)\n4. User types \"make it more casual\" and presses Enter\n5. ChatInput calls sendMessage() (`ChatInput.tsx:67`)\n6. ChatContext initiates SSE stream to /api/chat (`ChatContext.tsx:89`)\n7. Agent responds with edit_artifact tool call\n8. toolHandlers.edit_artifact invokes Supabase function (`toolHandlers.ts:145`)\n9. Function returns { success: true, version: 2, change_summary: \"...\" }\n10. queryClient.invalidateQueries(['artifact', id]) (`toolHandlers.ts:152`)\n11. ToolCallBubble renders with change_summary (`ToolCallBubble.tsx:23`)\n12. Artifact component re-fetches and re-renders\n\n**Outcome:**\n- Artifact content updated with edit\n- Version incremented (1 → 2)\n- Change summary shown in chat bubble\n- Editor shows new content without refresh\n\n**Key Files:**\n- `components/chat/ChatContext.tsx` — State management\n- `lib/toolHandlers.ts` — Tool execution\n- `components/artifacts/Canvas.tsx` — Editor mount\n- `components/chat/ToolCallBubble.tsx` — Result display\n\n**Feedback Points:**\n- Loading: Typing indicator in chat, spinner in bubble\n- Success: Green checkmark, change summary displayed\n- Error: Red error bubble with message\n\n**Notes:**\n- Edit requires artifact to be open (context.artifact_id set)\n- SSE stream may timeout after 30s\n- Version conflict possible if concurrent edits\n```\n\n## Minimal Template\n\nFor quick documentation:\n\n```markdown\n### U{N}: {Name}\n\n**Trigger:** {User action}\n**Context:** {Required state}\n**Outcome:** {What happens}\n**Entry:** `{main component}`\n```\n\n## Step Documentation\n\nEach step should include:\n- Actor (User, Component, Context)\n- Action (opens, clicks, calls, renders)\n- Target (artifact, message, modal)\n- Location (Component:line)\n\n**Good:**\n```\n5. ChatInput calls sendMessage() (`ChatInput.tsx:67`)\n```\n\n**Bad:**\n```\n5. Message sent\n```\n\n## Context Requirements\n\nDocument what state must exist:\n\n**Good:**\n```\n**Context Required:**\n- artifact_id must be set in ChatContext\n- User must be authenticated\n- Artifact must not be archived\n```\n\n**Bad:**\n```\n**Context Required:** Some state\n```\n\n## Feedback Points\n\nDocument how the user knows what's happening:\n\n| State | Example |\n|-------|---------|\n| Loading | Spinner, skeleton, typing indicator |\n| Success | Toast, checkmark, updated content |\n| Error | Error message, red highlight, retry button |\n"
    }
  ],
  "tags": [
    "audit",
    "pipeline",
    "discovery",
    "ui",
    "frontend",
    "interaction"
  ],
  "dependsOn": [
    "requirements"
  ]
}