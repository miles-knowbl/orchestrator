{
  "id": "git-workflow",
  "name": "git-workflow",
  "version": "1.0.0",
  "description": "Manages git workflows for the engineering loop. Handles worktrees for parallel development, branching conventions, PR creation, and coordination between agents and human engineers. Provides isolation for concurrent system development.",
  "phase": "SHIP",
  "category": "core",
  "content": "# Git Workflow\n\nParallel development with git worktrees and structured branching.\n\n## When to Use\n\n- **Starting work on a system** ‚Äî Create isolated worktree\n- **Parallel development** ‚Äî Multiple systems simultaneously\n- **Coordination** ‚Äî Multiple engineers/agents on same repo\n- **PR creation** ‚Äî Preparing work for review\n- **Hotfixes** ‚Äî Emergency fixes while feature work continues\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `worktree-commands.md` | Core worktree commands and patterns |\n| `pr-templates.md` | Templates for pull request descriptions |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `conflict-resolution.md` | When merge conflicts occur |\n| `scripts.md` | Helper scripts for common operations |\n\n**Verification:** Ensure worktree is created and branch follows naming convention.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Git worktree | `../{system-name}/` | When starting system work |\n| Feature branch | Git | Always |\n| PR description | GitHub | When ready for review |\n\n## Core Concept\n\nGit worktrees allow multiple working directories from a single repository, enabling:\n- Isolated development environments per system\n- No need to stash/switch branches\n- Parallel work on independent systems\n- Clean separation of concerns\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                         GIT WORKTREE MODEL                                   ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îÇ  repository/                                                                ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ .git/                    # Shared git database                         ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ main branch (production) # Protected, merge only                       ‚îÇ\n‚îÇ  ‚îÇ                                                                          ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ .worktrees/              # Isolated working directories                ‚îÇ\n‚îÇ      ‚îú‚îÄ‚îÄ system-auth/         # Agent 1 working here                        ‚îÇ\n‚îÇ      ‚îú‚îÄ‚îÄ system-orders/       # Agent 2 working here                        ‚îÇ\n‚îÇ      ‚îî‚îÄ‚îÄ hotfix-login/        # Human engineer fixing bug                   ‚îÇ\n‚îÇ                                                                             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Branching Convention\n\n### Branch Naming\n\n```\n{type}/{system-or-feature-name}\n```\n\n| Type | Use Case | Example |\n|------|----------|---------|\n| `feature/` | New system or feature | `feature/system-servicegrid` |\n| `hotfix/` | Urgent production fix | `hotfix/auth-bypass` |\n| `bugfix/` | Non-urgent bug fix | `bugfix/order-validation` |\n| `chore/` | Maintenance, deps | `chore/update-dependencies` |\n| `docs/` | Documentation only | `docs/api-reference` |\n\n### Protected Branches\n\n| Branch | Purpose | Merge Via |\n|--------|---------|-----------|\n| `main` | Production code | PR with approval |\n| `develop` | Integration (optional) | PR from feature |\n\n## Workflow: Claim a System\n\n### Step 1: Navigate to Repository\n\n```bash\ncd /path/to/repository\n```\n\n### Step 2: Ensure Main is Current\n\n```bash\ngit checkout main\ngit pull origin main\n```\n\n### Step 3: Create Worktree\n\n```bash\n# Create worktree with new branch\ngit worktree add .worktrees/system-servicegrid -b feature/system-servicegrid\n\n# This creates:\n# - .worktrees/system-servicegrid/ (working directory)\n# - feature/system-servicegrid (new branch from current HEAD)\n```\n\n### Step 4: Navigate to Worktree\n\n```bash\ncd .worktrees/system-servicegrid\n```\n\n### Step 5: Verify Setup\n\n```bash\n# Confirm branch\ngit branch --show-current\n# feature/system-servicegrid\n\n# Confirm location\npwd\n# /path/to/repository/.worktrees/system-servicegrid\n```\n\n## Workflow: Daily Development\n\n### Making Changes\n\n```bash\n# Work in worktree\ncd .worktrees/system-servicegrid\n\n# Make changes...\n# Edit files, run tests, etc.\n\n# Stage and commit\ngit add .\ngit commit -m \"feat(servicegrid): implement work order model\"\n```\n\n### Commit Message Convention\n\n```\n{type}({scope}): {description}\n\n[optional body]\n\n[optional footer]\n```\n\n| Type | Meaning |\n|------|---------|\n| `feat` | New feature |\n| `fix` | Bug fix |\n| `docs` | Documentation |\n| `style` | Formatting (no code change) |\n| `refactor` | Code change (no feature/fix) |\n| `test` | Adding tests |\n| `chore` | Maintenance |\n\nExample:\n```\nfeat(servicegrid): implement work order model\n\n- Add WorkOrder model with status enum\n- Add validation for required fields\n- Add database migration\n\nCloses #123\n```\n\n### Pushing Changes\n\n```bash\n# First push (set upstream)\ngit push -u origin feature/system-servicegrid\n\n# Subsequent pushes\ngit push\n```\n\n### Pulling Updates from Main\n\nWhen main has been updated and you need those changes:\n\n```bash\n# Option 1: Rebase (preferred for clean history)\ngit fetch origin main\ngit rebase origin/main\n\n# Option 2: Merge (if rebase is complex)\ngit fetch origin main\ngit merge origin/main\n```\n\n## Workflow: Create PR\n\n### Step 1: Ensure All Changes Committed\n\n```bash\ngit status\n# Should be clean\n```\n\n### Step 2: Push Final Changes\n\n```bash\ngit push\n```\n\n### Step 3: Create PR via GitHub CLI\n\n```bash\ngh pr create \\\n  --base main \\\n  --head feature/system-servicegrid \\\n  --title \"feat: ServiceGrid Core System\" \\\n  --body-file PR_DESCRIPTION.md \\\n  --label \"system:servicegrid\" \\\n  --reviewer @tech-lead\n```\n\nOr with inline body:\n\n```bash\ngh pr create \\\n  --base main \\\n  --head feature/system-servicegrid \\\n  --title \"feat: ServiceGrid Core System\" \\\n  --body \"## Summary\nImplements the core ServiceGrid system.\n\nCloses #123\n\n## Changes\n- Work order model and API\n- Status management\n- Mobile sync support\n\n## Testing\n- Unit tests: ‚úÖ\n- Integration tests: ‚úÖ\n- Manual testing: ‚úÖ\"\n```\n\n### Step 4: Link PR to Issue\n\n```bash\n# PR body should reference issue\n# \"Closes #123\" or \"Fixes #123\"\n```\n\n‚Üí See `references/pr-templates.md`\n\n## Workflow: After Merge\n\n### Step 1: Return to Main Repository\n\n```bash\ncd /path/to/repository\n```\n\n### Step 2: Update Main\n\n```bash\ngit checkout main\ngit pull origin main\n```\n\n### Step 3: Remove Worktree\n\n```bash\ngit worktree remove .worktrees/system-servicegrid\n```\n\n### Step 4: Optionally Delete Branch\n\n```bash\n# Local\ngit branch -d feature/system-servicegrid\n\n# Remote (usually done via PR merge settings)\ngit push origin --delete feature/system-servicegrid\n```\n\n## Parallel Development\n\n### Multiple Worktrees\n\n```bash\n# Agent 1 works on ServiceGrid\ngit worktree add .worktrees/system-servicegrid -b feature/system-servicegrid\ncd .worktrees/system-servicegrid\n\n# Agent 2 works on Routing (different terminal/session)\ngit worktree add .worktrees/system-routing -b feature/system-routing\ncd .worktrees/system-routing\n\n# Human engineer works on hotfix\ngit worktree add .worktrees/hotfix-auth -b hotfix/auth-bypass\ncd .worktrees/hotfix-auth\n```\n\n### List Active Worktrees\n\n```bash\ngit worktree list\n# /path/to/repo                 abc1234 [main]\n# /path/to/repo/.worktrees/system-servicegrid  def5678 [feature/system-servicegrid]\n# /path/to/repo/.worktrees/system-routing      ghi9012 [feature/system-routing]\n```\n\n### Coordination Rules\n\n1. **No shared files** ‚Äî Each worktree modifies different parts\n2. **API contracts** ‚Äî Agree on interfaces before implementing\n3. **Merge order** ‚Äî Dependencies merge first\n4. **Communication** ‚Äî Update GitHub issue with progress\n\n## Conflict Resolution\n\n### When Conflicts Occur\n\nConflicts happen when:\n- Multiple worktrees modify same files\n- Main updated after branch created\n- Dependent system merged, breaking yours\n\n### Resolution Process\n\n```bash\n# In your worktree\ngit fetch origin main\ngit rebase origin/main\n\n# If conflicts:\n# 1. Edit conflicted files\n# 2. Resolve conflicts\n# 3. Stage resolved files\ngit add <resolved-files>\n\n# 4. Continue rebase\ngit rebase --continue\n\n# 5. Force push (if already pushed)\ngit push --force-with-lease\n```\n\n### Avoiding Conflicts\n\n- Communicate what files you're modifying\n- Pull main frequently\n- Keep PRs small and merge often\n- Use feature flags for partial features\n\n## Commands Reference\n\n### Worktree Commands\n\n```bash\n# Create worktree with new branch\ngit worktree add <path> -b <branch-name>\n\n# Create worktree from existing branch\ngit worktree add <path> <existing-branch>\n\n# List worktrees\ngit worktree list\n\n# Remove worktree\ngit worktree remove <path>\n\n# Prune stale worktree entries\ngit worktree prune\n```\n\n### Branch Commands\n\n```bash\n# Create and checkout new branch\ngit checkout -b <branch-name>\n\n# List branches\ngit branch -a\n\n# Delete local branch\ngit branch -d <branch-name>\n\n# Delete remote branch\ngit push origin --delete <branch-name>\n```\n\n### PR Commands (GitHub CLI)\n\n```bash\n# Create PR\ngh pr create --base main --head <branch>\n\n# List PRs\ngh pr list\n\n# Check PR status\ngh pr status\n\n# View PR\ngh pr view <number>\n\n# Merge PR\ngh pr merge <number> --squash --delete-branch\n```\n\n‚Üí See `references/worktree-commands.md`\n\n## Human-in-the-Loop Gates\n\n### When Human Approval Required\n\n| Gate | Trigger | Process |\n|------|---------|---------|\n| Architecture | New patterns | Add `needs:architecture-review` label |\n| Security | Auth/crypto/PII | Add `needs:security-review` label |\n| Database | Schema changes | Add `needs:dba-review` label |\n| Deploy | Production merge | Required reviewer approval |\n\n### Requesting Review\n\n```bash\n# Create PR with specific reviewers\ngh pr create \\\n  --reviewer security-team,tech-lead \\\n  --label \"needs:security-review\"\n\n# Add reviewers to existing PR\ngh pr edit <number> --add-reviewer @security-team\n```\n\n### Waiting for Approval\n\n```bash\n# Check PR review status\ngh pr checks <number>\n\n# View review comments\ngh pr view <number> --comments\n```\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `engineering` (loop) | Git workflow is part of the implementation phase |\n| `entry-portal` | Creates issues that git workflow implements |\n| `code-review` | Prepares PR for review, handles feedback |\n\n## Key Principles\n\n**Isolate work.** Each system gets its own worktree.\n\n**Commit often.** Small, logical commits are easier to review and revert.\n\n**Pull main frequently.** Avoid large merge conflicts.\n\n**PR early.** Open draft PR early for visibility.\n\n**Clean up.** Remove worktrees after merge.\n\n## Mode-Specific Behavior\n\nGit workflow and branching approach differ by orchestrator mode:\n\n### Greenfield Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Full system branches |\n| **Approach** | Comprehensive‚Äîfeature branches per system |\n| **Patterns** | Free choice‚Äîestablish branching conventions |\n| **Deliverables** | Full PR with complete system |\n| **Validation** | Standard review process |\n| **Constraints** | Minimal‚Äîsquash or merge commit |\n\n### Brownfield-Polish Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Gap-specific branches |\n| **Approach** | Extend existing‚Äîmatch repo conventions |\n| **Patterns** | Should match existing branch/commit style |\n| **Deliverables** | Delta PR for single gap or related gaps |\n| **Validation** | Existing + pattern conformance review |\n| **Constraints** | Don't break existing merge conventions |\n\n**Polish considerations:**\n- Branch names reference gap being filled\n- PRs should be smaller and focused\n- Commit messages follow existing repo style\n- Merge strategy matches repo convention\n\n### Brownfield-Enterprise Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Change-request-specific branches |\n| **Approach** | Surgical‚Äîisolated change environment required |\n| **Patterns** | Must conform exactly‚ÄîCR number in all references |\n| **Deliverables** | Change record PR matching CR scope exactly |\n| **Validation** | Full regression + multiple approvals |\n| **Constraints** | Requires approval‚Äîteam policy enforced |\n\n**Enterprise git workflow requirements:**\n- Branch name includes CR number\n- PR title includes CR number\n- All commits reference CR\n- Squash commits for clean history\n- Delete branch after merge\n\n**Enterprise branch naming:**\n```\nchange/CR-12345-fix-auth-timeout\n```\n\n**Enterprise commit format:**\n```\nfix(auth): resolve timeout issue\n\nImplements the fix specified in CR-12345.\n- Increase timeout from 5s to 30s\n- Add retry logic for transient failures\n\nCR-12345\n```\n\n---\n\n## References\n\n- `references/worktree-commands.md`: Complete worktree command reference\n- `references/pr-templates.md`: PR description templates\n- `references/conflict-resolution.md`: Detailed conflict resolution guide",
  "references": [
    {
      "name": "conflict-resolution.md",
      "path": "references/conflict-resolution.md",
      "content": "# Conflict Resolution\n\nGuide to resolving git conflicts in worktrees.\n\n## Why Conflicts Happen\n\nConflicts occur when:\n- Multiple developers modify the same lines\n- Main branch is updated after your branch was created\n- Dependent system is merged, changing shared files\n- Two worktrees accidentally modify the same file\n\n## Conflict Prevention\n\n### Before They Happen\n\n1. **Communicate** ‚Äî Let others know what files you're modifying\n2. **Pull frequently** ‚Äî Integrate main often to minimize drift\n3. **Small PRs** ‚Äî Merge often, don't let branches live too long\n4. **Define boundaries** ‚Äî Each system should own its files\n5. **API contracts** ‚Äî Agree on interfaces before implementing\n\n### Check for Potential Conflicts\n\n```bash\n# Before starting work, check if main has diverged\ngit fetch origin main\ngit log --oneline HEAD..origin/main\n# If many commits, consider rebasing before starting\n\n# See what files changed on main\ngit diff --name-only HEAD origin/main\n```\n\n## Detecting Conflicts\n\n### Before Merge/Rebase\n\n```bash\n# Dry run merge to see conflicts\ngit merge --no-commit --no-ff origin/main\ngit diff --name-only --diff-filter=U\n# U = Unmerged (conflicted)\n\n# Abort the dry run\ngit merge --abort\n```\n\n### During Rebase\n\n```bash\ngit rebase origin/main\n# CONFLICT (content): Merge conflict in src/file.ts\n```\n\n## Resolving Conflicts\n\n### Standard Resolution Process\n\n```bash\n# 1. Start the rebase\ngit fetch origin main\ngit rebase origin/main\n\n# 2. Git stops at first conflict\n# Conflicted files are marked in status\ngit status\n# both modified: src/file.ts\n\n# 3. Open conflicted file\n# Look for conflict markers:\n# <<<<<<< HEAD\n# your changes\n# =======\n# their changes\n# >>>>>>> origin/main\n\n# 4. Edit file to resolve\n# Remove markers, keep correct code\n# May need to combine both changes\n\n# 5. Stage resolved file\ngit add src/file.ts\n\n# 6. Continue rebase\ngit rebase --continue\n\n# 7. Repeat for each conflict\n\n# 8. Push (force required after rebase)\ngit push --force-with-lease\n```\n\n### Understanding Conflict Markers\n\n```typescript\n<<<<<<< HEAD\n// Your changes (current branch)\nconst config = { timeout: 5000 };\n=======\n// Their changes (incoming from main)\nconst config = { timeout: 3000, retries: 3 };\n>>>>>>> origin/main\n```\n\n**Resolution options:**\n\n```typescript\n// Option 1: Keep yours\nconst config = { timeout: 5000 };\n\n// Option 2: Keep theirs\nconst config = { timeout: 3000, retries: 3 };\n\n// Option 3: Combine both\nconst config = { timeout: 5000, retries: 3 };\n```\n\n### Using VS Code for Resolution\n\n```bash\n# Open conflicted file in VS Code\ncode src/file.ts\n\n# VS Code shows:\n# - \"Accept Current Change\" (yours)\n# - \"Accept Incoming Change\" (theirs)\n# - \"Accept Both Changes\"\n# - \"Compare Changes\"\n```\n\n### Using Git Mergetool\n\n```bash\n# Configure mergetool\ngit config --global merge.tool vimdiff\n\n# Or for VS Code\ngit config --global merge.tool vscode\ngit config --global mergetool.vscode.cmd 'code --wait $MERGED'\n\n# Launch mergetool for conflicts\ngit mergetool\n```\n\n## Conflict Scenarios\n\n### Scenario 1: Same File, Different Sections\n\n```bash\n# Your changes: modified function A\n# Their changes: modified function B (different part of file)\n\n# Resolution: Usually both can be kept\n# Git may auto-resolve, or you keep both sections\n```\n\n### Scenario 2: Same Lines Modified\n\n```bash\n# Your changes: timeout = 5000\n# Their changes: timeout = 3000\n\n# Resolution: Decide which value is correct\n# May need to discuss with other developer\n```\n\n### Scenario 3: File Deleted vs Modified\n\n```bash\n# You: deleted the file\n# They: modified the file\n\n# Resolution:\n# Keep deletion: git rm src/file.ts\n# Keep modification: git add src/file.ts\n```\n\n### Scenario 4: File Renamed\n\n```bash\n# You: renamed file.ts -> newName.ts\n# They: modified file.ts\n\n# Resolution: Apply their changes to your renamed file\n# May need manual editing\n```\n\n### Scenario 5: Package Lock Conflicts\n\n```bash\n# package-lock.json almost always conflicts\n\n# Resolution: Regenerate\ngit checkout --ours package-lock.json  # Or --theirs\nrm package-lock.json\nnpm install\ngit add package-lock.json\n```\n\n### Scenario 6: Migration File Conflicts\n\n```bash\n# Database migrations with conflicting timestamps\n\n# Resolution:\n# 1. Abort current resolution\n# 2. Rename your migration to new timestamp\n# 3. Ensure migrations run in correct order\n# 4. Test migration sequence\n```\n\n## Abort and Retry\n\n### Abort Rebase\n\n```bash\n# Something went wrong, start over\ngit rebase --abort\n```\n\n### Abort Merge\n\n```bash\ngit merge --abort\n```\n\n### Reset to Known State\n\n```bash\n# Go back to before you started\ngit reset --hard origin/feature/my-branch\n```\n\n## Advanced Resolution\n\n### Interactive Rebase for Complex Cases\n\n```bash\n# Rebase with ability to edit, squash, reorder\ngit rebase -i origin/main\n\n# In editor:\n# pick abc1234 First commit\n# squash def5678 Fixup commit\n# pick ghi9012 Third commit\n\n# Squashing related commits can reduce conflicts\n```\n\n### Cherry-Pick Specific Commits\n\n```bash\n# If rebase is too messy, start fresh\ngit checkout main\ngit checkout -b feature/my-feature-v2\ngit cherry-pick abc1234  # Pick good commits\ngit cherry-pick def5678\n```\n\n### Theirs/Ours Strategy\n\n```bash\n# Accept all their changes for a file\ngit checkout --theirs src/file.ts\ngit add src/file.ts\n\n# Accept all your changes for a file\ngit checkout --ours src/file.ts\ngit add src/file.ts\n```\n\n## After Resolution\n\n### Verify Resolution\n\n```bash\n# Make sure code compiles\nnpm run build  # or equivalent\n\n# Run tests\nnpm test\n\n# Check for markers accidentally left in\ngrep -r \"<<<<<<\" src/\ngrep -r \"======\" src/\ngrep -r \">>>>>>\" src/\n```\n\n### Push Resolved Branch\n\n```bash\n# After rebase, force push is required\ngit push --force-with-lease\n\n# --force-with-lease is safer than --force\n# It fails if remote has new commits you haven't seen\n```\n\n### Communicate Resolution\n\n```bash\n# Comment on PR\n\"Resolved conflicts with main. Key decisions:\n- Kept their timeout value (3000ms) per #123\n- Combined our retry logic with their error handling\"\n```\n\n## Coordination with Team\n\n### Before Resolving\n\n1. Check if anyone else is working on same files\n2. Discuss complex conflicts before resolving\n3. Consider pair programming for tricky merges\n\n### After Resolving\n\n1. Run full test suite\n2. Note resolution decisions in PR\n3. Request re-review if changes are significant\n\n## Conflict Resolution Checklist\n\n- [ ] Understood both changes (yours and theirs)\n- [ ] Resolved all markers removed\n- [ ] Code compiles\n- [ ] Tests pass\n- [ ] No unintended changes\n- [ ] Pushed with force-with-lease\n- [ ] PR updated with resolution notes\n"
    },
    {
      "name": "pr-templates.md",
      "path": "references/pr-templates.md",
      "content": "# PR Templates\n\nTemplates for Pull Request descriptions.\n\n## System PR Template\n\nFor PRs implementing a complete system:\n\n```markdown\n## üéØ System: [System Name]\n\nCloses #[issue-number]\n\n### Summary\n\n[2-3 sentences describing what this system does]\n\n### Changes\n\n- [Major change 1]\n- [Major change 2]\n- [Major change 3]\n\n### Architecture Decisions\n\n| Decision | Choice | Rationale |\n|----------|--------|-----------|\n| [Decision 1] | [Choice] | [Why] |\n| [Decision 2] | [Choice] | [Why] |\n\n### API Endpoints\n\n| Method | Endpoint | Description |\n|--------|----------|-------------|\n| GET | /api/resource | List resources |\n| POST | /api/resource | Create resource |\n| ... | ... | ... |\n\n### Database Changes\n\n- [ ] No database changes\n- [ ] Migration included: `YYYYMMDD_description.sql`\n- [ ] Migration reviewed by DBA\n\n### Testing\n\n- [ ] Unit tests added/updated\n- [ ] Integration tests added/updated\n- [ ] E2E tests added/updated (if applicable)\n- [ ] Manual testing completed\n\n**Test Coverage:** [X]%\n\n### Documentation\n\n- [ ] README updated\n- [ ] API documentation updated\n- [ ] Architecture docs updated\n- [ ] Runbook created/updated\n\n### Security Considerations\n\n- [ ] No security implications\n- [ ] Security review requested\n- [ ] Auth/authz properly implemented\n- [ ] Input validation implemented\n- [ ] No sensitive data logged\n\n### Performance\n\n- [ ] No performance implications\n- [ ] Performance tested\n- [ ] Meets SLA: [target]\n\n### Checklist\n\n- [ ] Code follows style guidelines\n- [ ] Self-reviewed my code\n- [ ] No console.log or debug statements\n- [ ] No hardcoded secrets\n- [ ] All tests passing\n- [ ] Documentation complete\n\n### Screenshots/Recordings\n\n[If applicable, add screenshots or recordings]\n\n### How to Test\n\n1. [Step 1]\n2. [Step 2]\n3. [Step 3]\n```\n\n## Feature PR Template\n\nFor PRs adding a feature to an existing system:\n\n```markdown\n## ‚ú® Feature: [Feature Name]\n\nCloses #[issue-number]\n\n### Summary\n\n[Brief description of the feature]\n\n### Changes\n\n- [Change 1]\n- [Change 2]\n\n### Testing\n\n- [ ] Unit tests added\n- [ ] Manual testing completed\n\n### Checklist\n\n- [ ] Code follows style guidelines\n- [ ] Tests passing\n- [ ] Documentation updated (if needed)\n\n### How to Test\n\n1. [Step 1]\n2. [Step 2]\n```\n\n## Bug Fix PR Template\n\nFor PRs fixing bugs:\n\n```markdown\n## üêõ Fix: [Bug Description]\n\nCloses #[issue-number]\n\n### Problem\n\n[What was happening]\n\n### Root Cause\n\n[Why it was happening]\n\n### Solution\n\n[What was changed to fix it]\n\n### Testing\n\n- [ ] Added test that reproduces the bug\n- [ ] Test now passes with fix\n- [ ] Regression tests still pass\n\n### Checklist\n\n- [ ] Root cause identified\n- [ ] Fix is minimal and targeted\n- [ ] Tests added to prevent regression\n```\n\n## Hotfix PR Template\n\nFor urgent production fixes:\n\n```markdown\n## üö® Hotfix: [Issue]\n\n### Urgency\n\n**Severity:** [Critical/High]\n**Impact:** [Who/what is affected]\n**Reported:** [When/where]\n\n### Problem\n\n[What is broken in production]\n\n### Fix\n\n[Minimal change to resolve]\n\n### Rollback Plan\n\n```bash\n[Commands to rollback if needed]\n```\n\n### Testing\n\n- [ ] Fix verified locally\n- [ ] Fix verified in staging\n- [ ] Monitoring in place\n\n### Deploy Steps\n\n1. [Step 1]\n2. [Step 2]\n\n### Post-Deploy Verification\n\n- [ ] [Check 1]\n- [ ] [Check 2]\n```\n\n## Documentation PR Template\n\nFor documentation-only changes:\n\n```markdown\n## üìö Docs: [What's being documented]\n\n### Changes\n\n- [Doc change 1]\n- [Doc change 2]\n\n### Preview\n\n[Link to preview if available]\n\n### Checklist\n\n- [ ] Spelling/grammar checked\n- [ ] Links verified\n- [ ] Code examples tested\n```\n\n## Dependency Update PR Template\n\nFor updating dependencies:\n\n```markdown\n## üì¶ Deps: Update [package] to [version]\n\n### Changes\n\n| Package | From | To | Changelog |\n|---------|------|-----|-----------|\n| [pkg] | [old] | [new] | [link] |\n\n### Breaking Changes\n\n- [ ] None\n- [ ] Yes: [describe]\n\n### Security Fixes\n\n- [ ] None\n- [ ] Yes: [CVE if applicable]\n\n### Testing\n\n- [ ] All tests passing\n- [ ] Application tested manually\n- [ ] No behavior changes observed\n\n### Checklist\n\n- [ ] Lock file updated\n- [ ] No unintended downgrades\n- [ ] Changelog reviewed\n```\n\n## PR Description Best Practices\n\n### Do\n\n- Link to the issue being addressed\n- Explain WHY not just WHAT\n- Include testing instructions\n- Add screenshots for UI changes\n- List any breaking changes\n- Note any required follow-up\n\n### Don't\n\n- Leave the description empty\n- Copy-paste the entire diff\n- Include sensitive information\n- Make it longer than necessary\n\n## Creating PR with Template\n\n### Using File\n\n```bash\n# Create PR_DESCRIPTION.md with template content\ngh pr create \\\n  --base main \\\n  --head feature/my-feature \\\n  --title \"feat: My Feature\" \\\n  --body-file PR_DESCRIPTION.md\n```\n\n### Using Here-doc\n\n```bash\ngh pr create \\\n  --base main \\\n  --head feature/my-feature \\\n  --title \"feat: My Feature\" \\\n  --body \"## Summary\n\nImplements XYZ feature.\n\nCloses #123\n\n## Changes\n\n- Added foo\n- Modified bar\n\n## Testing\n\n- [x] Unit tests\n- [x] Manual testing\"\n```\n\n## Repository PR Template\n\nCreate `.github/PULL_REQUEST_TEMPLATE.md` for automatic template:\n\n```markdown\n## Summary\n\n[Brief description]\n\nCloses #\n\n## Changes\n\n-\n\n## Testing\n\n- [ ] Tests added/updated\n- [ ] Manual testing completed\n\n## Checklist\n\n- [ ] Code follows style guidelines\n- [ ] Documentation updated\n- [ ] All tests passing\n```\n"
    },
    {
      "name": "scripts.md",
      "path": "references/scripts.md",
      "content": "# Git Workflow Scripts\n\nReady-to-use scripts for common git operations.\n\n## Setup\n\nSave these scripts to your project's `scripts/` directory and make executable:\n\n```bash\nchmod +x scripts/*.sh\n```\n\n---\n\n## worktree-create.sh\n\nCreate an isolated worktree for a system.\n\n```bash\n#!/bin/bash\n# Usage: ./scripts/worktree-create.sh sys-002 work-order-service\n# Creates: .worktrees/work-order-service with feature/system-work-orders branch\n\nset -e\n\nSYSTEM_ID=$1\nSYSTEM_NAME=$2\n\nif [ -z \"$SYSTEM_ID\" ] || [ -z \"$SYSTEM_NAME\" ]; then\n    echo \"Usage: $0 <system-id> <system-name>\"\n    echo \"Example: $0 sys-002 work-order-service\"\n    exit 1\nfi\n\nBRANCH_NAME=\"feature/system-${SYSTEM_NAME}\"\nWORKTREE_PATH=\".worktrees/${SYSTEM_NAME}\"\n\necho \"üå≥ Creating worktree for ${SYSTEM_NAME}...\"\n\n# Ensure we're on main and up to date\ngit checkout main\ngit pull origin main\n\n# Create branch if it doesn't exist\nif git show-ref --quiet \"refs/heads/${BRANCH_NAME}\"; then\n    echo \"Branch ${BRANCH_NAME} already exists\"\nelse\n    echo \"Creating branch ${BRANCH_NAME}...\"\n    git branch \"${BRANCH_NAME}\"\nfi\n\n# Create worktree directory\nmkdir -p .worktrees\n\n# Add worktree\nif [ -d \"${WORKTREE_PATH}\" ]; then\n    echo \"Worktree already exists at ${WORKTREE_PATH}\"\nelse\n    git worktree add \"${WORKTREE_PATH}\" \"${BRANCH_NAME}\"\n    echo \"‚úÖ Created worktree at ${WORKTREE_PATH}\"\nfi\n\n# Navigate to worktree\necho \"\"\necho \"To work in this worktree:\"\necho \"  cd ${WORKTREE_PATH}\"\necho \"\"\necho \"Branch: ${BRANCH_NAME}\"\n```\n\n---\n\n## worktree-cleanup.sh\n\nRemove a worktree after work is complete.\n\n```bash\n#!/bin/bash\n# Usage: ./scripts/worktree-cleanup.sh work-order-service [--delete-branch]\n# Removes worktree and optionally deletes the branch\n\nset -e\n\nSYSTEM_NAME=$1\nDELETE_BRANCH=$2\n\nif [ -z \"$SYSTEM_NAME\" ]; then\n    echo \"Usage: $0 <system-name> [--delete-branch]\"\n    echo \"Example: $0 work-order-service --delete-branch\"\n    exit 1\nfi\n\nWORKTREE_PATH=\".worktrees/${SYSTEM_NAME}\"\nBRANCH_NAME=\"feature/system-${SYSTEM_NAME}\"\n\necho \"üßπ Cleaning up worktree for ${SYSTEM_NAME}...\"\n\n# Check worktree exists\nif [ ! -d \"${WORKTREE_PATH}\" ]; then\n    echo \"Worktree not found at ${WORKTREE_PATH}\"\n    exit 1\nfi\n\n# Return to main\ncd \"$(git rev-parse --show-toplevel)\"\n\n# Remove worktree\ngit worktree remove \"${WORKTREE_PATH}\" --force\necho \"‚úÖ Removed worktree\"\n\n# Optionally delete branch\nif [ \"$DELETE_BRANCH\" = \"--delete-branch\" ]; then\n    git branch -d \"${BRANCH_NAME}\" 2>/dev/null || git branch -D \"${BRANCH_NAME}\"\n    echo \"‚úÖ Deleted branch ${BRANCH_NAME}\"\nfi\n\n# Prune worktree references\ngit worktree prune\n\necho \"\"\necho \"Cleanup complete!\"\n```\n\n---\n\n## worktree-status.sh\n\nShow status of all worktrees.\n\n```bash\n#!/bin/bash\n# Usage: ./scripts/worktree-status.sh\n# Shows all worktrees with their branch and status\n\necho \"üìä Worktree Status\"\necho \"==================\"\necho \"\"\n\n# List all worktrees\ngit worktree list --porcelain | while read -r line; do\n    if [[ $line == worktree* ]]; then\n        path=\"${line#worktree }\"\n    elif [[ $line == HEAD* ]]; then\n        head=\"${line#HEAD }\"\n    elif [[ $line == branch* ]]; then\n        branch=\"${line#branch refs/heads/}\"\n\n        # Get status info\n        if [ -d \"$path\" ]; then\n            cd \"$path\"\n\n            # Count uncommitted changes\n            changes=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')\n\n            # Get ahead/behind\n            upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)\n            if [ -n \"$upstream\" ]; then\n                ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null)\n                behind=$(git rev-list --count HEAD..@{u} 2>/dev/null)\n                sync=\"‚Üë${ahead} ‚Üì${behind}\"\n            else\n                sync=\"no upstream\"\n            fi\n\n            cd - > /dev/null\n\n            # Print status\n            printf \"%-40s %-30s changes: %-3s %s\\n\" \"$path\" \"$branch\" \"$changes\" \"$sync\"\n        fi\n    fi\ndone\n\necho \"\"\necho \"Total worktrees: $(git worktree list | wc -l | tr -d ' ')\"\n```\n\n---\n\n## pr-create.sh\n\nCreate a pull request with standard format.\n\n```bash\n#!/bin/bash\n# Usage: ./scripts/pr-create.sh \"feat: Work Order Service\" [--draft]\n# Creates a PR from current branch to main\n\nset -e\n\nTITLE=$1\nDRAFT=$2\n\nif [ -z \"$TITLE\" ]; then\n    echo \"Usage: $0 \\\"<title>\\\" [--draft]\"\n    echo \"Example: $0 \\\"feat: Work Order Service\\\" --draft\"\n    exit 1\nfi\n\nBRANCH=$(git branch --show-current)\nSYSTEM_NAME=$(echo \"$BRANCH\" | sed 's/feature\\/system-//')\n\necho \"üìù Creating PR for ${BRANCH}...\"\n\n# Ensure we have latest main\ngit fetch origin main\n\n# Check for unpushed commits\nUNPUSHED=$(git log origin/${BRANCH}..${BRANCH} 2>/dev/null | wc -l)\nif [ \"$UNPUSHED\" -gt 0 ]; then\n    echo \"Pushing ${UNPUSHED} commits...\"\n    git push origin \"${BRANCH}\"\nfi\n\n# Build PR body\nPR_BODY=$(cat << EOF\n## Summary\n\n[Brief description of what this PR does]\n\n## Changes\n\n- [Change 1]\n- [Change 2]\n\n## Testing\n\n- [ ] Unit tests pass\n- [ ] Integration tests pass\n- [ ] Manual testing completed\n\n## Checklist\n\n- [ ] Code follows project conventions\n- [ ] Documentation updated\n- [ ] No security issues introduced\n- [ ] Performance acceptable\n\n## Related\n\n- Closes #[issue number]\n\n---\n*System: ${SYSTEM_NAME}*\nEOF\n)\n\n# Create PR\nif [ \"$DRAFT\" = \"--draft\" ]; then\n    gh pr create --base main --head \"${BRANCH}\" --title \"${TITLE}\" --body \"${PR_BODY}\" --draft\nelse\n    gh pr create --base main --head \"${BRANCH}\" --title \"${TITLE}\" --body \"${PR_BODY}\"\nfi\n\necho \"\"\necho \"‚úÖ PR created!\"\n```\n\n---\n\n## sync-main.sh\n\nSync current branch with main (rebase).\n\n```bash\n#!/bin/bash\n# Usage: ./scripts/sync-main.sh\n# Rebases current branch on latest main\n\nset -e\n\nBRANCH=$(git branch --show-current)\n\nif [ \"$BRANCH\" = \"main\" ]; then\n    echo \"Already on main, pulling latest...\"\n    git pull origin main\n    exit 0\nfi\n\necho \"üîÑ Syncing ${BRANCH} with main...\"\n\n# Stash any changes\nSTASHED=false\nif [ -n \"$(git status --porcelain)\" ]; then\n    echo \"Stashing local changes...\"\n    git stash\n    STASHED=true\nfi\n\n# Fetch and rebase\ngit fetch origin main\ngit rebase origin/main\n\nif [ \"$STASHED\" = true ]; then\n    echo \"Restoring stashed changes...\"\n    git stash pop\nfi\n\necho \"\"\necho \"‚úÖ Branch synced with main\"\necho \"\"\necho \"To push: git push origin ${BRANCH} --force-with-lease\"\n```\n\n---\n\n## commit-feature.sh\n\nMake a conventional commit.\n\n```bash\n#!/bin/bash\n# Usage: ./scripts/commit-feature.sh \"add work order CRUD endpoints\"\n# Creates: feat(work-order): add work order CRUD endpoints\n\nset -e\n\nMESSAGE=$1\n\nif [ -z \"$MESSAGE\" ]; then\n    echo \"Usage: $0 \\\"<commit message>\\\"\"\n    echo \"Example: $0 \\\"add work order CRUD endpoints\\\"\"\n    exit 1\nfi\n\n# Extract scope from branch name\nBRANCH=$(git branch --show-current)\nSCOPE=$(echo \"$BRANCH\" | sed 's/feature\\/system-//' | cut -d'-' -f1-2)\n\n# Default type\nTYPE=\"feat\"\n\n# Detect type from message\nif [[ \"$MESSAGE\" == fix:* ]] || [[ \"$MESSAGE\" == *\"fix \"* ]]; then\n    TYPE=\"fix\"\n    MESSAGE=\"${MESSAGE#fix: }\"\nelif [[ \"$MESSAGE\" == docs:* ]] || [[ \"$MESSAGE\" == *\"documentation\"* ]]; then\n    TYPE=\"docs\"\n    MESSAGE=\"${MESSAGE#docs: }\"\nelif [[ \"$MESSAGE\" == test:* ]] || [[ \"$MESSAGE\" == *\"test\"* ]]; then\n    TYPE=\"test\"\n    MESSAGE=\"${MESSAGE#test: }\"\nelif [[ \"$MESSAGE\" == refactor:* ]]; then\n    TYPE=\"refactor\"\n    MESSAGE=\"${MESSAGE#refactor: }\"\nfi\n\n# Stage all changes\ngit add -A\n\n# Commit with conventional format\nFULL_MESSAGE=\"${TYPE}(${SCOPE}): ${MESSAGE}\"\ngit commit -m \"${FULL_MESSAGE}\"\n\necho \"\"\necho \"‚úÖ Committed: ${FULL_MESSAGE}\"\n```\n\n---\n\n## branch-cleanup.sh\n\nClean up merged branches.\n\n```bash\n#!/bin/bash\n# Usage: ./scripts/branch-cleanup.sh\n# Removes local branches that have been merged to main\n\nset -e\n\necho \"üßπ Cleaning up merged branches...\"\n\n# Switch to main\ngit checkout main\ngit pull origin main\n\n# Find and delete merged branches\nMERGED=$(git branch --merged main | grep -v \"main\" | grep -v \"\\*\")\n\nif [ -z \"$MERGED\" ]; then\n    echo \"No merged branches to clean up\"\n    exit 0\nfi\n\necho \"The following branches have been merged:\"\necho \"$MERGED\"\necho \"\"\nread -p \"Delete these branches? (y/n) \" -n 1 -r\necho \"\"\n\nif [[ $REPLY =~ ^[Yy]$ ]]; then\n    echo \"$MERGED\" | xargs git branch -d\n    echo \"‚úÖ Branches deleted\"\nelse\n    echo \"Cancelled\"\nfi\n```\n\n---\n\n## Installation\n\nAdd all scripts to your project:\n\n```bash\nmkdir -p scripts\n\n# Copy each script above to scripts/\n# Then make executable:\nchmod +x scripts/*.sh\n\n# Add to .gitignore if you don't want to commit\necho \"scripts/*.sh\" >> .gitignore\n\n# Or commit them for team use\ngit add scripts/\ngit commit -m \"chore: add git workflow scripts\"\n```\n\n## Usage Summary\n\n| Script | Purpose | Example |\n|--------|---------|---------|\n| `worktree-create.sh` | Create isolated worktree | `./scripts/worktree-create.sh sys-002 work-orders` |\n| `worktree-cleanup.sh` | Remove worktree | `./scripts/worktree-cleanup.sh work-orders --delete-branch` |\n| `worktree-status.sh` | Show all worktrees | `./scripts/worktree-status.sh` |\n| `pr-create.sh` | Create PR | `./scripts/pr-create.sh \"feat: Work Orders\"` |\n| `sync-main.sh` | Rebase on main | `./scripts/sync-main.sh` |\n| `commit-feature.sh` | Conventional commit | `./scripts/commit-feature.sh \"add CRUD\"` |\n| `branch-cleanup.sh` | Delete merged branches | `./scripts/branch-cleanup.sh` |\n"
    },
    {
      "name": "worktree-commands.md",
      "path": "references/worktree-commands.md",
      "content": "# Worktree Commands Reference\n\nComplete reference for git worktree operations.\n\n## Basic Worktree Operations\n\n### Create Worktree with New Branch\n\n```bash\ngit worktree add <path> -b <new-branch-name>\n```\n\nCreates a new working directory at `<path>` and creates a new branch `<new-branch-name>` starting from the current HEAD.\n\n**Example:**\n```bash\ngit worktree add .worktrees/system-auth -b feature/system-auth\n```\n\n### Create Worktree from Existing Branch\n\n```bash\ngit worktree add <path> <existing-branch>\n```\n\nCreates a new working directory at `<path>` checking out `<existing-branch>`.\n\n**Example:**\n```bash\ngit worktree add .worktrees/hotfix-urgent hotfix/urgent-fix\n```\n\n### Create Worktree from Remote Branch\n\n```bash\ngit fetch origin\ngit worktree add <path> <remote-branch>\n```\n\n**Example:**\n```bash\ngit fetch origin\ngit worktree add .worktrees/review-pr origin/feature/new-feature\n```\n\n### Create Detached HEAD Worktree\n\n```bash\ngit worktree add --detach <path> <commit>\n```\n\nCreates a worktree at a specific commit without creating a branch.\n\n**Example:**\n```bash\ngit worktree add --detach .worktrees/investigate-bug abc1234\n```\n\n## Listing Worktrees\n\n### List All Worktrees\n\n```bash\ngit worktree list\n```\n\n**Output:**\n```\n/home/user/repo                 abc1234 [main]\n/home/user/repo/.worktrees/system-auth  def5678 [feature/system-auth]\n/home/user/repo/.worktrees/system-orders  ghi9012 [feature/system-orders]\n```\n\n### Verbose List\n\n```bash\ngit worktree list --porcelain\n```\n\n**Output:**\n```\nworktree /home/user/repo\nHEAD abc1234\nbranch refs/heads/main\n\nworktree /home/user/repo/.worktrees/system-auth\nHEAD def5678\nbranch refs/heads/feature/system-auth\n```\n\n## Removing Worktrees\n\n### Remove Worktree (Clean)\n\n```bash\ngit worktree remove <path>\n```\n\nRemoves worktree if working directory is clean.\n\n**Example:**\n```bash\ngit worktree remove .worktrees/system-auth\n```\n\n### Force Remove Worktree\n\n```bash\ngit worktree remove --force <path>\n```\n\nRemoves worktree even if there are uncommitted changes.\n\n**Example:**\n```bash\ngit worktree remove --force .worktrees/abandoned-feature\n```\n\n### Prune Stale Worktrees\n\n```bash\ngit worktree prune\n```\n\nRemoves worktree administrative files for worktrees whose directories have been deleted.\n\n### Dry Run Prune\n\n```bash\ngit worktree prune --dry-run\n```\n\nShows what would be pruned without actually doing it.\n\n## Moving Worktrees\n\n### Move Worktree to New Location\n\n```bash\ngit worktree move <worktree> <new-path>\n```\n\n**Example:**\n```bash\ngit worktree move .worktrees/system-auth .worktrees/auth-service\n```\n\n## Worktree Lock/Unlock\n\n### Lock Worktree\n\n```bash\ngit worktree lock <path>\n```\n\nPrevents worktree from being pruned. Useful for worktrees on removable drives.\n\n**Example:**\n```bash\ngit worktree lock .worktrees/external-drive-work\n```\n\n### Lock with Reason\n\n```bash\ngit worktree lock --reason \"On external drive\" <path>\n```\n\n### Unlock Worktree\n\n```bash\ngit worktree unlock <path>\n```\n\n## Common Patterns\n\n### Pattern: System Development\n\n```bash\n# 1. Start from clean main\ncd /path/to/repo\ngit checkout main\ngit pull origin main\n\n# 2. Create worktree for system\ngit worktree add .worktrees/system-servicegrid -b feature/system-servicegrid\n\n# 3. Work in worktree\ncd .worktrees/system-servicegrid\n# ... develop ...\n\n# 4. Push changes\ngit push -u origin feature/system-servicegrid\n\n# 5. Create PR\ngh pr create --base main --head feature/system-servicegrid\n\n# 6. After merge, cleanup\ncd /path/to/repo\ngit checkout main\ngit pull origin main\ngit worktree remove .worktrees/system-servicegrid\ngit branch -d feature/system-servicegrid\n```\n\n### Pattern: Parallel Systems\n\n```bash\n# System 1\ngit worktree add .worktrees/system-auth -b feature/system-auth\n\n# System 2 (different terminal)\ngit worktree add .worktrees/system-orders -b feature/system-orders\n\n# System 3 (different terminal)\ngit worktree add .worktrees/system-routing -b feature/system-routing\n```\n\n### Pattern: Review a PR\n\n```bash\n# Fetch PR branch\ngit fetch origin pull/123/head:pr-123\n\n# Create worktree for review\ngit worktree add .worktrees/review-pr-123 pr-123\n\n# Review\ncd .worktrees/review-pr-123\n# ... review code, run tests ...\n\n# Cleanup\ncd /path/to/repo\ngit worktree remove .worktrees/review-pr-123\ngit branch -D pr-123\n```\n\n### Pattern: Hotfix While Feature in Progress\n\n```bash\n# Current state: working on feature in worktree\n# Need to make urgent hotfix\n\n# Create hotfix worktree from main\ngit worktree add .worktrees/hotfix-urgent -b hotfix/urgent-fix origin/main\n\n# Work on hotfix\ncd .worktrees/hotfix-urgent\n# ... fix ...\ngit commit -am \"fix: urgent production issue\"\ngit push -u origin hotfix/urgent-fix\n\n# Create PR, get it merged\n\n# Return to feature work\ncd .worktrees/system-servicegrid\ngit fetch origin main\ngit rebase origin/main\n```\n\n### Pattern: Testing Different Configurations\n\n```bash\n# Test against different base branches\ngit worktree add .worktrees/test-against-develop develop\ngit worktree add .worktrees/test-against-main main\n\n# Run tests in each\ncd .worktrees/test-against-develop && npm test\ncd .worktrees/test-against-main && npm test\n```\n\n## Directory Structure\n\n### Recommended Layout\n\n```\nrepository/\n‚îú‚îÄ‚îÄ .git/                 # Shared git database\n‚îú‚îÄ‚îÄ .gitignore           # Should include .worktrees/\n‚îú‚îÄ‚îÄ src/                 # Main branch source\n‚îú‚îÄ‚îÄ ...\n‚îî‚îÄ‚îÄ .worktrees/          # All worktrees here\n    ‚îú‚îÄ‚îÄ system-auth/     # feature/system-auth\n    ‚îú‚îÄ‚îÄ system-orders/   # feature/system-orders\n    ‚îî‚îÄ‚îÄ hotfix-urgent/   # hotfix/urgent-fix\n```\n\n### .gitignore Entry\n\n```gitignore\n# Worktrees directory\n.worktrees/\n```\n\n## Troubleshooting\n\n### Error: \"is already checked out\"\n\n```bash\n# Can't create worktree for branch that's checked out elsewhere\ngit worktree add .worktrees/test main\n# fatal: 'main' is already checked out at '/path/to/repo'\n\n# Solution: use different branch or detached HEAD\ngit worktree add .worktrees/test-main --detach main\n```\n\n### Error: \"not a valid worktree path\"\n\n```bash\n# Worktree was deleted without git worktree remove\ngit worktree remove .worktrees/deleted\n# fatal: '.worktrees/deleted' is not a valid worktree path\n\n# Solution: prune stale entries\ngit worktree prune\n```\n\n### Worktree Has Uncommitted Changes\n\n```bash\n# Can't remove worktree with changes\ngit worktree remove .worktrees/dirty\n# fatal: '.worktrees/dirty' contains modified or untracked files\n\n# Solution 1: commit or stash changes\ncd .worktrees/dirty\ngit stash  # or git commit\n\n# Solution 2: force remove\ngit worktree remove --force .worktrees/dirty\n```\n\n### Worktree on Different Filesystem\n\n```bash\n# Lock worktrees on removable drives\ngit worktree lock --reason \"On USB drive\" /mnt/usb/worktree\n\n# This prevents accidental pruning\n```\n\n## Best Practices\n\n1. **Use `.worktrees/` directory** ‚Äî Keep all worktrees organized\n2. **Add to .gitignore** ‚Äî Don't commit worktree directories\n3. **Name branches clearly** ‚Äî Include system/feature name\n4. **Clean up after merge** ‚Äî Remove worktrees promptly\n5. **Prune regularly** ‚Äî Run `git worktree prune` occasionally\n6. **Lock if needed** ‚Äî For worktrees on removable storage\n"
    }
  ],
  "tags": [
    "git",
    "branching",
    "deployment",
    "pr",
    "core-workflow"
  ],
  "dependsOn": []
}