{
  "id": "architecture-extractor",
  "name": "architecture-extractor",
  "version": "1.0.0",
  "description": "Analyze a source system — codebase, documentation, diagrams, or verbal description — and extract a clean, structured architecture document. Reverse-engineers components, data flows, interfaces, patterns, and constraints into ARCHITECTURE.md.",
  "phase": "EXTRACT",
  "category": "engineering",
  "content": "# Architecture Extractor\n\nAnalyze a source system and extract its architecture into a structured document.\n\n## When to Use\n\n- **Porting an existing system** --- Need to understand its architecture before rebuilding in a new stack\n- **Reverse-engineering** --- Source system has no architecture docs, need to create them\n- **Architecture audit** --- Want a clean snapshot of how a system is actually structured\n- **Transposition input** --- First step of the transpose-loop: extract before mapping to a new stack\n- When you say: \"extract the architecture\", \"what's the architecture of this system?\", \"document how this works\"\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `ARCHITECTURE.md` | Project root | Always |\n\n## Core Concept\n\nArchitecture extraction answers: **\"What is the actual architecture of this system?\"**\n\nThis skill works from whatever source material is available:\n\n| Source | Approach |\n|--------|----------|\n| **Codebase** | Read entry points, trace data flows, map module boundaries |\n| **Documentation** | Synthesize from READMEs, wikis, API docs |\n| **Diagrams** | Interpret from existing visual representations |\n| **Verbal description** | Structure from user's explanation of how the system works |\n| **Running system** | Infer from API responses, database schema, logs |\n\nExtraction is NOT:\n- Designing a new architecture (that's `architect`)\n- Evaluating quality (that's `audit-loop`)\n- Planning a migration (that's `migration-planner`)\n\n## The Extraction Process\n\n```\nSOURCE MATERIAL\n     │\n     ▼\n┌─────────────────────────────────────────────────────────┐\n│                 EXTRACTION PROCESS                       │\n│                                                         │\n│  1. SURVEY                                              │\n│     └─→ What source material exists? What's missing?    │\n│                                                         │\n│  2. MAP COMPONENTS                                      │\n│     └─→ Services, modules, layers, external systems     │\n│                                                         │\n│  3. TRACE DATA FLOWS                                    │\n│     └─→ Request paths, event flows, data pipelines      │\n│                                                         │\n│  4. EXTRACT DATA MODEL                                  │\n│     └─→ Entities, relationships, storage patterns       │\n│                                                         │\n│  5. IDENTIFY INTERFACES                                 │\n│     └─→ APIs, protocols, contracts between components   │\n│                                                         │\n│  6. CATALOG CROSS-CUTTING CONCERNS                      │\n│     └─→ Auth, logging, errors, caching, config          │\n│                                                         │\n│  7. DOCUMENT PATTERNS                                   │\n│     └─→ Architectural patterns in use, conventions      │\n│                                                         │\n│  8. CAPTURE CONSTRAINTS                                 │\n│     └─→ What the architecture optimizes for and why     │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n     │\n     ▼\nARCHITECTURE.md\n```\n\n## Step 1: Survey Source Material\n\nAssess what's available and identify gaps:\n\n```markdown\n### Source Material Inventory\n\n| Source | Available | Quality | Notes |\n|--------|-----------|---------|-------|\n| Codebase | Yes/No | High/Medium/Low | [location, language, size] |\n| README / docs | Yes/No | | [what's covered] |\n| API documentation | Yes/No | | [format, completeness] |\n| Database schema | Yes/No | | [access method] |\n| Architecture diagrams | Yes/No | | [format, age] |\n| User description | Yes/No | | [detail level] |\n| Running instance | Yes/No | | [access available] |\n\n### Gaps\n- [What's missing that would help]\n```\n\nPrioritize codebase and database schema as the most reliable sources. Documentation may be outdated.\n\n## Step 2: Map Components\n\nIdentify every distinct component:\n\n```markdown\n### Component Inventory\n\n| Component | Type | Responsibility | Technology | Communicates With |\n|-----------|------|---------------|------------|-------------------|\n| [name] | service/module/layer/external | [what it does] | [language/framework] | [other components] |\n```\n\n**Component types:**\n\n| Type | Description | How to Identify |\n|------|-------------|-----------------|\n| **Service** | Independent deployable unit | Separate process, own entry point |\n| **Module** | Logical grouping within a service | Directory/package boundary |\n| **Layer** | Horizontal slice (presentation, business, data) | Import direction, naming conventions |\n| **External** | Third-party system | API calls, SDK usage |\n| **Infrastructure** | Platform component | Database, queue, cache, CDN |\n\n## Step 3: Trace Data Flows\n\nFor each major user action or system event, trace the full path:\n\n```markdown\n### Data Flow: [Action Name]\n\n1. [Entry point] receives [input]\n2. [Component A] validates and transforms\n3. [Component B] applies business logic\n4. [Storage] persists result\n5. [Component C] sends notification\n6. [Entry point] returns [output]\n```\n\nIdentify:\n- **Request paths** — user action to response\n- **Event flows** — triggers, handlers, side effects\n- **Data pipelines** — batch processing, ETL, sync jobs\n- **Background processes** — cron jobs, workers, schedulers\n\n## Step 4: Extract Data Model\n\n```markdown\n### Data Model\n\n| Entity | Storage | Key Fields | Relationships |\n|--------|---------|------------|---------------|\n| [name] | [postgres/mongo/redis/etc] | [important fields] | [belongs_to/has_many/references] |\n\n### Storage Patterns\n\n| Pattern | Where Used | Purpose |\n|---------|-----------|---------|\n| [e.g., soft delete] | [entities] | [why] |\n| [e.g., JSONB columns] | [entities] | [why] |\n| [e.g., event sourcing] | [entities] | [why] |\n```\n\n## Step 5: Identify Interfaces\n\n```markdown\n### API Surfaces\n\n| Interface | Protocol | Format | Auth | Consumers |\n|-----------|----------|--------|------|-----------|\n| [name] | REST/GraphQL/gRPC/WebSocket | JSON/protobuf | [method] | [who calls it] |\n\n### Internal Interfaces\n\n| From | To | Mechanism | Contract |\n|------|-----|-----------|----------|\n| [component] | [component] | function call/event/queue/HTTP | [shape of data exchanged] |\n```\n\n## Step 6: Catalog Cross-Cutting Concerns\n\n| Concern | Implementation | Notes |\n|---------|---------------|-------|\n| **Authentication** | [method: JWT, session, OAuth, API key] | [provider, flow] |\n| **Authorization** | [method: RBAC, ABAC, RLS] | [granularity] |\n| **Error handling** | [strategy: exceptions, result types, error codes] | [propagation pattern] |\n| **Logging** | [library, format, destination] | [structured? levels?] |\n| **Configuration** | [method: env vars, config files, feature flags] | [per-environment?] |\n| **Caching** | [what, where, TTL strategy] | [invalidation method] |\n| **Monitoring** | [metrics, health checks, alerting] | [tools used] |\n\n## Step 7: Document Patterns\n\nIdentify architectural patterns in use:\n\n```markdown\n### Architectural Patterns\n\n| Pattern | Where Applied | Confidence |\n|---------|--------------|------------|\n| [e.g., Layered architecture] | [whole system / specific service] | High/Medium/Low |\n| [e.g., Event-driven] | [specific subsystem] | |\n| [e.g., Repository pattern] | [data access layer] | |\n| [e.g., CQRS] | [read vs write paths] | |\n\n### Conventions\n\n| Convention | Example | Consistency |\n|-----------|---------|-------------|\n| [naming] | [example from code] | [how consistently followed] |\n| [file structure] | [example layout] | |\n| [error format] | [example error] | |\n```\n\n## Step 8: Capture Constraints and Quality Attributes\n\n```markdown\n### Quality Attributes (What the Architecture Optimizes For)\n\n| Attribute | Evidence | Priority |\n|-----------|----------|----------|\n| [e.g., Developer velocity] | [simple stack, few abstractions] | Inferred: High |\n| [e.g., Scalability] | [stateless services, queue-based workers] | Inferred: Medium |\n\n### Constraints\n\n| Constraint | Source | Impact |\n|-----------|--------|--------|\n| [e.g., Must run on single server] | [infrastructure setup] | [limits horizontal scaling] |\n| [e.g., Python-only team] | [all code is Python] | [technology choices] |\n```\n\n## ARCHITECTURE.md Template\n\n```markdown\n# [System Name] Architecture\n\n## Overview\n[One paragraph: what the system does and how it's structured]\n\n## Components\n[Component inventory table from Step 2]\n\n### Component Diagram\n[ASCII diagram showing components and connections]\n\n## Data Model\n[Entity table and storage patterns from Step 4]\n\n## Data Flows\n[Major data flow traces from Step 3]\n\n## Interfaces\n[API surfaces and internal interfaces from Step 5]\n\n## Cross-Cutting Concerns\n[Table from Step 6]\n\n## Architectural Patterns\n[Patterns and conventions from Step 7]\n\n## Quality Attributes and Constraints\n[From Step 8]\n\n## Source Material\n[What was analyzed, confidence level per section]\n```\n\n## Confidence Levels\n\nNot all extracted architecture has equal certainty. Mark confidence:\n\n| Level | Meaning | When to Apply |\n|-------|---------|---------------|\n| **High** | Directly observed in code/schema | Read it in source |\n| **Medium** | Inferred from patterns | Multiple clues point to this |\n| **Low** | Best guess from limited info | Single clue or user description only |\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `architect` | Architect designs new architecture; extractor documents existing architecture |\n| `stack-analyzer` | Extractor output feeds stack-analyzer for transposition mapping |\n| `spec` | Extracted architecture informs spec compilation |\n| `code-verification` | Extraction may reveal architectural issues |\n\n## Key Principles\n\n**Extract what IS, not what SHOULD BE.** Document the actual architecture, not an idealized version. Note gaps and issues but don't fix them during extraction.\n\n**Trace code over documentation.** Code is truth. Documentation may be outdated. When they conflict, trust the code.\n\n**Confidence matters.** Mark uncertain sections. Downstream skills (stack-analyzer, spec) need to know what's solid and what's inferred.\n\n**Components over code.** Focus on structural elements and their relationships, not implementation details. The goal is architectural understanding, not a code walkthrough.\n\n**One pass is not enough.** Initial survey reveals structure; data flow tracing reveals hidden connections. Plan for at least two passes through the source material.",
  "references": [],
  "tags": [
    "architecture",
    "analysis",
    "extraction",
    "reverse-engineering",
    "transposition"
  ],
  "dependsOn": []
}