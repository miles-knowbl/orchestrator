{
  "id": "integration-test",
  "name": "integration-test",
  "version": "1.0.0",
  "description": "Validates that multiple systems work together correctly. Tests cross-system contracts, end-to-end workflows, and interface compatibility. Complements unit testing (test-generation) and code validation (code-validation) by focusing on system boundaries.",
  "phase": "TEST",
  "category": "core",
  "content": "# Integration Test\n\nValidate systems work together.\n\n## When to Use\n\n- **After implementing a system** — Verify it integrates with dependencies\n- **Before shipping** — Confirm end-to-end workflows function\n- **After contract changes** — Validate interface compatibility\n- **Cross-system features** — Test workflows spanning multiple systems\n- **Regression prevention** — Ensure changes don't break integrations\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `scenario-templates.md` | Templates for integration test scenarios |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| MCP tool definitions or API specs | When testing specific integrations |\n\n**Verification:** Ensure integration tests are executable, not just documented.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Integration test files | `tests/integration/` | Always |\n| `INTEGRATION-TEST.md` | Project root | When documenting test scenarios |\n\n## Core Concept\n\nIntegration testing answers: **\"Do these systems work together correctly?\"**\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                    INTEGRATION TESTING                                       │\n│                                                                             │\n│  Unit Tests        Integration Tests         E2E Tests                      │\n│  ──────────        ─────────────────         ─────────                      │\n│  Single            System                    Full                           │\n│  Component         Boundaries                Workflows                      │\n│                                                                             │\n│  ┌───────┐         ┌───────┐  ┌───────┐     ┌───────┐                      │\n│  │   A   │         │   A   │──│   B   │     │   A   │──▶│   B   │──▶│   C  │\n│  └───────┘         └───────┘  └───────┘     └───────┘                      │\n│                                                                             │\n│  \"Does A work?\"    \"Do A and B work       \"Does the whole                  │\n│                     together?\"              workflow work?\"                 │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n## Integration Test Types\n\n### 1. Contract Tests\n\nVerify systems honor their API contracts.\n\n| Type | Description | Example |\n|------|-------------|---------|\n| **Consumer Contract** | Consumer's expectations of provider | \"Order Service expects Auth to return JWT with userId\" |\n| **Provider Contract** | Provider's published interface | \"Auth Service returns JWT per OpenAPI spec\" |\n| **Pact-style** | Bidirectional contract verification | Both sides verify against shared contract |\n\n### 2. API Integration Tests\n\nTest actual HTTP/RPC communication between services.\n\n| Focus | What to Test |\n|-------|--------------|\n| Happy path | Standard request → expected response |\n| Error handling | Invalid input → proper error code |\n| Authentication | Token → authorized/unauthorized correctly |\n| Rate limiting | Excessive requests → throttled |\n| Timeout | Slow response → handled gracefully |\n\n### 3. Event Integration Tests\n\nTest asynchronous message passing.\n\n| Focus | What to Test |\n|-------|--------------|\n| Event publishing | Action → event published correctly |\n| Event consuming | Event received → correct handling |\n| Event ordering | Sequence preserved when required |\n| Duplicate handling | Same event twice → idempotent |\n| Dead letter | Failed processing → captured |\n\n### 4. Data Integration Tests\n\nTest data flows between systems.\n\n| Focus | What to Test |\n|-------|--------------|\n| Data format | Correct schema between systems |\n| Data transformation | Mapped correctly |\n| Data consistency | Same data in both systems |\n| Referential integrity | Foreign keys valid |\n\n### 5. End-to-End Tests\n\nTest complete user workflows.\n\n| Focus | What to Test |\n|-------|--------------|\n| Critical paths | Main user journeys |\n| Cross-system flows | Actions spanning services |\n| State transitions | Complete lifecycle |\n\n## The Integration Test Process\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                  INTEGRATION TEST PROCESS                                    │\n│                                                                             │\n│  1. IDENTIFY INTEGRATION POINTS                                             │\n│     └─→ What systems does this system interact with?                        │\n│     └─→ What APIs does it call? What events does it publish/consume?        │\n│                                                                             │\n│  2. GATHER CONTRACTS                                                        │\n│     └─→ Load API specs from interfaces/api/                                 │\n│     └─→ Load event schemas from interfaces/events/                          │\n│                                                                             │\n│  3. DESIGN TEST SCENARIOS                                                   │\n│     └─→ Happy path scenarios                                                │\n│     └─→ Error scenarios                                                     │\n│     └─→ Edge cases                                                          │\n│                                                                             │\n│  4. SET UP TEST ENVIRONMENT                                                 │\n│     └─→ Start required services (or mocks)                                  │\n│     └─→ Set up test data                                                    │\n│     └─→ Configure test credentials                                          │\n│                                                                             │\n│  5. IMPLEMENT TESTS                                                         │\n│     └─→ Contract tests                                                      │\n│     └─→ API integration tests                                               │\n│     └─→ Event integration tests                                             │\n│     └─→ E2E tests for critical paths                                        │\n│                                                                             │\n│  6. RUN AND VERIFY                                                          │\n│     └─→ Execute tests                                                       │\n│     └─→ Analyze failures                                                    │\n│     └─→ Fix contract mismatches                                             │\n│                                                                             │\n│  7. DOCUMENT INTEGRATION                                                    │\n│     └─→ Update interface documentation                                      │\n│     └─→ Document test coverage                                              │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n## Step 1: Identify Integration Points\n\nFor the system under test, document:\n\n```markdown\n## Integration Points: [System Name]\n\n### APIs Called (Outbound)\n| Service | Endpoint | Method | Purpose |\n|---------|----------|--------|---------|\n| Auth | /auth/verify | POST | Verify JWT token |\n| User | /users/{id} | GET | Get user details |\n\n### APIs Exposed (Inbound)\n| Endpoint | Method | Consumers | Purpose |\n|----------|--------|-----------|---------|\n| /orders | POST | Mobile App, Web App | Create order |\n| /orders/{id} | GET | Mobile App, Web App, Analytics | Get order |\n\n### Events Published\n| Event | Channel | Consumers |\n|-------|---------|-----------|\n| OrderCreated | orders/created | Notification, Analytics |\n| OrderCompleted | orders/completed | Billing, Analytics |\n\n### Events Consumed\n| Event | Channel | Publisher |\n|-------|---------|-----------|\n| UserCreated | users/created | User Service |\n| PaymentReceived | payments/received | Billing Service |\n\n### Data Dependencies\n| System | Data | Direction | Sync Method |\n|--------|------|-----------|-------------|\n| User Service | User records | Read | API call |\n| Inventory | Stock levels | Read | Event |\n```\n\n## Step 2: Gather Contracts\n\nLoad contracts from domain memory:\n\n```bash\n# API contracts\ncat domain-memory/{domain}/interfaces/api/auth-service.yaml\ncat domain-memory/{domain}/interfaces/api/order-service.yaml\n\n# Event contracts\ncat domain-memory/{domain}/interfaces/events/order-events.yaml\n```\n\nIf contracts don't exist, create them using templates from `memory-manager/references/interface-contracts.md`.\n\n## Step 3: Design Test Scenarios\n\n### Scenario Template\n\n```markdown\n## Scenario: [Name]\n\n**Type:** Contract | API | Event | E2E\n**Systems Involved:** [List]\n**Priority:** High | Medium | Low\n\n### Setup\n- [Precondition 1]\n- [Precondition 2]\n\n### Steps\n1. [Action 1]\n2. [Action 2]\n3. [Action 3]\n\n### Expected Results\n- [Expected outcome 1]\n- [Expected outcome 2]\n\n### Cleanup\n- [Cleanup step 1]\n```\n\n### Scenario Categories\n\n| Category | Scenarios to Include |\n|----------|---------------------|\n| **Happy Path** | Standard successful flow |\n| **Authentication** | Valid token, invalid token, expired token |\n| **Authorization** | Permitted actions, forbidden actions |\n| **Validation** | Valid input, invalid input, edge cases |\n| **Error Handling** | Service down, timeout, malformed response |\n| **Concurrency** | Simultaneous requests, race conditions |\n| **Data Integrity** | Consistent data across systems |\n\n→ See `references/scenario-templates.md`\n\n## Step 4: Test Environment\n\n### Options\n\n| Environment | Pros | Cons | Use When |\n|-------------|------|------|----------|\n| **Mocks** | Fast, isolated | Not real services | Unit-level integration |\n| **Docker Compose** | Realistic, reproducible | Setup complexity | Local development |\n| **Staging** | Production-like | Shared, may be unstable | Pre-production |\n| **Production (read-only)** | Real data | Risk | Smoke tests only |\n\n### Docker Compose Example\n\n```yaml\n# docker-compose.test.yaml\nversion: '3.8'\n\nservices:\n  # System under test\n  order-service:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - AUTH_SERVICE_URL=http://auth-service:3001\n      - DATABASE_URL=postgres://postgres:postgres@db:5432/orders\n    depends_on:\n      - auth-service\n      - db\n\n  # Dependency\n  auth-service:\n    image: auth-service:test\n    ports:\n      - \"3001:3001\"\n    environment:\n      - JWT_SECRET=test-secret\n\n  # Database\n  db:\n    image: postgres:14\n    environment:\n      - POSTGRES_PASSWORD=postgres\n      - POSTGRES_DB=orders\n\n  # Message broker\n  kafka:\n    image: confluentinc/cp-kafka:latest\n    ports:\n      - \"9092:9092\"\n```\n\n### Test Data Setup\n\n```javascript\n// test/setup.js\nasync function setupTestData() {\n  // Create test users\n  await authService.createUser({\n    id: 'test-user-1',\n    email: 'test@example.com',\n    role: 'technician'\n  });\n  \n  // Create test orders\n  await orderService.createOrder({\n    id: 'test-order-1',\n    customerId: 'test-customer-1',\n    status: 'pending'\n  });\n}\n\nasync function teardownTestData() {\n  await orderService.deleteOrder('test-order-1');\n  await authService.deleteUser('test-user-1');\n}\n```\n\n→ See `references/test-environment-setup.md`\n\n## Step 5: Implement Tests\n\n### Contract Test Example (Pact-style)\n\n```javascript\n// Consumer side (Order Service expects Auth Service)\ndescribe('Auth Service Contract', () => {\n  it('verifies JWT token', async () => {\n    // Define expected interaction\n    await provider.addInteraction({\n      state: 'a valid JWT exists',\n      uponReceiving: 'a request to verify token',\n      withRequest: {\n        method: 'POST',\n        path: '/auth/verify',\n        headers: { 'Content-Type': 'application/json' },\n        body: { token: 'valid-jwt-token' }\n      },\n      willRespondWith: {\n        status: 200,\n        body: {\n          valid: true,\n          userId: Matchers.string(),\n          expiresAt: Matchers.iso8601DateTime()\n        }\n      }\n    });\n    \n    // Execute\n    const result = await authClient.verifyToken('valid-jwt-token');\n    \n    // Verify\n    expect(result.valid).toBe(true);\n    expect(result.userId).toBeDefined();\n  });\n});\n```\n\n### API Integration Test Example\n\n```javascript\n// test/integration/order-api.test.js\ndescribe('Order API Integration', () => {\n  let authToken;\n  \n  beforeAll(async () => {\n    // Get real auth token from Auth Service\n    authToken = await authService.login({\n      email: 'test@example.com',\n      password: 'test-password'\n    });\n  });\n  \n  describe('POST /orders', () => {\n    it('creates order with valid token', async () => {\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          customerId: 'test-customer-1',\n          items: [{ productId: 'prod-1', quantity: 2 }]\n        });\n      \n      expect(response.status).toBe(201);\n      expect(response.body.id).toBeDefined();\n      expect(response.body.status).toBe('pending');\n      \n      // Verify in database\n      const order = await db.orders.findById(response.body.id);\n      expect(order).toBeDefined();\n    });\n    \n    it('rejects request with invalid token', async () => {\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', 'Bearer invalid-token')\n        .send({ customerId: 'test-customer-1' });\n      \n      expect(response.status).toBe(401);\n    });\n    \n    it('handles auth service timeout gracefully', async () => {\n      // Simulate Auth Service being slow\n      authServiceMock.setLatency(5000);\n      \n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({ customerId: 'test-customer-1' });\n      \n      // Should timeout and return error\n      expect(response.status).toBe(503);\n      expect(response.body.error).toContain('Service unavailable');\n    });\n  });\n});\n```\n\n### Event Integration Test Example\n\n```javascript\n// test/integration/order-events.test.js\ndescribe('Order Events Integration', () => {\n  let eventCapture;\n  \n  beforeAll(async () => {\n    // Subscribe to events\n    eventCapture = await kafka.subscribe('orders/#');\n  });\n  \n  afterAll(async () => {\n    await kafka.unsubscribe(eventCapture);\n  });\n  \n  it('publishes OrderCreated event on order creation', async () => {\n    // Create order\n    const order = await orderService.createOrder({\n      customerId: 'test-customer-1',\n      items: [{ productId: 'prod-1', quantity: 2 }]\n    });\n    \n    // Wait for event\n    const event = await eventCapture.waitForEvent(\n      'orders/created',\n      { orderId: order.id },\n      5000 // timeout\n    );\n    \n    // Verify event\n    expect(event.orderId).toBe(order.id);\n    expect(event.customerId).toBe('test-customer-1');\n    expect(event.timestamp).toBeDefined();\n  });\n  \n  it('handles duplicate events idempotently', async () => {\n    const event = {\n      eventId: 'evt-123',\n      orderId: 'order-123',\n      customerId: 'cust-123'\n    };\n    \n    // Publish same event twice\n    await kafka.publish('orders/created', event);\n    await kafka.publish('orders/created', event);\n    \n    // Should only create one record\n    const orders = await db.orders.findByCustomerId('cust-123');\n    expect(orders.length).toBe(1);\n  });\n});\n```\n\n### End-to-End Test Example\n\n```javascript\n// test/e2e/order-workflow.test.js\ndescribe('Order Workflow E2E', () => {\n  it('completes full order lifecycle', async () => {\n    // Step 1: Customer creates order\n    const createResponse = await api\n      .post('/orders')\n      .set('Authorization', `Bearer ${customerToken}`)\n      .send({\n        customerId: customerId,\n        items: [{ productId: 'prod-1', quantity: 1 }]\n      });\n    \n    expect(createResponse.status).toBe(201);\n    const orderId = createResponse.body.id;\n    \n    // Step 2: Order assigned to technician\n    const assignResponse = await api\n      .post(`/orders/${orderId}/assign`)\n      .set('Authorization', `Bearer ${dispatcherToken}`)\n      .send({ technicianId: technicianId });\n    \n    expect(assignResponse.status).toBe(200);\n    \n    // Verify notification sent (check Notification Service)\n    const notifications = await notificationService\n      .getNotifications(technicianId);\n    expect(notifications).toContainEqual(\n      expect.objectContaining({ type: 'ORDER_ASSIGNED', orderId })\n    );\n    \n    // Step 3: Technician starts work\n    const startResponse = await api\n      .post(`/orders/${orderId}/start`)\n      .set('Authorization', `Bearer ${technicianToken}`);\n    \n    expect(startResponse.status).toBe(200);\n    \n    // Step 4: Technician completes order\n    const completeResponse = await api\n      .post(`/orders/${orderId}/complete`)\n      .set('Authorization', `Bearer ${technicianToken}`)\n      .send({\n        signature: 'base64-signature',\n        notes: 'Work completed successfully'\n      });\n    \n    expect(completeResponse.status).toBe(200);\n    \n    // Verify final state\n    const finalOrder = await api.get(`/orders/${orderId}`);\n    expect(finalOrder.body.status).toBe('completed');\n    \n    // Verify analytics received event\n    const analytics = await analyticsService.getOrderMetrics(orderId);\n    expect(analytics.completedAt).toBeDefined();\n  });\n});\n```\n\n→ See `references/test-patterns.md`\n\n## Step 6: Run and Verify\n\n### Running Tests\n\n```bash\n# Run all integration tests\nnpm run test:integration\n\n# Run specific test file\nnpm run test:integration -- order-api.test.js\n\n# Run with coverage\nnpm run test:integration -- --coverage\n\n# Run in CI\nnpm run test:integration:ci\n```\n\n### Analyzing Failures\n\n| Failure Type | Likely Cause | Investigation |\n|--------------|--------------|---------------|\n| Connection refused | Service not running | Check Docker, ports |\n| 401 Unauthorized | Token issue | Check token generation, expiry |\n| 500 Internal Error | Bug in service | Check service logs |\n| Timeout | Slow service or deadlock | Check performance, dependencies |\n| Contract mismatch | API changed | Compare contract vs implementation |\n| Event not received | Pub/sub issue | Check broker, subscriptions |\n\n### Contract Mismatch Resolution\n\nWhen contract test fails:\n\n1. **Identify mismatch** — What differs from contract?\n2. **Determine source of truth** — Is contract wrong or implementation wrong?\n3. **Coordinate change** — If contract changes, notify all consumers\n4. **Update and verify** — Fix mismatch, re-run tests\n\n## Step 7: Document Integration\n\n### Integration Test Coverage\n\n```markdown\n## Integration Test Coverage: [System Name]\n\n### API Integration\n| Endpoint | Test Count | Covered Scenarios |\n|----------|------------|-------------------|\n| POST /orders | 5 | create, validation, auth, error handling |\n| GET /orders/{id} | 3 | found, not found, unauthorized |\n| POST /orders/{id}/complete | 4 | success, validation, auth, already complete |\n\n### Event Integration\n| Event | Direction | Test Count | Covered Scenarios |\n|-------|-----------|------------|-------------------|\n| OrderCreated | Publish | 3 | publish, format, idempotency |\n| PaymentReceived | Consume | 2 | process, duplicate handling |\n\n### E2E Workflows\n| Workflow | Test Count | Systems Involved |\n|----------|------------|------------------|\n| Order Lifecycle | 1 | Auth, Order, Notification, Analytics |\n| Payment Flow | 1 | Order, Payment, Billing |\n\n### Coverage Gaps\n- [ ] Rate limiting not tested\n- [ ] Bulk operations not tested\n```\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `test-generation` | Creates unit tests; integration-test focuses on boundaries |\n| `code-validation` | Validates single system; integration-test validates interactions |\n| `memory-manager` | Provides interface contracts for testing |\n| `loop-controller` | Invokes integration-test during VALIDATE stage |\n\n## Key Principles\n\n**Test at boundaries.** Focus on where systems meet.\n\n**Use real services when practical.** Mocks hide integration issues.\n\n**Test failure modes.** Systems fail; test graceful degradation.\n\n**Keep tests independent.** Each test should set up and clean up.\n\n**Contract tests prevent regression.** They catch breaking changes early.\n\n## Mode-Specific Behavior\n\nIntegration testing approach differs by orchestrator mode:\n\n### Greenfield Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Full coverage—all integration points |\n| **Approach** | Comprehensive—contract, API, event, E2E |\n| **Patterns** | Free choice—establish test infrastructure |\n| **Deliverables** | Full test suite, Docker Compose, docs |\n| **Validation** | All integration points tested |\n| **Constraints** | Minimal—full control over environment |\n\n**Greenfield integration testing:**\n```\n1. Define all integration contracts\n2. Set up test environment (Docker Compose)\n3. Create test data factories\n4. Write contract tests for all interfaces\n5. Write API integration tests for all endpoints\n6. Write event integration tests for all events\n7. Write E2E tests for critical user journeys\n8. Document integration test coverage\n```\n\n**Greenfield test priorities:**\n- All outbound API calls tested\n- All inbound API endpoints tested\n- All events (publish/consume) tested\n- Critical E2E flows covered\n- Contract tests for all interfaces\n\n### Brownfield-Polish Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Gap-specific—new/modified integrations |\n| **Approach** | Extend existing—match test patterns |\n| **Patterns** | Should match existing test conventions |\n| **Deliverables** | Gap tests following existing structure |\n| **Validation** | Existing tests pass + gaps covered |\n| **Constraints** | Don't restructure—use existing infrastructure |\n\n**Polish integration testing:**\n```\n1. Identify existing integration test patterns\n2. Find untested integration points\n3. Add tests following existing conventions\n4. Use existing test infrastructure\n5. Verify new code doesn't break existing integrations\n6. Update documentation for new integrations\n```\n\n**Polish considerations:**\n- Match existing test file structure\n- Use existing test utilities and helpers\n- Follow existing naming conventions\n- Don't change test configuration\n- Add to existing test suites\n\n**Polish gap analysis:**\n```markdown\n## Integration Test Gaps\n\n### Currently Tested\n- Auth API integration ✓\n- User API integration ✓\n\n### Missing Tests\n- Payment API integration ← Add\n- Notification events ← Add\n- Rate limiting ← Add\n```\n\n### Brownfield-Enterprise Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Change-specific—affected integrations only |\n| **Approach** | Surgical—regression tests for changes |\n| **Patterns** | Must conform exactly to existing tests |\n| **Deliverables** | Regression tests, contract verification |\n| **Validation** | Full regression—existing tests pass |\n| **Constraints** | Requires approval—no contract changes without sign-off |\n\n**Enterprise integration testing:**\n```\n1. Identify which integrations are affected by change\n2. Find existing tests for those integrations\n3. Add regression tests matching existing patterns\n4. Verify existing integration tests still pass\n5. Document any contract changes required\n6. Get contract changes approved before implementing\n```\n\n**Enterprise constraints:**\n- Do NOT add new integration test frameworks\n- Do NOT modify test environment configuration\n- Do NOT change existing contract definitions without approval\n- Tests must pass in existing CI/CD pipeline\n- Contract changes require consumer notification\n\n### Mode-Specific Test Types\n\n| Test Type | Greenfield | Polish | Enterprise |\n|-----------|------------|--------|------------|\n| **Contract** | Create all | Add missing | Verify existing |\n| **API** | All endpoints | New endpoints | Changed endpoints |\n| **Event** | All events | New events | Changed events |\n| **E2E** | Critical flows | Gap fill | If affected |\n\n### Environment by Mode\n\n| Mode | Environment | Setup Ownership |\n|------|-------------|-----------------|\n| **Greenfield** | Docker Compose (custom) | Full control |\n| **Polish** | Existing test infrastructure | Extend carefully |\n| **Enterprise** | Approved environments only | No modifications |\n\n### Contract Management by Mode\n\n**Greenfield:**\n- Create new contracts for all interfaces\n- Define contract versioning strategy\n- Establish contract testing pipeline\n- Full ownership of contract definitions\n\n**Polish:**\n- Verify against existing contracts\n- Add contracts for new integrations\n- Follow existing versioning patterns\n- Coordinate changes with existing consumers\n\n**Enterprise:**\n- Read-only contract verification\n- No contract modifications without approval\n- Document contract change requests\n- Follow change management process\n\n### Integration Test Coverage Targets\n\n| Mode | Target Coverage |\n|------|-----------------|\n| **Greenfield** | 100% of integration points |\n| **Polish** | Match existing + new integrations |\n| **Enterprise** | Changed integrations only |\n\n## References\n\n- `references/scenario-templates.md`: Test scenario templates\n- `references/test-environment-setup.md`: Environment configuration\n- `references/test-patterns.md`: Common integration test patterns\n- `references/contract-testing.md`: Contract testing deep dive",
  "references": [
    {
      "name": "INTEGRATION-TEST.md",
      "path": "references/INTEGRATION-TEST.md",
      "content": "# INTEGRATION-TEST.md Template\n\n## Integration Test Plan: {{system-name}}\n\n**Domain:** {{domain}}\n**Date:** {{date}}\n**Systems Under Test:** {{systems}}\n\n---\n\n## Test Scope\n\n### In Scope\n- {{component-1}} ↔ {{component-2}} integration\n- {{external-service}} connectivity\n- End-to-end {{flow-name}} flow\n\n### Out of Scope\n- Unit-level testing (covered by unit tests)\n- Performance testing (separate perf-analysis)\n- Security testing (separate security-audit)\n\n---\n\n## Test Scenarios\n\n### Scenario 1: {{scenario-name}}\n\n**Description:** {{what-is-being-tested}}\n\n**Preconditions:**\n- {{precondition-1}}\n- {{precondition-2}}\n\n**Steps:**\n1. {{step-1}}\n2. {{step-2}}\n3. {{step-3}}\n\n**Expected Result:**\n- {{expected-1}}\n- {{expected-2}}\n\n**Actual Result:** {{pass/fail}}\n\n---\n\n### Scenario 2: {{scenario-name}}\n\n...\n\n---\n\n## Environment Setup\n\n```bash\n# Start dependencies\n{{setup-commands}}\n\n# Run integration tests\n{{test-commands}}\n\n# Cleanup\n{{cleanup-commands}}\n```\n\n---\n\n## Test Results Summary\n\n| Scenario | Status | Duration | Notes |\n|----------|--------|----------|-------|\n| {{name}} | ✅/❌ | {{s}}s | |\n\n**Total:** {{pass}}/{{total}} passed\n**Duration:** {{m}}m {{s}}s\n\n---\n\n## Issues Found\n\n| ID | Scenario | Issue | Severity | Status |\n|----|----------|-------|----------|--------|\n| 1 | {{name}} | {{issue}} | {{H/M/L}} | {{status}} |\n\n---\n\n**Tested by:** {{agent}}\n**Date:** {{date}}\n"
    },
    {
      "name": "contract-testing.md",
      "path": "references/contract-testing.md",
      "content": "# Contract Testing\n\nComprehensive guide to contract testing for validating API contracts between services in distributed systems.\n\n## Purpose\n\nThis reference provides patterns and practices for implementing contract testing. Use this when:\n\n- Validating API contracts between microservices\n- Preventing breaking changes in service interfaces\n- Ensuring consumer expectations match provider implementations\n- Implementing continuous contract verification in CI/CD\n- Managing API versioning and evolution\n- Coordinating interface changes across teams\n\n## Core Concepts\n\n### What is Contract Testing?\n\nContract testing verifies that two services (a consumer and a provider) can communicate correctly by testing against a shared contract definition.\n\n```\n+------------------------------------------------------------------+\n|                    CONTRACT TESTING MODEL                         |\n|                                                                   |\n|   CONSUMER                    CONTRACT               PROVIDER     |\n|   (Client)                                          (Server)      |\n|                                                                   |\n|   +---------+             +------------+           +---------+    |\n|   |         |  Expects    |            |  Honors   |         |    |\n|   | Order   |------------>|  Contract  |<----------|  Auth   |    |\n|   | Service |             |            |           | Service |    |\n|   |         |             | - Request  |           |         |    |\n|   +---------+             |   format   |           +---------+    |\n|                           | - Response |                          |\n|                           |   format   |                          |\n|                           | - Status   |                          |\n|                           |   codes    |                          |\n|                           +------------+                          |\n|                                                                   |\n|   Consumer Test:              Contract:         Provider Test:    |\n|   \"When I call verify,       \"POST /verify      \"When receiving   |\n|    I expect these fields\"     returns {...}\"     valid request,   |\n|                                                  return {...}\"    |\n|                                                                   |\n+------------------------------------------------------------------+\n```\n\n### Contract Testing vs Other Testing\n\n| Test Type | Scope | Dependencies | Speed | Purpose |\n|-----------|-------|--------------|-------|---------|\n| **Unit** | Single function | Mocked | Fast | Logic correctness |\n| **Integration** | Multiple components | Real/Mocked | Medium | Component interaction |\n| **Contract** | API boundary | Mocked | Fast | Interface compatibility |\n| **E2E** | Full system | Real | Slow | User journey validation |\n\n### Types of Contract Testing\n\n| Approach | Description | Best For |\n|----------|-------------|----------|\n| **Consumer-Driven** | Consumers define expectations, providers verify | APIs with known consumers |\n| **Provider-Driven** | Providers publish contract, consumers verify | Public APIs, OpenAPI |\n| **Bidirectional** | Both sides verify against shared contract | Internal microservices |\n\n## Consumer-Driven Contract Testing\n\n### Workflow Overview\n\n```\n+------------------------------------------------------------------+\n|              CONSUMER-DRIVEN CONTRACT WORKFLOW                    |\n|                                                                   |\n|  1. CONSUMER DEFINES EXPECTATIONS                                 |\n|     +------------------+                                          |\n|     | Consumer Test    |---> \"I expect POST /verify               |\n|     | (Pact)           |      to return {valid: true, userId}\"    |\n|     +------------------+                                          |\n|              |                                                    |\n|              v                                                    |\n|  2. CONTRACT GENERATED                                            |\n|     +------------------+                                          |\n|     | Contract File    |---> Stored in Pact Broker                |\n|     | (JSON/YAML)      |     or version control                   |\n|     +------------------+                                          |\n|              |                                                    |\n|              v                                                    |\n|  3. PROVIDER VERIFIES                                             |\n|     +------------------+                                          |\n|     | Provider Test    |---> Verify implementation                |\n|     | (Pact Verifier)  |     meets consumer expectations          |\n|     +------------------+                                          |\n|              |                                                    |\n|              v                                                    |\n|  4. RESULTS PUBLISHED                                             |\n|     +------------------+                                          |\n|     | Pact Broker      |---> Track verification status            |\n|     |                  |     across versions                      |\n|     +------------------+                                          |\n|                                                                   |\n+------------------------------------------------------------------+\n```\n\n### Consumer Side Implementation (Pact)\n\n```typescript\n// consumer/tests/auth-service.contract.test.ts\nimport { PactV3, MatchersV3 } from '@pact-foundation/pact';\nimport { AuthServiceClient } from '../clients/auth-service';\n\nconst { like, eachLike, regex, datetime } = MatchersV3;\n\ndescribe('Auth Service Contract', () => {\n  const provider = new PactV3({\n    consumer: 'OrderService',\n    provider: 'AuthService',\n    dir: './pacts',\n  });\n\n  describe('Token Verification', () => {\n    it('verifies valid JWT token', async () => {\n      // Define the expected interaction\n      provider\n        .given('a valid JWT token exists')\n        .uponReceiving('a request to verify a valid token')\n        .withRequest({\n          method: 'POST',\n          path: '/auth/verify',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: {\n            token: like('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'),\n          },\n        })\n        .willRespondWith({\n          status: 200,\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: {\n            valid: true,\n            userId: like('user-123'),\n            email: like('user@example.com'),\n            roles: eachLike('user'),\n            expiresAt: datetime('yyyy-MM-dd\\'T\\'HH:mm:ss.SSS\\'Z\\''),\n          },\n        });\n\n      await provider.executeTest(async (mockServer) => {\n        // Create client pointing to mock server\n        const client = new AuthServiceClient(mockServer.url);\n\n        // Execute the actual call\n        const result = await client.verifyToken('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...');\n\n        // Verify the client handles the response correctly\n        expect(result.valid).toBe(true);\n        expect(result.userId).toBeDefined();\n        expect(result.email).toBeDefined();\n        expect(result.roles).toBeInstanceOf(Array);\n        expect(new Date(result.expiresAt)).toBeInstanceOf(Date);\n      });\n    });\n\n    it('handles invalid token', async () => {\n      provider\n        .given('an invalid token is provided')\n        .uponReceiving('a request to verify an invalid token')\n        .withRequest({\n          method: 'POST',\n          path: '/auth/verify',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: {\n            token: like('invalid-token'),\n          },\n        })\n        .willRespondWith({\n          status: 401,\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: {\n            error: {\n              code: 'INVALID_TOKEN',\n              message: like('Token is invalid or expired'),\n            },\n          },\n        });\n\n      await provider.executeTest(async (mockServer) => {\n        const client = new AuthServiceClient(mockServer.url);\n\n        await expect(client.verifyToken('invalid-token'))\n          .rejects\n          .toThrow('Token is invalid or expired');\n      });\n    });\n\n    it('handles expired token', async () => {\n      provider\n        .given('an expired token is provided')\n        .uponReceiving('a request to verify an expired token')\n        .withRequest({\n          method: 'POST',\n          path: '/auth/verify',\n          body: {\n            token: like('expired-token'),\n          },\n        })\n        .willRespondWith({\n          status: 401,\n          body: {\n            error: {\n              code: 'TOKEN_EXPIRED',\n              message: like('Token has expired'),\n              expiredAt: datetime('yyyy-MM-dd\\'T\\'HH:mm:ss.SSS\\'Z\\''),\n            },\n          },\n        });\n\n      await provider.executeTest(async (mockServer) => {\n        const client = new AuthServiceClient(mockServer.url);\n\n        try {\n          await client.verifyToken('expired-token');\n          fail('Should have thrown');\n        } catch (error) {\n          expect(error.code).toBe('TOKEN_EXPIRED');\n          expect(error.expiredAt).toBeDefined();\n        }\n      });\n    });\n  });\n\n  describe('User Info', () => {\n    it('retrieves user information', async () => {\n      provider\n        .given('user usr-123 exists')\n        .uponReceiving('a request to get user info')\n        .withRequest({\n          method: 'GET',\n          path: '/auth/users/usr-123',\n          headers: {\n            Authorization: regex(/^Bearer .+$/, 'Bearer valid-token'),\n          },\n        })\n        .willRespondWith({\n          status: 200,\n          body: {\n            id: 'usr-123',\n            email: like('user@example.com'),\n            name: like('John Doe'),\n            roles: eachLike('user'),\n            createdAt: datetime('yyyy-MM-dd\\'T\\'HH:mm:ss.SSS\\'Z\\''),\n            lastLoginAt: datetime('yyyy-MM-dd\\'T\\'HH:mm:ss.SSS\\'Z\\''),\n          },\n        });\n\n      await provider.executeTest(async (mockServer) => {\n        const client = new AuthServiceClient(mockServer.url);\n        const user = await client.getUserInfo('usr-123', 'valid-token');\n\n        expect(user.id).toBe('usr-123');\n        expect(user.email).toBeDefined();\n        expect(user.name).toBeDefined();\n      });\n    });\n  });\n});\n```\n\n### Provider Side Verification\n\n```typescript\n// provider/tests/contract.verification.test.ts\nimport { Verifier } from '@pact-foundation/pact';\nimport { app } from '../src/app';\nimport { Server } from 'http';\nimport { db } from '../src/database';\n\ndescribe('Auth Service Provider Verification', () => {\n  let server: Server;\n  const port = 4000;\n\n  beforeAll(async () => {\n    server = app.listen(port);\n  });\n\n  afterAll(async () => {\n    server.close();\n    await db.close();\n  });\n\n  it('verifies contracts with all consumers', async () => {\n    const verifier = new Verifier({\n      provider: 'AuthService',\n      providerBaseUrl: `http://localhost:${port}`,\n\n      // Fetch contracts from Pact Broker\n      pactBrokerUrl: process.env.PACT_BROKER_URL,\n      pactBrokerToken: process.env.PACT_BROKER_TOKEN,\n\n      // Or use local pact files\n      // pactUrls: ['./pacts/OrderService-AuthService.json'],\n\n      // Provider states setup\n      stateHandlers: {\n        'a valid JWT token exists': async () => {\n          // Setup: Create valid token in test database\n          await db.tokens.create({\n            token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',\n            userId: 'user-123',\n            expiresAt: new Date(Date.now() + 3600000),\n          });\n        },\n\n        'an invalid token is provided': async () => {\n          // No setup needed - token doesn't exist\n        },\n\n        'an expired token is provided': async () => {\n          await db.tokens.create({\n            token: 'expired-token',\n            userId: 'user-123',\n            expiresAt: new Date(Date.now() - 3600000), // Expired\n          });\n        },\n\n        'user usr-123 exists': async () => {\n          await db.users.create({\n            id: 'usr-123',\n            email: 'user@example.com',\n            name: 'John Doe',\n            roles: ['user'],\n            createdAt: new Date(),\n            lastLoginAt: new Date(),\n          });\n        },\n      },\n\n      // Cleanup after each interaction\n      afterEach: async () => {\n        await db.tokens.deleteAll();\n        await db.users.deleteAll();\n      },\n\n      // Publish results to Pact Broker\n      publishVerificationResult: process.env.CI === 'true',\n      providerVersion: process.env.GIT_COMMIT_SHA || '1.0.0',\n      providerVersionBranch: process.env.GIT_BRANCH || 'main',\n\n      // Logging\n      logLevel: 'info',\n    });\n\n    await verifier.verifyProvider();\n  });\n});\n```\n\n### Pact Matchers Reference\n\n| Matcher | Purpose | Example |\n|---------|---------|---------|\n| `like(value)` | Match type, not exact value | `like('user-123')` |\n| `eachLike(value)` | Array with elements matching pattern | `eachLike({ id: like('1') })` |\n| `regex(pattern, example)` | Match regex pattern | `regex(/^\\d{4}-\\d{2}$/, '2024-01')` |\n| `datetime(format)` | Match datetime format | `datetime(\"yyyy-MM-dd'T'HH:mm:ss\")` |\n| `integer()` | Match integer | `integer(123)` |\n| `decimal()` | Match decimal | `decimal(12.34)` |\n| `boolean()` | Match boolean | `boolean(true)` |\n| `uuid()` | Match UUID format | `uuid()` |\n| `email()` | Match email format | `email()` |\n| `ipv4Address()` | Match IPv4 address | `ipv4Address()` |\n| `nullValue()` | Match null | `nullValue()` |\n| `atLeastOneLike(value, min)` | Array with minimum elements | `atLeastOneLike(item, 2)` |\n| `atMostOneLike(value, max)` | Array with maximum elements | `atMostOneLike(item, 5)` |\n\n## Provider-Driven Contract Testing\n\n### OpenAPI Schema Validation\n\n```typescript\n// tests/openapi-contract.test.ts\nimport SwaggerParser from '@apidevtools/swagger-parser';\nimport request from 'supertest';\nimport Ajv from 'ajv';\nimport addFormats from 'ajv-formats';\nimport { app } from '../src/app';\n\ndescribe('OpenAPI Contract Compliance', () => {\n  let api: any;\n  let ajv: Ajv;\n\n  beforeAll(async () => {\n    // Load and validate OpenAPI spec\n    api = await SwaggerParser.dereference('./openapi.yaml');\n\n    // Setup JSON Schema validator\n    ajv = new Ajv({ allErrors: true, strict: false });\n    addFormats(ajv);\n  });\n\n  function validateResponse(\n    path: string,\n    method: string,\n    statusCode: number,\n    body: any\n  ): void {\n    const pathSpec = api.paths[path];\n    if (!pathSpec) {\n      throw new Error(`Path ${path} not found in OpenAPI spec`);\n    }\n\n    const operationSpec = pathSpec[method.toLowerCase()];\n    if (!operationSpec) {\n      throw new Error(`Method ${method} not found for path ${path}`);\n    }\n\n    const responseSpec = operationSpec.responses[statusCode];\n    if (!responseSpec) {\n      throw new Error(`Status ${statusCode} not defined for ${method} ${path}`);\n    }\n\n    const schema = responseSpec.content?.['application/json']?.schema;\n    if (schema) {\n      const validate = ajv.compile(schema);\n      const valid = validate(body);\n\n      if (!valid) {\n        throw new Error(\n          `Response does not match schema: ${ajv.errorsText(validate.errors)}`\n        );\n      }\n    }\n  }\n\n  describe('GET /users/{id}', () => {\n    it('returns response matching OpenAPI schema', async () => {\n      const user = await userFactory.create();\n\n      const response = await request(app)\n        .get(`/users/${user.id}`)\n        .set('Authorization', `Bearer ${adminToken}`);\n\n      expect(response.status).toBe(200);\n      validateResponse('/users/{id}', 'GET', 200, response.body);\n    });\n\n    it('returns 404 matching OpenAPI error schema', async () => {\n      const response = await request(app)\n        .get('/users/non-existent')\n        .set('Authorization', `Bearer ${adminToken}`);\n\n      expect(response.status).toBe(404);\n      validateResponse('/users/{id}', 'GET', 404, response.body);\n    });\n  });\n\n  describe('POST /orders', () => {\n    it('accepts request matching OpenAPI request schema', async () => {\n      // This tests that the request body matches the spec\n      const requestBody = {\n        items: [\n          { productId: 'prod-1', quantity: 2 },\n          { productId: 'prod-2', quantity: 1 },\n        ],\n        shippingAddress: {\n          street: '123 Main St',\n          city: 'Test City',\n          state: 'TS',\n          zip: '12345',\n          country: 'US',\n        },\n      };\n\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send(requestBody);\n\n      expect(response.status).toBe(201);\n      validateResponse('/orders', 'POST', 201, response.body);\n    });\n\n    it('rejects request not matching schema with 400', async () => {\n      // Missing required fields\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [] }); // Empty items not allowed\n\n      expect(response.status).toBe(400);\n      validateResponse('/orders', 'POST', 400, response.body);\n    });\n  });\n});\n```\n\n### Prism Mock Server\n\nUse Prism to create a mock server from OpenAPI spec for consumer testing:\n\n```bash\n# Install Prism\nnpm install -g @stoplight/prism-cli\n\n# Run mock server from OpenAPI spec\nprism mock openapi.yaml -p 4010\n\n# Run with dynamic responses\nprism mock openapi.yaml -p 4010 --dynamic\n```\n\n```typescript\n// Consumer test against Prism mock\ndescribe('User Service Client', () => {\n  const baseUrl = 'http://localhost:4010';\n\n  it('handles user response from API', async () => {\n    const client = new UserServiceClient(baseUrl);\n    const user = await client.getUser('usr-123');\n\n    // Response matches OpenAPI schema\n    expect(user).toHaveProperty('id');\n    expect(user).toHaveProperty('email');\n    expect(user).toHaveProperty('name');\n  });\n});\n```\n\n## Bidirectional Contract Testing\n\n### Schema Registry Approach\n\n```typescript\n// shared/contracts/user-events.ts\nimport { z } from 'zod';\n\n// Define contract schemas\nexport const UserCreatedEventSchema = z.object({\n  eventId: z.string().uuid(),\n  eventType: z.literal('UserCreated'),\n  timestamp: z.string().datetime(),\n  payload: z.object({\n    userId: z.string(),\n    email: z.string().email(),\n    name: z.string(),\n    roles: z.array(z.string()),\n  }),\n});\n\nexport type UserCreatedEvent = z.infer<typeof UserCreatedEventSchema>;\n\nexport const UserUpdatedEventSchema = z.object({\n  eventId: z.string().uuid(),\n  eventType: z.literal('UserUpdated'),\n  timestamp: z.string().datetime(),\n  payload: z.object({\n    userId: z.string(),\n    changes: z.record(z.unknown()),\n  }),\n});\n\nexport type UserUpdatedEvent = z.infer<typeof UserUpdatedEventSchema>;\n\n// Registry of all event schemas\nexport const EventSchemas = {\n  UserCreated: UserCreatedEventSchema,\n  UserUpdated: UserUpdatedEventSchema,\n};\n```\n\n```typescript\n// producer/tests/event-contract.test.ts\nimport { UserCreatedEventSchema } from '@shared/contracts/user-events';\n\ndescribe('User Service Event Contracts', () => {\n  describe('UserCreated Event', () => {\n    it('publishes event matching contract schema', async () => {\n      const user = await userService.createUser({\n        email: 'new@example.com',\n        name: 'New User',\n      });\n\n      const event = await eventCapture.waitForEvent('user.created');\n\n      // Validate against contract schema\n      const validation = UserCreatedEventSchema.safeParse(event);\n      expect(validation.success).toBe(true);\n\n      if (!validation.success) {\n        console.error('Schema validation errors:', validation.error.errors);\n      }\n    });\n  });\n});\n\n// consumer/tests/event-contract.test.ts\nimport { UserCreatedEventSchema, UserCreatedEvent } from '@shared/contracts/user-events';\n\ndescribe('Order Service - User Events Consumer', () => {\n  describe('UserCreated Event Handler', () => {\n    it('handles event matching contract schema', async () => {\n      // Create valid event per contract\n      const validEvent: UserCreatedEvent = {\n        eventId: crypto.randomUUID(),\n        eventType: 'UserCreated',\n        timestamp: new Date().toISOString(),\n        payload: {\n          userId: 'usr-123',\n          email: 'user@example.com',\n          name: 'Test User',\n          roles: ['customer'],\n        },\n      };\n\n      // Validate test data matches contract\n      expect(UserCreatedEventSchema.safeParse(validEvent).success).toBe(true);\n\n      // Publish and verify handling\n      await kafka.publish('user.created', validEvent);\n\n      await waitForCondition(async () => {\n        const user = await db.users.findById('usr-123');\n        return user !== null;\n      });\n\n      const user = await db.users.findById('usr-123');\n      expect(user.email).toBe('user@example.com');\n    });\n  });\n});\n```\n\n## CI/CD Integration\n\n### Contract Testing Pipeline\n\n```yaml\n# .github/workflows/contract-tests.yaml\nname: Contract Tests\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  # Consumer tests - generate contracts\n  consumer-contracts:\n    runs-on: ubuntu-latest\n    services:\n      pact-broker:\n        image: pactfoundation/pact-broker:latest\n        ports:\n          - 9292:9292\n        env:\n          PACT_BROKER_DATABASE_URL: sqlite:////tmp/pact.sqlite\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run consumer contract tests\n        run: npm run test:contract:consumer\n        env:\n          PACT_BROKER_URL: http://localhost:9292\n\n      - name: Publish pacts to broker\n        run: |\n          npx pact-broker publish ./pacts \\\n            --broker-base-url=$PACT_BROKER_URL \\\n            --consumer-app-version=${{ github.sha }} \\\n            --branch=${{ github.ref_name }}\n        env:\n          PACT_BROKER_URL: http://localhost:9292\n\n      - name: Upload pact files\n        uses: actions/upload-artifact@v4\n        with:\n          name: pact-contracts\n          path: ./pacts\n\n  # Provider verification\n  provider-verification:\n    runs-on: ubuntu-latest\n    needs: consumer-contracts\n    strategy:\n      matrix:\n        provider: [auth-service, user-service, order-service]\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          repository: org/${{ matrix.provider }}\n\n      - name: Download pact files\n        uses: actions/download-artifact@v4\n        with:\n          name: pact-contracts\n          path: ./pacts\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Start provider service\n        run: npm run start:test &\n        env:\n          PORT: 4000\n\n      - name: Wait for service\n        run: |\n          timeout 30 bash -c 'until curl -sf http://localhost:4000/health; do sleep 1; done'\n\n      - name: Verify provider contracts\n        run: npm run test:contract:provider\n        env:\n          PROVIDER_BASE_URL: http://localhost:4000\n          PACT_BROKER_URL: ${{ secrets.PACT_BROKER_URL }}\n          PACT_BROKER_TOKEN: ${{ secrets.PACT_BROKER_TOKEN }}\n          GIT_COMMIT: ${{ github.sha }}\n          GIT_BRANCH: ${{ github.ref_name }}\n\n  # Can-i-deploy check\n  can-i-deploy:\n    runs-on: ubuntu-latest\n    needs: provider-verification\n    if: github.event_name == 'push'\n\n    steps:\n      - name: Check deployment safety\n        run: |\n          npx pact-broker can-i-deploy \\\n            --pacticipant OrderService \\\n            --version ${{ github.sha }} \\\n            --to production \\\n            --broker-base-url ${{ secrets.PACT_BROKER_URL }} \\\n            --broker-token ${{ secrets.PACT_BROKER_TOKEN }}\n```\n\n### Can-I-Deploy Workflow\n\n```\n+------------------------------------------------------------------+\n|                    CAN-I-DEPLOY WORKFLOW                          |\n|                                                                   |\n|  Before deploying a service version, verify:                      |\n|                                                                   |\n|  1. All consumer contracts are satisfied                          |\n|     +---------------+     +-----------------+                     |\n|     | OrderService  |---->| Pact Broker     |                     |\n|     | v1.2.3        |     | Verification DB |                     |\n|     +---------------+     +-----------------+                     |\n|                                  |                                |\n|                                  v                                |\n|  2. Provider can fulfill all consumer expectations                |\n|     +-----------------+                                           |\n|     | AuthService     |  Verified against:                        |\n|     | production      |  - OrderService v1.2.3 (pending deploy)   |\n|     +-----------------+  - PaymentService v2.0.1 (production)     |\n|                         - NotificationService v1.5.0 (production) |\n|                                                                   |\n|  3. Decision Matrix:                                              |\n|                                                                   |\n|     Consumer    Provider    Status      Can Deploy?               |\n|     v1.2.3      prod        VERIFIED    YES                       |\n|     v1.2.3      prod        FAILED      NO - fix contract         |\n|     v1.2.3      prod        UNKNOWN     NO - run verification     |\n|                                                                   |\n+------------------------------------------------------------------+\n```\n\n## Best Practices\n\n### Contract Design Principles\n\n| Principle | Description | Example |\n|-----------|-------------|---------|\n| **Postel's Law** | Be conservative in what you send, liberal in what you accept | Accept extra fields, only require minimum |\n| **Versioning** | Version contracts to allow evolution | `/api/v1/users`, `Accept: application/vnd.api+json;version=1` |\n| **Backward Compatibility** | New versions should not break existing consumers | Add fields, don't remove or rename |\n| **Minimal Contracts** | Only specify what you actually need | Don't match entire response if you only use 2 fields |\n\n### Consumer Contract Best Practices\n\n```typescript\n// DO: Only specify what you actually use\nprovider\n  .uponReceiving('a request for user')\n  .willRespondWith({\n    status: 200,\n    body: {\n      // Only match fields the consumer actually uses\n      id: like('usr-123'),\n      email: like('user@example.com'),\n      // Don't match fields you ignore\n    },\n  });\n\n// DON'T: Over-specify the contract\nprovider\n  .uponReceiving('a request for user')\n  .willRespondWith({\n    status: 200,\n    body: {\n      // Matching every field creates brittle contracts\n      id: 'usr-123',\n      email: 'user@example.com',\n      name: 'John Doe',\n      createdAt: '2024-01-01T00:00:00Z',\n      updatedAt: '2024-01-01T00:00:00Z',\n      lastLoginAt: '2024-01-15T10:30:00Z',\n      preferences: { theme: 'dark', language: 'en' },\n      // etc...\n    },\n  });\n```\n\n### Provider State Management\n\n```typescript\n// Good: Clear, specific state names\nstateHandlers: {\n  'user usr-123 exists with role admin': async () => {\n    await db.users.create({\n      id: 'usr-123',\n      roles: ['admin'],\n    });\n  },\n\n  'user usr-123 has 3 orders': async () => {\n    await db.users.create({ id: 'usr-123' });\n    await db.orders.createMany([\n      { userId: 'usr-123', status: 'completed' },\n      { userId: 'usr-123', status: 'pending' },\n      { userId: 'usr-123', status: 'shipped' },\n    ]);\n  },\n\n  'no users exist': async () => {\n    await db.users.deleteAll();\n  },\n}\n\n// Bad: Vague state names\nstateHandlers: {\n  'user exists': async () => { /* Which user? What properties? */ },\n  'data is set up': async () => { /* What data? */ },\n}\n```\n\n### Contract Versioning Strategy\n\n```typescript\n// Version in URL path\n/api/v1/users\n/api/v2/users\n\n// Version in header\nAccept: application/vnd.myapi.v1+json\nAccept: application/vnd.myapi.v2+json\n\n// Version in query parameter\n/users?version=1\n/users?version=2\n\n// Recommended: URL path for major versions, header for minor\n```\n\n### Breaking vs Non-Breaking Changes\n\n| Change Type | Breaking? | Example |\n|-------------|-----------|---------|\n| Add optional field | No | Add `middleName?: string` |\n| Add required field | Yes | Add `phoneNumber: string` |\n| Remove field | Yes | Remove `legacyId` |\n| Rename field | Yes | `userName` -> `username` |\n| Change field type | Yes | `age: string` -> `age: number` |\n| Add enum value | Maybe | Add new status value |\n| Remove enum value | Yes | Remove status value |\n| Change URL | Yes | `/users` -> `/accounts` |\n| Add optional query param | No | Add `?includeDeleted=true` |\n| Add required query param | Yes | Require `?tenantId=xxx` |\n\n### Handling Breaking Changes\n\n```typescript\n// Step 1: Add new field alongside old (backward compatible)\n{\n  userName: 'johndoe',     // Deprecated\n  username: 'johndoe',     // New\n}\n\n// Step 2: Update all consumers to use new field\n\n// Step 3: Mark old field as deprecated in docs\n\n// Step 4: After all consumers migrated, remove old field in next major version\n```\n\n## Troubleshooting\n\n### Common Contract Failures\n\n| Failure | Cause | Solution |\n|---------|-------|----------|\n| `Missing provider state` | State handler not defined | Add state handler for the state |\n| `Response body mismatch` | Response structure changed | Update consumer expectations or fix provider |\n| `Status code mismatch` | Different error handling | Align on error status codes |\n| `Header mismatch` | Missing or different headers | Add required headers in provider |\n| `No matching interaction` | Request doesn't match contract | Check URL, method, headers, body |\n\n### Debugging Contract Failures\n\n```typescript\n// Enable verbose logging\nconst verifier = new Verifier({\n  logLevel: 'debug',\n  // ...\n});\n\n// Print request/response details\nprovider\n  .uponReceiving('a request')\n  .withRequest({\n    method: 'POST',\n    path: '/test',\n  })\n  // Add request logging\n  .willRespondWith({\n    status: 200,\n  });\n\n// Use Pact Broker's comparison UI\n// Navigate to: {PACT_BROKER_URL}/pacts/provider/{PROVIDER}/consumer/{CONSUMER}/latest\n```\n\n### Flaky Contract Tests\n\n```typescript\n// Problem: Time-sensitive values\nbody: {\n  createdAt: '2024-01-15T10:30:00Z', // Exact match fails\n}\n\n// Solution: Use matchers\nbody: {\n  createdAt: datetime(\"yyyy-MM-dd'T'HH:mm:ss'Z'\"),\n}\n\n// Problem: Random IDs\nbody: {\n  id: 'abc-123', // Exact value\n}\n\n// Solution: Use type matcher\nbody: {\n  id: like('abc-123'), // Matches any string\n}\n\n// Problem: Order-dependent arrays\nbody: {\n  items: [\n    { id: '1', name: 'First' },\n    { id: '2', name: 'Second' },\n  ],\n}\n\n// Solution: Use eachLike for unordered\nbody: {\n  items: eachLike({ id: like('1'), name: like('First') }),\n}\n```\n\n## Examples\n\n### Complete Contract Test Suite\n\n```typescript\n// consumer/tests/contracts/payment-service.contract.ts\nimport { PactV3, MatchersV3 } from '@pact-foundation/pact';\n\nconst { like, eachLike, decimal, uuid, datetime } = MatchersV3;\n\ndescribe('Payment Service Contract', () => {\n  const provider = new PactV3({\n    consumer: 'OrderService',\n    provider: 'PaymentService',\n    dir: './pacts',\n  });\n\n  describe('Create Payment Intent', () => {\n    it('creates payment intent for order', async () => {\n      provider\n        .given('merchant account is active')\n        .uponReceiving('a request to create payment intent')\n        .withRequest({\n          method: 'POST',\n          path: '/payment-intents',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': like('Bearer sk_test_xxx'),\n            'Idempotency-Key': uuid(),\n          },\n          body: {\n            amount: decimal(9999),\n            currency: 'usd',\n            orderId: like('ord-123'),\n            customerId: like('cus-123'),\n            metadata: {\n              orderNumber: like('ORD-2024-001'),\n            },\n          },\n        })\n        .willRespondWith({\n          status: 201,\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: {\n            id: like('pi_1234567890'),\n            status: 'requires_payment_method',\n            amount: decimal(9999),\n            currency: 'usd',\n            clientSecret: like('pi_xxx_secret_yyy'),\n            createdAt: datetime(\"yyyy-MM-dd'T'HH:mm:ss'Z'\"),\n          },\n        });\n\n      await provider.executeTest(async (mockServer) => {\n        const client = new PaymentServiceClient(mockServer.url, 'sk_test_xxx');\n\n        const result = await client.createPaymentIntent({\n          amount: 99.99,\n          currency: 'usd',\n          orderId: 'ord-123',\n          customerId: 'cus-123',\n          metadata: { orderNumber: 'ORD-2024-001' },\n        });\n\n        expect(result.id).toMatch(/^pi_/);\n        expect(result.status).toBe('requires_payment_method');\n        expect(result.clientSecret).toBeDefined();\n      });\n    });\n\n    it('handles duplicate idempotency key', async () => {\n      provider\n        .given('payment intent pi_existing exists with idempotency key idem-123')\n        .uponReceiving('a duplicate request with same idempotency key')\n        .withRequest({\n          method: 'POST',\n          path: '/payment-intents',\n          headers: {\n            'Idempotency-Key': 'idem-123',\n          },\n          body: like({\n            amount: 9999,\n            currency: 'usd',\n          }),\n        })\n        .willRespondWith({\n          status: 200,\n          body: {\n            id: 'pi_existing',\n            // Returns the existing payment intent\n          },\n        });\n\n      await provider.executeTest(async (mockServer) => {\n        const client = new PaymentServiceClient(mockServer.url, 'sk_test_xxx');\n\n        const result = await client.createPaymentIntent(\n          { amount: 99.99, currency: 'usd' },\n          { idempotencyKey: 'idem-123' }\n        );\n\n        expect(result.id).toBe('pi_existing');\n      });\n    });\n  });\n\n  describe('Capture Payment', () => {\n    it('captures authorized payment', async () => {\n      provider\n        .given('payment intent pi_authorized is authorized for $99.99')\n        .uponReceiving('a request to capture payment')\n        .withRequest({\n          method: 'POST',\n          path: '/payment-intents/pi_authorized/capture',\n          body: {\n            amountToCapture: decimal(9999),\n          },\n        })\n        .willRespondWith({\n          status: 200,\n          body: {\n            id: 'pi_authorized',\n            status: 'succeeded',\n            amountCaptured: decimal(9999),\n            capturedAt: datetime(\"yyyy-MM-dd'T'HH:mm:ss'Z'\"),\n          },\n        });\n\n      await provider.executeTest(async (mockServer) => {\n        const client = new PaymentServiceClient(mockServer.url, 'sk_test_xxx');\n\n        const result = await client.capturePayment('pi_authorized', 99.99);\n\n        expect(result.status).toBe('succeeded');\n        expect(result.amountCaptured).toBe(99.99);\n      });\n    });\n\n    it('fails to capture already captured payment', async () => {\n      provider\n        .given('payment intent pi_captured is already captured')\n        .uponReceiving('a request to capture already captured payment')\n        .withRequest({\n          method: 'POST',\n          path: '/payment-intents/pi_captured/capture',\n        })\n        .willRespondWith({\n          status: 400,\n          body: {\n            error: {\n              code: 'ALREADY_CAPTURED',\n              message: like('Payment has already been captured'),\n            },\n          },\n        });\n\n      await provider.executeTest(async (mockServer) => {\n        const client = new PaymentServiceClient(mockServer.url, 'sk_test_xxx');\n\n        await expect(client.capturePayment('pi_captured'))\n          .rejects\n          .toMatchObject({\n            code: 'ALREADY_CAPTURED',\n          });\n      });\n    });\n  });\n\n  describe('Refund Payment', () => {\n    it('creates full refund', async () => {\n      provider\n        .given('payment intent pi_captured has $99.99 captured')\n        .uponReceiving('a request to refund full amount')\n        .withRequest({\n          method: 'POST',\n          path: '/payment-intents/pi_captured/refund',\n          body: {\n            amount: decimal(9999),\n            reason: 'customer_request',\n          },\n        })\n        .willRespondWith({\n          status: 201,\n          body: {\n            id: like('re_123'),\n            paymentIntentId: 'pi_captured',\n            amount: decimal(9999),\n            status: 'succeeded',\n            reason: 'customer_request',\n            createdAt: datetime(\"yyyy-MM-dd'T'HH:mm:ss'Z'\"),\n          },\n        });\n\n      await provider.executeTest(async (mockServer) => {\n        const client = new PaymentServiceClient(mockServer.url, 'sk_test_xxx');\n\n        const refund = await client.refundPayment('pi_captured', {\n          amount: 99.99,\n          reason: 'customer_request',\n        });\n\n        expect(refund.status).toBe('succeeded');\n        expect(refund.amount).toBe(99.99);\n      });\n    });\n\n    it('handles refund exceeding captured amount', async () => {\n      provider\n        .given('payment intent pi_small has $10.00 captured')\n        .uponReceiving('a request to refund more than captured')\n        .withRequest({\n          method: 'POST',\n          path: '/payment-intents/pi_small/refund',\n          body: {\n            amount: decimal(9999), // $99.99 > $10.00\n          },\n        })\n        .willRespondWith({\n          status: 400,\n          body: {\n            error: {\n              code: 'REFUND_EXCEEDS_CAPTURED',\n              message: like('Refund amount exceeds captured amount'),\n              maxRefundable: decimal(1000),\n            },\n          },\n        });\n\n      await provider.executeTest(async (mockServer) => {\n        const client = new PaymentServiceClient(mockServer.url, 'sk_test_xxx');\n\n        try {\n          await client.refundPayment('pi_small', { amount: 99.99 });\n          fail('Should have thrown');\n        } catch (error) {\n          expect(error.code).toBe('REFUND_EXCEEDS_CAPTURED');\n          expect(error.maxRefundable).toBe(10.00);\n        }\n      });\n    });\n  });\n});\n```\n\n## See Also\n\n- `scenario-templates.md` - Test scenario templates\n- `test-environment-setup.md` - Environment configuration\n- `test-patterns.md` - Common integration test patterns\n"
    },
    {
      "name": "scenario-templates.md",
      "path": "references/scenario-templates.md",
      "content": "# Scenario Templates\n\nTemplates for common integration test scenarios.\n\n## API Integration Scenarios\n\n### Happy Path - Create Resource\n\n```markdown\n## Scenario: Create [Resource] - Success\n\n**Type:** API Integration\n**Systems:** [Consumer] → [Provider]\n**Priority:** High\n\n### Setup\n- Valid authentication token exists\n- Required dependencies are available\n\n### Steps\n1. Send POST request to /[resources]\n2. Include valid request body\n3. Include Authorization header\n\n### Expected Results\n- Response status: 201 Created\n- Response body contains created resource\n- Resource exists in database\n- Any triggered events are published\n\n### Test Code\n```javascript\nit('creates [resource] successfully', async () => {\n  const response = await request(app)\n    .post('/[resources]')\n    .set('Authorization', `Bearer ${token}`)\n    .send({\n      field1: 'value1',\n      field2: 'value2'\n    });\n  \n  expect(response.status).toBe(201);\n  expect(response.body.id).toBeDefined();\n  expect(response.body.field1).toBe('value1');\n  \n  // Verify persistence\n  const record = await db.[resources].findById(response.body.id);\n  expect(record).toBeDefined();\n});\n```\n```\n\n### Validation Error\n\n```markdown\n## Scenario: Create [Resource] - Validation Error\n\n**Type:** API Integration\n**Systems:** [Consumer] → [Provider]\n**Priority:** High\n\n### Setup\n- Valid authentication token exists\n\n### Steps\n1. Send POST request with invalid data\n2. Missing required field OR invalid format\n\n### Expected Results\n- Response status: 400 Bad Request\n- Response body contains error details\n- No resource created\n\n### Test Code\n```javascript\nit('rejects invalid [resource] data', async () => {\n  const response = await request(app)\n    .post('/[resources]')\n    .set('Authorization', `Bearer ${token}`)\n    .send({\n      // Missing required field\n      field2: 'value2'\n    });\n  \n  expect(response.status).toBe(400);\n  expect(response.body.error).toBeDefined();\n  expect(response.body.details).toContain('field1');\n});\n```\n```\n\n### Authentication Required\n\n```markdown\n## Scenario: Access [Resource] - No Token\n\n**Type:** API Integration\n**Systems:** [Consumer] → [Provider]\n**Priority:** High\n\n### Setup\n- No authentication token provided\n\n### Steps\n1. Send request without Authorization header\n\n### Expected Results\n- Response status: 401 Unauthorized\n- Response body contains error message\n\n### Test Code\n```javascript\nit('rejects request without token', async () => {\n  const response = await request(app)\n    .get('/[resources]/123');\n  \n  expect(response.status).toBe(401);\n  expect(response.body.error).toBe('Authentication required');\n});\n```\n```\n\n### Authorization Denied\n\n```markdown\n## Scenario: Access [Resource] - Forbidden\n\n**Type:** API Integration\n**Systems:** [Consumer] → [Provider]\n**Priority:** High\n\n### Setup\n- Valid token exists but lacks permission\n\n### Steps\n1. Send request with token lacking required role/permission\n\n### Expected Results\n- Response status: 403 Forbidden\n- Response body contains error message\n\n### Test Code\n```javascript\nit('forbids access without required role', async () => {\n  const userToken = await getTokenForRole('user'); // not admin\n  \n  const response = await request(app)\n    .delete('/[resources]/123')\n    .set('Authorization', `Bearer ${userToken}`);\n  \n  expect(response.status).toBe(403);\n  expect(response.body.error).toBe('Insufficient permissions');\n});\n```\n```\n\n### Service Unavailable\n\n```markdown\n## Scenario: [Resource] - Dependency Down\n\n**Type:** API Integration\n**Systems:** [Service] → [Dependency]\n**Priority:** Medium\n\n### Setup\n- Dependency service is unavailable\n\n### Steps\n1. Send request that requires dependency\n2. Dependency times out or connection refused\n\n### Expected Results\n- Response status: 503 Service Unavailable\n- Response contains meaningful error\n- No partial state left\n\n### Test Code\n```javascript\nit('handles dependency failure gracefully', async () => {\n  // Make dependency unavailable\n  await dependencyMock.setUnavailable();\n  \n  const response = await request(app)\n    .post('/[resources]')\n    .set('Authorization', `Bearer ${token}`)\n    .send({ field1: 'value1' });\n  \n  expect(response.status).toBe(503);\n  expect(response.body.error).toContain('temporarily unavailable');\n  \n  // Verify no partial record created\n  const records = await db.[resources].findAll();\n  expect(records.length).toBe(0);\n});\n```\n```\n\n## Event Integration Scenarios\n\n### Event Published\n\n```markdown\n## Scenario: [Event] Published on [Action]\n\n**Type:** Event Integration\n**Systems:** [Publisher] → Message Broker\n**Priority:** High\n\n### Setup\n- Message broker is running\n- Event subscriber is listening\n\n### Steps\n1. Trigger action that should publish event\n2. Capture published event\n\n### Expected Results\n- Event published to correct channel\n- Event contains expected data\n- Event matches schema\n\n### Test Code\n```javascript\nit('publishes [Event] on [action]', async () => {\n  const eventCapture = await broker.subscribe('[channel]');\n  \n  // Trigger action\n  await service.[action]({ id: '123', data: 'value' });\n  \n  // Wait for event\n  const event = await eventCapture.waitForEvent(5000);\n  \n  expect(event.type).toBe('[EventType]');\n  expect(event.data.id).toBe('123');\n  expect(event.timestamp).toBeDefined();\n  \n  // Validate against schema\n  expect(validateSchema(event, '[EventType]Schema')).toBe(true);\n});\n```\n```\n\n### Event Consumed\n\n```markdown\n## Scenario: [Event] Consumed Successfully\n\n**Type:** Event Integration\n**Systems:** Message Broker → [Consumer]\n**Priority:** High\n\n### Setup\n- Consumer is running and subscribed\n\n### Steps\n1. Publish event to channel\n2. Verify consumer processed it\n\n### Expected Results\n- Consumer receives event\n- Consumer performs expected action\n- No error logged\n\n### Test Code\n```javascript\nit('processes [Event] correctly', async () => {\n  // Publish event\n  await broker.publish('[channel]', {\n    type: '[EventType]',\n    data: { id: '123', value: 'test' }\n  });\n  \n  // Wait for processing\n  await waitFor(async () => {\n    const record = await db.[table].findById('123');\n    return record !== null;\n  }, 5000);\n  \n  // Verify result\n  const record = await db.[table].findById('123');\n  expect(record.value).toBe('test');\n});\n```\n```\n\n### Duplicate Event Handling\n\n```markdown\n## Scenario: Duplicate [Event] Handled Idempotently\n\n**Type:** Event Integration\n**Systems:** Message Broker → [Consumer]\n**Priority:** High\n\n### Setup\n- Consumer is running\n\n### Steps\n1. Publish same event twice\n2. Verify only one action taken\n\n### Expected Results\n- Event processed once\n- No duplicate records/actions\n- No errors\n\n### Test Code\n```javascript\nit('handles duplicate [Event] idempotently', async () => {\n  const event = {\n    eventId: 'evt-123',\n    type: '[EventType]',\n    data: { id: '456' }\n  };\n  \n  // Publish twice\n  await broker.publish('[channel]', event);\n  await broker.publish('[channel]', event);\n  \n  // Wait for processing\n  await sleep(2000);\n  \n  // Verify single record\n  const records = await db.[table].findByField('externalId', '456');\n  expect(records.length).toBe(1);\n});\n```\n```\n\n## E2E Workflow Scenarios\n\n### Complete Workflow\n\n```markdown\n## Scenario: [Workflow Name] - Happy Path\n\n**Type:** End-to-End\n**Systems:** [List all systems involved]\n**Priority:** High\n\n### Setup\n- All services running\n- Test data created\n- Test users exist\n\n### Steps\n1. [User A] performs [Action 1]\n2. System [X] processes and triggers [Y]\n3. [User B] receives notification\n4. [User B] performs [Action 2]\n5. System [Z] finalizes\n\n### Expected Results\n- Each step completes successfully\n- Data consistent across all systems\n- Notifications delivered\n- Final state correct\n\n### Test Code\n```javascript\nit('completes [workflow] successfully', async () => {\n  // Step 1\n  const step1Result = await userA.perform[Action1]({...});\n  expect(step1Result.status).toBe('success');\n  \n  // Step 2 - verify system processing\n  await waitFor(async () => {\n    const state = await systemX.getState(step1Result.id);\n    return state.processed === true;\n  }, 10000);\n  \n  // Step 3 - verify notification\n  const notifications = await userB.getNotifications();\n  expect(notifications).toContainEqual(\n    expect.objectContaining({ type: '[NotificationType]' })\n  );\n  \n  // Step 4\n  const step4Result = await userB.perform[Action2]({...});\n  expect(step4Result.status).toBe('success');\n  \n  // Step 5 - verify final state\n  const finalState = await systemZ.getFinalState(step1Result.id);\n  expect(finalState.status).toBe('completed');\n  expect(finalState.allSystemsConsistent).toBe(true);\n});\n```\n```\n\n### Workflow with Failure Recovery\n\n```markdown\n## Scenario: [Workflow] - Recovery from Failure\n\n**Type:** End-to-End\n**Systems:** [List all systems involved]\n**Priority:** Medium\n\n### Setup\n- All services running\n- Failure injection capability\n\n### Steps\n1. Start workflow normally\n2. Inject failure at [step]\n3. Verify system detects failure\n4. Trigger retry/recovery\n5. Verify workflow completes\n\n### Expected Results\n- Failure detected\n- No data corruption\n- Recovery successful\n- Final state correct\n\n### Test Code\n```javascript\nit('recovers from [failure type]', async () => {\n  // Start workflow\n  const workflowId = await workflow.start({...});\n  \n  // Inject failure\n  await failureInjector.fail('[service]', '[failure-type]');\n  \n  // Wait for failure detection\n  await waitFor(async () => {\n    const state = await workflow.getState(workflowId);\n    return state.status === 'failed';\n  }, 10000);\n  \n  // Restore service\n  await failureInjector.restore('[service]');\n  \n  // Trigger recovery\n  await workflow.retry(workflowId);\n  \n  // Verify completion\n  await waitFor(async () => {\n    const state = await workflow.getState(workflowId);\n    return state.status === 'completed';\n  }, 30000);\n  \n  // Verify data consistency\n  const data = await verifyConsistency(workflowId);\n  expect(data.consistent).toBe(true);\n});\n```\n```\n\n## Contract Test Scenarios\n\n### Provider Contract\n\n```markdown\n## Scenario: [Provider] Contract Verification\n\n**Type:** Contract (Provider side)\n**Systems:** [Provider]\n**Priority:** High\n\n### Setup\n- Provider service running\n- Contract file loaded\n\n### Steps\n1. Load contract expectations\n2. For each interaction:\n   - Send specified request\n   - Verify response matches contract\n\n### Expected Results\n- All interactions pass\n- Response format matches\n- Response values match matchers\n\n### Test Code\n```javascript\ndescribe('[Provider] Contract', () => {\n  const contracts = loadContracts('[provider]-contracts.json');\n  \n  contracts.forEach(contract => {\n    it(`satisfies: ${contract.description}`, async () => {\n      // Set up provider state\n      await providerStates.setup(contract.providerState);\n      \n      // Send request per contract\n      const response = await request(app)\n        .request(contract.request.method, contract.request.path)\n        .set(contract.request.headers)\n        .send(contract.request.body);\n      \n      // Verify response\n      expect(response.status).toBe(contract.response.status);\n      expect(response.body).toMatchObject(contract.response.body);\n      \n      // Clean up\n      await providerStates.cleanup(contract.providerState);\n    });\n  });\n});\n```\n```\n\n### Consumer Contract\n\n```markdown\n## Scenario: [Consumer] Expectations of [Provider]\n\n**Type:** Contract (Consumer side)\n**Systems:** [Consumer] → [Provider]\n**Priority:** High\n\n### Setup\n- Mock provider running\n- Consumer service running\n\n### Steps\n1. Define expected interactions\n2. Consumer makes calls\n3. Verify interactions match\n\n### Expected Results\n- Consumer handles responses correctly\n- Interactions recorded match expectations\n- Contract can be shared with provider\n\n### Test Code\n```javascript\ndescribe('[Consumer] Expectations', () => {\n  let mockProvider;\n  \n  beforeAll(async () => {\n    mockProvider = await Pact({\n      consumer: '[Consumer]',\n      provider: '[Provider]'\n    });\n  });\n  \n  it('expects [interaction description]', async () => {\n    // Define expectation\n    await mockProvider.addInteraction({\n      state: '[provider state]',\n      uponReceiving: '[description]',\n      withRequest: {\n        method: 'GET',\n        path: '/resource/123'\n      },\n      willRespondWith: {\n        status: 200,\n        body: {\n          id: Matchers.string('123'),\n          name: Matchers.string()\n        }\n      }\n    });\n    \n    // Consumer makes call\n    const result = await consumer.getResource('123');\n    \n    // Verify consumer handled it\n    expect(result.id).toBe('123');\n    \n    // Verify interaction occurred\n    await mockProvider.verify();\n  });\n  \n  afterAll(async () => {\n    // Write contract file\n    await mockProvider.finalize();\n  });\n});\n```\n```\n"
    },
    {
      "name": "test-environment-setup.md",
      "path": "references/test-environment-setup.md",
      "content": "# Test Environment Setup\n\nComprehensive guide for configuring integration test environments across different deployment scenarios.\n\n## Purpose\n\nThis reference provides patterns and procedures for setting up reliable, reproducible integration test environments. Use this when:\n\n- Setting up local development testing\n- Configuring CI/CD pipeline test stages\n- Creating isolated test environments\n- Managing test dependencies and services\n- Troubleshooting environment issues\n\n## Core Concepts\n\n### Environment Isolation Levels\n\nIntegration tests require careful isolation to ensure reliability and prevent cross-test contamination.\n\n```\n+------------------------------------------------------------------+\n|                    ISOLATION LEVELS                               |\n|                                                                   |\n|  Level 1: Process Isolation                                       |\n|  +------------------+  +------------------+                       |\n|  | Test Process A   |  | Test Process B   |                       |\n|  | - Shared DB      |  | - Shared DB      |                       |\n|  | - Shared Services|  | - Shared Services|                       |\n|  +------------------+  +------------------+                       |\n|  Fast but risk of interference                                    |\n|                                                                   |\n|  Level 2: Database Isolation                                      |\n|  +------------------+  +------------------+                       |\n|  | Test Suite A     |  | Test Suite B     |                       |\n|  | - Own Schema     |  | - Own Schema     |                       |\n|  | - Shared Services|  | - Shared Services|                       |\n|  +------------------+  +------------------+                       |\n|  Balanced isolation and speed                                     |\n|                                                                   |\n|  Level 3: Container Isolation                                     |\n|  +------------------+  +------------------+                       |\n|  | Container Set A  |  | Container Set B  |                       |\n|  | - Own DB         |  | - Own DB         |                       |\n|  | - Own Services   |  | - Own Services   |                       |\n|  +------------------+  +------------------+                       |\n|  Full isolation, slower startup                                   |\n|                                                                   |\n+------------------------------------------------------------------+\n```\n\n### Test Environment Components\n\n| Component | Purpose | Options |\n|-----------|---------|---------|\n| **Database** | Persistent storage | PostgreSQL, MySQL, MongoDB, In-memory |\n| **Cache** | Fast data access | Redis, Memcached, In-memory |\n| **Message Broker** | Async communication | Kafka, RabbitMQ, In-memory |\n| **External Services** | Third-party APIs | Mocks, Stubs, Sandboxes |\n| **Identity Provider** | Authentication | Mock IdP, Test accounts |\n| **File Storage** | Binary data | Local FS, MinIO, Mock S3 |\n\n## Docker Compose Setup\n\n### Basic Configuration\n\n```yaml\n# docker-compose.test.yaml\nversion: '3.8'\n\nservices:\n  # PostgreSQL Database\n  postgres:\n    image: postgres:15-alpine\n    container_name: test-postgres\n    ports:\n      - \"5433:5432\"  # Use non-standard port to avoid conflicts\n    environment:\n      POSTGRES_USER: test\n      POSTGRES_PASSWORD: test\n      POSTGRES_DB: test_db\n    volumes:\n      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U test -d test_db\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n\n  # Redis Cache\n  redis:\n    image: redis:7-alpine\n    container_name: test-redis\n    ports:\n      - \"6380:6379\"\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n\n  # Kafka Message Broker\n  zookeeper:\n    image: confluentinc/cp-zookeeper:7.4.0\n    container_name: test-zookeeper\n    environment:\n      ZOOKEEPER_CLIENT_PORT: 2181\n      ZOOKEEPER_TICK_TIME: 2000\n    healthcheck:\n      test: [\"CMD\", \"nc\", \"-z\", \"localhost\", \"2181\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  kafka:\n    image: confluentinc/cp-kafka:7.4.0\n    container_name: test-kafka\n    depends_on:\n      zookeeper:\n        condition: service_healthy\n    ports:\n      - \"9093:9093\"\n    environment:\n      KAFKA_BROKER_ID: 1\n      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9093\n      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n      KAFKA_AUTO_CREATE_TOPICS_ENABLE: \"true\"\n    healthcheck:\n      test: [\"CMD\", \"kafka-broker-api-versions\", \"--bootstrap-server\", \"localhost:9093\"]\n      interval: 10s\n      timeout: 10s\n      retries: 5\n\n  # MinIO S3-Compatible Storage\n  minio:\n    image: minio/minio:latest\n    container_name: test-minio\n    ports:\n      - \"9001:9000\"\n      - \"9002:9001\"\n    environment:\n      MINIO_ROOT_USER: minioadmin\n      MINIO_ROOT_PASSWORD: minioadmin\n    command: server /data --console-address \":9001\"\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:9000/minio/health/live\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  # Application Under Test\n  app:\n    build:\n      context: .\n      dockerfile: Dockerfile.test\n    container_name: test-app\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n      kafka:\n        condition: service_healthy\n    ports:\n      - \"3001:3000\"\n    environment:\n      NODE_ENV: test\n      DATABASE_URL: postgres://test:test@postgres:5432/test_db\n      REDIS_URL: redis://redis:6379\n      KAFKA_BROKERS: kafka:29092\n      S3_ENDPOINT: http://minio:9000\n      S3_ACCESS_KEY: minioadmin\n      S3_SECRET_KEY: minioadmin\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 10s\n      timeout: 5s\n      retries: 10\n\nnetworks:\n  default:\n    name: integration-test-network\n```\n\n### Multi-Service Configuration\n\n```yaml\n# docker-compose.microservices.test.yaml\nversion: '3.8'\n\nservices:\n  # Infrastructure Services\n  postgres:\n    extends:\n      file: docker-compose.test.yaml\n      service: postgres\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n\n  redis:\n    extends:\n      file: docker-compose.test.yaml\n      service: redis\n\n  kafka:\n    extends:\n      file: docker-compose.test.yaml\n      service: kafka\n    depends_on:\n      - zookeeper\n\n  zookeeper:\n    extends:\n      file: docker-compose.test.yaml\n      service: zookeeper\n\n  # Application Services\n  auth-service:\n    build:\n      context: ./services/auth\n      dockerfile: Dockerfile\n    container_name: test-auth-service\n    ports:\n      - \"3010:3000\"\n    environment:\n      DATABASE_URL: postgres://test:test@postgres:5432/auth_db\n      JWT_SECRET: test-jwt-secret-key-for-testing\n      JWT_EXPIRY: 3600\n    depends_on:\n      postgres:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  user-service:\n    build:\n      context: ./services/user\n      dockerfile: Dockerfile\n    container_name: test-user-service\n    ports:\n      - \"3011:3000\"\n    environment:\n      DATABASE_URL: postgres://test:test@postgres:5432/user_db\n      AUTH_SERVICE_URL: http://auth-service:3000\n      REDIS_URL: redis://redis:6379\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n      auth-service:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  order-service:\n    build:\n      context: ./services/order\n      dockerfile: Dockerfile\n    container_name: test-order-service\n    ports:\n      - \"3012:3000\"\n    environment:\n      DATABASE_URL: postgres://test:test@postgres:5432/order_db\n      AUTH_SERVICE_URL: http://auth-service:3000\n      USER_SERVICE_URL: http://user-service:3000\n      KAFKA_BROKERS: kafka:29092\n    depends_on:\n      postgres:\n        condition: service_healthy\n      kafka:\n        condition: service_healthy\n      auth-service:\n        condition: service_healthy\n      user-service:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  notification-service:\n    build:\n      context: ./services/notification\n      dockerfile: Dockerfile\n    container_name: test-notification-service\n    ports:\n      - \"3013:3000\"\n    environment:\n      KAFKA_BROKERS: kafka:29092\n      REDIS_URL: redis://redis:6379\n      SMTP_HOST: mailhog\n      SMTP_PORT: 1025\n    depends_on:\n      kafka:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  # Test Utilities\n  mailhog:\n    image: mailhog/mailhog\n    container_name: test-mailhog\n    ports:\n      - \"1025:1025\"  # SMTP\n      - \"8025:8025\"  # Web UI\n\nvolumes:\n  postgres-data:\n\nnetworks:\n  default:\n    name: microservices-test-network\n```\n\n## Database Setup Patterns\n\n### Schema Initialization\n\n```sql\n-- scripts/init-db.sql\n\n-- Create separate databases for each service\nCREATE DATABASE auth_db;\nCREATE DATABASE user_db;\nCREATE DATABASE order_db;\n\n-- Create test user with full privileges\nCREATE USER test_user WITH PASSWORD 'test_password';\nGRANT ALL PRIVILEGES ON DATABASE auth_db TO test_user;\nGRANT ALL PRIVILEGES ON DATABASE user_db TO test_user;\nGRANT ALL PRIVILEGES ON DATABASE order_db TO test_user;\n\n-- Connect to each database and create schemas\n\\c auth_db;\nCREATE SCHEMA IF NOT EXISTS public;\nGRANT ALL ON SCHEMA public TO test_user;\n\n\\c user_db;\nCREATE SCHEMA IF NOT EXISTS public;\nGRANT ALL ON SCHEMA public TO test_user;\n\n\\c order_db;\nCREATE SCHEMA IF NOT EXISTS public;\nGRANT ALL ON SCHEMA public TO test_user;\n```\n\n### Test Database Utilities\n\n```typescript\n// test/utils/database.ts\nimport { Pool, PoolClient } from 'pg';\n\nexport interface TestDatabaseConfig {\n  host: string;\n  port: number;\n  user: string;\n  password: string;\n  database: string;\n}\n\nexport class TestDatabase {\n  private pool: Pool;\n  private client: PoolClient | null = null;\n\n  constructor(config: TestDatabaseConfig) {\n    this.pool = new Pool(config);\n  }\n\n  /**\n   * Begin a transaction that will be rolled back after test\n   * Provides test isolation without database cleanup\n   */\n  async beginTransaction(): Promise<PoolClient> {\n    this.client = await this.pool.connect();\n    await this.client.query('BEGIN');\n    return this.client;\n  }\n\n  /**\n   * Rollback transaction to restore database state\n   */\n  async rollbackTransaction(): Promise<void> {\n    if (this.client) {\n      await this.client.query('ROLLBACK');\n      this.client.release();\n      this.client = null;\n    }\n  }\n\n  /**\n   * Truncate all tables in specified schema\n   * Use for complete data reset between test suites\n   */\n  async truncateAllTables(schema: string = 'public'): Promise<void> {\n    const result = await this.pool.query(`\n      SELECT tablename FROM pg_tables\n      WHERE schemaname = $1\n      AND tablename NOT LIKE 'pg_%'\n      AND tablename NOT LIKE '_prisma_%'\n    `, [schema]);\n\n    const tables = result.rows.map(row => row.tablename);\n\n    if (tables.length > 0) {\n      await this.pool.query(`\n        TRUNCATE TABLE ${tables.map(t => `\"${schema}\".\"${t}\"`).join(', ')}\n        RESTART IDENTITY CASCADE\n      `);\n    }\n  }\n\n  /**\n   * Seed database with test data\n   */\n  async seed(seedData: Record<string, any[]>): Promise<void> {\n    for (const [table, rows] of Object.entries(seedData)) {\n      for (const row of rows) {\n        const columns = Object.keys(row);\n        const values = Object.values(row);\n        const placeholders = columns.map((_, i) => `$${i + 1}`).join(', ');\n\n        await this.pool.query(`\n          INSERT INTO \"${table}\" (${columns.map(c => `\"${c}\"`).join(', ')})\n          VALUES (${placeholders})\n          ON CONFLICT DO NOTHING\n        `, values);\n      }\n    }\n  }\n\n  /**\n   * Close database connections\n   */\n  async close(): Promise<void> {\n    await this.pool.end();\n  }\n}\n\n// Usage in tests\nexport const testDb = new TestDatabase({\n  host: process.env.TEST_DB_HOST || 'localhost',\n  port: parseInt(process.env.TEST_DB_PORT || '5433'),\n  user: process.env.TEST_DB_USER || 'test',\n  password: process.env.TEST_DB_PASSWORD || 'test',\n  database: process.env.TEST_DB_NAME || 'test_db',\n});\n```\n\n### Database Isolation Strategies\n\n| Strategy | Speed | Isolation | Complexity | Use Case |\n|----------|-------|-----------|------------|----------|\n| **Transaction Rollback** | Fast | High | Low | Unit-like integration tests |\n| **Table Truncation** | Medium | High | Low | Suite-level cleanup |\n| **Schema Per Test** | Slow | Complete | Medium | Parallel test execution |\n| **Database Per Test** | Slowest | Complete | High | Complex state scenarios |\n\n```typescript\n// test/utils/isolation-strategies.ts\n\n/**\n * Transaction-based isolation (fastest)\n */\nexport function withTransactionIsolation(\n  db: TestDatabase\n): jest.Lifecycle {\n  return {\n    beforeEach: async () => {\n      await db.beginTransaction();\n    },\n    afterEach: async () => {\n      await db.rollbackTransaction();\n    },\n  };\n}\n\n/**\n * Truncation-based isolation (moderate speed)\n */\nexport function withTruncationIsolation(\n  db: TestDatabase,\n  tables: string[]\n): jest.Lifecycle {\n  return {\n    beforeEach: async () => {\n      // No-op before each\n    },\n    afterEach: async () => {\n      await db.truncateAllTables();\n    },\n  };\n}\n\n/**\n * Schema-based isolation (supports parallelism)\n */\nexport function withSchemaIsolation(\n  db: TestDatabase,\n  schemaPrefix: string\n): jest.Lifecycle {\n  const schemaName = `${schemaPrefix}_${process.pid}`;\n\n  return {\n    beforeAll: async () => {\n      await db.query(`CREATE SCHEMA IF NOT EXISTS \"${schemaName}\"`);\n      await db.query(`SET search_path TO \"${schemaName}\"`);\n    },\n    afterAll: async () => {\n      await db.query(`DROP SCHEMA IF EXISTS \"${schemaName}\" CASCADE`);\n    },\n  };\n}\n```\n\n## Test Data Management\n\n### Fixture Loading System\n\n```typescript\n// test/fixtures/loader.ts\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\n\nexport interface Fixture {\n  name: string;\n  table: string;\n  data: Record<string, any>[];\n  dependencies?: string[];\n}\n\nexport class FixtureLoader {\n  private fixturesDir: string;\n  private loadedFixtures: Map<string, Fixture> = new Map();\n\n  constructor(fixturesDir: string) {\n    this.fixturesDir = fixturesDir;\n  }\n\n  /**\n   * Load fixture from YAML file\n   */\n  loadFixture(name: string): Fixture {\n    if (this.loadedFixtures.has(name)) {\n      return this.loadedFixtures.get(name)!;\n    }\n\n    const filePath = path.join(this.fixturesDir, `${name}.yaml`);\n    const content = fs.readFileSync(filePath, 'utf-8');\n    const fixture = yaml.load(content) as Fixture;\n\n    this.loadedFixtures.set(name, fixture);\n    return fixture;\n  }\n\n  /**\n   * Load fixture and all its dependencies in correct order\n   */\n  loadWithDependencies(name: string): Fixture[] {\n    const fixture = this.loadFixture(name);\n    const result: Fixture[] = [];\n\n    // Load dependencies first (recursively)\n    if (fixture.dependencies) {\n      for (const dep of fixture.dependencies) {\n        result.push(...this.loadWithDependencies(dep));\n      }\n    }\n\n    // Add current fixture if not already loaded\n    if (!result.find(f => f.name === fixture.name)) {\n      result.push(fixture);\n    }\n\n    return result;\n  }\n\n  /**\n   * Apply fixtures to database\n   */\n  async applyFixtures(\n    db: TestDatabase,\n    fixtures: Fixture[]\n  ): Promise<void> {\n    for (const fixture of fixtures) {\n      await db.seed({ [fixture.table]: fixture.data });\n    }\n  }\n}\n\n// Example fixture file: test/fixtures/users.yaml\n/*\nname: users\ntable: users\ndata:\n  - id: \"usr-001\"\n    email: \"admin@test.com\"\n    role: \"admin\"\n    created_at: \"2024-01-01T00:00:00Z\"\n  - id: \"usr-002\"\n    email: \"user@test.com\"\n    role: \"user\"\n    created_at: \"2024-01-01T00:00:00Z\"\n*/\n\n// Example fixture file: test/fixtures/orders.yaml\n/*\nname: orders\ntable: orders\ndependencies:\n  - users\ndata:\n  - id: \"ord-001\"\n    user_id: \"usr-002\"\n    status: \"pending\"\n    total: 100.00\n    created_at: \"2024-01-15T10:00:00Z\"\n*/\n```\n\n### Factory Pattern for Test Data\n\n```typescript\n// test/factories/index.ts\nimport { faker } from '@faker-js/faker';\n\n// Base factory interface\ninterface Factory<T> {\n  build(overrides?: Partial<T>): T;\n  buildMany(count: number, overrides?: Partial<T>): T[];\n  create(overrides?: Partial<T>): Promise<T>;\n  createMany(count: number, overrides?: Partial<T>): Promise<T[]>;\n}\n\n// User factory\nexport const userFactory: Factory<User> = {\n  build(overrides = {}) {\n    return {\n      id: faker.string.uuid(),\n      email: faker.internet.email(),\n      name: faker.person.fullName(),\n      role: 'user',\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      ...overrides,\n    };\n  },\n\n  buildMany(count, overrides = {}) {\n    return Array.from({ length: count }, () => this.build(overrides));\n  },\n\n  async create(overrides = {}) {\n    const user = this.build(overrides);\n    await db.query(`\n      INSERT INTO users (id, email, name, role, created_at, updated_at)\n      VALUES ($1, $2, $3, $4, $5, $6)\n    `, [user.id, user.email, user.name, user.role, user.createdAt, user.updatedAt]);\n    return user;\n  },\n\n  async createMany(count, overrides = {}) {\n    const users = this.buildMany(count, overrides);\n    for (const user of users) {\n      await this.create(user);\n    }\n    return users;\n  },\n};\n\n// Order factory with relationships\nexport const orderFactory: Factory<Order> = {\n  build(overrides = {}) {\n    return {\n      id: faker.string.uuid(),\n      userId: faker.string.uuid(),\n      status: 'pending',\n      items: [],\n      total: 0,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      ...overrides,\n    };\n  },\n\n  buildMany(count, overrides = {}) {\n    return Array.from({ length: count }, () => this.build(overrides));\n  },\n\n  async create(overrides = {}) {\n    // Create user if not provided\n    let userId = overrides.userId;\n    if (!userId) {\n      const user = await userFactory.create();\n      userId = user.id;\n    }\n\n    const order = this.build({ ...overrides, userId });\n    await db.query(`\n      INSERT INTO orders (id, user_id, status, items, total, created_at, updated_at)\n      VALUES ($1, $2, $3, $4, $5, $6, $7)\n    `, [order.id, order.userId, order.status, JSON.stringify(order.items),\n        order.total, order.createdAt, order.updatedAt]);\n    return order;\n  },\n\n  async createMany(count, overrides = {}) {\n    const orders = [];\n    for (let i = 0; i < count; i++) {\n      orders.push(await this.create(overrides));\n    }\n    return orders;\n  },\n};\n```\n\n## Service Mocking\n\n### WireMock Configuration\n\n```yaml\n# wiremock/mappings/auth-service.json\n{\n  \"request\": {\n    \"method\": \"POST\",\n    \"url\": \"/auth/verify\"\n  },\n  \"response\": {\n    \"status\": 200,\n    \"headers\": {\n      \"Content-Type\": \"application/json\"\n    },\n    \"jsonBody\": {\n      \"valid\": true,\n      \"userId\": \"{{randomValue type='UUID'}}\",\n      \"expiresAt\": \"{{now offset='1 hour' format='yyyy-MM-dd HH:mm:ss'}}\"\n    },\n    \"transformers\": [\"response-template\"]\n  }\n}\n```\n\n```yaml\n# docker-compose with WireMock\nservices:\n  wiremock:\n    image: wiremock/wiremock:3.0.0\n    container_name: test-wiremock\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - ./wiremock:/home/wiremock\n    command: [\"--verbose\", \"--global-response-templating\"]\n```\n\n### HTTP Mock Server (Node.js)\n\n```typescript\n// test/mocks/http-mock-server.ts\nimport express, { Express, Request, Response, NextFunction } from 'express';\nimport { Server } from 'http';\n\nexport interface MockEndpoint {\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  path: string;\n  handler: (req: Request, res: Response) => void;\n  latency?: number;\n}\n\nexport class HttpMockServer {\n  private app: Express;\n  private server: Server | null = null;\n  private endpoints: Map<string, MockEndpoint> = new Map();\n  private requestLog: Array<{ method: string; path: string; body: any; headers: any }> = [];\n\n  constructor(private port: number = 9999) {\n    this.app = express();\n    this.app.use(express.json());\n    this.app.use(this.logRequest.bind(this));\n    this.app.use(this.routeHandler.bind(this));\n  }\n\n  private logRequest(req: Request, _res: Response, next: NextFunction): void {\n    this.requestLog.push({\n      method: req.method,\n      path: req.path,\n      body: req.body,\n      headers: req.headers,\n    });\n    next();\n  }\n\n  private routeHandler(req: Request, res: Response): void {\n    const key = `${req.method}:${req.path}`;\n    const endpoint = this.endpoints.get(key);\n\n    if (endpoint) {\n      if (endpoint.latency) {\n        setTimeout(() => endpoint.handler(req, res), endpoint.latency);\n      } else {\n        endpoint.handler(req, res);\n      }\n    } else {\n      res.status(404).json({ error: 'Mock endpoint not configured' });\n    }\n  }\n\n  /**\n   * Register a mock endpoint\n   */\n  mock(endpoint: MockEndpoint): void {\n    const key = `${endpoint.method}:${endpoint.path}`;\n    this.endpoints.set(key, endpoint);\n  }\n\n  /**\n   * Set latency for simulating slow responses\n   */\n  setLatency(method: string, path: string, latencyMs: number): void {\n    const key = `${method}:${path}`;\n    const endpoint = this.endpoints.get(key);\n    if (endpoint) {\n      endpoint.latency = latencyMs;\n    }\n  }\n\n  /**\n   * Get all requests made to a specific endpoint\n   */\n  getRequests(method?: string, path?: string): typeof this.requestLog {\n    return this.requestLog.filter(r =>\n      (!method || r.method === method) && (!path || r.path === path)\n    );\n  }\n\n  /**\n   * Clear request log and reset endpoints\n   */\n  reset(): void {\n    this.requestLog = [];\n  }\n\n  /**\n   * Start the mock server\n   */\n  async start(): Promise<void> {\n    return new Promise((resolve) => {\n      this.server = this.app.listen(this.port, () => {\n        console.log(`Mock server running on port ${this.port}`);\n        resolve();\n      });\n    });\n  }\n\n  /**\n   * Stop the mock server\n   */\n  async stop(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        this.server.close((err) => {\n          if (err) reject(err);\n          else resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n}\n\n// Usage example\nconst mockAuthService = new HttpMockServer(3010);\n\nmockAuthService.mock({\n  method: 'POST',\n  path: '/auth/verify',\n  handler: (req, res) => {\n    const { token } = req.body;\n    if (token === 'valid-token') {\n      res.json({ valid: true, userId: 'user-123' });\n    } else if (token === 'expired-token') {\n      res.status(401).json({ error: 'Token expired' });\n    } else {\n      res.status(401).json({ error: 'Invalid token' });\n    }\n  },\n});\n```\n\n## CI/CD Integration\n\n### GitHub Actions Configuration\n\n```yaml\n# .github/workflows/integration-tests.yaml\nname: Integration Tests\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  integration-tests:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_USER: test\n          POSTGRES_PASSWORD: test\n          POSTGRES_DB: test_db\n        ports:\n          - 5432:5432\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n      redis:\n        image: redis:7\n        ports:\n          - 6379:6379\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run database migrations\n        run: npm run db:migrate:test\n        env:\n          DATABASE_URL: postgres://test:test@localhost:5432/test_db\n\n      - name: Seed test data\n        run: npm run db:seed:test\n        env:\n          DATABASE_URL: postgres://test:test@localhost:5432/test_db\n\n      - name: Run integration tests\n        run: npm run test:integration\n        env:\n          DATABASE_URL: postgres://test:test@localhost:5432/test_db\n          REDIS_URL: redis://localhost:6379\n          NODE_ENV: test\n\n      - name: Upload test results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: integration-test-results\n          path: test-results/\n          retention-days: 7\n```\n\n### Docker-in-Docker Setup for Complex Tests\n\n```yaml\n# .github/workflows/e2e-tests.yaml\nname: E2E Tests\n\non:\n  push:\n    branches: [main]\n  schedule:\n    - cron: '0 2 * * *'  # Run nightly\n\njobs:\n  e2e-tests:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Start test environment\n        run: |\n          docker compose -f docker-compose.test.yaml up -d --build\n          docker compose -f docker-compose.test.yaml logs -f &\n\n          # Wait for services to be healthy\n          ./scripts/wait-for-services.sh\n\n      - name: Run E2E tests\n        run: |\n          docker compose -f docker-compose.test.yaml exec -T app \\\n            npm run test:e2e\n\n      - name: Collect logs on failure\n        if: failure()\n        run: |\n          docker compose -f docker-compose.test.yaml logs > docker-logs.txt\n\n      - name: Upload logs on failure\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: docker-logs\n          path: docker-logs.txt\n\n      - name: Stop test environment\n        if: always()\n        run: docker compose -f docker-compose.test.yaml down -v\n```\n\n### Service Health Wait Script\n\n```bash\n#!/bin/bash\n# scripts/wait-for-services.sh\n\nset -e\n\nMAX_RETRIES=30\nRETRY_INTERVAL=2\n\nwait_for_service() {\n  local service_name=$1\n  local health_url=$2\n  local retries=0\n\n  echo \"Waiting for $service_name...\"\n\n  while [ $retries -lt $MAX_RETRIES ]; do\n    if curl -sf \"$health_url\" > /dev/null 2>&1; then\n      echo \"$service_name is ready!\"\n      return 0\n    fi\n\n    retries=$((retries + 1))\n    echo \"  Attempt $retries/$MAX_RETRIES...\"\n    sleep $RETRY_INTERVAL\n  done\n\n  echo \"ERROR: $service_name did not become ready in time\"\n  return 1\n}\n\n# Wait for all services\nwait_for_service \"PostgreSQL\" \"http://localhost:5432\"\nwait_for_service \"Redis\" \"http://localhost:6379\"\nwait_for_service \"Application\" \"http://localhost:3001/health\"\n\necho \"All services are ready!\"\n```\n\n## Test Configuration\n\n### Jest Integration Test Config\n\n```javascript\n// jest.integration.config.js\nmodule.exports = {\n  displayName: 'integration',\n  testEnvironment: 'node',\n  testMatch: ['**/*.integration.test.ts'],\n  setupFilesAfterEnv: ['<rootDir>/test/setup/integration.ts'],\n  globalSetup: '<rootDir>/test/setup/global-setup.ts',\n  globalTeardown: '<rootDir>/test/setup/global-teardown.ts',\n  testTimeout: 30000,\n  maxWorkers: 1,  // Run serially for database isolation\n  verbose: true,\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n    '!src/**/*.test.ts',\n  ],\n};\n```\n\n### Global Setup and Teardown\n\n```typescript\n// test/setup/global-setup.ts\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\nexport default async function globalSetup(): Promise<void> {\n  console.log('Starting test environment...');\n\n  // Start Docker Compose if not in CI (CI has its own services)\n  if (!process.env.CI) {\n    await execAsync('docker compose -f docker-compose.test.yaml up -d');\n\n    // Wait for services\n    await waitForServices();\n  }\n\n  // Run migrations\n  await execAsync('npm run db:migrate:test');\n\n  console.log('Test environment ready!');\n}\n\nasync function waitForServices(): Promise<void> {\n  const maxRetries = 30;\n  const retryInterval = 1000;\n\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      // Check database\n      await execAsync('pg_isready -h localhost -p 5433 -U test');\n      // Check Redis\n      await execAsync('redis-cli -p 6380 ping');\n      console.log('All services are ready');\n      return;\n    } catch {\n      console.log(`Waiting for services... (${i + 1}/${maxRetries})`);\n      await new Promise(resolve => setTimeout(resolve, retryInterval));\n    }\n  }\n\n  throw new Error('Services did not become ready in time');\n}\n```\n\n```typescript\n// test/setup/global-teardown.ts\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\nexport default async function globalTeardown(): Promise<void> {\n  console.log('Cleaning up test environment...');\n\n  // Stop Docker Compose if not in CI\n  if (!process.env.CI) {\n    await execAsync('docker compose -f docker-compose.test.yaml down -v');\n  }\n\n  console.log('Test environment cleaned up!');\n}\n```\n\n```typescript\n// test/setup/integration.ts\nimport { testDb, TestDatabase } from '../utils/database';\n\nbeforeAll(async () => {\n  await testDb.truncateAllTables();\n});\n\nafterEach(async () => {\n  // Clear any mocks\n  jest.clearAllMocks();\n});\n\nafterAll(async () => {\n  await testDb.close();\n});\n```\n\n## Troubleshooting Guide\n\n### Common Issues and Solutions\n\n| Issue | Symptoms | Solution |\n|-------|----------|----------|\n| **Port conflicts** | \"Address already in use\" | Use non-standard ports in test config |\n| **Stale containers** | Tests see old data | Add `--force-recreate` to docker compose |\n| **Slow startup** | Tests timeout waiting | Increase health check retries |\n| **Database locks** | Tests hang | Use transaction rollback isolation |\n| **Flaky tests** | Intermittent failures | Add proper waits, check race conditions |\n| **Memory issues** | Container OOM | Limit test data, increase container memory |\n\n### Debugging Commands\n\n```bash\n# View container logs\ndocker compose -f docker-compose.test.yaml logs -f\n\n# Execute shell in container\ndocker compose -f docker-compose.test.yaml exec app sh\n\n# Check container health\ndocker compose -f docker-compose.test.yaml ps\n\n# View database contents\ndocker compose -f docker-compose.test.yaml exec postgres psql -U test -d test_db\n\n# Clear all volumes and restart\ndocker compose -f docker-compose.test.yaml down -v\ndocker compose -f docker-compose.test.yaml up -d --force-recreate\n\n# Check network connectivity\ndocker compose -f docker-compose.test.yaml exec app ping postgres\n```\n\n### Performance Optimization\n\n| Optimization | Impact | Implementation |\n|--------------|--------|----------------|\n| **Parallel test suites** | 2-4x faster | Schema-per-worker isolation |\n| **Cached base images** | Faster startup | Use CI image caching |\n| **Volume mounts** | Faster rebuilds | Mount node_modules |\n| **Health check tuning** | Faster readiness | Optimize check intervals |\n| **Test data subset** | Faster seeding | Use minimal fixture sets |\n\n## Examples\n\n### Complete Integration Test Suite Setup\n\n```typescript\n// test/integration/orders.integration.test.ts\nimport request from 'supertest';\nimport { app } from '../../src/app';\nimport { testDb } from '../utils/database';\nimport { userFactory, orderFactory } from '../factories';\nimport { mockAuthService } from '../mocks/auth-service';\n\ndescribe('Orders API Integration', () => {\n  let testUser: User;\n  let authToken: string;\n\n  beforeAll(async () => {\n    // Start mock auth service\n    await mockAuthService.start();\n\n    // Create test user\n    testUser = await userFactory.create({ role: 'customer' });\n    authToken = 'test-token-' + testUser.id;\n\n    // Configure mock to accept our token\n    mockAuthService.mock({\n      method: 'POST',\n      path: '/auth/verify',\n      handler: (req, res) => {\n        if (req.body.token === authToken) {\n          res.json({ valid: true, userId: testUser.id });\n        } else {\n          res.status(401).json({ error: 'Invalid token' });\n        }\n      },\n    });\n  });\n\n  afterAll(async () => {\n    await mockAuthService.stop();\n    await testDb.truncateAllTables();\n  });\n\n  beforeEach(async () => {\n    await testDb.beginTransaction();\n  });\n\n  afterEach(async () => {\n    await testDb.rollbackTransaction();\n    mockAuthService.reset();\n  });\n\n  describe('POST /orders', () => {\n    it('creates order with valid authentication', async () => {\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          items: [{ productId: 'prod-1', quantity: 2 }],\n        });\n\n      expect(response.status).toBe(201);\n      expect(response.body).toMatchObject({\n        userId: testUser.id,\n        status: 'pending',\n        items: expect.arrayContaining([\n          expect.objectContaining({ productId: 'prod-1', quantity: 2 }),\n        ]),\n      });\n\n      // Verify auth service was called\n      const authRequests = mockAuthService.getRequests('POST', '/auth/verify');\n      expect(authRequests).toHaveLength(1);\n      expect(authRequests[0].body.token).toBe(authToken);\n    });\n\n    it('rejects request without authentication', async () => {\n      const response = await request(app)\n        .post('/orders')\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      expect(response.status).toBe(401);\n    });\n\n    it('handles auth service timeout gracefully', async () => {\n      // Set high latency on auth service\n      mockAuthService.setLatency('POST', '/auth/verify', 5000);\n\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] })\n        .timeout(3000);\n\n      expect(response.status).toBe(503);\n      expect(response.body.error).toContain('Service unavailable');\n    });\n  });\n\n  describe('GET /orders/:id', () => {\n    let existingOrder: Order;\n\n    beforeEach(async () => {\n      existingOrder = await orderFactory.create({ userId: testUser.id });\n    });\n\n    it('returns order for authenticated owner', async () => {\n      const response = await request(app)\n        .get(`/orders/${existingOrder.id}`)\n        .set('Authorization', `Bearer ${authToken}`);\n\n      expect(response.status).toBe(200);\n      expect(response.body.id).toBe(existingOrder.id);\n    });\n\n    it('returns 404 for non-existent order', async () => {\n      const response = await request(app)\n        .get('/orders/non-existent-id')\n        .set('Authorization', `Bearer ${authToken}`);\n\n      expect(response.status).toBe(404);\n    });\n\n    it('returns 403 when accessing other user order', async () => {\n      const otherUser = await userFactory.create();\n      const otherOrder = await orderFactory.create({ userId: otherUser.id });\n\n      const response = await request(app)\n        .get(`/orders/${otherOrder.id}`)\n        .set('Authorization', `Bearer ${authToken}`);\n\n      expect(response.status).toBe(403);\n    });\n  });\n});\n```\n\n## See Also\n\n- `scenario-templates.md` - Test scenario templates\n- `test-patterns.md` - Common integration test patterns\n- `contract-testing.md` - Contract testing deep dive\n"
    },
    {
      "name": "test-patterns.md",
      "path": "references/test-patterns.md",
      "content": "# Integration Test Patterns\n\nComprehensive guide to common patterns for integration testing distributed systems, APIs, and event-driven architectures.\n\n## Purpose\n\nThis reference provides battle-tested patterns for writing effective integration tests. Use this when:\n\n- Testing API endpoints that interact with databases\n- Validating service-to-service communication\n- Testing event publishing and consumption\n- Implementing end-to-end workflow tests\n- Handling authentication and authorization in tests\n- Testing error scenarios and failure modes\n\n## Core Patterns Overview\n\n```\n+------------------------------------------------------------------+\n|                 INTEGRATION TEST PATTERNS                         |\n|                                                                   |\n|  +-----------------+     +------------------+                     |\n|  | API Testing     |     | Event Testing    |                     |\n|  | - Request/Response |  | - Publish/Consume|                     |\n|  | - Auth flows    |     | - Event ordering |                     |\n|  | - Error handling|     | - Idempotency    |                     |\n|  +-----------------+     +------------------+                     |\n|                                                                   |\n|  +-----------------+     +------------------+                     |\n|  | Database Testing|     | External Service |                     |\n|  | - Transactions  |     | - Mocking        |                     |\n|  | - Migrations    |     | - Stubbing       |                     |\n|  | - Constraints   |     | - Sandboxes      |                     |\n|  +-----------------+     +------------------+                     |\n|                                                                   |\n|  +-----------------+     +------------------+                     |\n|  | E2E Workflows   |     | Resilience       |                     |\n|  | - Multi-step    |     | - Timeouts       |                     |\n|  | - State machines|     | - Retries        |                     |\n|  | - User journeys |     | - Circuit breakers|                    |\n|  +-----------------+     +------------------+                     |\n|                                                                   |\n+------------------------------------------------------------------+\n```\n\n## API Testing Patterns\n\n### Pattern 1: Request-Response Validation\n\nValidates that API endpoints return correct responses for given inputs.\n\n```typescript\n// patterns/api-testing.ts\n\n/**\n * Pattern: Complete Request-Response Testing\n * Tests the full HTTP cycle including headers, status codes, and body\n */\ndescribe('User API', () => {\n  describe('GET /users/:id', () => {\n    it('returns user with all expected fields', async () => {\n      // Arrange\n      const user = await userFactory.create({\n        id: 'usr-123',\n        email: 'test@example.com',\n        name: 'Test User',\n      });\n\n      // Act\n      const response = await request(app)\n        .get('/users/usr-123')\n        .set('Accept', 'application/json');\n\n      // Assert - Status code\n      expect(response.status).toBe(200);\n\n      // Assert - Headers\n      expect(response.headers['content-type']).toMatch(/application\\/json/);\n      expect(response.headers['cache-control']).toBe('private, max-age=300');\n\n      // Assert - Body structure\n      expect(response.body).toMatchObject({\n        id: 'usr-123',\n        email: 'test@example.com',\n        name: 'Test User',\n        createdAt: expect.any(String),\n      });\n\n      // Assert - No sensitive fields exposed\n      expect(response.body).not.toHaveProperty('passwordHash');\n      expect(response.body).not.toHaveProperty('internalId');\n    });\n\n    it('returns 404 for non-existent user', async () => {\n      const response = await request(app)\n        .get('/users/non-existent')\n        .set('Accept', 'application/json');\n\n      expect(response.status).toBe(404);\n      expect(response.body).toMatchObject({\n        error: {\n          code: 'USER_NOT_FOUND',\n          message: expect.stringContaining('not found'),\n        },\n      });\n    });\n  });\n});\n```\n\n### Pattern 2: CRUD Operation Testing\n\nComprehensive testing of Create, Read, Update, Delete operations.\n\n```typescript\n/**\n * Pattern: Full CRUD Lifecycle Testing\n * Ensures all CRUD operations work correctly and consistently\n */\ndescribe('Products CRUD', () => {\n  let createdProductId: string;\n\n  describe('CREATE - POST /products', () => {\n    it('creates product with valid data', async () => {\n      const productData = {\n        name: 'Test Product',\n        price: 29.99,\n        category: 'electronics',\n      };\n\n      const response = await request(app)\n        .post('/products')\n        .send(productData)\n        .set('Authorization', `Bearer ${adminToken}`);\n\n      expect(response.status).toBe(201);\n      expect(response.body).toMatchObject({\n        id: expect.any(String),\n        ...productData,\n        createdAt: expect.any(String),\n      });\n\n      // Store for subsequent tests\n      createdProductId = response.body.id;\n\n      // Verify in database\n      const dbProduct = await db.products.findById(createdProductId);\n      expect(dbProduct).toMatchObject(productData);\n    });\n\n    it('rejects invalid price', async () => {\n      const response = await request(app)\n        .post('/products')\n        .send({ name: 'Test', price: -10 })\n        .set('Authorization', `Bearer ${adminToken}`);\n\n      expect(response.status).toBe(400);\n      expect(response.body.error.code).toBe('VALIDATION_ERROR');\n      expect(response.body.error.details).toContainEqual(\n        expect.objectContaining({ field: 'price' })\n      );\n    });\n  });\n\n  describe('READ - GET /products/:id', () => {\n    it('retrieves created product', async () => {\n      const response = await request(app)\n        .get(`/products/${createdProductId}`);\n\n      expect(response.status).toBe(200);\n      expect(response.body.id).toBe(createdProductId);\n    });\n  });\n\n  describe('UPDATE - PUT /products/:id', () => {\n    it('updates product fields', async () => {\n      const updateData = { price: 39.99 };\n\n      const response = await request(app)\n        .put(`/products/${createdProductId}`)\n        .send(updateData)\n        .set('Authorization', `Bearer ${adminToken}`);\n\n      expect(response.status).toBe(200);\n      expect(response.body.price).toBe(39.99);\n\n      // Verify in database\n      const dbProduct = await db.products.findById(createdProductId);\n      expect(dbProduct.price).toBe(39.99);\n    });\n\n    it('preserves unmodified fields', async () => {\n      const before = await db.products.findById(createdProductId);\n\n      await request(app)\n        .put(`/products/${createdProductId}`)\n        .send({ price: 49.99 })\n        .set('Authorization', `Bearer ${adminToken}`);\n\n      const after = await db.products.findById(createdProductId);\n      expect(after.name).toBe(before.name);\n      expect(after.category).toBe(before.category);\n    });\n  });\n\n  describe('DELETE - DELETE /products/:id', () => {\n    it('deletes product', async () => {\n      const response = await request(app)\n        .delete(`/products/${createdProductId}`)\n        .set('Authorization', `Bearer ${adminToken}`);\n\n      expect(response.status).toBe(204);\n\n      // Verify deletion\n      const dbProduct = await db.products.findById(createdProductId);\n      expect(dbProduct).toBeNull();\n    });\n\n    it('returns 404 for already deleted product', async () => {\n      const response = await request(app)\n        .delete(`/products/${createdProductId}`)\n        .set('Authorization', `Bearer ${adminToken}`);\n\n      expect(response.status).toBe(404);\n    });\n  });\n});\n```\n\n### Pattern 3: Authentication Flow Testing\n\nComplete testing of authentication and authorization.\n\n```typescript\n/**\n * Pattern: Authentication and Authorization Testing\n * Tests login, token validation, and permission enforcement\n */\ndescribe('Authentication', () => {\n  describe('Login Flow', () => {\n    it('returns JWT token for valid credentials', async () => {\n      // Create user with known password\n      const password = 'SecurePass123!';\n      const user = await userFactory.create({\n        email: 'auth@test.com',\n        passwordHash: await hashPassword(password),\n      });\n\n      const response = await request(app)\n        .post('/auth/login')\n        .send({ email: 'auth@test.com', password });\n\n      expect(response.status).toBe(200);\n      expect(response.body).toMatchObject({\n        accessToken: expect.any(String),\n        refreshToken: expect.any(String),\n        expiresIn: expect.any(Number),\n      });\n\n      // Verify token is valid\n      const decoded = jwt.verify(response.body.accessToken, JWT_SECRET);\n      expect(decoded.userId).toBe(user.id);\n    });\n\n    it('returns 401 for invalid password', async () => {\n      await userFactory.create({ email: 'user@test.com' });\n\n      const response = await request(app)\n        .post('/auth/login')\n        .send({ email: 'user@test.com', password: 'wrong' });\n\n      expect(response.status).toBe(401);\n      expect(response.body.error.code).toBe('INVALID_CREDENTIALS');\n\n      // Should not reveal if email exists\n      expect(response.body.error.message).not.toContain('password');\n    });\n\n    it('rate limits after failed attempts', async () => {\n      const email = 'ratelimit@test.com';\n      await userFactory.create({ email });\n\n      // Make 5 failed attempts\n      for (let i = 0; i < 5; i++) {\n        await request(app)\n          .post('/auth/login')\n          .send({ email, password: 'wrong' });\n      }\n\n      // 6th attempt should be rate limited\n      const response = await request(app)\n        .post('/auth/login')\n        .send({ email, password: 'correct' });\n\n      expect(response.status).toBe(429);\n      expect(response.headers['retry-after']).toBeDefined();\n    });\n  });\n\n  describe('Protected Routes', () => {\n    let validToken: string;\n    let adminToken: string;\n\n    beforeAll(async () => {\n      const user = await userFactory.create({ role: 'user' });\n      const admin = await userFactory.create({ role: 'admin' });\n      validToken = generateToken(user);\n      adminToken = generateToken(admin);\n    });\n\n    it('allows access with valid token', async () => {\n      const response = await request(app)\n        .get('/api/profile')\n        .set('Authorization', `Bearer ${validToken}`);\n\n      expect(response.status).toBe(200);\n    });\n\n    it('rejects expired token', async () => {\n      const expiredToken = generateToken({ id: 'user-1' }, { expiresIn: '-1h' });\n\n      const response = await request(app)\n        .get('/api/profile')\n        .set('Authorization', `Bearer ${expiredToken}`);\n\n      expect(response.status).toBe(401);\n      expect(response.body.error.code).toBe('TOKEN_EXPIRED');\n    });\n\n    it('rejects malformed token', async () => {\n      const response = await request(app)\n        .get('/api/profile')\n        .set('Authorization', 'Bearer invalid.token.here');\n\n      expect(response.status).toBe(401);\n    });\n\n    it('enforces role-based access', async () => {\n      // Admin-only endpoint\n      const userResponse = await request(app)\n        .get('/api/admin/users')\n        .set('Authorization', `Bearer ${validToken}`);\n\n      expect(userResponse.status).toBe(403);\n\n      const adminResponse = await request(app)\n        .get('/api/admin/users')\n        .set('Authorization', `Bearer ${adminToken}`);\n\n      expect(adminResponse.status).toBe(200);\n    });\n  });\n});\n```\n\n### Pattern 4: Pagination and Filtering\n\nTesting list endpoints with pagination, sorting, and filtering.\n\n```typescript\n/**\n * Pattern: Pagination and Filtering Testing\n * Ensures list endpoints handle pagination correctly\n */\ndescribe('Products List API', () => {\n  beforeAll(async () => {\n    // Create 50 products for pagination testing\n    await productFactory.createMany(50, {\n      category: (i) => i < 25 ? 'electronics' : 'clothing',\n      price: (i) => 10 + i,\n      createdAt: (i) => new Date(Date.now() - i * 86400000),\n    });\n  });\n\n  describe('Pagination', () => {\n    it('returns default page size', async () => {\n      const response = await request(app).get('/products');\n\n      expect(response.status).toBe(200);\n      expect(response.body.items).toHaveLength(20); // Default page size\n      expect(response.body.meta).toMatchObject({\n        page: 1,\n        pageSize: 20,\n        totalItems: 50,\n        totalPages: 3,\n      });\n    });\n\n    it('returns requested page', async () => {\n      const response = await request(app)\n        .get('/products')\n        .query({ page: 2, pageSize: 10 });\n\n      expect(response.body.items).toHaveLength(10);\n      expect(response.body.meta.page).toBe(2);\n    });\n\n    it('returns empty array for page beyond data', async () => {\n      const response = await request(app)\n        .get('/products')\n        .query({ page: 100 });\n\n      expect(response.status).toBe(200);\n      expect(response.body.items).toHaveLength(0);\n    });\n\n    it('includes pagination links', async () => {\n      const response = await request(app)\n        .get('/products')\n        .query({ page: 2 });\n\n      expect(response.body.links).toMatchObject({\n        first: expect.stringContaining('page=1'),\n        prev: expect.stringContaining('page=1'),\n        next: expect.stringContaining('page=3'),\n        last: expect.stringContaining('page=3'),\n      });\n    });\n  });\n\n  describe('Filtering', () => {\n    it('filters by category', async () => {\n      const response = await request(app)\n        .get('/products')\n        .query({ category: 'electronics' });\n\n      expect(response.body.items).toHaveLength(20);\n      expect(response.body.items.every(p => p.category === 'electronics')).toBe(true);\n    });\n\n    it('filters by price range', async () => {\n      const response = await request(app)\n        .get('/products')\n        .query({ minPrice: 30, maxPrice: 40 });\n\n      expect(response.body.items.every(p => p.price >= 30 && p.price <= 40)).toBe(true);\n    });\n\n    it('combines multiple filters', async () => {\n      const response = await request(app)\n        .get('/products')\n        .query({\n          category: 'electronics',\n          minPrice: 20,\n          maxPrice: 30,\n        });\n\n      expect(response.body.items.every(p =>\n        p.category === 'electronics' &&\n        p.price >= 20 &&\n        p.price <= 30\n      )).toBe(true);\n    });\n  });\n\n  describe('Sorting', () => {\n    it('sorts by price ascending', async () => {\n      const response = await request(app)\n        .get('/products')\n        .query({ sort: 'price', order: 'asc' });\n\n      const prices = response.body.items.map(p => p.price);\n      expect(prices).toEqual([...prices].sort((a, b) => a - b));\n    });\n\n    it('sorts by price descending', async () => {\n      const response = await request(app)\n        .get('/products')\n        .query({ sort: 'price', order: 'desc' });\n\n      const prices = response.body.items.map(p => p.price);\n      expect(prices).toEqual([...prices].sort((a, b) => b - a));\n    });\n\n    it('sorts by creation date by default', async () => {\n      const response = await request(app).get('/products');\n\n      const dates = response.body.items.map(p => new Date(p.createdAt).getTime());\n      expect(dates).toEqual([...dates].sort((a, b) => b - a)); // Newest first\n    });\n  });\n});\n```\n\n## Event Testing Patterns\n\n### Pattern 5: Event Publishing Verification\n\nTesting that actions correctly publish events.\n\n```typescript\n/**\n * Pattern: Event Publishing Verification\n * Ensures actions publish correct events to message broker\n */\ndescribe('Order Events', () => {\n  let eventCapture: EventCapture;\n\n  beforeAll(async () => {\n    eventCapture = await kafka.createCapture(['orders.*']);\n  });\n\n  afterAll(async () => {\n    await eventCapture.close();\n  });\n\n  beforeEach(() => {\n    eventCapture.clear();\n  });\n\n  describe('Order Creation Events', () => {\n    it('publishes OrderCreated event when order is created', async () => {\n      // Act\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({\n          items: [{ productId: 'prod-1', quantity: 2 }],\n        });\n\n      // Wait for event\n      const event = await eventCapture.waitForEvent({\n        topic: 'orders.created',\n        timeout: 5000,\n        filter: (e) => e.payload.orderId === response.body.id,\n      });\n\n      // Assert event structure\n      expect(event).toMatchObject({\n        topic: 'orders.created',\n        payload: {\n          orderId: response.body.id,\n          userId: expect.any(String),\n          items: expect.arrayContaining([\n            expect.objectContaining({\n              productId: 'prod-1',\n              quantity: 2,\n            }),\n          ]),\n          timestamp: expect.any(String),\n        },\n        metadata: {\n          correlationId: expect.any(String),\n          version: '1.0',\n        },\n      });\n    });\n\n    it('includes all required fields in event', async () => {\n      await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      const event = await eventCapture.waitForEvent({\n        topic: 'orders.created',\n        timeout: 5000,\n      });\n\n      // Verify against event schema\n      const schema = await loadEventSchema('orders.created');\n      const validation = schema.validate(event.payload);\n      expect(validation.valid).toBe(true);\n    });\n  });\n\n  describe('Order Status Events', () => {\n    let orderId: string;\n\n    beforeEach(async () => {\n      const order = await orderFactory.create({ status: 'pending' });\n      orderId = order.id;\n    });\n\n    it('publishes OrderShipped event on shipment', async () => {\n      await request(app)\n        .post(`/orders/${orderId}/ship`)\n        .set('Authorization', `Bearer ${adminToken}`)\n        .send({ trackingNumber: 'TRACK123' });\n\n      const event = await eventCapture.waitForEvent({\n        topic: 'orders.shipped',\n        timeout: 5000,\n      });\n\n      expect(event.payload).toMatchObject({\n        orderId,\n        trackingNumber: 'TRACK123',\n        shippedAt: expect.any(String),\n      });\n    });\n\n    it('does not publish event if action fails', async () => {\n      // Try to ship already shipped order\n      await db.orders.update(orderId, { status: 'shipped' });\n\n      await request(app)\n        .post(`/orders/${orderId}/ship`)\n        .set('Authorization', `Bearer ${adminToken}`)\n        .send({ trackingNumber: 'TRACK123' });\n\n      // Wait briefly then verify no event\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      const events = eventCapture.getEvents('orders.shipped');\n      expect(events.filter(e => e.payload.orderId === orderId)).toHaveLength(0);\n    });\n  });\n});\n```\n\n### Pattern 6: Event Consumption Testing\n\nTesting that services correctly process incoming events.\n\n```typescript\n/**\n * Pattern: Event Consumption Testing\n * Verifies services correctly handle incoming events\n */\ndescribe('Notification Service - Event Handling', () => {\n  describe('OrderCreated Event', () => {\n    it('sends confirmation email on order creation', async () => {\n      // Arrange\n      const user = await userFactory.create({ email: 'notify@test.com' });\n      const order = await orderFactory.create({ userId: user.id });\n\n      // Act - Publish event\n      await kafka.publish('orders.created', {\n        orderId: order.id,\n        userId: user.id,\n        items: order.items,\n        total: order.total,\n        timestamp: new Date().toISOString(),\n      });\n\n      // Wait for processing\n      await waitForCondition(async () => {\n        const notifications = await db.notifications.findByUserId(user.id);\n        return notifications.length > 0;\n      }, 5000);\n\n      // Assert - Check notification created\n      const notifications = await db.notifications.findByUserId(user.id);\n      expect(notifications).toContainEqual(\n        expect.objectContaining({\n          type: 'ORDER_CONFIRMATION',\n          channel: 'email',\n          orderId: order.id,\n        })\n      );\n\n      // Assert - Check email sent (via mock mail service)\n      const sentEmails = await mockMailService.getSentEmails();\n      expect(sentEmails).toContainEqual(\n        expect.objectContaining({\n          to: 'notify@test.com',\n          subject: expect.stringContaining('Order Confirmation'),\n        })\n      );\n    });\n\n    it('handles duplicate events idempotently', async () => {\n      const user = await userFactory.create();\n      const order = await orderFactory.create({ userId: user.id });\n\n      const event = {\n        eventId: 'evt-unique-123',\n        orderId: order.id,\n        userId: user.id,\n        items: order.items,\n        timestamp: new Date().toISOString(),\n      };\n\n      // Publish same event twice\n      await kafka.publish('orders.created', event);\n      await kafka.publish('orders.created', event);\n\n      // Wait for processing\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      // Should only create one notification\n      const notifications = await db.notifications.findByUserId(user.id);\n      const orderNotifications = notifications.filter(\n        n => n.orderId === order.id && n.type === 'ORDER_CONFIRMATION'\n      );\n      expect(orderNotifications).toHaveLength(1);\n    });\n\n    it('handles malformed events gracefully', async () => {\n      // Publish invalid event\n      await kafka.publish('orders.created', {\n        // Missing required fields\n        orderId: 'incomplete',\n      });\n\n      // Wait briefly\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      // Check event was sent to dead letter queue\n      const dlqEvents = await kafka.getEvents('orders.created.dlq');\n      expect(dlqEvents).toContainEqual(\n        expect.objectContaining({\n          originalEvent: expect.objectContaining({ orderId: 'incomplete' }),\n          error: expect.stringContaining('validation'),\n        })\n      );\n    });\n  });\n});\n```\n\n### Pattern 7: Event Ordering and Sequencing\n\nTesting that events are processed in correct order.\n\n```typescript\n/**\n * Pattern: Event Ordering Verification\n * Ensures event sequences are handled correctly\n */\ndescribe('Order State Machine Events', () => {\n  it('processes order lifecycle events in sequence', async () => {\n    const orderId = 'order-lifecycle-test';\n\n    // Publish events in order with delays\n    const events = [\n      { topic: 'orders.created', payload: { orderId, status: 'pending' } },\n      { topic: 'orders.paid', payload: { orderId, paymentId: 'pay-1' } },\n      { topic: 'orders.shipped', payload: { orderId, trackingNumber: 'TRK-1' } },\n      { topic: 'orders.delivered', payload: { orderId, deliveredAt: new Date() } },\n    ];\n\n    for (const event of events) {\n      await kafka.publish(event.topic, event.payload);\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n\n    // Wait for processing\n    await waitForCondition(async () => {\n      const order = await db.orders.findById(orderId);\n      return order?.status === 'delivered';\n    }, 10000);\n\n    // Verify final state\n    const order = await db.orders.findById(orderId);\n    expect(order.status).toBe('delivered');\n\n    // Verify state history\n    const history = await db.orderHistory.findByOrderId(orderId);\n    const statuses = history.map(h => h.status);\n    expect(statuses).toEqual(['pending', 'paid', 'shipped', 'delivered']);\n  });\n\n  it('rejects out-of-order events', async () => {\n    const orderId = 'order-ooo-test';\n\n    // Create order in pending state\n    await orderFactory.create({ id: orderId, status: 'pending' });\n\n    // Try to deliver without shipping first\n    await kafka.publish('orders.delivered', {\n      orderId,\n      deliveredAt: new Date(),\n    });\n\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Order should still be pending\n    const order = await db.orders.findById(orderId);\n    expect(order.status).toBe('pending');\n\n    // Check error logged\n    const errors = await db.eventErrors.findByOrderId(orderId);\n    expect(errors).toContainEqual(\n      expect.objectContaining({\n        event: 'orders.delivered',\n        error: expect.stringContaining('Invalid state transition'),\n      })\n    );\n  });\n});\n```\n\n## Database Integration Patterns\n\n### Pattern 8: Transaction Testing\n\nTesting database transactions and rollback behavior.\n\n```typescript\n/**\n * Pattern: Transaction Behavior Testing\n * Verifies transactions commit or rollback correctly\n */\ndescribe('Order Transaction Handling', () => {\n  it('commits transaction on successful order', async () => {\n    const initialInventory = await db.inventory.getQuantity('prod-1');\n\n    const response = await request(app)\n      .post('/orders')\n      .set('Authorization', `Bearer ${token}`)\n      .send({\n        items: [{ productId: 'prod-1', quantity: 5 }],\n      });\n\n    expect(response.status).toBe(201);\n\n    // Verify all changes committed\n    const order = await db.orders.findById(response.body.id);\n    expect(order).toBeDefined();\n\n    const newInventory = await db.inventory.getQuantity('prod-1');\n    expect(newInventory).toBe(initialInventory - 5);\n\n    const payment = await db.payments.findByOrderId(response.body.id);\n    expect(payment).toBeDefined();\n  });\n\n  it('rolls back transaction on payment failure', async () => {\n    const initialInventory = await db.inventory.getQuantity('prod-1');\n    const initialOrderCount = await db.orders.count();\n\n    // Mock payment to fail\n    mockPaymentService.mockFailure('INSUFFICIENT_FUNDS');\n\n    const response = await request(app)\n      .post('/orders')\n      .set('Authorization', `Bearer ${token}`)\n      .send({\n        items: [{ productId: 'prod-1', quantity: 5 }],\n      });\n\n    expect(response.status).toBe(402);\n\n    // Verify no changes persisted\n    const newInventory = await db.inventory.getQuantity('prod-1');\n    expect(newInventory).toBe(initialInventory);\n\n    const newOrderCount = await db.orders.count();\n    expect(newOrderCount).toBe(initialOrderCount);\n  });\n\n  it('handles concurrent modifications correctly', async () => {\n    // Only 10 items in stock\n    await db.inventory.setQuantity('limited-prod', 10);\n\n    // Attempt 3 orders of 5 items simultaneously\n    const orderPromises = [\n      request(app).post('/orders').set('Authorization', `Bearer ${token1}`).send({\n        items: [{ productId: 'limited-prod', quantity: 5 }],\n      }),\n      request(app).post('/orders').set('Authorization', `Bearer ${token2}`).send({\n        items: [{ productId: 'limited-prod', quantity: 5 }],\n      }),\n      request(app).post('/orders').set('Authorization', `Bearer ${token3}`).send({\n        items: [{ productId: 'limited-prod', quantity: 5 }],\n      }),\n    ];\n\n    const responses = await Promise.all(orderPromises);\n\n    // Exactly 2 should succeed, 1 should fail with out of stock\n    const successes = responses.filter(r => r.status === 201);\n    const failures = responses.filter(r => r.status === 409);\n\n    expect(successes).toHaveLength(2);\n    expect(failures).toHaveLength(1);\n\n    // Inventory should be 0\n    const finalInventory = await db.inventory.getQuantity('limited-prod');\n    expect(finalInventory).toBe(0);\n  });\n});\n```\n\n### Pattern 9: Constraint Validation\n\nTesting database constraints and data integrity.\n\n```typescript\n/**\n * Pattern: Database Constraint Testing\n * Verifies database constraints are enforced\n */\ndescribe('Data Integrity', () => {\n  describe('Unique Constraints', () => {\n    it('prevents duplicate email registration', async () => {\n      await userFactory.create({ email: 'unique@test.com' });\n\n      const response = await request(app)\n        .post('/users')\n        .send({\n          email: 'unique@test.com',\n          name: 'Duplicate User',\n        });\n\n      expect(response.status).toBe(409);\n      expect(response.body.error.code).toBe('EMAIL_EXISTS');\n    });\n\n    it('allows same email after soft delete', async () => {\n      const user = await userFactory.create({ email: 'reuse@test.com' });\n      await db.users.softDelete(user.id);\n\n      const response = await request(app)\n        .post('/users')\n        .send({\n          email: 'reuse@test.com',\n          name: 'New User',\n        });\n\n      expect(response.status).toBe(201);\n    });\n  });\n\n  describe('Foreign Key Constraints', () => {\n    it('prevents order with non-existent product', async () => {\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({\n          items: [{ productId: 'non-existent-product', quantity: 1 }],\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error.code).toBe('INVALID_PRODUCT');\n    });\n\n    it('cascades deletion appropriately', async () => {\n      const user = await userFactory.create();\n      const order = await orderFactory.create({ userId: user.id });\n\n      // Delete user\n      await request(app)\n        .delete(`/users/${user.id}`)\n        .set('Authorization', `Bearer ${adminToken}`);\n\n      // Order should be archived, not deleted\n      const archivedOrder = await db.orders.findById(order.id);\n      expect(archivedOrder.status).toBe('archived');\n      expect(archivedOrder.userId).toBeNull();\n    });\n  });\n\n  describe('Check Constraints', () => {\n    it('prevents negative prices', async () => {\n      const response = await request(app)\n        .post('/products')\n        .set('Authorization', `Bearer ${adminToken}`)\n        .send({\n          name: 'Invalid Product',\n          price: -10,\n        });\n\n      expect(response.status).toBe(400);\n    });\n\n    it('enforces order status transitions', async () => {\n      const order = await orderFactory.create({ status: 'delivered' });\n\n      const response = await request(app)\n        .put(`/orders/${order.id}/status`)\n        .set('Authorization', `Bearer ${adminToken}`)\n        .send({ status: 'pending' });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error.code).toBe('INVALID_STATUS_TRANSITION');\n    });\n  });\n});\n```\n\n## External Service Integration Patterns\n\n### Pattern 10: Mock Service Switching\n\nTesting with different mock responses for various scenarios.\n\n```typescript\n/**\n * Pattern: Configurable Mock Services\n * Allows switching mock behavior per test\n */\ndescribe('Payment Processing', () => {\n  let paymentMock: PaymentServiceMock;\n\n  beforeAll(() => {\n    paymentMock = new PaymentServiceMock();\n    paymentMock.start(3030);\n  });\n\n  afterAll(() => {\n    paymentMock.stop();\n  });\n\n  beforeEach(() => {\n    paymentMock.reset();\n  });\n\n  describe('Successful Payments', () => {\n    beforeEach(() => {\n      paymentMock.configure({\n        '/charge': {\n          status: 200,\n          body: {\n            transactionId: 'txn-success-123',\n            status: 'completed',\n            amount: 100,\n          },\n        },\n      });\n    });\n\n    it('processes payment and updates order', async () => {\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      expect(response.status).toBe(201);\n      expect(response.body.paymentStatus).toBe('completed');\n    });\n  });\n\n  describe('Payment Failures', () => {\n    it('handles insufficient funds', async () => {\n      paymentMock.configure({\n        '/charge': {\n          status: 402,\n          body: { error: 'INSUFFICIENT_FUNDS' },\n        },\n      });\n\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      expect(response.status).toBe(402);\n      expect(response.body.error.code).toBe('PAYMENT_FAILED');\n    });\n\n    it('handles card declined', async () => {\n      paymentMock.configure({\n        '/charge': {\n          status: 400,\n          body: { error: 'CARD_DECLINED' },\n        },\n      });\n\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error.code).toBe('CARD_DECLINED');\n    });\n  });\n\n  describe('Payment Service Outages', () => {\n    it('handles timeout with retry', async () => {\n      let callCount = 0;\n      paymentMock.configure({\n        '/charge': {\n          handler: async (req, res) => {\n            callCount++;\n            if (callCount < 3) {\n              // Timeout on first 2 calls\n              await new Promise(resolve => setTimeout(resolve, 5000));\n            }\n            res.json({ transactionId: 'txn-retry-123', status: 'completed' });\n          },\n        },\n      });\n\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      expect(response.status).toBe(201);\n      expect(callCount).toBe(3); // Retried twice\n    });\n\n    it('fails gracefully after retries exhausted', async () => {\n      paymentMock.configure({\n        '/charge': {\n          latency: 10000, // Always timeout\n        },\n      });\n\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      expect(response.status).toBe(503);\n      expect(response.body.error.code).toBe('SERVICE_UNAVAILABLE');\n    });\n  });\n});\n```\n\n### Pattern 11: Webhook Testing\n\nTesting incoming webhooks and callbacks.\n\n```typescript\n/**\n * Pattern: Webhook Integration Testing\n * Tests receiving and processing webhooks from external services\n */\ndescribe('Payment Webhooks', () => {\n  const WEBHOOK_SECRET = 'whsec_test123';\n\n  function signPayload(payload: object): string {\n    const timestamp = Math.floor(Date.now() / 1000);\n    const payloadString = JSON.stringify(payload);\n    const signature = crypto\n      .createHmac('sha256', WEBHOOK_SECRET)\n      .update(`${timestamp}.${payloadString}`)\n      .digest('hex');\n    return `t=${timestamp},v1=${signature}`;\n  }\n\n  describe('Payment Completed Webhook', () => {\n    it('updates order on successful payment', async () => {\n      const order = await orderFactory.create({\n        status: 'pending_payment',\n        paymentIntentId: 'pi_test123',\n      });\n\n      const payload = {\n        type: 'payment_intent.succeeded',\n        data: {\n          object: {\n            id: 'pi_test123',\n            status: 'succeeded',\n            amount: 10000,\n          },\n        },\n      };\n\n      const response = await request(app)\n        .post('/webhooks/stripe')\n        .set('Stripe-Signature', signPayload(payload))\n        .send(payload);\n\n      expect(response.status).toBe(200);\n\n      // Verify order updated\n      const updatedOrder = await db.orders.findById(order.id);\n      expect(updatedOrder.status).toBe('paid');\n      expect(updatedOrder.paidAt).toBeDefined();\n    });\n\n    it('rejects webhook with invalid signature', async () => {\n      const payload = {\n        type: 'payment_intent.succeeded',\n        data: { object: { id: 'pi_test123' } },\n      };\n\n      const response = await request(app)\n        .post('/webhooks/stripe')\n        .set('Stripe-Signature', 'invalid-signature')\n        .send(payload);\n\n      expect(response.status).toBe(401);\n    });\n\n    it('rejects replay attacks', async () => {\n      const payload = {\n        type: 'payment_intent.succeeded',\n        data: { object: { id: 'pi_test123' } },\n      };\n\n      // Use old timestamp\n      const oldTimestamp = Math.floor(Date.now() / 1000) - 400; // 6+ minutes old\n      const payloadString = JSON.stringify(payload);\n      const signature = crypto\n        .createHmac('sha256', WEBHOOK_SECRET)\n        .update(`${oldTimestamp}.${payloadString}`)\n        .digest('hex');\n\n      const response = await request(app)\n        .post('/webhooks/stripe')\n        .set('Stripe-Signature', `t=${oldTimestamp},v1=${signature}`)\n        .send(payload);\n\n      expect(response.status).toBe(401);\n      expect(response.body.error).toContain('expired');\n    });\n\n    it('handles duplicate webhooks idempotently', async () => {\n      const order = await orderFactory.create({\n        status: 'pending_payment',\n        paymentIntentId: 'pi_duplicate',\n      });\n\n      const payload = {\n        id: 'evt_unique_123',\n        type: 'payment_intent.succeeded',\n        data: { object: { id: 'pi_duplicate' } },\n      };\n\n      // Send same webhook twice\n      await request(app)\n        .post('/webhooks/stripe')\n        .set('Stripe-Signature', signPayload(payload))\n        .send(payload);\n\n      const response = await request(app)\n        .post('/webhooks/stripe')\n        .set('Stripe-Signature', signPayload(payload))\n        .send(payload);\n\n      expect(response.status).toBe(200);\n\n      // Verify processed only once\n      const logs = await db.webhookLogs.findByEventId('evt_unique_123');\n      expect(logs).toHaveLength(1);\n    });\n  });\n\n  describe('Payment Failed Webhook', () => {\n    it('notifies customer on payment failure', async () => {\n      const user = await userFactory.create({ email: 'customer@test.com' });\n      const order = await orderFactory.create({\n        userId: user.id,\n        status: 'pending_payment',\n        paymentIntentId: 'pi_failed',\n      });\n\n      const payload = {\n        type: 'payment_intent.payment_failed',\n        data: {\n          object: {\n            id: 'pi_failed',\n            last_payment_error: {\n              code: 'card_declined',\n              message: 'Your card was declined',\n            },\n          },\n        },\n      };\n\n      await request(app)\n        .post('/webhooks/stripe')\n        .set('Stripe-Signature', signPayload(payload))\n        .send(payload);\n\n      // Verify notification sent\n      const notifications = await db.notifications.findByUserId(user.id);\n      expect(notifications).toContainEqual(\n        expect.objectContaining({\n          type: 'PAYMENT_FAILED',\n          channel: 'email',\n        })\n      );\n    });\n  });\n});\n```\n\n## Resilience Testing Patterns\n\n### Pattern 12: Timeout and Retry Behavior\n\nTesting system behavior under degraded conditions.\n\n```typescript\n/**\n * Pattern: Resilience and Timeout Testing\n * Verifies system handles slow/failing dependencies correctly\n */\ndescribe('Resilience', () => {\n  describe('Timeout Handling', () => {\n    it('times out slow external service calls', async () => {\n      mockUserService.setLatency(10000); // 10 second delay\n\n      const startTime = Date.now();\n      const response = await request(app)\n        .get('/orders/with-user-details')\n        .set('Authorization', `Bearer ${token}`);\n\n      const duration = Date.now() - startTime;\n\n      expect(response.status).toBe(503);\n      expect(duration).toBeLessThan(5000); // Should timeout before 5s\n    });\n\n    it('uses cached data when service times out', async () => {\n      // Prime cache\n      mockUserService.setLatency(0);\n      await request(app)\n        .get('/orders/with-user-details')\n        .set('Authorization', `Bearer ${token}`);\n\n      // Make service slow\n      mockUserService.setLatency(10000);\n\n      const response = await request(app)\n        .get('/orders/with-user-details')\n        .set('Authorization', `Bearer ${token}`);\n\n      expect(response.status).toBe(200);\n      expect(response.headers['x-data-source']).toBe('cache');\n    });\n  });\n\n  describe('Circuit Breaker', () => {\n    it('opens circuit after consecutive failures', async () => {\n      mockPaymentService.configure({ '/charge': { status: 500 } });\n\n      // Make requests until circuit opens\n      for (let i = 0; i < 5; i++) {\n        await request(app)\n          .post('/orders')\n          .set('Authorization', `Bearer ${token}`)\n          .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n      }\n\n      // Next request should fail fast\n      const startTime = Date.now();\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      const duration = Date.now() - startTime;\n\n      expect(response.status).toBe(503);\n      expect(response.body.error.code).toBe('CIRCUIT_OPEN');\n      expect(duration).toBeLessThan(100); // Should fail fast\n    });\n\n    it('half-opens circuit after cooldown', async () => {\n      mockPaymentService.configure({ '/charge': { status: 500 } });\n\n      // Open circuit\n      for (let i = 0; i < 5; i++) {\n        await request(app)\n          .post('/orders')\n          .set('Authorization', `Bearer ${token}`)\n          .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n      }\n\n      // Wait for cooldown\n      await new Promise(resolve => setTimeout(resolve, 5000));\n\n      // Make service healthy\n      mockPaymentService.configure({\n        '/charge': { status: 200, body: { transactionId: 'txn-1' } },\n      });\n\n      // Should attempt request (half-open)\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      expect(response.status).toBe(201);\n    });\n  });\n\n  describe('Retry Logic', () => {\n    it('retries on transient failures', async () => {\n      let attempts = 0;\n      mockPaymentService.configure({\n        '/charge': {\n          handler: (req, res) => {\n            attempts++;\n            if (attempts < 3) {\n              res.status(503).json({ error: 'Service busy' });\n            } else {\n              res.json({ transactionId: 'txn-retry' });\n            }\n          },\n        },\n      });\n\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      expect(response.status).toBe(201);\n      expect(attempts).toBe(3);\n    });\n\n    it('does not retry on client errors', async () => {\n      let attempts = 0;\n      mockPaymentService.configure({\n        '/charge': {\n          handler: (req, res) => {\n            attempts++;\n            res.status(400).json({ error: 'Invalid card' });\n          },\n        },\n      });\n\n      const response = await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      expect(response.status).toBe(400);\n      expect(attempts).toBe(1); // No retries\n    });\n\n    it('uses exponential backoff', async () => {\n      const callTimes: number[] = [];\n      mockPaymentService.configure({\n        '/charge': {\n          handler: (req, res) => {\n            callTimes.push(Date.now());\n            if (callTimes.length < 4) {\n              res.status(503).json({ error: 'Retry' });\n            } else {\n              res.json({ transactionId: 'txn-1' });\n            }\n          },\n        },\n      });\n\n      await request(app)\n        .post('/orders')\n        .set('Authorization', `Bearer ${token}`)\n        .send({ items: [{ productId: 'prod-1', quantity: 1 }] });\n\n      // Verify exponential delays\n      const delays = [];\n      for (let i = 1; i < callTimes.length; i++) {\n        delays.push(callTimes[i] - callTimes[i - 1]);\n      }\n\n      // Each delay should be roughly double the previous\n      expect(delays[1]).toBeGreaterThan(delays[0] * 1.5);\n      expect(delays[2]).toBeGreaterThan(delays[1] * 1.5);\n    });\n  });\n});\n```\n\n## End-to-End Workflow Patterns\n\n### Pattern 13: Multi-Step Workflow Testing\n\nTesting complete user journeys across services.\n\n```typescript\n/**\n * Pattern: Complete Workflow Testing\n * Tests entire user journeys spanning multiple services\n */\ndescribe('E-Commerce Order Workflow', () => {\n  let customer: User;\n  let customerToken: string;\n  let orderId: string;\n\n  beforeAll(async () => {\n    customer = await userFactory.create({\n      email: 'e2e@test.com',\n      role: 'customer',\n    });\n    customerToken = generateToken(customer);\n  });\n\n  describe('Complete Purchase Flow', () => {\n    it('Step 1: Add items to cart', async () => {\n      const response = await request(app)\n        .post('/cart/items')\n        .set('Authorization', `Bearer ${customerToken}`)\n        .send({\n          productId: 'prod-laptop',\n          quantity: 1,\n        });\n\n      expect(response.status).toBe(200);\n      expect(response.body.items).toHaveLength(1);\n      expect(response.body.items[0].productId).toBe('prod-laptop');\n    });\n\n    it('Step 2: Apply discount code', async () => {\n      const response = await request(app)\n        .post('/cart/discount')\n        .set('Authorization', `Bearer ${customerToken}`)\n        .send({\n          code: 'SAVE10',\n        });\n\n      expect(response.status).toBe(200);\n      expect(response.body.discount).toBe(10);\n      expect(response.body.discountedTotal).toBeLessThan(response.body.subtotal);\n    });\n\n    it('Step 3: Set shipping address', async () => {\n      const response = await request(app)\n        .post('/cart/shipping')\n        .set('Authorization', `Bearer ${customerToken}`)\n        .send({\n          address: {\n            street: '123 Test St',\n            city: 'Test City',\n            state: 'TS',\n            zip: '12345',\n            country: 'US',\n          },\n        });\n\n      expect(response.status).toBe(200);\n      expect(response.body.shippingCost).toBeGreaterThan(0);\n    });\n\n    it('Step 4: Create order from cart', async () => {\n      const response = await request(app)\n        .post('/orders/from-cart')\n        .set('Authorization', `Bearer ${customerToken}`)\n        .send({\n          paymentMethodId: 'pm_test_visa',\n        });\n\n      expect(response.status).toBe(201);\n      expect(response.body.status).toBe('pending_payment');\n      orderId = response.body.id;\n\n      // Cart should be cleared\n      const cartResponse = await request(app)\n        .get('/cart')\n        .set('Authorization', `Bearer ${customerToken}`);\n      expect(cartResponse.body.items).toHaveLength(0);\n    });\n\n    it('Step 5: Process payment (via webhook)', async () => {\n      // Simulate Stripe webhook\n      await request(app)\n        .post('/webhooks/stripe')\n        .set('Stripe-Signature', signPayload({\n          type: 'payment_intent.succeeded',\n          data: { object: { id: `pi_${orderId}` } },\n        }))\n        .send({\n          type: 'payment_intent.succeeded',\n          data: { object: { id: `pi_${orderId}` } },\n        });\n\n      // Verify order status\n      const orderResponse = await request(app)\n        .get(`/orders/${orderId}`)\n        .set('Authorization', `Bearer ${customerToken}`);\n\n      expect(orderResponse.body.status).toBe('paid');\n    });\n\n    it('Step 6: Verify confirmation email sent', async () => {\n      await waitForCondition(async () => {\n        const emails = await mockMailService.getSentEmails();\n        return emails.some(e => e.to === 'e2e@test.com');\n      }, 5000);\n\n      const emails = await mockMailService.getSentEmails();\n      const confirmationEmail = emails.find(e =>\n        e.to === 'e2e@test.com' &&\n        e.subject.includes('Order Confirmation')\n      );\n\n      expect(confirmationEmail).toBeDefined();\n      expect(confirmationEmail.body).toContain(orderId);\n    });\n\n    it('Step 7: Ship order', async () => {\n      const response = await request(app)\n        .post(`/orders/${orderId}/ship`)\n        .set('Authorization', `Bearer ${adminToken}`)\n        .send({\n          carrier: 'UPS',\n          trackingNumber: 'UPS123456789',\n        });\n\n      expect(response.status).toBe(200);\n      expect(response.body.status).toBe('shipped');\n    });\n\n    it('Step 8: Verify shipping notification', async () => {\n      await waitForCondition(async () => {\n        const emails = await mockMailService.getSentEmails();\n        return emails.some(e =>\n          e.to === 'e2e@test.com' &&\n          e.subject.includes('Shipped')\n        );\n      }, 5000);\n\n      const emails = await mockMailService.getSentEmails();\n      const shippingEmail = emails.find(e =>\n        e.to === 'e2e@test.com' &&\n        e.subject.includes('Shipped')\n      );\n\n      expect(shippingEmail).toBeDefined();\n      expect(shippingEmail.body).toContain('UPS123456789');\n    });\n\n    it('Step 9: Mark as delivered', async () => {\n      const response = await request(app)\n        .post(`/orders/${orderId}/deliver`)\n        .set('Authorization', `Bearer ${adminToken}`);\n\n      expect(response.status).toBe(200);\n      expect(response.body.status).toBe('delivered');\n    });\n\n    it('Step 10: Customer leaves review', async () => {\n      const response = await request(app)\n        .post(`/orders/${orderId}/review`)\n        .set('Authorization', `Bearer ${customerToken}`)\n        .send({\n          rating: 5,\n          comment: 'Great product, fast shipping!',\n        });\n\n      expect(response.status).toBe(201);\n\n      // Verify review appears on product\n      const productResponse = await request(app)\n        .get('/products/prod-laptop/reviews');\n\n      expect(productResponse.body.reviews).toContainEqual(\n        expect.objectContaining({\n          rating: 5,\n          comment: 'Great product, fast shipping!',\n          verified: true,\n        })\n      );\n    });\n  });\n});\n```\n\n## Utility Functions\n\n### Wait Helpers\n\n```typescript\n// test/utils/wait.ts\n\n/**\n * Wait for a condition to become true\n */\nexport async function waitForCondition(\n  condition: () => Promise<boolean>,\n  timeoutMs: number = 5000,\n  intervalMs: number = 100\n): Promise<void> {\n  const startTime = Date.now();\n\n  while (Date.now() - startTime < timeoutMs) {\n    if (await condition()) {\n      return;\n    }\n    await new Promise(resolve => setTimeout(resolve, intervalMs));\n  }\n\n  throw new Error(`Condition not met within ${timeoutMs}ms`);\n}\n\n/**\n * Wait for an event to be captured\n */\nexport async function waitForEvent<T>(\n  capture: EventCapture,\n  filter: (event: T) => boolean,\n  timeoutMs: number = 5000\n): Promise<T> {\n  return waitForCondition(async () => {\n    const events = capture.getEvents();\n    return events.some(filter);\n  }, timeoutMs).then(() => {\n    const events = capture.getEvents() as T[];\n    return events.find(filter)!;\n  });\n}\n\n/**\n * Wait for database record to match condition\n */\nexport async function waitForRecord<T>(\n  query: () => Promise<T | null>,\n  condition: (record: T) => boolean,\n  timeoutMs: number = 5000\n): Promise<T> {\n  return waitForCondition(async () => {\n    const record = await query();\n    return record !== null && condition(record);\n  }, timeoutMs).then(async () => {\n    return (await query())!;\n  });\n}\n```\n\n### Response Matchers\n\n```typescript\n// test/utils/matchers.ts\n\nexpect.extend({\n  toBeValidApiResponse(received) {\n    const hasStatus = typeof received.status === 'number';\n    const hasBody = typeof received.body === 'object';\n\n    if (hasStatus && hasBody) {\n      return {\n        message: () => 'Expected not to be a valid API response',\n        pass: true,\n      };\n    }\n\n    return {\n      message: () => `Expected valid API response with status and body`,\n      pass: false,\n    };\n  },\n\n  toHavePaginationMeta(received) {\n    const requiredFields = ['page', 'pageSize', 'totalItems', 'totalPages'];\n    const hasMeta = received.body?.meta;\n    const hasAllFields = requiredFields.every(\n      field => hasMeta && typeof hasMeta[field] === 'number'\n    );\n\n    if (hasAllFields) {\n      return {\n        message: () => 'Expected not to have pagination meta',\n        pass: true,\n      };\n    }\n\n    return {\n      message: () =>\n        `Expected response to have pagination meta with ${requiredFields.join(', ')}`,\n      pass: false,\n    };\n  },\n});\n```\n\n## See Also\n\n- `scenario-templates.md` - Test scenario templates\n- `test-environment-setup.md` - Environment configuration\n- `contract-testing.md` - Contract testing deep dive\n"
    }
  ],
  "tags": [
    "testing",
    "integration",
    "e2e",
    "api-testing",
    "core-workflow"
  ],
  "dependsOn": [
    "test-generation"
  ]
}