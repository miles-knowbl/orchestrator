{
  "id": "refactor",
  "name": "refactor",
  "version": "1.0.0",
  "description": "Improve existing code without changing its external behavior. Identifies code smells, applies proven refactoring patterns, and ensures safety through tests. Makes code more readable, maintainable, and performant while preserving functionality.",
  "phase": "REVIEW",
  "category": "core",
  "content": "# Refactor\n\nImprove code without changing behavior.\n\n## When to Use\n\n- **Before adding features** — Clean up code that will be modified\n- **After code review** — Address feedback about code quality\n- **Technical debt** — Pay down accumulated cruft\n- **Performance issues** — Optimize hot paths\n- **Comprehension problems** — Make code easier to understand\n- When you say: \"refactor this\", \"clean up\", \"improve this code\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `refactoring-catalog.md` | Named refactoring patterns |\n| `code-smells.md` | Identify what needs refactoring |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `refactoring-strategies.md` | When planning large refactors |\n| `legacy-code-patterns.md` | When working with legacy code |\n\n**Verification:** Ensure tests pass after refactoring to confirm behavior preserved.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Refactored code | `src/` | Always |\n| Updated tests | `tests/` | If behavior changed |\n| `REFACTOR.md` | Project root | For significant refactors |\n\n## Core Concept\n\nRefactor answers: **\"How do I make this code better without breaking it?\"**\n\nRefactoring is:\n- **Behavior-preserving** — External behavior stays the same\n- **Incremental** — Small steps, each leaving code working\n- **Test-supported** — Tests verify nothing broke\n- **Intentional** — Driven by specific improvements\n\nRefactoring is NOT:\n- Adding new features\n- Fixing bugs (that changes behavior)\n- Rewriting from scratch\n- Performance optimization alone (though it can enable it)\n\n## The Refactoring Process\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                  REFACTORING PROCESS                    │\n│                                                         │\n│  1. ENSURE TEST COVERAGE                                │\n│     └─→ Can't refactor safely without tests             │\n│                                                         │\n│  2. IDENTIFY CODE SMELLS                                │\n│     └─→ What specifically is wrong?                     │\n│                                                         │\n│  3. SELECT REFACTORING                                  │\n│     └─→ Which pattern addresses the smell?              │\n│                                                         │\n│  4. APPLY IN SMALL STEPS                                │\n│     └─→ One change at a time, tests passing             │\n│                                                         │\n│  5. TEST AFTER EACH STEP                                │\n│     └─→ Run tests, verify behavior unchanged            │\n│                                                         │\n│  6. COMMIT FREQUENTLY                                   │\n│     └─→ Small commits, easy to revert                   │\n│                                                         │\n│  7. REVIEW THE RESULT                                   │\n│     └─→ Is the code actually better?                    │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Step 1: Ensure Test Coverage\n\n**Never refactor without tests.**\n\nBefore refactoring, verify:\n\n```markdown\n## Pre-Refactoring Checklist\n\n- [ ] Unit tests exist for the code being changed\n- [ ] Tests cover the main behaviors\n- [ ] Tests cover important edge cases\n- [ ] All tests pass\n- [ ] You understand what the tests are checking\n```\n\nIf tests don't exist:\n\n```markdown\n## Adding Tests Before Refactoring\n\n1. Write characterization tests (tests that capture current behavior)\n2. Focus on inputs and outputs, not implementation\n3. Cover happy path and error cases\n4. Get tests passing before any refactoring\n```\n\n```typescript\n// Characterization test - captures current behavior\ndescribe('OrderCalculator', () => {\n  it('calculates total for current production data', () => {\n    // Use actual examples from production\n    const order = {\n      items: [\n        { price: 1999, quantity: 2 },\n        { price: 499, quantity: 1 },\n      ],\n      discount: 0.1,\n    };\n\n    // Capture current output (run once to get value)\n    expect(calculator.getTotal(order)).toBe(4047);\n  });\n});\n```\n\n## Step 2: Identify Code Smells\n\nCode smells are symptoms that suggest refactoring opportunities.\n\n### Bloaters (Too Big)\n\n| Smell | Symptom | Refactoring |\n|-------|---------|-------------|\n| **Long Method** | Method >20 lines, hard to understand | Extract Method |\n| **Large Class** | Class does too many things | Extract Class |\n| **Long Parameter List** | >3 parameters | Parameter Object |\n| **Primitive Obsession** | Using primitives for domain concepts | Value Objects |\n| **Data Clumps** | Same fields appear together repeatedly | Extract Class |\n\n### Object-Orientation Abusers\n\n| Smell | Symptom | Refactoring |\n|-------|---------|-------------|\n| **Switch Statements** | Repeated switches on type | Replace with Polymorphism |\n| **Parallel Inheritance** | Subclass in one hierarchy requires subclass in another | Move Method, Collapse Hierarchy |\n| **Refused Bequest** | Subclass doesn't use inherited methods | Replace Inheritance with Delegation |\n| **Alternative Classes** | Different classes with similar interfaces | Extract Superclass |\n\n### Change Preventers\n\n| Smell | Symptom | Refactoring |\n|-------|---------|-------------|\n| **Divergent Change** | One class changed for multiple reasons | Extract Class |\n| **Shotgun Surgery** | One change requires edits to many classes | Move Method, Inline Class |\n| **Feature Envy** | Method uses another class's data more than its own | Move Method |\n\n### Dispensables (Remove)\n\n| Smell | Symptom | Refactoring |\n|-------|---------|-------------|\n| **Comments** | Code needs explanation to understand | Extract Method, Rename |\n| **Duplicate Code** | Same code in multiple places | Extract Method, Pull Up |\n| **Dead Code** | Unreachable or unused code | Delete it |\n| **Speculative Generality** | Unused abstractions \"just in case\" | Collapse Hierarchy, Inline |\n| **Lazy Class** | Class that doesn't do enough | Inline Class |\n\n### Couplers (Too Connected)\n\n| Smell | Symptom | Refactoring |\n|-------|---------|-------------|\n| **Feature Envy** | Method uses another class more than its own | Move Method |\n| **Inappropriate Intimacy** | Classes know too much about each other | Move Method, Extract Class |\n| **Message Chains** | a.b().c().d().e() | Hide Delegate |\n| **Middle Man** | Class just delegates everything | Remove Middle Man |\n\n→ See `references/code-smells.md`\n\n## Step 3: Select Refactoring\n\nMatch the smell to the refactoring:\n\n```\n┌─────────────────────────────────────────────────────────┐\n│             SMELL → REFACTORING DECISION                │\n│                                                         │\n│  Long Method?                                           │\n│  └─→ Extract Method                                     │\n│                                                         │\n│  Duplicate Code?                                        │\n│  ├─→ Same class: Extract Method                         │\n│  ├─→ Sibling classes: Pull Up Method                    │\n│  └─→ Unrelated classes: Extract Class                   │\n│                                                         │\n│  Long Parameter List?                                   │\n│  ├─→ Related params: Introduce Parameter Object         │\n│  └─→ Can compute: Replace Parameter with Method Call    │\n│                                                         │\n│  Switch on Type?                                        │\n│  └─→ Replace Conditional with Polymorphism              │\n│                                                         │\n│  Feature Envy?                                          │\n│  └─→ Move Method to the class it envies                 │\n│                                                         │\n│  Data Clump?                                            │\n│  └─→ Extract Class for the clumped data                 │\n│                                                         │\n│  Primitive Obsession?                                   │\n│  └─→ Replace Primitive with Value Object                │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Step 4: Apply in Small Steps\n\n**The key to safe refactoring: small, reversible steps.**\n\n### Extract Method Example\n\nBefore:\n```typescript\nfunction printOrder(order: Order): void {\n  console.log('Order Details');\n  console.log('=============');\n\n  // Print items\n  let total = 0;\n  for (const item of order.items) {\n    console.log(`${item.name}: $${item.price}`);\n    total += item.price * item.quantity;\n  }\n\n  // Apply discount\n  if (order.discount > 0) {\n    const discountAmount = total * order.discount;\n    total -= discountAmount;\n    console.log(`Discount: -$${discountAmount}`);\n  }\n\n  // Print total\n  console.log('=============');\n  console.log(`Total: $${total}`);\n}\n```\n\nStep 1 - Extract `printItems`:\n```typescript\nfunction printOrder(order: Order): void {\n  console.log('Order Details');\n  console.log('=============');\n\n  const subtotal = printItems(order.items);  // ← Extracted\n\n  // Apply discount\n  let total = subtotal;\n  if (order.discount > 0) {\n    const discountAmount = total * order.discount;\n    total -= discountAmount;\n    console.log(`Discount: -$${discountAmount}`);\n  }\n\n  console.log('=============');\n  console.log(`Total: $${total}`);\n}\n\nfunction printItems(items: OrderItem[]): number {\n  let total = 0;\n  for (const item of items) {\n    console.log(`${item.name}: $${item.price}`);\n    total += item.price * item.quantity;\n  }\n  return total;\n}\n```\n\n**Run tests. ✓**\n\nStep 2 - Extract `applyDiscount`:\n```typescript\nfunction printOrder(order: Order): void {\n  console.log('Order Details');\n  console.log('=============');\n\n  const subtotal = printItems(order.items);\n  const total = applyDiscount(subtotal, order.discount);  // ← Extracted\n\n  console.log('=============');\n  console.log(`Total: $${total}`);\n}\n\nfunction applyDiscount(subtotal: number, discount: number): number {\n  if (discount > 0) {\n    const discountAmount = subtotal * discount;\n    console.log(`Discount: -$${discountAmount}`);\n    return subtotal - discountAmount;\n  }\n  return subtotal;\n}\n```\n\n**Run tests. ✓**\n\nStep 3 - Extract `printHeader` and `printTotal`:\n```typescript\nfunction printOrder(order: Order): void {\n  printHeader();\n  const subtotal = printItems(order.items);\n  const total = applyDiscount(subtotal, order.discount);\n  printTotal(total);\n}\n\nfunction printHeader(): void {\n  console.log('Order Details');\n  console.log('=============');\n}\n\nfunction printTotal(total: number): void {\n  console.log('=============');\n  console.log(`Total: $${total}`);\n}\n```\n\n**Run tests. ✓ Commit.**\n\n→ See `references/refactoring-catalog.md`\n\n## Step 5: Test After Each Step\n\n```typescript\n// After EVERY small change:\nnpm test\n\n// If tests fail:\n// 1. Undo the change (git checkout)\n// 2. Try smaller step\n// 3. Or fix the issue before continuing\n```\n\n### Testing Strategies During Refactoring\n\n| Strategy | When to Use |\n|----------|-------------|\n| **Run all tests** | Small codebase, fast tests |\n| **Run affected tests** | Large codebase, slow tests |\n| **Snapshot testing** | Complex output you want to preserve |\n| **Manual verification** | UI changes, no automated tests |\n\n## Step 6: Commit Frequently\n\n```bash\n# Good: Small, atomic commits\ngit commit -m \"refactor: extract printItems method\"\ngit commit -m \"refactor: extract applyDiscount method\"\ngit commit -m \"refactor: extract header and footer printing\"\n\n# Bad: One big commit\ngit commit -m \"refactor: cleaned up printOrder\"\n```\n\nBenefits:\n- Easy to revert one step if something breaks\n- Clear history of what changed\n- Easier code review\n- Can bisect to find problems\n\n## Step 7: Review the Result\n\nAfter refactoring, ask:\n\n```markdown\n## Post-Refactoring Review\n\n### Readability\n- [ ] Is the code easier to understand?\n- [ ] Are names clearer?\n- [ ] Is the structure more logical?\n\n### Maintainability\n- [ ] Is it easier to change?\n- [ ] Are responsibilities clear?\n- [ ] Is duplication reduced?\n\n### Correctness\n- [ ] All tests still pass?\n- [ ] No behavior changed?\n- [ ] Edge cases still work?\n\n### Did we overdo it?\n- [ ] Is it simpler, not more complex?\n- [ ] Did we avoid premature abstraction?\n- [ ] Is it still easy to debug?\n```\n\n## Common Refactorings\n\n### Extract Method\n\n**When:** Long method, code block that can be named\n\n```typescript\n// Before\nfunction processOrder(order: Order): void {\n  // Validate order\n  if (!order.items.length) throw new Error('Empty order');\n  if (!order.customer) throw new Error('No customer');\n  if (order.total < 0) throw new Error('Invalid total');\n\n  // Process...\n}\n\n// After\nfunction processOrder(order: Order): void {\n  validateOrder(order);\n  // Process...\n}\n\nfunction validateOrder(order: Order): void {\n  if (!order.items.length) throw new Error('Empty order');\n  if (!order.customer) throw new Error('No customer');\n  if (order.total < 0) throw new Error('Invalid total');\n}\n```\n\n### Rename\n\n**When:** Name doesn't clearly express intent\n\n```typescript\n// Before\nfunction calc(d: number[]): number {\n  let t = 0;\n  for (const n of d) t += n;\n  return t / d.length;\n}\n\n// After\nfunction calculateAverage(numbers: number[]): number {\n  let sum = 0;\n  for (const number of numbers) sum += number;\n  return sum / numbers.length;\n}\n```\n\n### Replace Conditional with Polymorphism\n\n**When:** Switch statement on type that appears in multiple places\n\n```typescript\n// Before\nfunction calculatePay(employee: Employee): number {\n  switch (employee.type) {\n    case 'hourly':\n      return employee.hours * employee.rate;\n    case 'salaried':\n      return employee.salary / 12;\n    case 'commission':\n      return employee.sales * employee.commissionRate;\n  }\n}\n\n// After\ninterface Employee {\n  calculatePay(): number;\n}\n\nclass HourlyEmployee implements Employee {\n  constructor(private hours: number, private rate: number) {}\n  calculatePay(): number {\n    return this.hours * this.rate;\n  }\n}\n\nclass SalariedEmployee implements Employee {\n  constructor(private salary: number) {}\n  calculatePay(): number {\n    return this.salary / 12;\n  }\n}\n\nclass CommissionEmployee implements Employee {\n  constructor(private sales: number, private rate: number) {}\n  calculatePay(): number {\n    return this.sales * this.rate;\n  }\n}\n```\n\n### Introduce Parameter Object\n\n**When:** Same parameters passed together repeatedly\n\n```typescript\n// Before\nfunction createEvent(\n  startDate: Date,\n  endDate: Date,\n  startTime: string,\n  endTime: string,\n  timezone: string\n): Event { }\n\nfunction validateDateRange(\n  startDate: Date,\n  endDate: Date,\n  startTime: string,\n  endTime: string,\n  timezone: string\n): boolean { }\n\n// After\ninterface DateRange {\n  startDate: Date;\n  endDate: Date;\n  startTime: string;\n  endTime: string;\n  timezone: string;\n}\n\nfunction createEvent(range: DateRange): Event { }\nfunction validateDateRange(range: DateRange): boolean { }\n```\n\n### Replace Primitive with Value Object\n\n**When:** Primitive carries domain meaning\n\n```typescript\n// Before\nfunction processPayment(amountCents: number, currency: string): void {\n  // Easy to make mistakes:\n  // - Pass dollars instead of cents\n  // - Pass invalid currency\n  // - Mix up currencies\n}\n\n// After\nclass Money {\n  constructor(\n    private readonly cents: number,\n    private readonly currency: Currency\n  ) {\n    if (cents < 0) throw new Error('Amount cannot be negative');\n  }\n\n  add(other: Money): Money {\n    if (this.currency !== other.currency) {\n      throw new Error('Currency mismatch');\n    }\n    return new Money(this.cents + other.cents, this.currency);\n  }\n\n  toString(): string {\n    return `${this.currency} ${(this.cents / 100).toFixed(2)}`;\n  }\n}\n\nfunction processPayment(amount: Money): void {\n  // Type system prevents mistakes\n}\n```\n\n→ See `references/refactoring-catalog.md`\n\n## When NOT to Refactor\n\n| Situation | Why Not | Alternative |\n|-----------|---------|-------------|\n| **No tests** | Can't verify behavior preserved | Write tests first |\n| **Deadline pressure** | Risk of breaking things | Schedule for later |\n| **Rewrite needed** | Refactoring won't help | Plan rewrite instead |\n| **Working code you won't touch** | No benefit | Leave it alone |\n| **During feature development** | Context switching | Finish feature first |\n\n## Refactoring vs Rewriting\n\n| Refactoring | Rewriting |\n|-------------|-----------|\n| Incremental changes | Start from scratch |\n| Behavior preserved | May change behavior |\n| Low risk | High risk |\n| Continuous delivery | Big bang |\n| Tests guide you | Need new tests |\n\n**Rule of thumb:** If you can improve the code through a series of small, safe changes, refactor. If the code is fundamentally broken or the design is wrong, consider rewriting.\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `code-review` | Review may identify refactoring opportunities |\n| `code-verification` | Verify structure after refactoring |\n| `code-validation` | Validate behavior preserved |\n| `implement` | Refactor before implementing new features |\n| `debug-assist` | May refactor to make debugging easier |\n| `test-generation` | Need tests before refactoring |\n\n## Key Principles\n\n**Small steps.** Each change should be trivial and safe.\n\n**Tests first.** Never refactor without tests.\n\n**One thing at a time.** Don't mix refactoring with feature work.\n\n**Commit often.** Make it easy to revert.\n\n**Know when to stop.** Good enough is good enough.\n\n**Preserve behavior.** The whole point is not changing what the code does.\n\n## Mode-Specific Behavior\n\nRefactoring scope and constraints differ by orchestrator mode:\n\n### Greenfield Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Full—any code in the new system |\n| **Approach** | Comprehensive—refactor as you go |\n| **Patterns** | Free choice—establish clean patterns |\n| **Deliverables** | Full refactored code with tests |\n| **Validation** | Standard—tests before and after |\n| **Constraints** | Minimal—separate commits encouraged |\n\n### Brownfield-Polish Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Gap-specific—related code primarily |\n| **Approach** | Extend existing—refactor before filling gap |\n| **Patterns** | Should match existing codebase style |\n| **Deliverables** | Delta refactoring separate from features |\n| **Validation** | Existing tests + new coverage |\n| **Constraints** | Don't restructure unrelated code |\n\n**Polish considerations:**\n- Refactor only what you're changing\n- Don't \"improve\" unrelated code\n- Match refactoring style to codebase\n- Document why refactoring was needed\n- Get approval for large refactors\n\n### Brownfield-Enterprise Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Change-specific—related code only |\n| **Approach** | Surgical—avoid refactoring if possible |\n| **Patterns** | Must conform exactly—no style changes |\n| **Deliverables** | Change record with separate CR |\n| **Validation** | Full regression testing required |\n| **Constraints** | Requires approval—never mix with features |\n\n**Enterprise refactoring constraints:**\n- Refactoring requires separate change request\n- No refactoring mixed with feature changes\n- Must justify business value of refactoring\n- Full test coverage required before and after\n- Rollback plan required\n\n**Enterprise refactoring process:**\n1. Create separate CR for refactoring\n2. Get CR approved\n3. Implement refactoring in isolation\n4. Full regression testing\n5. Merge refactoring first\n6. Then implement feature change\n\n---\n\n## References\n\n- `references/code-smells.md`: Detailed catalog of code smells\n- `references/refactoring-catalog.md`: Complete refactoring patterns\n- `references/refactoring-strategies.md`: Large-scale refactoring approaches\n- `references/legacy-code-patterns.md`: Working with code without tests",
  "references": [
    {
      "name": "code-smells.md",
      "path": "references/code-smells.md",
      "content": "# Code Smells\n\nA comprehensive catalog of code smells and how to identify them.\n\n## What Are Code Smells?\n\nCode smells are surface indications that usually correspond to deeper problems in the system. They're not bugs—the code works—but they indicate weakness in design that may slow development or increase risk of bugs in the future.\n\n## Bloaters\n\nCode that has grown too large to handle effectively.\n\n### Long Method\n\n**Symptoms:**\n- Method is longer than 20 lines\n- Need to scroll to see the whole method\n- Multiple levels of abstraction in one method\n- Comments separating \"sections\" within a method\n\n**Example:**\n```typescript\n// SMELL: Method does too many things\nfunction processOrder(order: Order): Result {\n  // Validate order (10 lines)\n  // Calculate totals (15 lines)\n  // Check inventory (20 lines)\n  // Process payment (25 lines)\n  // Send notifications (15 lines)\n  // Update database (10 lines)\n}\n```\n\n**Refactorings:**\n- Extract Method\n- Replace Temp with Query\n- Introduce Parameter Object\n- Decompose Conditional\n\n### Large Class\n\n**Symptoms:**\n- Class has >300 lines\n- Class has >10 methods\n- Class has >5 instance variables\n- Class name includes \"And\" or \"Manager\"\n- Hard to summarize what the class does\n\n**Example:**\n```typescript\n// SMELL: Class does too many unrelated things\nclass UserManager {\n  // User CRUD (50 lines)\n  // Authentication (100 lines)\n  // Password hashing (50 lines)\n  // Email sending (75 lines)\n  // Session management (50 lines)\n  // Audit logging (40 lines)\n}\n```\n\n**Refactorings:**\n- Extract Class\n- Extract Subclass\n- Extract Interface\n\n### Long Parameter List\n\n**Symptoms:**\n- More than 3-4 parameters\n- Parameters often passed together\n- Hard to remember parameter order\n- Boolean parameters control behavior\n\n**Example:**\n```typescript\n// SMELL: Too many parameters\nfunction createUser(\n  firstName: string,\n  lastName: string,\n  email: string,\n  phone: string,\n  street: string,\n  city: string,\n  state: string,\n  zip: string,\n  country: string,\n  isAdmin: boolean,\n  sendWelcomeEmail: boolean\n): User { }\n```\n\n**Refactorings:**\n- Introduce Parameter Object\n- Preserve Whole Object\n- Replace Parameter with Method Call\n\n### Primitive Obsession\n\n**Symptoms:**\n- Using strings for phone numbers, emails, money\n- Using numbers for IDs, amounts, distances\n- Using arrays for structured data\n- Constants for \"type codes\"\n\n**Example:**\n```typescript\n// SMELL: Primitives for domain concepts\nfunction processPayment(\n  amount: number,        // Cents? Dollars? What currency?\n  cardNumber: string,    // No validation\n  expiry: string,        // What format?\n  customerId: string     // Could be any string\n): void { }\n```\n\n**Refactorings:**\n- Replace Primitive with Value Object\n- Replace Type Code with Class\n- Replace Type Code with Subclasses\n\n### Data Clumps\n\n**Symptoms:**\n- Same 3+ fields appear together in multiple places\n- Parameters that always travel together\n- Fields that are always used together\n\n**Example:**\n```typescript\n// SMELL: These three always appear together\nfunction validateAddress(street: string, city: string, zip: string): boolean { }\nfunction formatAddress(street: string, city: string, zip: string): string { }\nfunction geocodeAddress(street: string, city: string, zip: string): Coords { }\n\nclass Customer {\n  billingStreet: string;\n  billingCity: string;\n  billingZip: string;\n  shippingStreet: string;\n  shippingCity: string;\n  shippingZip: string;\n}\n```\n\n**Refactorings:**\n- Extract Class\n- Introduce Parameter Object\n- Preserve Whole Object\n\n## Object-Orientation Abusers\n\nCode that doesn't use OO principles effectively.\n\n### Switch Statements\n\n**Symptoms:**\n- Switch on type/enum in multiple places\n- Adding new type requires changes in multiple files\n- Switch in methods that should be polymorphic\n\n**Example:**\n```typescript\n// SMELL: Type switch appears everywhere\nfunction calculateArea(shape: Shape): number {\n  switch (shape.type) {\n    case 'circle': return Math.PI * shape.radius ** 2;\n    case 'rectangle': return shape.width * shape.height;\n    case 'triangle': return 0.5 * shape.base * shape.height;\n  }\n}\n\nfunction draw(shape: Shape): void {\n  switch (shape.type) {\n    case 'circle': drawCircle(shape);\n    case 'rectangle': drawRectangle(shape);\n    case 'triangle': drawTriangle(shape);\n  }\n}\n```\n\n**Refactorings:**\n- Replace Conditional with Polymorphism\n- Replace Type Code with Subclasses\n- Replace Type Code with State/Strategy\n\n### Refused Bequest\n\n**Symptoms:**\n- Subclass doesn't use most inherited methods\n- Subclass overrides methods to do nothing\n- \"Is-a\" relationship doesn't make sense\n\n**Example:**\n```typescript\n// SMELL: Stack isn't really a List\nclass Stack extends ArrayList {\n  push(item: T): void { this.add(item); }\n  pop(): T { return this.remove(this.size() - 1); }\n\n  // Inherited but shouldn't be used:\n  // add(index, item), remove(index), get(index), etc.\n}\n```\n\n**Refactorings:**\n- Replace Inheritance with Delegation\n- Extract Superclass\n- Push Down Method\n\n### Temporary Field\n\n**Symptoms:**\n- Instance variables only used in some methods\n- Variables set to null/undefined when not needed\n- Fields that only make sense in certain states\n\n**Example:**\n```typescript\n// SMELL: These fields only used in one method\nclass Order {\n  // Always used\n  items: Item[];\n  total: number;\n\n  // Only used during checkout\n  tempShippingCost: number | null;\n  tempTaxAmount: number | null;\n  tempDiscountApplied: boolean;\n}\n```\n\n**Refactorings:**\n- Extract Class\n- Replace Method with Method Object\n- Introduce Null Object\n\n## Change Preventers\n\nCode that makes changes difficult.\n\n### Divergent Change\n\n**Symptoms:**\n- One class changes for different reasons\n- Different developers change same file for unrelated features\n- \"God class\" that knows everything\n\n**Example:**\n```typescript\n// SMELL: Changes for different reasons\nclass Employee {\n  // Changes when: HR policy changes\n  calculatePay(): number { }\n\n  // Changes when: Reporting requirements change\n  generateReport(): string { }\n\n  // Changes when: Database schema changes\n  save(): void { }\n}\n```\n\n**Refactorings:**\n- Extract Class\n- Extract Module\n\n### Shotgun Surgery\n\n**Symptoms:**\n- Small change requires edits to many files\n- Related code scattered across codebase\n- Easy to miss one place when making changes\n\n**Example:**\n```typescript\n// SMELL: Adding a new field requires changes everywhere\n// user.ts\ninterface User { email: string; /* need to add phone */ }\n\n// userForm.ts\n// need to add phone input\n\n// userValidation.ts\n// need to add phone validation\n\n// userRepository.ts\n// need to add phone to queries\n\n// userApi.ts\n// need to add phone to serialization\n```\n\n**Refactorings:**\n- Move Method\n- Move Field\n- Inline Class\n\n### Parallel Inheritance Hierarchies\n\n**Symptoms:**\n- Creating subclass in one hierarchy requires subclass in another\n- Class names have same prefix in different hierarchies\n- Hierarchies evolve together\n\n**Example:**\n```typescript\n// SMELL: Every Shape needs a ShapeRenderer\nclass Shape { }\nclass Circle extends Shape { }\nclass Rectangle extends Shape { }\n\nclass ShapeRenderer { }\nclass CircleRenderer extends ShapeRenderer { }\nclass RectangleRenderer extends ShapeRenderer { }\n```\n\n**Refactorings:**\n- Move Method to collapse hierarchies\n- Visitor pattern\n- Strategy pattern\n\n## Dispensables\n\nCode that could be removed.\n\n### Comments\n\n**Symptoms:**\n- Comments explain what code does (not why)\n- Comments apologize for bad code\n- Commented-out code\n- TODOs that are years old\n\n**Example:**\n```typescript\n// SMELL: Comments that should be code\n// Loop through users and check if they're active\nfor (let i = 0; i < users.length; i++) {\n  // Get the current user\n  const u = users[i];\n  // Check if the user is active\n  if (u.a === true) {\n    // Add to the result\n    r.push(u);\n  }\n}\n\n// BETTER: Self-documenting code\nconst activeUsers = users.filter(user => user.isActive);\n```\n\n**Refactorings:**\n- Extract Method (give it a good name)\n- Rename Variable\n- Introduce Assertion\n\n### Duplicate Code\n\n**Symptoms:**\n- Same code in multiple places\n- Similar code with minor variations\n- Copy-paste with search-replace\n\n**Example:**\n```typescript\n// SMELL: Same validation in multiple places\nfunction createUser(data: UserData): User {\n  if (!data.email) throw new Error('Email required');\n  if (!data.email.includes('@')) throw new Error('Invalid email');\n  // ...\n}\n\nfunction updateUser(id: string, data: UserData): User {\n  if (!data.email) throw new Error('Email required');\n  if (!data.email.includes('@')) throw new Error('Invalid email');\n  // ...\n}\n```\n\n**Refactorings:**\n- Extract Method\n- Pull Up Method\n- Form Template Method\n\n### Dead Code\n\n**Symptoms:**\n- Unused variables, parameters, methods, classes\n- Unreachable code after return/throw\n- Code commented \"just in case\"\n- Features no one uses\n\n**Example:**\n```typescript\n// SMELL: Unused code\nfunction processOrder(order: Order, debug: boolean = false): void {\n  const startTime = Date.now();  // Never used\n\n  if (false) {\n    // This can never execute\n    console.log('Debug mode');\n  }\n\n  // Old implementation - keeping just in case\n  // function oldProcess() { ... }\n}\n```\n\n**Refactorings:**\n- Delete it (version control has it)\n- Remove parameter\n\n### Speculative Generality\n\n**Symptoms:**\n- Abstract classes with one implementation\n- Parameters that are never used\n- Hooks for \"future extensibility\"\n- YAGNI violations\n\n**Example:**\n```typescript\n// SMELL: Over-engineered for hypothetical future\ninterface PaymentProcessor { }\ninterface PaymentProcessorFactory { }\nabstract class AbstractPaymentProcessor implements PaymentProcessor { }\nclass PaymentProcessorFactoryImpl implements PaymentProcessorFactory { }\nclass ConcretePaymentProcessor extends AbstractPaymentProcessor { }\n\n// Only one payment processor ever used\n```\n\n**Refactorings:**\n- Collapse Hierarchy\n- Inline Class\n- Remove Parameter\n\n## Couplers\n\nCode that's too tightly connected.\n\n### Feature Envy\n\n**Symptoms:**\n- Method uses data from another class more than its own\n- Method could move to another class entirely\n- Lots of getter calls on one object\n\n**Example:**\n```typescript\n// SMELL: This method envies Customer\nclass Order {\n  getCustomerDiscount(): number {\n    const customer = this.customer;\n    if (customer.loyaltyYears > 5) {\n      return customer.totalPurchases > 10000 ? 0.15 : 0.10;\n    }\n    return customer.hasCoupon ? 0.05 : 0;\n  }\n}\n```\n\n**Refactorings:**\n- Move Method\n- Extract Method then Move\n\n### Inappropriate Intimacy\n\n**Symptoms:**\n- Classes access each other's private members\n- Circular dependencies between classes\n- Classes know implementation details of each other\n\n**Example:**\n```typescript\n// SMELL: Too much knowledge of each other\nclass Order {\n  private items: Item[];\n\n  // Customer reaches into Order's internals\n}\n\nclass Customer {\n  getTotalSpent(orders: Order[]): number {\n    let total = 0;\n    for (const order of orders) {\n      // Accessing private field through backdoor\n      for (const item of (order as any).items) {\n        total += item.price;\n      }\n    }\n    return total;\n  }\n}\n```\n\n**Refactorings:**\n- Move Method\n- Replace Bidirectional with Unidirectional\n- Extract Class\n\n### Message Chains\n\n**Symptoms:**\n- Long chains of method calls: a.b().c().d()\n- Client knows about intermediate objects\n- Changes to chain structure break many clients\n\n**Example:**\n```typescript\n// SMELL: Long chain exposes structure\nconst departmentName = employee\n  .getDepartment()\n  .getManager()\n  .getDepartment()\n  .getName();\n```\n\n**Refactorings:**\n- Hide Delegate\n- Extract Method\n\n### Middle Man\n\n**Symptoms:**\n- Class delegates most methods to another class\n- Thin wrapper that adds no value\n- Pass-through methods everywhere\n\n**Example:**\n```typescript\n// SMELL: Order just forwards to OrderDetails\nclass Order {\n  private details: OrderDetails;\n\n  getItems(): Item[] { return this.details.getItems(); }\n  getTotal(): number { return this.details.getTotal(); }\n  getCustomer(): Customer { return this.details.getCustomer(); }\n  getShipping(): Address { return this.details.getShipping(); }\n  // Every method just delegates\n}\n```\n\n**Refactorings:**\n- Remove Middle Man\n- Inline Method\n- Replace Delegation with Inheritance\n"
    },
    {
      "name": "legacy-code-patterns.md",
      "path": "references/legacy-code-patterns.md",
      "content": "# Legacy Code Patterns\n\nTechniques for working with code that has no tests.\n\n## The Legacy Code Dilemma\n\n**Problem:** Need tests to refactor safely, but code is untestable without refactoring.\n\n**Solution:** Make tiny, safe changes to get code under test, then refactor properly.\n\n## Characterization Tests\n\nTests that capture current behavior, not expected behavior.\n\n### Writing Characterization Tests\n\n```typescript\n// Step 1: Call the code and see what happens\nit('characterizes calculateDiscount behavior', () => {\n  const order = { items: [...], customer: {...} };\n  const result = calculateDiscount(order);\n  console.log(result); // Run once to see: 127.50\n});\n\n// Step 2: Assert the actual output\nit('characterizes calculateDiscount behavior', () => {\n  const order = { items: [...], customer: {...} };\n  const result = calculateDiscount(order);\n  expect(result).toBe(127.50); // Now we have a safety net\n});\n```\n\n### Characterization Test Process\n\n```markdown\n1. Find a code path you need to test\n2. Write a test that calls the code\n3. Run it and observe the output\n4. Assert that output (even if it seems wrong)\n5. Repeat for different inputs\n6. Now you can refactor safely\n```\n\n### Example: Complex Function\n\n```typescript\n// Legacy code with no tests\nfunction processOrder(order: any): any {\n  // 200 lines of complex logic\n  // Nobody knows exactly what it does\n}\n\n// Characterization tests\ndescribe('processOrder characterization', () => {\n  it('handles empty order', () => {\n    const result = processOrder({ items: [] });\n    expect(result).toEqual({ status: 'error', message: 'No items' });\n  });\n\n  it('handles single item order', () => {\n    const order = {\n      items: [{ sku: 'ABC', qty: 1, price: 10 }],\n      customer: { id: 'C1', tier: 'gold' }\n    };\n    const result = processOrder(order);\n    expect(result).toMatchSnapshot(); // Capture complex output\n  });\n\n  it('applies gold customer discount', () => {\n    const order = {\n      items: [{ sku: 'ABC', qty: 1, price: 100 }],\n      customer: { id: 'C1', tier: 'gold' }\n    };\n    const result = processOrder(order);\n    expect(result.total).toBe(90); // 10% discount observed\n  });\n});\n```\n\n## Seams\n\nPoints where you can alter behavior without editing code.\n\n### Types of Seams\n\n| Seam Type | How It Works | Example |\n|-----------|--------------|---------|\n| **Object Seam** | Override via subclass/injection | Replace database with mock |\n| **Link Seam** | Replace at link time | Different library in test |\n| **Preprocessing Seam** | Conditional compilation | #ifdef TEST |\n\n### Object Seam Example\n\n```typescript\n// Legacy code - hard to test\nclass OrderProcessor {\n  process(order: Order): void {\n    // Complex logic...\n    this.database.save(order);\n    this.emailService.sendConfirmation(order.customer);\n  }\n\n  private database = new Database();\n  private emailService = new EmailService();\n}\n\n// Step 1: Extract seams (minimal change)\nclass OrderProcessor {\n  process(order: Order): void {\n    // Complex logic...\n    this.getDatabase().save(order);\n    this.getEmailService().sendConfirmation(order.customer);\n  }\n\n  protected getDatabase(): Database {\n    return new Database();\n  }\n\n  protected getEmailService(): EmailService {\n    return new EmailService();\n  }\n}\n\n// Step 2: Test via subclass\nclass TestableOrderProcessor extends OrderProcessor {\n  public mockDatabase = new MockDatabase();\n  public mockEmail = new MockEmailService();\n\n  protected getDatabase(): Database {\n    return this.mockDatabase;\n  }\n\n  protected getEmailService(): EmailService {\n    return this.mockEmail;\n  }\n}\n\n// Step 3: Write tests\nit('saves order to database', () => {\n  const processor = new TestableOrderProcessor();\n  processor.process(testOrder);\n  expect(processor.mockDatabase.savedOrders).toContain(testOrder);\n});\n```\n\n### Dependency Injection Seam\n\n```typescript\n// Legacy: Dependencies created internally\nclass PaymentProcessor {\n  process(payment: Payment): void {\n    const stripe = new StripeClient(process.env.STRIPE_KEY);\n    stripe.charge(payment);\n  }\n}\n\n// Step 1: Constructor injection (minimal change)\nclass PaymentProcessor {\n  private stripeClient: StripeClient;\n\n  constructor(stripeClient?: StripeClient) {\n    this.stripeClient = stripeClient ?? new StripeClient(process.env.STRIPE_KEY);\n  }\n\n  process(payment: Payment): void {\n    this.stripeClient.charge(payment);\n  }\n}\n\n// Step 2: Now testable\nit('charges via Stripe', () => {\n  const mockStripe = { charge: jest.fn() };\n  const processor = new PaymentProcessor(mockStripe);\n\n  processor.process(testPayment);\n\n  expect(mockStripe.charge).toHaveBeenCalledWith(testPayment);\n});\n```\n\n## Sprout Methods\n\nAdd new functionality in a tested method, call from legacy code.\n\n### Sprout Method Process\n\n```markdown\n1. Identify where new code needs to go\n2. Write new code as a separate, tested method\n3. Call the new method from the legacy code\n```\n\n```typescript\n// Legacy code - untested mess\nclass InvoiceProcessor {\n  process(invoice: Invoice): void {\n    // 100 lines of untested code\n    // ...\n    // Need to add: tax calculation\n    // ...\n    // 100 more lines\n  }\n}\n\n// Step 1: Write new functionality with tests\nclass InvoiceProcessor {\n  // NEW: Tested method\n  calculateTax(invoice: Invoice): number {\n    const taxRate = this.getTaxRate(invoice.region);\n    return invoice.subtotal * taxRate;\n  }\n\n  private getTaxRate(region: string): number {\n    const rates: Record<string, number> = {\n      'CA': 0.0725,\n      'NY': 0.08,\n      'TX': 0.0625,\n    };\n    return rates[region] ?? 0;\n  }\n\n  process(invoice: Invoice): void {\n    // 100 lines of untested code\n    // ...\n    invoice.tax = this.calculateTax(invoice); // Call sprouted method\n    // ...\n    // 100 more lines\n  }\n}\n\n// Tests for new functionality\ndescribe('calculateTax', () => {\n  it('calculates CA tax correctly', () => {\n    const invoice = { subtotal: 100, region: 'CA' };\n    expect(processor.calculateTax(invoice)).toBe(7.25);\n  });\n});\n```\n\n## Sprout Classes\n\nWhen sprouting a method isn't enough, create a new class.\n\n```typescript\n// Legacy code\nclass OrderService {\n  submitOrder(order: Order): void {\n    // 500 lines of legacy code\n    // Need to add: fraud detection\n  }\n}\n\n// Step 1: Create new tested class\nclass FraudDetector {\n  constructor(private readonly rules: FraudRule[]) {}\n\n  check(order: Order): FraudResult {\n    for (const rule of this.rules) {\n      const result = rule.evaluate(order);\n      if (result.isFraudulent) {\n        return result;\n      }\n    }\n    return { isFraudulent: false };\n  }\n}\n\n// Step 2: Call from legacy code\nclass OrderService {\n  private fraudDetector = new FraudDetector(this.loadRules());\n\n  submitOrder(order: Order): void {\n    // Check for fraud first (new, tested code)\n    const fraudResult = this.fraudDetector.check(order);\n    if (fraudResult.isFraudulent) {\n      throw new FraudDetectedError(fraudResult);\n    }\n\n    // 500 lines of legacy code continues...\n  }\n}\n```\n\n## Wrap Method\n\nWrap existing method to add behavior before/after.\n\n```typescript\n// Legacy code\nclass Employee {\n  pay(): void {\n    // Complex payroll logic\n    Money amount = this.calculatePay();\n    this.dispatchPayment(amount);\n  }\n}\n\n// Need to add logging\n// Step 1: Rename existing method\nclass Employee {\n  private dispatchPayroll(): void {\n    Money amount = this.calculatePay();\n    this.dispatchPayment(amount);\n  }\n}\n\n// Step 2: Create wrapper with old name\nclass Employee {\n  pay(): void {\n    this.logPayment();        // New behavior\n    this.dispatchPayroll();   // Original behavior\n  }\n\n  private logPayment(): void {\n    this.auditLog.record('payment', this.id, new Date());\n  }\n\n  private dispatchPayroll(): void {\n    Money amount = this.calculatePay();\n    this.dispatchPayment(amount);\n  }\n}\n```\n\n## Breaking Dependencies\n\n### Extract Interface\n\n```typescript\n// Legacy: Concrete dependency\nclass OrderProcessor {\n  constructor(private db: PostgresDatabase) {}\n}\n\n// Step 1: Extract interface\ninterface Database {\n  save(entity: Entity): void;\n  find(id: string): Entity | null;\n}\n\nclass PostgresDatabase implements Database {\n  save(entity: Entity): void { /* ... */ }\n  find(id: string): Entity | null { /* ... */ }\n}\n\n// Step 2: Depend on interface\nclass OrderProcessor {\n  constructor(private db: Database) {}\n}\n\n// Step 3: Create test double\nclass InMemoryDatabase implements Database {\n  private data = new Map<string, Entity>();\n\n  save(entity: Entity): void {\n    this.data.set(entity.id, entity);\n  }\n\n  find(id: string): Entity | null {\n    return this.data.get(id) ?? null;\n  }\n}\n```\n\n### Parameterize Constructor\n\n```typescript\n// Legacy: Hardcoded dependencies\nclass ReportGenerator {\n  private formatter = new PdfFormatter();\n  private sender = new EmailSender();\n\n  generate(data: ReportData): void {\n    const pdf = this.formatter.format(data);\n    this.sender.send(pdf);\n  }\n}\n\n// Step 1: Add parameters with defaults\nclass ReportGenerator {\n  private formatter: Formatter;\n  private sender: Sender;\n\n  constructor(\n    formatter: Formatter = new PdfFormatter(),\n    sender: Sender = new EmailSender()\n  ) {\n    this.formatter = formatter;\n    this.sender = sender;\n  }\n}\n\n// Production code unchanged\nconst generator = new ReportGenerator();\n\n// Test code can inject mocks\nconst generator = new ReportGenerator(mockFormatter, mockSender);\n```\n\n### Extract and Override Call\n\n```typescript\n// Legacy: Static method call\nclass PriceCalculator {\n  calculate(items: Item[]): number {\n    let total = 0;\n    for (const item of items) {\n      total += item.price * TaxService.getCurrentRate(); // Static call!\n    }\n    return total;\n  }\n}\n\n// Step 1: Extract to instance method\nclass PriceCalculator {\n  calculate(items: Item[]): number {\n    let total = 0;\n    for (const item of items) {\n      total += item.price * this.getTaxRate(); // Instance method\n    }\n    return total;\n  }\n\n  protected getTaxRate(): number {\n    return TaxService.getCurrentRate();\n  }\n}\n\n// Step 2: Override in test\nclass TestablePriceCalculator extends PriceCalculator {\n  public taxRate = 0.1;\n\n  protected getTaxRate(): number {\n    return this.taxRate;\n  }\n}\n\nit('calculates with tax', () => {\n  const calc = new TestablePriceCalculator();\n  calc.taxRate = 0.1;\n\n  const result = calc.calculate([{ price: 100 }]);\n\n  expect(result).toBe(110);\n});\n```\n\n## Golden Master Testing\n\nFor code that produces complex output.\n\n```typescript\n// Step 1: Generate golden master\nfunction generateGoldenMaster(): void {\n  const inputs = loadProductionInputs(); // Real data samples\n  const results = inputs.map(input => ({\n    input,\n    output: legacyFunction(input)\n  }));\n  fs.writeFileSync('golden-master.json', JSON.stringify(results, null, 2));\n}\n\n// Step 2: Test against golden master\ndescribe('legacyFunction', () => {\n  const goldenMaster = JSON.parse(fs.readFileSync('golden-master.json'));\n\n  goldenMaster.forEach(({ input, output }, index) => {\n    it(`matches golden master case ${index}`, () => {\n      expect(legacyFunction(input)).toEqual(output);\n    });\n  });\n});\n\n// Step 3: Now safe to refactor\n// If tests pass, behavior is preserved\n```\n\n## Safe Refactoring Moves\n\nChanges that are safe without tests (if done carefully):\n\n| Change | Safety | Notes |\n|--------|--------|-------|\n| Rename variable | Very safe | IDE refactoring |\n| Rename method | Safe | IDE refactoring, check all usages |\n| Extract variable | Safe | No behavior change |\n| Extract method | Safe | If done mechanically |\n| Inline variable | Safe | Simple substitution |\n| Reorder methods | Very safe | No behavior change |\n| Add whitespace | Very safe | No behavior change |\n| Extract interface | Safe | Adding, not changing |\n\n## Risky Changes Without Tests\n\n| Change | Risk | Why |\n|--------|------|-----|\n| Change conditional | High | Easy to change behavior |\n| Change loop | High | Off-by-one errors |\n| Change method signature | Medium | Can break callers |\n| Move code between methods | Medium | Side effect changes |\n| Remove code | High | Might be needed |\n| Optimize | High | Subtle behavior changes |\n"
    },
    {
      "name": "refactoring-catalog.md",
      "path": "references/refactoring-catalog.md",
      "content": "# Refactoring Catalog\n\nDetailed examples of common refactoring patterns.\n\n## Method Composition\n\n### Extract Method\n\n**When:** Code fragment that can be grouped together and named.\n\n**Steps:**\n1. Create new method with descriptive name\n2. Copy extracted code to new method\n3. Replace original code with method call\n4. Compile and test\n\n```typescript\n// Before\nfunction printOwing(invoice: Invoice): void {\n  let outstanding = 0;\n\n  console.log('***********************');\n  console.log('**** Customer Owes ****');\n  console.log('***********************');\n\n  for (const order of invoice.orders) {\n    outstanding += order.amount;\n  }\n\n  console.log(`name: ${invoice.customer}`);\n  console.log(`amount: ${outstanding}`);\n}\n\n// After\nfunction printOwing(invoice: Invoice): void {\n  printBanner();\n  const outstanding = calculateOutstanding(invoice);\n  printDetails(invoice, outstanding);\n}\n\nfunction printBanner(): void {\n  console.log('***********************');\n  console.log('**** Customer Owes ****');\n  console.log('***********************');\n}\n\nfunction calculateOutstanding(invoice: Invoice): number {\n  return invoice.orders.reduce((sum, order) => sum + order.amount, 0);\n}\n\nfunction printDetails(invoice: Invoice, outstanding: number): void {\n  console.log(`name: ${invoice.customer}`);\n  console.log(`amount: ${outstanding}`);\n}\n```\n\n### Inline Method\n\n**When:** Method body is as clear as its name.\n\n```typescript\n// Before\nfunction getRating(): number {\n  return moreThanFiveLateDeliveries() ? 2 : 1;\n}\n\nfunction moreThanFiveLateDeliveries(): boolean {\n  return this.numberOfLateDeliveries > 5;\n}\n\n// After\nfunction getRating(): number {\n  return this.numberOfLateDeliveries > 5 ? 2 : 1;\n}\n```\n\n### Replace Temp with Query\n\n**When:** Temporary variable holds result of expression.\n\n```typescript\n// Before\nfunction calculateTotal(): number {\n  const basePrice = quantity * itemPrice;\n  if (basePrice > 1000) {\n    return basePrice * 0.95;\n  }\n  return basePrice * 0.98;\n}\n\n// After\nfunction calculateTotal(): number {\n  if (basePrice() > 1000) {\n    return basePrice() * 0.95;\n  }\n  return basePrice() * 0.98;\n}\n\nfunction basePrice(): number {\n  return quantity * itemPrice;\n}\n```\n\n### Split Temporary Variable\n\n**When:** Temp variable assigned more than once (not a loop counter).\n\n```typescript\n// Before\nlet temp = 2 * (height + width);\nconsole.log(temp);\ntemp = height * width;\nconsole.log(temp);\n\n// After\nconst perimeter = 2 * (height + width);\nconsole.log(perimeter);\nconst area = height * width;\nconsole.log(area);\n```\n\n## Moving Features\n\n### Move Method\n\n**When:** Method uses or is used by more features of another class.\n\n```typescript\n// Before\nclass Account {\n  overdraftCharge(): number {\n    if (this.type.isPremium()) {\n      const baseCharge = 10;\n      if (this.daysOverdrawn > 7) {\n        return baseCharge + (this.daysOverdrawn - 7) * 0.85;\n      }\n      return baseCharge;\n    }\n    return this.daysOverdrawn * 1.75;\n  }\n}\n\n// After - method moved to AccountType\nclass AccountType {\n  overdraftCharge(daysOverdrawn: number): number {\n    if (this.isPremium()) {\n      const baseCharge = 10;\n      if (daysOverdrawn > 7) {\n        return baseCharge + (daysOverdrawn - 7) * 0.85;\n      }\n      return baseCharge;\n    }\n    return daysOverdrawn * 1.75;\n  }\n}\n\nclass Account {\n  overdraftCharge(): number {\n    return this.type.overdraftCharge(this.daysOverdrawn);\n  }\n}\n```\n\n### Move Field\n\n**When:** Field used more by another class.\n\n```typescript\n// Before\nclass Account {\n  private interestRate: number;\n  private type: AccountType;\n\n  interestForAmount(days: number): number {\n    return this.interestRate * days * 365;\n  }\n}\n\n// After - interestRate belongs with AccountType\nclass AccountType {\n  private interestRate: number;\n\n  getInterestRate(): number {\n    return this.interestRate;\n  }\n}\n\nclass Account {\n  private type: AccountType;\n\n  interestForAmount(days: number): number {\n    return this.type.getInterestRate() * days * 365;\n  }\n}\n```\n\n### Extract Class\n\n**When:** Class does work that should be done by two classes.\n\n```typescript\n// Before\nclass Person {\n  private name: string;\n  private officeAreaCode: string;\n  private officeNumber: string;\n\n  getTelephoneNumber(): string {\n    return `(${this.officeAreaCode}) ${this.officeNumber}`;\n  }\n}\n\n// After\nclass TelephoneNumber {\n  private areaCode: string;\n  private number: string;\n\n  getTelephoneNumber(): string {\n    return `(${this.areaCode}) ${this.number}`;\n  }\n}\n\nclass Person {\n  private name: string;\n  private officeTelephone: TelephoneNumber;\n\n  getTelephoneNumber(): string {\n    return this.officeTelephone.getTelephoneNumber();\n  }\n}\n```\n\n### Inline Class\n\n**When:** Class isn't doing enough to justify its existence.\n\n```typescript\n// Before\nclass TelephoneNumber {\n  private areaCode: string;\n  private number: string;\n\n  getAreaCode(): string { return this.areaCode; }\n  getNumber(): string { return this.number; }\n}\n\nclass Person {\n  private name: string;\n  private telephone: TelephoneNumber;\n\n  getAreaCode(): string { return this.telephone.getAreaCode(); }\n  getNumber(): string { return this.telephone.getNumber(); }\n}\n\n// After - if TelephoneNumber doesn't pull its weight\nclass Person {\n  private name: string;\n  private areaCode: string;\n  private number: string;\n\n  getAreaCode(): string { return this.areaCode; }\n  getNumber(): string { return this.number; }\n}\n```\n\n## Organizing Data\n\n### Replace Primitive with Object\n\n**When:** Primitive needs more behavior than just storage.\n\n```typescript\n// Before\nclass Order {\n  private customerId: string;\n\n  getCustomer(): string {\n    return this.customerId;\n  }\n\n  setCustomer(id: string): void {\n    this.customerId = id;\n  }\n}\n\n// After\nclass Customer {\n  constructor(private readonly id: string) {}\n\n  getId(): string { return this.id; }\n}\n\nclass Order {\n  private customer: Customer;\n\n  getCustomer(): Customer {\n    return this.customer;\n  }\n\n  setCustomer(customer: Customer): void {\n    this.customer = customer;\n  }\n}\n```\n\n### Replace Magic Number with Constant\n\n**When:** Literal number with particular meaning.\n\n```typescript\n// Before\nfunction potentialEnergy(mass: number, height: number): number {\n  return mass * 9.81 * height;\n}\n\n// After\nconst GRAVITATIONAL_CONSTANT = 9.81;\n\nfunction potentialEnergy(mass: number, height: number): number {\n  return mass * GRAVITATIONAL_CONSTANT * height;\n}\n```\n\n### Introduce Parameter Object\n\n**When:** Group of parameters that naturally go together.\n\n```typescript\n// Before\nfunction amountInvoiced(startDate: Date, endDate: Date): number { }\nfunction amountReceived(startDate: Date, endDate: Date): number { }\nfunction amountOverdue(startDate: Date, endDate: Date): number { }\n\n// After\nclass DateRange {\n  constructor(\n    public readonly start: Date,\n    public readonly end: Date\n  ) {}\n\n  contains(date: Date): boolean {\n    return date >= this.start && date <= this.end;\n  }\n}\n\nfunction amountInvoiced(range: DateRange): number { }\nfunction amountReceived(range: DateRange): number { }\nfunction amountOverdue(range: DateRange): number { }\n```\n\n## Simplifying Conditionals\n\n### Decompose Conditional\n\n**When:** Complex conditional (if-then-else) with complex clauses.\n\n```typescript\n// Before\nif (date.before(SUMMER_START) || date.after(SUMMER_END)) {\n  charge = quantity * winterRate + winterServiceCharge;\n} else {\n  charge = quantity * summerRate;\n}\n\n// After\nif (isSummer(date)) {\n  charge = summerCharge(quantity);\n} else {\n  charge = winterCharge(quantity);\n}\n\nfunction isSummer(date: Date): boolean {\n  return !date.before(SUMMER_START) && !date.after(SUMMER_END);\n}\n\nfunction summerCharge(quantity: number): number {\n  return quantity * summerRate;\n}\n\nfunction winterCharge(quantity: number): number {\n  return quantity * winterRate + winterServiceCharge;\n}\n```\n\n### Consolidate Conditional Expression\n\n**When:** Sequence of conditional checks with same result.\n\n```typescript\n// Before\nfunction disabilityAmount(): number {\n  if (this.seniority < 2) return 0;\n  if (this.monthsDisabled > 12) return 0;\n  if (this.isPartTime) return 0;\n  // compute the disability amount\n  return baseAmount * 1.5;\n}\n\n// After\nfunction disabilityAmount(): number {\n  if (this.isNotEligibleForDisability()) return 0;\n  return baseAmount * 1.5;\n}\n\nfunction isNotEligibleForDisability(): boolean {\n  return this.seniority < 2\n    || this.monthsDisabled > 12\n    || this.isPartTime;\n}\n```\n\n### Replace Conditional with Polymorphism\n\n**When:** Conditional that chooses different behavior based on type.\n\n```typescript\n// Before\nclass Bird {\n  getSpeed(): number {\n    switch (this.type) {\n      case 'EUROPEAN':\n        return this.getBaseSpeed();\n      case 'AFRICAN':\n        return this.getBaseSpeed() - this.getLoadFactor() * this.numberOfCoconuts;\n      case 'NORWEGIAN_BLUE':\n        return this.isNailed ? 0 : this.getBaseSpeed();\n    }\n  }\n}\n\n// After\nabstract class Bird {\n  abstract getSpeed(): number;\n  protected getBaseSpeed(): number { /* ... */ }\n}\n\nclass EuropeanBird extends Bird {\n  getSpeed(): number {\n    return this.getBaseSpeed();\n  }\n}\n\nclass AfricanBird extends Bird {\n  getSpeed(): number {\n    return this.getBaseSpeed() - this.getLoadFactor() * this.numberOfCoconuts;\n  }\n}\n\nclass NorwegianBlueBird extends Bird {\n  getSpeed(): number {\n    return this.isNailed ? 0 : this.getBaseSpeed();\n  }\n}\n```\n\n### Replace Nested Conditional with Guard Clauses\n\n**When:** Conditional with special cases obscuring main logic.\n\n```typescript\n// Before\nfunction getPayAmount(): number {\n  let result: number;\n  if (this.isDead) {\n    result = deadAmount();\n  } else {\n    if (this.isSeparated) {\n      result = separatedAmount();\n    } else {\n      if (this.isRetired) {\n        result = retiredAmount();\n      } else {\n        result = normalPayAmount();\n      }\n    }\n  }\n  return result;\n}\n\n// After\nfunction getPayAmount(): number {\n  if (this.isDead) return deadAmount();\n  if (this.isSeparated) return separatedAmount();\n  if (this.isRetired) return retiredAmount();\n  return normalPayAmount();\n}\n```\n\n## Simplifying Method Calls\n\n### Rename Method\n\n**When:** Name of method does not reveal its purpose.\n\n```typescript\n// Before\nclass Customer {\n  getinvcdtlmt(): number { /* ... */ }\n}\n\n// After\nclass Customer {\n  getInvoiceableCreditLimit(): number { /* ... */ }\n}\n```\n\n### Separate Query from Modifier\n\n**When:** Method returns value and has side effects.\n\n```typescript\n// Before\nfunction getTotalOutstandingAndSetReadyForSummaries(): number {\n  this.isReadyForSummaries = true;\n  return this.invoices.reduce((sum, inv) => sum + inv.amount, 0);\n}\n\n// After\nfunction getTotalOutstanding(): number {\n  return this.invoices.reduce((sum, inv) => sum + inv.amount, 0);\n}\n\nfunction setReadyForSummaries(): void {\n  this.isReadyForSummaries = true;\n}\n```\n\n### Replace Parameter with Method Call\n\n**When:** Parameter value can be obtained by called method.\n\n```typescript\n// Before\nconst basePrice = quantity * itemPrice;\nconst discount = getDiscount(basePrice);\nconst finalPrice = applyDiscount(basePrice, discount);\n\n// After\nconst basePrice = quantity * itemPrice;\nconst finalPrice = applyDiscount(basePrice);\n\nfunction applyDiscount(basePrice: number): number {\n  const discount = getDiscount(basePrice);\n  return basePrice - discount;\n}\n```\n\n### Preserve Whole Object\n\n**When:** Getting several values from object to pass as parameters.\n\n```typescript\n// Before\nconst low = room.getTempRange().getLow();\nconst high = room.getTempRange().getHigh();\nconst withinPlan = plan.withinRange(low, high);\n\n// After\nconst withinPlan = plan.withinRange(room.getTempRange());\n```\n\n## Dealing with Generalization\n\n### Pull Up Method\n\n**When:** Methods with identical results on subclasses.\n\n```typescript\n// Before\nclass Salesperson extends Employee {\n  getName(): string { return this.name; }\n}\n\nclass Engineer extends Employee {\n  getName(): string { return this.name; }\n}\n\n// After\nclass Employee {\n  getName(): string { return this.name; }\n}\n\nclass Salesperson extends Employee { }\nclass Engineer extends Employee { }\n```\n\n### Push Down Method\n\n**When:** Behavior on superclass is relevant only for some subclasses.\n\n```typescript\n// Before\nclass Employee {\n  getQuota(): number { /* ... */ }\n}\n\nclass Salesperson extends Employee { }\nclass Engineer extends Employee { }\n\n// After - only Salesperson has quotas\nclass Employee { }\n\nclass Salesperson extends Employee {\n  getQuota(): number { /* ... */ }\n}\n\nclass Engineer extends Employee { }\n```\n\n### Extract Superclass\n\n**When:** Two classes have similar features.\n\n```typescript\n// Before\nclass Department {\n  getName(): string { /* ... */ }\n  getAnnualCost(): number { /* ... */ }\n  getHeadCount(): number { /* ... */ }\n}\n\nclass Employee {\n  getName(): string { /* ... */ }\n  getAnnualCost(): number { /* ... */ }\n  getId(): string { /* ... */ }\n}\n\n// After\nabstract class Party {\n  abstract getName(): string;\n  abstract getAnnualCost(): number;\n}\n\nclass Department extends Party {\n  getName(): string { /* ... */ }\n  getAnnualCost(): number { /* ... */ }\n  getHeadCount(): number { /* ... */ }\n}\n\nclass Employee extends Party {\n  getName(): string { /* ... */ }\n  getAnnualCost(): number { /* ... */ }\n  getId(): string { /* ... */ }\n}\n```\n\n### Replace Inheritance with Delegation\n\n**When:** Subclass uses only part of superclass interface or inheritance isn't appropriate.\n\n```typescript\n// Before\nclass Stack extends ArrayList {\n  push(element: T): void {\n    this.add(element);\n  }\n\n  pop(): T {\n    return this.remove(this.size() - 1);\n  }\n}\n\n// After\nclass Stack {\n  private items: ArrayList = new ArrayList();\n\n  push(element: T): void {\n    this.items.add(element);\n  }\n\n  pop(): T {\n    return this.items.remove(this.items.size() - 1);\n  }\n\n  size(): number {\n    return this.items.size();\n  }\n}\n```\n"
    },
    {
      "name": "refactoring-strategies.md",
      "path": "references/refactoring-strategies.md",
      "content": "# Refactoring Strategies\n\nApproaches for large-scale refactoring and codebase improvement.\n\n## Strategy Selection\n\n| Situation | Strategy |\n|-----------|----------|\n| Small, focused changes | Opportunistic Refactoring |\n| Preparing for a feature | Preparatory Refactoring |\n| Understanding code | Comprehension Refactoring |\n| Cleaning up after feature | Cleanup Refactoring |\n| Large architectural change | Planned Refactoring |\n| Introducing patterns gradually | Strangler Fig |\n| Changing interfaces safely | Expand-Contract |\n\n## Opportunistic Refactoring\n\n**When:** You notice small improvements while working on other code.\n\n**Approach:** \"Leave the code cleaner than you found it.\"\n\n```markdown\n## Example Workflow\n\n1. Working on feature X\n2. Notice poorly named variable\n3. Quick rename (2 minutes)\n4. Continue with feature X\n5. Notice duplicate code\n6. Quick extract method (5 minutes)\n7. Continue with feature X\n8. Commit feature + refactorings together\n```\n\n**Guidelines:**\n- Keep refactorings small (<10 minutes)\n- Don't start if it becomes large\n- Run tests after each refactoring\n- Include in same PR as feature\n\n## Preparatory Refactoring\n\n**When:** Current code structure makes new feature difficult.\n\n**Approach:** \"First make the change easy, then make the easy change.\"\n\n```markdown\n## Example Workflow\n\n1. Feature: Add new payment method\n2. Current code has hardcoded payment logic\n3. Before feature:\n   - Extract PaymentProcessor interface\n   - Move existing logic to StripePaymentProcessor\n   - Add factory for payment processors\n4. Commit refactoring (separate PR)\n5. Now feature is easy:\n   - Add PayPalPaymentProcessor\n   - Register in factory\n6. Commit feature\n```\n\n```typescript\n// Before: Hardcoded Stripe\nfunction processPayment(amount: number, card: CardInfo): void {\n  stripe.charges.create({ amount, source: card.token });\n}\n\n// After preparatory refactoring: Extensible\ninterface PaymentProcessor {\n  process(amount: number, details: PaymentDetails): Promise<PaymentResult>;\n}\n\nclass StripeProcessor implements PaymentProcessor { /* ... */ }\n\n// Now adding PayPal is easy\nclass PayPalProcessor implements PaymentProcessor { /* ... */ }\n```\n\n**Guidelines:**\n- Separate refactoring from feature in commits\n- Consider separate PR for large refactorings\n- Refactoring should make feature trivial to add\n\n## Comprehension Refactoring\n\n**When:** You're trying to understand confusing code.\n\n**Approach:** Refactor as you learn to capture your understanding.\n\n```markdown\n## Example Workflow\n\n1. Reading complex function\n2. \"What does this section do?\"\n3. Extract method with descriptive name\n4. \"Ah, it calculates shipping discount\"\n5. Rename variables as you understand them\n6. Add type annotations where unclear\n7. Now code documents your understanding\n```\n\n```typescript\n// Before: What is this?\nfunction calc(o: any): number {\n  let t = 0;\n  for (const i of o.i) {\n    t += i.p * i.q;\n  }\n  if (o.c && o.c.d > 0) {\n    t = t * (1 - o.c.d);\n  }\n  if (t > 100) {\n    t = t * 0.9;\n  }\n  return t;\n}\n\n// After: Now it's clear\nfunction calculateOrderTotal(order: Order): number {\n  const subtotal = calculateSubtotal(order.items);\n  const afterCoupon = applyCouponDiscount(subtotal, order.coupon);\n  const afterBulk = applyBulkDiscount(afterCoupon);\n  return afterBulk;\n}\n\nfunction calculateSubtotal(items: OrderItem[]): number {\n  return items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n}\n\nfunction applyCouponDiscount(amount: number, coupon?: Coupon): number {\n  if (coupon && coupon.discountPercent > 0) {\n    return amount * (1 - coupon.discountPercent);\n  }\n  return amount;\n}\n\nfunction applyBulkDiscount(amount: number): number {\n  const BULK_THRESHOLD = 100;\n  const BULK_DISCOUNT = 0.1;\n  return amount > BULK_THRESHOLD ? amount * (1 - BULK_DISCOUNT) : amount;\n}\n```\n\n## Branch by Abstraction\n\n**When:** Need to replace a large component that's used everywhere.\n\n**Approach:** Introduce abstraction, migrate gradually, remove old code.\n\n```markdown\n## Steps\n\n1. Create abstraction layer over existing implementation\n2. Change all clients to use abstraction\n3. Create new implementation behind abstraction\n4. Gradually migrate from old to new\n5. Remove old implementation\n```\n\n```typescript\n// Step 1: Create abstraction\ninterface NotificationService {\n  send(user: User, message: string): Promise<void>;\n}\n\n// Step 2: Wrap old implementation\nclass LegacyNotificationAdapter implements NotificationService {\n  async send(user: User, message: string): Promise<void> {\n    oldNotificationSystem.sendEmail(user.email, message);\n  }\n}\n\n// Step 3: Create new implementation\nclass ModernNotificationService implements NotificationService {\n  async send(user: User, message: string): Promise<void> {\n    await this.twilioClient.send(user.phone, message);\n    await this.sendgrid.send(user.email, message);\n  }\n}\n\n// Step 4: Gradual migration with feature flag\nclass NotificationRouter implements NotificationService {\n  async send(user: User, message: string): Promise<void> {\n    if (featureFlags.isEnabled('modern-notifications', user.id)) {\n      await this.modernService.send(user, message);\n    } else {\n      await this.legacyAdapter.send(user, message);\n    }\n  }\n}\n\n// Step 5: After full migration, remove legacy\n```\n\n## Strangler Fig Pattern\n\n**When:** Replacing large legacy system incrementally.\n\n**Approach:** Build new system around the old, gradually strangling it.\n\n```markdown\n## Steps\n\n1. Identify seams in the old system\n2. Build new functionality at the edges\n3. Route some traffic to new system\n4. Gradually expand new system\n5. Eventually replace old system entirely\n```\n\n```\nPhase 1: New facade, old system behind\n┌────────────────────────────────────┐\n│            New Facade              │\n└─────────────────┬──────────────────┘\n                  │\n┌─────────────────▼──────────────────┐\n│          Legacy System             │\n│  ┌──────┐ ┌──────┐ ┌──────┐       │\n│  │Users │ │Orders│ │Payment│       │\n│  └──────┘ └──────┘ └──────┘       │\n└────────────────────────────────────┘\n\nPhase 2: Some functionality migrated\n┌────────────────────────────────────┐\n│            New Facade              │\n└───┬──────────────────┬─────────────┘\n    │                  │\n┌───▼───┐    ┌─────────▼─────────────┐\n│ New   │    │    Legacy System      │\n│ Users │    │  ┌──────┐ ┌──────┐   │\n└───────┘    │  │Orders│ │Payment│   │\n             │  └──────┘ └──────┘   │\n             └───────────────────────┘\n\nPhase 3: Legacy almost gone\n┌────────────────────────────────────┐\n│            New Facade              │\n└───┬────────────┬───────────────────┘\n    │            │\n┌───▼───┐  ┌─────▼────┐  ┌───────────┐\n│ New   │  │   New    │  │  Legacy   │\n│ Users │  │  Orders  │  │  Payment  │\n└───────┘  └──────────┘  └───────────┘\n```\n\n## Expand-Contract (Parallel Change)\n\n**When:** Changing a widely-used interface without breaking clients.\n\n**Approach:** Expand to support both old and new, migrate clients, contract to remove old.\n\n```markdown\n## Steps\n\n1. Expand: Add new interface alongside old\n2. Migrate: Move all clients to new interface\n3. Contract: Remove old interface\n```\n\n```typescript\n// Step 1: EXPAND - Add new method, keep old\nclass UserService {\n  // Old method - still works\n  getUser(userId: string): User {\n    return this.getUserById(userId);\n  }\n\n  // New method - better name, same logic\n  getUserById(userId: string): User {\n    return this.db.users.findById(userId);\n  }\n}\n\n// Step 2: MIGRATE - Update all clients\n// Before: userService.getUser(id)\n// After: userService.getUserById(id)\n\n// Step 3: CONTRACT - Remove old method\nclass UserService {\n  getUserById(userId: string): User {\n    return this.db.users.findById(userId);\n  }\n\n  // getUser removed\n}\n```\n\n**For APIs:**\n\n```typescript\n// Phase 1: Add new field, keep old\ninterface UserResponse {\n  userId: string;      // Old - deprecated\n  user_id: string;     // New - preferred\n}\n\n// Phase 2: Clients migrate to user_id\n\n// Phase 3: Remove userId\ninterface UserResponse {\n  user_id: string;\n}\n```\n\n## Mikado Method\n\n**When:** Complex refactoring with many dependencies.\n\n**Approach:** Try change, record failures, fix dependencies first, repeat.\n\n```markdown\n## Steps\n\n1. Set a goal\n2. Try to achieve it\n3. If it works, done!\n4. If it breaks, note what needs to change first\n5. Revert your changes\n6. Recursively fix prerequisites\n7. Try original goal again\n```\n\n```\nGoal: Extract PaymentService from OrderService\n│\n├── Try: Move payment methods\n│   └── Breaks: OrderService.process() uses PaymentService.charge()\n│       └── Fix first: Make OrderService use dependency injection\n│           │\n│           ├── Try: Add constructor injection\n│           │   └── Breaks: Tests create OrderService without params\n│           │       └── Fix first: Update tests to inject mock\n│           │           └── Done ✓\n│           │\n│           └── Now: Constructor injection works ✓\n│\n└── Now: Extract PaymentService works ✓\n```\n\n## Parallel Run\n\n**When:** Replacing critical system where correctness is essential.\n\n**Approach:** Run both old and new in parallel, compare results.\n\n```typescript\nclass PaymentProcessor {\n  async process(payment: Payment): Promise<Result> {\n    // Run both in parallel\n    const [oldResult, newResult] = await Promise.all([\n      this.legacyProcessor.process(payment),\n      this.newProcessor.process(payment),\n    ]);\n\n    // Compare results\n    if (!this.resultsMatch(oldResult, newResult)) {\n      this.logger.warn('Payment result mismatch', {\n        payment,\n        oldResult,\n        newResult,\n      });\n      // Alert for investigation\n      this.alertService.paymentMismatch(payment);\n    }\n\n    // Use old result until confident\n    return oldResult;\n\n    // After validation period:\n    // return newResult;\n  }\n}\n```\n\n## Feature Toggles for Refactoring\n\n**When:** Gradual rollout of refactored code.\n\n```typescript\nclass OrderService {\n  calculateTotal(order: Order): number {\n    if (featureFlags.isEnabled('new-pricing-engine', order.customerId)) {\n      return this.newPricingEngine.calculate(order);\n    }\n    return this.legacyPricing.calculate(order);\n  }\n}\n\n// Rollout stages:\n// 1. Internal users only\n// 2. 1% of customers\n// 3. 10% of customers\n// 4. 50% of customers\n// 5. 100% of customers\n// 6. Remove flag and legacy code\n```\n\n## Refactoring Planning\n\n### Assessing Refactoring Size\n\n| Size | Duration | Approach |\n|------|----------|----------|\n| Tiny | <30 min | Opportunistic, same commit |\n| Small | 1-4 hours | Same PR as feature or separate small PR |\n| Medium | 1-3 days | Dedicated PR, proper review |\n| Large | 1-2 weeks | Phased approach, multiple PRs |\n| Huge | >2 weeks | Project plan, incremental strategy |\n\n### Refactoring Sprint Planning\n\n```markdown\n## Refactoring Backlog Item\n\n**Title:** Extract PaymentService from OrderService\n\n**Current State:**\n- Payment logic embedded in OrderService\n- 500 lines of mixed concerns\n- Hard to test payment logic in isolation\n\n**Target State:**\n- Separate PaymentService class\n- Clear interface between services\n- Payment logic testable independently\n\n**Approach:**\n1. Add characterization tests for payment behavior\n2. Extract PaymentProcessor interface\n3. Move payment methods to new class\n4. Update OrderService to use PaymentService\n5. Remove duplication\n\n**Estimated Effort:** 3 points\n**Risk:** Medium (touches payment flow)\n**Dependencies:** None\n\n**Acceptance Criteria:**\n- [ ] All existing tests pass\n- [ ] Payment logic in separate service\n- [ ] New unit tests for PaymentService\n- [ ] No functional changes\n```\n"
    }
  ],
  "tags": [
    "quality",
    "refactoring",
    "improvement",
    "code-quality"
  ],
  "dependsOn": [
    "implement"
  ]
}