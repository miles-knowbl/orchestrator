{
  "id": "security-audit",
  "name": "security-audit",
  "version": "1.0.0",
  "description": "Perform comprehensive security analysis of code and systems. Identifies vulnerabilities including injection attacks, authentication flaws, data exposure, and misconfigurations. Follows OWASP guidelines and security best practices. Provides actionable remediation guidance.",
  "phase": "VALIDATE",
  "category": "engineering",
  "content": "# Security Audit\n\nIdentify and remediate security vulnerabilities.\n\n## When to Use\n\n- **New feature** — Security review before release\n- **Authentication changes** — Any auth/authz modifications\n- **Data handling** — Code that processes sensitive data\n- **External inputs** — APIs, file uploads, user inputs\n- **Dependencies** — New or updated third-party packages\n- **Pre-production** — Security gate before deployment\n- When you say: \"security review\", \"check for vulnerabilities\", \"audit this code\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `owasp-top-10.md` | Comprehensive vulnerability categories |\n| `vulnerability-patterns.md` | Common vulnerability patterns to check |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `remediation-patterns.md` | When fixing found vulnerabilities |\n| `secure-code-review.md` | When reviewing code for security |\n| `dependency-security.md` | When auditing dependencies |\n\n**Verification:** All OWASP Top 10 categories must be addressed in audit.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `SECURITY-AUDIT.md` | Project root | Always |\n\n## Core Concept\n\nSecurity audit answers: **\"How could an attacker exploit this system?\"**\n\nThink like an attacker:\n- What inputs can I control?\n- What data can I access?\n- What actions can I perform?\n- What assumptions can I violate?\n\nSecurity is about:\n- **Confidentiality** — Preventing unauthorized data access\n- **Integrity** — Preventing unauthorized data modification\n- **Availability** — Preventing service disruption\n\n## The Security Audit Process\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                SECURITY AUDIT PROCESS                   │\n│                                                         │\n│  1. UNDERSTAND THE SYSTEM                               │\n│     └─→ Architecture, data flows, trust boundaries      │\n│                                                         │\n│  2. IDENTIFY ATTACK SURFACE                             │\n│     └─→ Entry points, data inputs, external interfaces  │\n│                                                         │\n│  3. THREAT MODELING                                     │\n│     └─→ Who attacks? What do they want? How?            │\n│                                                         │\n│  4. VULNERABILITY ANALYSIS                              │\n│     └─→ OWASP Top 10, code patterns, dependencies       │\n│                                                         │\n│  5. RISK ASSESSMENT                                     │\n│     └─→ Severity, likelihood, impact                    │\n│                                                         │\n│  6. REMEDIATION PLANNING                                │\n│     └─→ Fixes, mitigations, defense in depth            │\n│                                                         │\n│  7. VERIFICATION                                        │\n│     └─→ Test fixes, regression testing                  │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Step 1: Understand the System\n\n### System Analysis Checklist\n\n```markdown\n## Architecture\n- [ ] What components exist? (frontend, API, database, cache)\n- [ ] How do components communicate?\n- [ ] What are the trust boundaries?\n- [ ] Where is sensitive data stored?\n\n## Data Classification\n- [ ] What data is collected? (PII, credentials, financial)\n- [ ] Where does data flow?\n- [ ] How is data protected at rest?\n- [ ] How is data protected in transit?\n\n## Authentication & Authorization\n- [ ] How do users authenticate?\n- [ ] How are sessions managed?\n- [ ] What authorization model is used?\n- [ ] What are the privilege levels?\n\n## External Dependencies\n- [ ] What third-party services are used?\n- [ ] What libraries/packages are included?\n- [ ] What APIs are consumed?\n```\n\n### Data Flow Diagram\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    TRUST BOUNDARY                       │\n│  ┌─────────┐                          ┌─────────────┐  │\n│  │ Browser │──HTTPS──▶│ API Gateway │──▶│ Auth Service│  │\n│  └─────────┘          └──────┬──────┘  └─────────────┘  │\n│       │                      │                          │\n│       │                      ▼                          │\n│       │               ┌─────────────┐                   │\n│       │               │ App Server  │                   │\n│       │               └──────┬──────┘                   │\n│       │                      │                          │\n│       │         ┌────────────┼────────────┐            │\n│       │         ▼            ▼            ▼            │\n│       │    ┌────────┐  ┌──────────┐  ┌─────────┐      │\n│       │    │Database│  │  Cache   │  │  Queue  │      │\n│       │    └────────┘  └──────────┘  └─────────┘      │\n└───────│─────────────────────────────────────────────────┘\n        │\n        ▼\n   [Attacker Entry Point]\n```\n\n## Step 2: Identify Attack Surface\n\n### Attack Surface Components\n\n| Component | Attack Vectors |\n|-----------|----------------|\n| **Web forms** | XSS, CSRF, injection |\n| **API endpoints** | Auth bypass, injection, DoS |\n| **File uploads** | Malware, path traversal, DoS |\n| **URL parameters** | Injection, IDOR, open redirect |\n| **Cookies/headers** | Session hijacking, injection |\n| **WebSockets** | Auth bypass, injection |\n| **Database queries** | SQL injection |\n| **System commands** | Command injection |\n| **File operations** | Path traversal |\n| **Deserialization** | Remote code execution |\n\n### Entry Point Inventory\n\n```markdown\n## API Endpoints\n| Endpoint | Method | Auth | Input | Risk |\n|----------|--------|------|-------|------|\n| /api/users | POST | None | JSON body | High - User creation |\n| /api/users/:id | GET | JWT | URL param | Medium - IDOR risk |\n| /api/upload | POST | JWT | File | High - File upload |\n| /api/search | GET | None | Query string | Medium - Injection |\n\n## User Inputs\n| Input | Type | Validation | Sanitization |\n|-------|------|------------|--------------|\n| email | String | Regex | HTML escape |\n| comment | String | Length | Markdown only |\n| file | Binary | Type check | Virus scan |\n```\n\n## Step 3: Threat Modeling\n\n### STRIDE Model\n\n| Threat | Description | Example |\n|--------|-------------|---------|\n| **S**poofing | Pretending to be someone else | Forged authentication |\n| **T**ampering | Modifying data or code | SQL injection |\n| **R**epudiation | Denying actions taken | Missing audit logs |\n| **I**nformation Disclosure | Exposing data | Error messages with stack traces |\n| **D**enial of Service | Making system unavailable | Resource exhaustion |\n| **E**levation of Privilege | Gaining unauthorized access | Admin bypass |\n\n### Threat Scenarios\n\n```markdown\n## Threat: Account Takeover\n- **Attacker**: External malicious user\n- **Goal**: Access other users' accounts\n- **Method**: \n  - Credential stuffing\n  - Password reset exploitation\n  - Session hijacking\n- **Impact**: High - Full account access\n- **Mitigations**:\n  - Rate limiting\n  - MFA\n  - Secure password reset flow\n\n## Threat: Data Exfiltration\n- **Attacker**: Malicious insider or external attacker\n- **Goal**: Steal sensitive user data\n- **Method**:\n  - SQL injection\n  - IDOR vulnerabilities\n  - API abuse\n- **Impact**: Critical - Data breach, compliance violation\n- **Mitigations**:\n  - Input validation\n  - Authorization checks\n  - Data encryption\n```\n\n## Step 4: Vulnerability Analysis\n\n### OWASP Top 10 (2021)\n\n| # | Vulnerability | Description |\n|---|---------------|-------------|\n| A01 | **Broken Access Control** | Users act outside intended permissions |\n| A02 | **Cryptographic Failures** | Weak/missing encryption |\n| A03 | **Injection** | Hostile data sent to interpreter |\n| A04 | **Insecure Design** | Missing security controls |\n| A05 | **Security Misconfiguration** | Improper settings |\n| A06 | **Vulnerable Components** | Known vulnerabilities in dependencies |\n| A07 | **Auth Failures** | Broken authentication |\n| A08 | **Data Integrity Failures** | Untrusted deserialization, CI/CD issues |\n| A09 | **Logging Failures** | Insufficient logging/monitoring |\n| A10 | **SSRF** | Server-side request forgery |\n\n→ See `references/owasp-top-10.md`\n\n### Code Review Security Checklist\n\n```markdown\n## Input Validation\n- [ ] All user input validated on server side\n- [ ] Input length limits enforced\n- [ ] Input type/format validated\n- [ ] Allow-lists preferred over deny-lists\n\n## Output Encoding\n- [ ] HTML output escaped\n- [ ] JSON output properly encoded\n- [ ] SQL queries parameterized\n- [ ] Shell commands escaped\n\n## Authentication\n- [ ] Passwords properly hashed (bcrypt/argon2)\n- [ ] Session tokens sufficiently random\n- [ ] Session expiration implemented\n- [ ] Password requirements enforced\n\n## Authorization\n- [ ] Every endpoint checks authorization\n- [ ] No direct object references without checks\n- [ ] Principle of least privilege applied\n- [ ] Admin functions properly protected\n\n## Data Protection\n- [ ] Sensitive data encrypted at rest\n- [ ] TLS used for all communications\n- [ ] Secrets not in source code\n- [ ] PII handled according to policy\n\n## Error Handling\n- [ ] Errors don't leak sensitive info\n- [ ] Generic error messages to users\n- [ ] Detailed errors logged securely\n- [ ] Fail securely (deny by default)\n```\n\n→ See `references/secure-code-review.md`\n\n## Step 5: Risk Assessment\n\n### Severity Rating\n\n| Severity | CVSS Score | Description |\n|----------|------------|-------------|\n| **Critical** | 9.0-10.0 | Immediate exploitation, severe impact |\n| **High** | 7.0-8.9 | Easily exploitable, significant impact |\n| **Medium** | 4.0-6.9 | Some exploitation difficulty, moderate impact |\n| **Low** | 0.1-3.9 | Difficult to exploit, minimal impact |\n| **Info** | 0.0 | Best practice, no direct security impact |\n\n### Risk Matrix\n\n```\n                    IMPACT\n                Low    Med    High   Crit\n           ┌────────────────────────────────\n     High  │  Med    High   Crit   Crit\nLIKELIHOOD │\n     Med   │  Low    Med    High   Crit\n           │\n     Low   │  Low    Low    Med    High\n```\n\n### Vulnerability Report Format\n\n```markdown\n## VULN-001: SQL Injection in User Search\n\n### Summary\nThe user search endpoint is vulnerable to SQL injection through\nthe `query` parameter, allowing attackers to extract database contents.\n\n### Severity: Critical (CVSS 9.8)\n\n### Location\n- File: `src/api/users/search.ts`\n- Line: 45\n- Endpoint: `GET /api/users/search?query=`\n\n### Vulnerable Code\n```typescript\nconst users = await db.query(\n  `SELECT * FROM users WHERE name LIKE '%${query}%'`\n);\n```\n\n### Proof of Concept\n```\nGET /api/users/search?query=' OR '1'='1' --\n```\n\n### Impact\n- Full database read access\n- Potential data exfiltration\n- Possible privilege escalation\n\n### Remediation\nUse parameterized queries:\n```typescript\nconst users = await db.query(\n  'SELECT * FROM users WHERE name LIKE $1',\n  [`%${query}%`]\n);\n```\n\n### References\n- CWE-89: SQL Injection\n- OWASP SQL Injection Prevention\n```\n\n## Step 6: Remediation Planning\n\n### Remediation Priority\n\n| Priority | Timeline | Criteria |\n|----------|----------|----------|\n| **P0** | Immediate | Critical severity, actively exploited |\n| **P1** | < 24 hours | Critical/High, easily exploitable |\n| **P2** | < 1 week | High/Medium, requires specific conditions |\n| **P3** | < 1 month | Medium/Low, defense in depth |\n| **P4** | Backlog | Low/Info, best practices |\n\n### Defense in Depth\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                  DEFENSE IN DEPTH                       │\n│                                                         │\n│  Layer 1: PERIMETER                                     │\n│  └─→ WAF, DDoS protection, rate limiting                │\n│                                                         │\n│  Layer 2: NETWORK                                       │\n│  └─→ Firewalls, network segmentation, TLS               │\n│                                                         │\n│  Layer 3: APPLICATION                                   │\n│  └─→ Input validation, output encoding, auth            │\n│                                                         │\n│  Layer 4: DATA                                          │\n│  └─→ Encryption, access controls, masking               │\n│                                                         │\n│  Layer 5: MONITORING                                    │\n│  └─→ Logging, alerting, incident response               │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### Common Fixes\n\n| Vulnerability | Fix |\n|---------------|-----|\n| SQL Injection | Parameterized queries |\n| XSS | Context-aware output encoding |\n| CSRF | CSRF tokens, SameSite cookies |\n| Auth Bypass | Centralized auth middleware |\n| IDOR | Authorization checks on every request |\n| Sensitive Data | Encryption, tokenization |\n| Hardcoded Secrets | Environment variables, secret managers |\n| Vulnerable Deps | Update, patch, or replace |\n\n→ See `references/remediation-patterns.md`\n\n## Step 7: Verification\n\n### Security Testing\n\n```markdown\n## Verification Checklist\n\n### Automated Testing\n- [ ] SAST (Static Analysis) scan passes\n- [ ] DAST (Dynamic Analysis) scan passes\n- [ ] Dependency vulnerability scan passes\n- [ ] Security unit tests pass\n\n### Manual Testing\n- [ ] Attempted to exploit original vulnerability\n- [ ] Tested edge cases and bypasses\n- [ ] Verified fix doesn't introduce new issues\n- [ ] Tested related functionality\n\n### Regression Testing\n- [ ] Existing security tests still pass\n- [ ] Functionality not broken by fix\n- [ ] Performance not degraded\n```\n\n### Security Test Cases\n\n```typescript\ndescribe('SQL Injection Prevention', () => {\n  it('rejects SQL injection in search query', async () => {\n    const response = await request(app)\n      .get('/api/users/search')\n      .query({ query: \"' OR '1'='1\" });\n    \n    // Should not return all users\n    expect(response.body.length).toBeLessThan(100);\n  });\n  \n  it('properly escapes special characters', async () => {\n    const response = await request(app)\n      .get('/api/users/search')\n      .query({ query: \"O'Brien\" });\n    \n    expect(response.status).toBe(200);\n    // Should find users with apostrophes in name\n  });\n});\n\ndescribe('XSS Prevention', () => {\n  it('escapes HTML in user-generated content', async () => {\n    await createUser({ name: '<script>alert(1)</script>' });\n    \n    const response = await request(app).get('/api/users/1');\n    \n    expect(response.body.name).not.toContain('<script>');\n    expect(response.body.name).toContain('&lt;script&gt;');\n  });\n});\n\ndescribe('Authorization', () => {\n  it('prevents accessing other users data', async () => {\n    const user1Token = await loginAs('user1');\n    \n    const response = await request(app)\n      .get('/api/users/user2/profile')\n      .set('Authorization', `Bearer ${user1Token}`);\n    \n    expect(response.status).toBe(403);\n  });\n});\n```\n\n## Common Vulnerability Patterns\n\n### Injection Vulnerabilities\n\n```typescript\n// SQL INJECTION - BAD\nconst user = await db.query(`SELECT * FROM users WHERE id = '${userId}'`);\n\n// SQL INJECTION - GOOD\nconst user = await db.query('SELECT * FROM users WHERE id = $1', [userId]);\n\n// COMMAND INJECTION - BAD\nexec(`convert ${filename} output.png`);\n\n// COMMAND INJECTION - GOOD\nexecFile('convert', [filename, 'output.png']);\n\n// NOSQL INJECTION - BAD\ndb.users.find({ username: req.body.username, password: req.body.password });\n\n// NOSQL INJECTION - GOOD\ndb.users.find({ \n  username: String(req.body.username), \n  password: String(req.body.password) \n});\n```\n\n### Authentication Vulnerabilities\n\n```typescript\n// TIMING ATTACK - BAD\nif (password === storedPassword) { /* ... */ }\n\n// TIMING ATTACK - GOOD\nif (crypto.timingSafeEqual(Buffer.from(password), Buffer.from(storedPassword))) { /* ... */ }\n\n// WEAK PASSWORD HASH - BAD\nconst hash = crypto.createHash('md5').update(password).digest('hex');\n\n// STRONG PASSWORD HASH - GOOD\nconst hash = await bcrypt.hash(password, 12);\n\n// INSECURE SESSION - BAD\nconst sessionId = `user_${Date.now()}`;\n\n// SECURE SESSION - GOOD\nconst sessionId = crypto.randomBytes(32).toString('hex');\n```\n\n### Authorization Vulnerabilities\n\n```typescript\n// IDOR - BAD\napp.get('/api/documents/:id', async (req, res) => {\n  const doc = await Document.findById(req.params.id);\n  res.json(doc); // No ownership check!\n});\n\n// IDOR - GOOD\napp.get('/api/documents/:id', async (req, res) => {\n  const doc = await Document.findOne({\n    _id: req.params.id,\n    ownerId: req.user.id  // Ownership check\n  });\n  if (!doc) return res.status(404).json({ error: 'Not found' });\n  res.json(doc);\n});\n\n// PRIVILEGE ESCALATION - BAD\napp.post('/api/users', async (req, res) => {\n  const user = await User.create(req.body); // Accepts role from input!\n});\n\n// PRIVILEGE ESCALATION - GOOD\napp.post('/api/users', async (req, res) => {\n  const { email, name, password } = req.body;\n  const user = await User.create({ \n    email, name, password,\n    role: 'user'  // Always set role server-side\n  });\n});\n```\n\n→ See `references/vulnerability-patterns.md`\n\n## Dependency Security\n\n### Checking Dependencies\n\n```bash\n# npm audit\nnpm audit\nnpm audit fix\n\n# Snyk\nsnyk test\nsnyk monitor\n\n# OWASP Dependency Check\ndependency-check --project MyProject --scan ./\n```\n\n### Dependency Policy\n\n```markdown\n## Dependency Security Policy\n\n### Before Adding\n- [ ] Check for known vulnerabilities\n- [ ] Review maintainer activity\n- [ ] Assess dependency count (prefer fewer)\n- [ ] Check license compatibility\n\n### Ongoing\n- [ ] Run `npm audit` in CI\n- [ ] Update dependencies monthly\n- [ ] Subscribe to security advisories\n- [ ] Have process for emergency patches\n```\n\n→ See `references/dependency-security.md`\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `code-review` | Security is part of review checklist |\n| `architect` | Security architecture decisions |\n| `implement` | Secure coding practices |\n| `code-verification` | Security linting rules |\n| `test-generation` | Security test cases |\n| `spec` | Security requirements in specs |\n\n## Key Principles\n\n**Defense in depth.** Multiple layers of protection.\n\n**Least privilege.** Minimum permissions necessary.\n\n**Fail secure.** Deny by default on errors.\n\n**Don't trust input.** Validate everything from outside trust boundary.\n\n**Keep secrets secret.** Never in code, logs, or error messages.\n\n**Stay updated.** Patch vulnerabilities promptly.\n\n## Mode-Specific Behavior\n\nSecurity audit scope and requirements differ by orchestrator mode:\n\n### Greenfield Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Full system audit |\n| **Approach** | Comprehensive—all OWASP Top 10 categories |\n| **Patterns** | Free choice—establish security baseline |\n| **Deliverables** | Full SECURITY-AUDIT.md |\n| **Validation** | Standard—all dependencies audited |\n| **Constraints** | Minimal—blocks SHIP phase on findings |\n\n### Brownfield-Polish Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Gap-specific + integration points |\n| **Approach** | Extend existing—categories relevant to gap |\n| **Patterns** | Should match existing security patterns |\n| **Deliverables** | Delta security assessment |\n| **Validation** | Existing controls + new gap coverage |\n| **Constraints** | Don't weaken existing security—blocks gap completion |\n\n**Polish considerations:**\n- Does gap introduce new attack surface?\n- Are existing security patterns followed?\n- Do new dependencies have vulnerabilities?\n- Does gap affect auth/authz?\n- Is sensitive data handling consistent?\n\n### Brownfield-Enterprise Mode\n\n| Aspect | Behavior |\n|--------|----------|\n| **Scope** | Change impact only |\n| **Approach** | Surgical—all OWASP categories mandatory |\n| **Patterns** | Must conform exactly—no security control changes |\n| **Deliverables** | Security impact assessment with sign-off |\n| **Validation** | Full regression + penetration testing may be required |\n| **Constraints** | Requires approval—security team must sign off |\n\n**Enterprise security requirements:**\n- Security audit is mandatory for all changes\n- Security team must approve before merge\n- Any security finding blocks deployment\n- Penetration testing may be required\n- Compliance documentation required\n\n**Enterprise security checklist:**\n- [ ] Change reviewed against all OWASP categories\n- [ ] No new vulnerabilities introduced\n- [ ] Existing security controls not weakened\n- [ ] Security team sign-off obtained\n- [ ] Compliance requirements verified\n\n**Enterprise security sign-off:**\n```markdown\n## Security Approval: CR-12345\n\n**Reviewed by:** Security Team\n**Date:** 2024-01-17\n**Decision:** APPROVED / APPROVED WITH CONDITIONS / REJECTED\n\n**Findings:** None / [List findings]\n**Conditions:** None / [List conditions]\n```\n\n---\n\n## References\n\n- `references/owasp-top-10.md`: Detailed OWASP Top 10 analysis\n- `references/secure-code-review.md`: Security-focused code review\n- `references/vulnerability-patterns.md`: Common vulnerabilities and fixes\n- `references/remediation-patterns.md`: Remediation strategies\n- `references/dependency-security.md`: Third-party dependency security",
  "references": [
    {
      "name": "dependency-security.md",
      "path": "references/dependency-security.md",
      "content": "# Dependency Security\n\nManaging security risks from third-party dependencies.\n\n## The Dependency Risk\n\nModern applications use hundreds of dependencies. Each dependency:\n- May contain vulnerabilities\n- May be abandoned or unmaintained\n- May have its own vulnerable dependencies\n- Could be compromised (supply chain attack)\n\n## Vulnerability Scanning\n\n### npm audit\n\n```bash\n# Run audit\nnpm audit\n\n# Fix automatically where possible\nnpm audit fix\n\n# Force fix (may have breaking changes)\nnpm audit fix --force\n\n# Generate JSON report\nnpm audit --json > audit-report.json\n\n# Check specific severity\nnpm audit --audit-level=high\n```\n\n### Snyk\n\n```bash\n# Install\nnpm install -g snyk\n\n# Authenticate\nsnyk auth\n\n# Test for vulnerabilities\nsnyk test\n\n# Monitor project (continuous)\nsnyk monitor\n\n# Test specific file\nsnyk test --file=package.json\n\n# Ignore specific vulnerability\nsnyk ignore --id=SNYK-JS-LODASH-567746\n```\n\n### GitHub Dependabot\n\n```yaml\n# .github/dependabot.yml\nversion: 2\nupdates:\n  - package-ecosystem: \"npm\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n    open-pull-requests-limit: 10\n    reviewers:\n      - \"security-team\"\n    labels:\n      - \"dependencies\"\n      - \"security\"\n    ignore:\n      # Ignore major version updates for stability\n      - dependency-name: \"*\"\n        update-types: [\"version-update:semver-major\"]\n```\n\n### OWASP Dependency-Check\n\n```bash\n# Docker\ndocker run --rm \\\n  -v $(pwd):/src \\\n  owasp/dependency-check \\\n  --scan /src \\\n  --format HTML \\\n  --out /src/report\n\n# In CI pipeline\ndependency-check --project \"MyApp\" --scan . --format JSON\n```\n\n## CI/CD Integration\n\n### GitHub Actions\n\n```yaml\n# .github/workflows/security.yml\nname: Security Scan\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n  schedule:\n    - cron: '0 0 * * 0'  # Weekly\n\njobs:\n  audit:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          \n      - name: Install dependencies\n        run: npm ci\n        \n      - name: Run npm audit\n        run: npm audit --audit-level=high\n        \n      - name: Run Snyk\n        uses: snyk/actions/node@master\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n        with:\n          args: --severity-threshold=high\n```\n\n### Pre-commit Hook\n\n```bash\n#!/bin/sh\n# .husky/pre-commit\n\n# Run npm audit before commit\nnpm audit --audit-level=high\nif [ $? -ne 0 ]; then\n  echo \"Security vulnerabilities found. Fix before committing.\"\n  exit 1\nfi\n```\n\n## Dependency Evaluation\n\n### Before Adding a Dependency\n\n| Check | How | Why |\n|-------|-----|-----|\n| Vulnerabilities | `npm audit`, Snyk | Known security issues |\n| Maintenance | GitHub activity | Abandoned = no patches |\n| Popularity | npm downloads | More eyes = more scrutiny |\n| Dependencies | `npm ls` | Transitive risk |\n| License | package.json | Legal compliance |\n| Size | bundlephobia.com | Attack surface |\n\n### Evaluation Checklist\n\n```markdown\n## New Dependency Evaluation: [package-name]\n\n### Security\n- [ ] No known vulnerabilities (npm audit, Snyk)\n- [ ] Maintainer has security policy\n- [ ] Package has been audited (if critical)\n\n### Maintenance\n- [ ] Last commit within 6 months\n- [ ] Responds to issues/PRs\n- [ ] Has multiple maintainers\n- [ ] Clear release process\n\n### Quality\n- [ ] Has tests\n- [ ] TypeScript support\n- [ ] Documentation exists\n- [ ] Used by reputable projects\n\n### Risk Assessment\n- [ ] Minimal permissions required\n- [ ] Reasonable dependency count\n- [ ] No eval() or similar dangers\n- [ ] No suspicious post-install scripts\n\n### Decision\n- [ ] APPROVED / REJECTED\n- Reason: _______________\n- Alternatives considered: _______________\n```\n\n## Lock Files\n\n### Why Lock Files Matter\n\n```bash\n# package.json might say:\n\"lodash\": \"^4.17.0\"\n\n# But without lock file, you might get:\n# - 4.17.0 (old, vulnerable)\n# - 4.17.21 (current, patched)\n# - 4.18.0 (future, unknown)\n\n# Lock file pins exact versions\n```\n\n### Best Practices\n\n```bash\n# Always commit lock files\ngit add package-lock.json\n\n# Use npm ci in CI/CD (respects lock file exactly)\nnpm ci  # Not npm install\n\n# Regenerate lock file carefully\nrm package-lock.json\nnpm install\nnpm audit\ngit diff package-lock.json  # Review changes\n```\n\n## Dependency Pinning\n\n### Version Strategies\n\n```json\n{\n  \"dependencies\": {\n    // Exact version (most secure, most maintenance)\n    \"express\": \"4.18.2\",\n    \n    // Allow patches (balance of security and updates)\n    \"lodash\": \"~4.17.21\",\n    \n    // Allow minor versions (convenient but riskier)\n    \"axios\": \"^1.6.0\",\n    \n    // Never use in production\n    \"debug\": \"*\",\n    \"dev-tool\": \"latest\"\n  }\n}\n```\n\n### Recommended Approach\n\n```json\n{\n  \"dependencies\": {\n    // Production: Allow patches only\n    \"express\": \"~4.18.2\",\n    \"pg\": \"~8.11.0\"\n  },\n  \"devDependencies\": {\n    // Dev: Allow minor versions\n    \"typescript\": \"^5.0.0\",\n    \"jest\": \"^29.0.0\"\n  }\n}\n```\n\n## Supply Chain Attacks\n\n### Attack Vectors\n\n| Attack | Description | Example |\n|--------|-------------|---------|\n| Typosquatting | Similar package names | `lodash` vs `1odash` |\n| Dependency Confusion | Public package same name as private | Internal `auth` package |\n| Compromised Maintainer | Account takeover | event-stream incident |\n| Malicious Code | Hidden in install scripts | Cryptominers |\n\n### Protections\n\n```bash\n# 1. Verify package authenticity\nnpm view lodash\n# Check: maintainers, repository, homepage\n\n# 2. Check install scripts\nnpm show [package] scripts\n# Be suspicious of preinstall/postinstall\n\n# 3. Use scoped packages for internal\n@mycompany/auth  # Can't be confused with public\n\n# 4. Enable package-lock\nnpm config set package-lock true\n\n# 5. Use npm provenance (when available)\nnpm publish --provenance\n```\n\n### Registry Security\n\n```bash\n# Use private registry for internal packages\nnpm config set @mycompany:registry https://npm.mycompany.com\n\n# Audit registry configuration\nnpm config list\n\n# Consider registry mirroring for air-gapped environments\n```\n\n## Handling Vulnerabilities\n\n### Triage Process\n\n```markdown\n## Vulnerability Triage\n\n1. **Assess Severity**\n   - Critical/High: Immediate action\n   - Medium: Plan for this sprint\n   - Low: Backlog\n\n2. **Determine Exploitability**\n   - Is the vulnerable code path used?\n   - Is it reachable from untrusted input?\n   - Are there mitigating controls?\n\n3. **Find Remediation**\n   - Update to patched version\n   - Use alternative package\n   - Apply workaround\n   - Accept risk (document decision)\n\n4. **Verify Fix**\n   - Run audit again\n   - Test functionality\n   - Deploy to staging first\n```\n\n### Remediation Options\n\n```bash\n# Option 1: Update package\nnpm update lodash\n\n# Option 2: Update to specific version\nnpm install lodash@4.17.21\n\n# Option 3: Force resolution (for transitive deps)\n# Add to package.json:\n{\n  \"overrides\": {\n    \"vulnerable-package\": \"^2.0.0\"\n  }\n}\n\n# Option 4: Replace package\nnpm uninstall vulnerable-package\nnpm install alternative-package\n\n# Option 5: Fork and patch (last resort)\n# Fork to your org, apply patch, use forked version\n```\n\n### Documentation\n\n```markdown\n## Security Decision Record\n\n**Package:** minimist\n**Vulnerability:** CVE-2021-44906 (Prototype Pollution)\n**Severity:** Critical\n**CVSS:** 9.8\n\n**Analysis:**\n- minimist is a transitive dependency of mkdirp\n- We don't use the vulnerable function directly\n- Input to minimist comes from our CLI args only\n- No untrusted input reaches minimist\n\n**Decision:** Accept risk for 30 days\n**Reason:** Breaking change in update, need testing time\n**Mitigation:** Input validation on CLI arguments\n**Review Date:** 2024-02-15\n\n**Approved By:** @security-lead\n**Date:** 2024-01-15\n```\n\n## Dependency Updates\n\n### Update Strategy\n\n```markdown\n## Monthly Dependency Update Process\n\n### Week 1: Assessment\n- [ ] Run `npm outdated`\n- [ ] Run `npm audit`\n- [ ] Review Dependabot PRs\n- [ ] Categorize updates (security, features, chores)\n\n### Week 2: Security Updates\n- [ ] Apply all security patches\n- [ ] Test in staging\n- [ ] Deploy to production\n- [ ] Monitor for issues\n\n### Week 3: Minor Updates\n- [ ] Apply non-breaking updates\n- [ ] Run full test suite\n- [ ] Deploy if tests pass\n\n### Week 4: Major Updates\n- [ ] Evaluate breaking changes\n- [ ] Update code if needed\n- [ ] Schedule for next release\n```\n\n### Automated Updates\n\n```yaml\n# Renovate configuration (alternative to Dependabot)\n# renovate.json\n{\n  \"$schema\": \"https://docs.renovatebot.com/renovate-schema.json\",\n  \"extends\": [\n    \"config:base\",\n    \":semanticCommits\",\n    \"group:recommended\"\n  ],\n  \"vulnerabilityAlerts\": {\n    \"enabled\": true,\n    \"labels\": [\"security\"]\n  },\n  \"packageRules\": [\n    {\n      \"matchUpdateTypes\": [\"patch\"],\n      \"automerge\": true\n    },\n    {\n      \"matchDepTypes\": [\"devDependencies\"],\n      \"automerge\": true\n    }\n  ]\n}\n```\n\n## Monitoring\n\n### Continuous Monitoring\n\n```typescript\n// Scheduled job to check for new vulnerabilities\nimport { exec } from 'child_process';\nimport { WebhookClient } from 'discord.js';\n\nasync function checkVulnerabilities() {\n  return new Promise((resolve, reject) => {\n    exec('npm audit --json', (error, stdout) => {\n      const result = JSON.parse(stdout);\n      \n      if (result.metadata.vulnerabilities.high > 0 || \n          result.metadata.vulnerabilities.critical > 0) {\n        // Alert security team\n        alertSecurityTeam(result);\n      }\n      \n      resolve(result);\n    });\n  });\n}\n\n// Run daily\ncron.schedule('0 9 * * *', checkVulnerabilities);\n```\n\n### Metrics to Track\n\n| Metric | Target | Action if Exceeded |\n|--------|--------|-------------------|\n| Critical vulns | 0 | Immediate fix |\n| High vulns | <3 | Fix within 7 days |\n| Medium vulns | <10 | Fix within 30 days |\n| Outdated deps | <20% | Monthly updates |\n| Avg dependency age | <6 months | Review and update |\n"
    },
    {
      "name": "owasp-top-10.md",
      "path": "references/owasp-top-10.md",
      "content": "# OWASP Top 10\n\nDetailed analysis of the OWASP Top 10 Web Application Security Risks (2021).\n\n## A01: Broken Access Control\n\n### Description\nUsers can act outside their intended permissions. This includes accessing other users' data, modifying data without permission, and privilege escalation.\n\n### Common Vulnerabilities\n\n**Insecure Direct Object Reference (IDOR)**\n```typescript\n// VULNERABLE: No ownership check\napp.get('/api/orders/:id', async (req, res) => {\n  const order = await Order.findById(req.params.id);\n  res.json(order);\n});\n\n// SECURE: Verify ownership\napp.get('/api/orders/:id', async (req, res) => {\n  const order = await Order.findOne({\n    _id: req.params.id,\n    customerId: req.user.id\n  });\n  if (!order) return res.status(404).json({ error: 'Not found' });\n  res.json(order);\n});\n```\n\n**Missing Function-Level Access Control**\n```typescript\n// VULNERABLE: No role check\napp.delete('/api/users/:id', async (req, res) => {\n  await User.findByIdAndDelete(req.params.id);\n  res.status(204).send();\n});\n\n// SECURE: Role-based access\napp.delete('/api/users/:id', requireRole('admin'), async (req, res) => {\n  await User.findByIdAndDelete(req.params.id);\n  res.status(204).send();\n});\n```\n\n**Path Traversal**\n```typescript\n// VULNERABLE: User controls file path\napp.get('/files/:filename', (req, res) => {\n  res.sendFile(`/uploads/${req.params.filename}`);\n});\n// Attack: GET /files/../../../etc/passwd\n\n// SECURE: Validate and sanitize\napp.get('/files/:filename', (req, res) => {\n  const filename = path.basename(req.params.filename);\n  const filepath = path.join('/uploads', filename);\n  \n  if (!filepath.startsWith('/uploads/')) {\n    return res.status(400).json({ error: 'Invalid path' });\n  }\n  res.sendFile(filepath);\n});\n```\n\n### Prevention\n- Deny by default except for public resources\n- Implement access control once, reuse everywhere\n- Log access control failures, alert on repeated failures\n- Disable directory listing\n- Use server-side sessions for access control\n\n## A02: Cryptographic Failures\n\n### Description\nFailures related to cryptography that lead to sensitive data exposure. Includes weak algorithms, improper key management, and missing encryption.\n\n### Common Vulnerabilities\n\n**Weak Password Hashing**\n```typescript\n// VULNERABLE: MD5/SHA1 without salt\nconst hash = crypto.createHash('md5').update(password).digest('hex');\n\n// SECURE: bcrypt with appropriate cost\nconst hash = await bcrypt.hash(password, 12);\n```\n\n**Missing Encryption at Rest**\n```typescript\n// VULNERABLE: Plain text sensitive data\nawait db.users.insert({ ssn: '123-45-6789' });\n\n// SECURE: Encrypted sensitive fields\nconst encryptedSSN = encrypt(ssn, process.env.ENCRYPTION_KEY);\nawait db.users.insert({ ssn: encryptedSSN });\n```\n\n**Weak TLS Configuration**\n```typescript\n// VULNERABLE: Allows weak protocols\nconst server = https.createServer({\n  cert: fs.readFileSync('cert.pem'),\n  key: fs.readFileSync('key.pem'),\n});\n\n// SECURE: Strong TLS configuration\nconst server = https.createServer({\n  cert: fs.readFileSync('cert.pem'),\n  key: fs.readFileSync('key.pem'),\n  minVersion: 'TLSv1.2',\n  ciphers: 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256',\n});\n```\n\n### Prevention\n- Classify data by sensitivity\n- Encrypt all sensitive data at rest\n- Use TLS 1.2+ for data in transit\n- Use strong algorithms (AES-256, bcrypt, Argon2)\n- Don't store sensitive data unnecessarily\n- Rotate keys regularly\n\n## A03: Injection\n\n### Description\nHostile data sent to an interpreter as part of a command or query. Includes SQL, NoSQL, OS, and LDAP injection.\n\n### Common Vulnerabilities\n\n**SQL Injection**\n```typescript\n// VULNERABLE: String concatenation\nconst query = `SELECT * FROM users WHERE email = '${email}'`;\n\n// SECURE: Parameterized query\nconst query = 'SELECT * FROM users WHERE email = $1';\nconst result = await db.query(query, [email]);\n```\n\n**NoSQL Injection**\n```typescript\n// VULNERABLE: Accepts operators from input\nconst user = await User.findOne({\n  email: req.body.email,\n  password: req.body.password  // Could be { $gt: '' }\n});\n\n// SECURE: Type coercion\nconst user = await User.findOne({\n  email: String(req.body.email),\n  password: String(req.body.password)\n});\n```\n\n**Command Injection**\n```typescript\n// VULNERABLE: Shell interpolation\nexec(`ping -c 4 ${hostname}`);\n// Attack: hostname = \"google.com; rm -rf /\"\n\n// SECURE: Argument array, no shell\nexecFile('ping', ['-c', '4', hostname]);\n```\n\n**Template Injection**\n```typescript\n// VULNERABLE: User input in template\nconst template = `Hello ${req.query.name}!`;\nres.render(template);\n\n// SECURE: Data passed to template\nres.render('greeting', { name: req.query.name });\n```\n\n### Prevention\n- Use parameterized queries everywhere\n- Use ORM/ODM with proper escaping\n- Validate and sanitize all input\n- Use allow-lists for permitted values\n- Escape special characters\n\n## A04: Insecure Design\n\n### Description\nMissing or ineffective security controls. Flaws in design that cannot be fixed by perfect implementation.\n\n### Common Vulnerabilities\n\n**Missing Rate Limiting**\n```typescript\n// VULNERABLE: No rate limiting on login\napp.post('/login', async (req, res) => {\n  // Allows unlimited password attempts\n});\n\n// SECURE: Rate limiting\nconst loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  message: 'Too many login attempts'\n});\n\napp.post('/login', loginLimiter, async (req, res) => {\n  // ...\n});\n```\n\n**Insufficient Anti-Automation**\n```typescript\n// VULNERABLE: No CAPTCHA on signup\napp.post('/signup', async (req, res) => {\n  await createUser(req.body);\n});\n\n// SECURE: CAPTCHA for sensitive operations\napp.post('/signup', verifyCaptcha, async (req, res) => {\n  await createUser(req.body);\n});\n```\n\n### Prevention\n- Use threat modeling during design\n- Establish secure development lifecycle\n- Use secure design patterns library\n- Limit resource consumption per user\n- Segregate tenants robustly\n\n## A05: Security Misconfiguration\n\n### Description\nImproper configuration of security controls. Includes default credentials, unnecessary features, and verbose errors.\n\n### Common Vulnerabilities\n\n**Verbose Error Messages**\n```typescript\n// VULNERABLE: Stack traces to users\napp.use((err, req, res, next) => {\n  res.status(500).json({\n    error: err.message,\n    stack: err.stack  // Exposes internal details!\n  });\n});\n\n// SECURE: Generic errors to users\napp.use((err, req, res, next) => {\n  logger.error(err);  // Log detailed error internally\n  res.status(500).json({\n    error: 'An unexpected error occurred'\n  });\n});\n```\n\n**Default Credentials**\n```typescript\n// VULNERABLE: Default admin password\nconst adminPassword = process.env.ADMIN_PASSWORD || 'admin123';\n\n// SECURE: Required configuration\nif (!process.env.ADMIN_PASSWORD) {\n  throw new Error('ADMIN_PASSWORD environment variable required');\n}\n```\n\n**Unnecessary Features Enabled**\n```typescript\n// VULNERABLE: Debug mode in production\napp.use(express.static('public', { dotfiles: 'allow' }));\n\n// SECURE: Disable unnecessary features\napp.use(express.static('public', { \n  dotfiles: 'deny',\n  index: false\n}));\n```\n\n### Prevention\n- Automated hardening process\n- Minimal platform without unnecessary features\n- Review and update configurations regularly\n- Segmented architecture\n- Send security directives to clients\n\n## A06: Vulnerable and Outdated Components\n\n### Description\nUsing components with known vulnerabilities. Includes libraries, frameworks, and other software modules.\n\n### Detection\n\n```bash\n# npm audit\nnpm audit\n\n# Snyk\nsnyk test\n\n# Check specific package\nnpm view lodash versions\nnpm audit --package-lock-only\n```\n\n### Prevention\n\n```json\n// package.json - Pin versions\n{\n  \"dependencies\": {\n    \"express\": \"4.18.2\",\n    \"lodash\": \"^4.17.21\"\n  }\n}\n```\n\n```yaml\n# GitHub Dependabot\n# .github/dependabot.yml\nversion: 2\nupdates:\n  - package-ecosystem: npm\n    directory: \"/\"\n    schedule:\n      interval: weekly\n    open-pull-requests-limit: 10\n```\n\n### Remediation\n- Remove unused dependencies\n- Continuously inventory component versions\n- Only obtain components from official sources\n- Monitor for unmaintained libraries\n- Create process for updating components\n\n## A07: Identification and Authentication Failures\n\n### Description\nConfirmation of user identity and session management failures.\n\n### Common Vulnerabilities\n\n**Weak Password Policy**\n```typescript\n// VULNERABLE: No password requirements\nconst isValid = password.length > 0;\n\n// SECURE: Strong password requirements\nconst isValid = \n  password.length >= 12 &&\n  /[A-Z]/.test(password) &&\n  /[a-z]/.test(password) &&\n  /[0-9]/.test(password) &&\n  /[^A-Za-z0-9]/.test(password) &&\n  !commonPasswords.includes(password);\n```\n\n**Session Fixation**\n```typescript\n// VULNERABLE: Session ID not regenerated\napp.post('/login', (req, res) => {\n  // ... authenticate\n  req.session.userId = user.id;\n});\n\n// SECURE: Regenerate session on auth\napp.post('/login', (req, res) => {\n  // ... authenticate\n  req.session.regenerate((err) => {\n    req.session.userId = user.id;\n    res.redirect('/dashboard');\n  });\n});\n```\n\n**Credential Stuffing**\n```typescript\n// SECURE: Multi-factor + rate limiting + breach detection\napp.post('/login', \n  rateLimit({ max: 5, windowMs: 15 * 60 * 1000 }),\n  async (req, res) => {\n    const user = await authenticate(req.body);\n    \n    if (await isBreachedPassword(req.body.password)) {\n      return res.status(401).json({\n        error: 'Password found in breach database'\n      });\n    }\n    \n    if (user.mfaEnabled) {\n      return res.json({ requiresMfa: true });\n    }\n    \n    // ... complete login\n  }\n);\n```\n\n### Prevention\n- Implement multi-factor authentication\n- Don't ship with default credentials\n- Implement weak password checks\n- Limit failed login attempts\n- Use server-side session management\n\n## A08: Software and Data Integrity Failures\n\n### Description\nCode and infrastructure that doesn't protect against integrity violations. Includes insecure deserialization and CI/CD vulnerabilities.\n\n### Common Vulnerabilities\n\n**Insecure Deserialization**\n```typescript\n// VULNERABLE: Deserializing untrusted data\nconst data = JSON.parse(req.body.data);\nconst user = Object.assign(new User(), data);  // Prototype pollution!\n\n// SECURE: Explicit property assignment\nconst data = JSON.parse(req.body.data);\nconst user = new User();\nuser.name = String(data.name);\nuser.email = String(data.email);\n```\n\n**Missing Integrity Verification**\n```typescript\n// VULNERABLE: No integrity check on updates\napp.post('/update', (req, res) => {\n  eval(req.body.code);  // Code execution!\n});\n\n// SECURE: Signed updates only\napp.post('/update', (req, res) => {\n  const { code, signature } = req.body;\n  if (!verifySignature(code, signature, publicKey)) {\n    return res.status(400).json({ error: 'Invalid signature' });\n  }\n  // Process verified code\n});\n```\n\n### Prevention\n- Use digital signatures for data/code\n- Verify npm packages come from expected sources\n- Use CI/CD pipeline security\n- Don't send serialized objects to untrusted clients\n\n## A09: Security Logging and Monitoring Failures\n\n### Description\nInsufficient logging, detection, and response to active attacks.\n\n### What to Log\n\n```typescript\nconst securityLogger = {\n  authSuccess: (userId: string, ip: string) => {\n    logger.info('AUTH_SUCCESS', { userId, ip, timestamp: Date.now() });\n  },\n  \n  authFailure: (email: string, ip: string, reason: string) => {\n    logger.warn('AUTH_FAILURE', { email, ip, reason, timestamp: Date.now() });\n  },\n  \n  accessDenied: (userId: string, resource: string, action: string) => {\n    logger.warn('ACCESS_DENIED', { userId, resource, action, timestamp: Date.now() });\n  },\n  \n  suspiciousActivity: (details: object) => {\n    logger.error('SUSPICIOUS_ACTIVITY', { ...details, timestamp: Date.now() });\n  },\n};\n```\n\n### What NOT to Log\n\n```typescript\n// NEVER log:\n// - Passwords (even hashed)\n// - Session tokens\n// - API keys\n// - Credit card numbers\n// - Social security numbers\n// - Full authentication tokens\n\n// BAD\nlogger.info('Login attempt', { email, password });\n\n// GOOD\nlogger.info('Login attempt', { email: maskEmail(email) });\n```\n\n### Prevention\n- Log all login, access control, and input validation failures\n- Ensure logs can be consumed by log management solutions\n- Establish alerting thresholds\n- Create incident response plan\n\n## A10: Server-Side Request Forgery (SSRF)\n\n### Description\nApplication fetches remote resource without validating user-supplied URL.\n\n### Common Vulnerabilities\n\n```typescript\n// VULNERABLE: Fetch arbitrary URLs\napp.get('/proxy', async (req, res) => {\n  const response = await fetch(req.query.url);\n  res.send(await response.text());\n});\n// Attack: GET /proxy?url=http://169.254.169.254/latest/meta-data/\n\n// SECURE: URL validation\nconst ALLOWED_HOSTS = ['api.trusted.com', 'cdn.trusted.com'];\n\napp.get('/proxy', async (req, res) => {\n  const url = new URL(req.query.url);\n  \n  if (!ALLOWED_HOSTS.includes(url.hostname)) {\n    return res.status(400).json({ error: 'Host not allowed' });\n  }\n  \n  if (url.protocol !== 'https:') {\n    return res.status(400).json({ error: 'HTTPS required' });\n  }\n  \n  const response = await fetch(url.toString());\n  res.send(await response.text());\n});\n```\n\n### Prevention\n- Sanitize and validate all user-supplied URLs\n- Use allow-list of permitted URLs/domains\n- Disable HTTP redirects\n- Don't send raw responses to clients\n- Block requests to private IP ranges\n"
    },
    {
      "name": "remediation-patterns.md",
      "path": "references/remediation-patterns.md",
      "content": "# Remediation Patterns\n\nStrategies for fixing security vulnerabilities.\n\n## Remediation Principles\n\n1. **Fix the root cause** — Don't just patch symptoms\n2. **Defense in depth** — Multiple layers of protection\n3. **Fail secure** — Errors should deny access\n4. **Least privilege** — Minimum permissions necessary\n5. **Verify the fix** — Test that vulnerability is closed\n\n## Input Validation Patterns\n\n### Validation Strategy\n\n```typescript\n// Defense in depth: validate at multiple layers\n\n// 1. API Gateway / Edge\n// Rate limiting, basic format checks\n\n// 2. Application Layer\nconst userSchema = z.object({\n  email: z.string().email().max(254),\n  name: z.string().min(1).max(100).regex(/^[\\p{L}\\s'-]+$/u),\n  age: z.number().int().min(13).max(150).optional(),\n});\n\n// 3. Domain Layer\nclass User {\n  constructor(data: ValidatedUserInput) {\n    this.email = new Email(data.email);  // Value object validates\n    this.name = new PersonName(data.name);\n  }\n}\n\n// 4. Database Layer\n// Constraints, triggers\n```\n\n### Allow-List Validation\n\n```typescript\n// For enumerated values\nconst ALLOWED_ROLES = ['user', 'editor', 'admin'] as const;\ntype Role = typeof ALLOWED_ROLES[number];\n\nfunction setRole(role: string): Role {\n  if (!ALLOWED_ROLES.includes(role as Role)) {\n    throw new ValidationError(`Invalid role: ${role}`);\n  }\n  return role as Role;\n}\n\n// For file types\nconst ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/gif'];\n\nasync function validateUpload(file: Express.Multer.File) {\n  const type = await fileTypeFromBuffer(file.buffer);\n  if (!type || !ALLOWED_MIME_TYPES.includes(type.mime)) {\n    throw new ValidationError('Invalid file type');\n  }\n}\n```\n\n### Sanitization\n\n```typescript\n// HTML sanitization for rich text\nimport DOMPurify from 'dompurify';\n\nfunction sanitizeHtml(input: string): string {\n  return DOMPurify.sanitize(input, {\n    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],\n    ALLOWED_ATTR: ['href'],\n    ALLOW_DATA_ATTR: false,\n  });\n}\n\n// Filename sanitization\nfunction sanitizeFilename(filename: string): string {\n  return filename\n    .replace(/[^a-zA-Z0-9.-]/g, '_')  // Replace unsafe chars\n    .replace(/\\.{2,}/g, '.')           // No directory traversal\n    .substring(0, 255);                // Length limit\n}\n\n// URL sanitization\nfunction sanitizeUrl(url: string): string | null {\n  try {\n    const parsed = new URL(url);\n    if (!['http:', 'https:'].includes(parsed.protocol)) {\n      return null;\n    }\n    return parsed.toString();\n  } catch {\n    return null;\n  }\n}\n```\n\n## Authentication Hardening\n\n### Password Security\n\n```typescript\nimport bcrypt from 'bcrypt';\nimport { zxcvbn } from '@zxcvbn-ts/core';\n\nconst PASSWORD_MIN_SCORE = 3;  // 0-4 scale\n\nasync function setPassword(userId: string, password: string): Promise<void> {\n  // Check password strength\n  const strength = zxcvbn(password);\n  if (strength.score < PASSWORD_MIN_SCORE) {\n    throw new ValidationError('Password is too weak', {\n      suggestions: strength.feedback.suggestions\n    });\n  }\n  \n  // Check against breached passwords\n  if (await isBreachedPassword(password)) {\n    throw new ValidationError('Password found in data breach');\n  }\n  \n  // Hash with bcrypt\n  const hash = await bcrypt.hash(password, 12);\n  \n  await db.users.update(userId, { passwordHash: hash });\n}\n\n// Breached password check (k-anonymity)\nasync function isBreachedPassword(password: string): Promise<boolean> {\n  const hash = crypto.createHash('sha1').update(password).digest('hex').toUpperCase();\n  const prefix = hash.substring(0, 5);\n  const suffix = hash.substring(5);\n  \n  const response = await fetch(`https://api.pwnedpasswords.com/range/${prefix}`);\n  const text = await response.text();\n  \n  return text.split('\\n').some(line => line.startsWith(suffix));\n}\n```\n\n### Session Management\n\n```typescript\n// Secure session configuration\nconst sessionConfig = {\n  secret: process.env.SESSION_SECRET,\n  name: '__Host-session',  // Cookie prefix for extra security\n  cookie: {\n    secure: true,           // HTTPS only\n    httpOnly: true,         // No JavaScript access\n    sameSite: 'strict',     // CSRF protection\n    maxAge: 3600000,        // 1 hour\n    path: '/',\n  },\n  resave: false,\n  saveUninitialized: false,\n  store: new RedisStore({ client: redisClient }),  // Server-side storage\n};\n\n// Session lifecycle\nclass SessionService {\n  async createSession(userId: string, req: Request): Promise<void> {\n    // Regenerate to prevent fixation\n    await new Promise<void>((resolve, reject) => {\n      req.session.regenerate((err) => {\n        if (err) reject(err);\n        else resolve();\n      });\n    });\n    \n    req.session.userId = userId;\n    req.session.createdAt = Date.now();\n    req.session.ip = req.ip;\n    req.session.userAgent = req.headers['user-agent'];\n  }\n  \n  async destroySession(req: Request): Promise<void> {\n    await new Promise<void>((resolve, reject) => {\n      req.session.destroy((err) => {\n        if (err) reject(err);\n        else resolve();\n      });\n    });\n  }\n  \n  validateSession(req: Request): boolean {\n    if (!req.session.userId) return false;\n    \n    // Check session age\n    const maxAge = 24 * 60 * 60 * 1000;  // 24 hours\n    if (Date.now() - req.session.createdAt > maxAge) {\n      return false;\n    }\n    \n    // Optional: validate IP (may cause issues with mobile)\n    // if (req.session.ip !== req.ip) return false;\n    \n    return true;\n  }\n}\n```\n\n### Multi-Factor Authentication\n\n```typescript\nimport { authenticator } from 'otplib';\n\nclass MfaService {\n  async setupMfa(userId: string): Promise<{ secret: string; qrCode: string }> {\n    const secret = authenticator.generateSecret();\n    const otpauth = authenticator.keyuri(userId, 'MyApp', secret);\n    \n    // Store encrypted secret\n    const encrypted = encrypt(secret);\n    await db.users.update(userId, { mfaSecret: encrypted, mfaEnabled: false });\n    \n    // Generate QR code\n    const qrCode = await QRCode.toDataURL(otpauth);\n    \n    return { secret, qrCode };\n  }\n  \n  async verifyAndEnable(userId: string, token: string): Promise<boolean> {\n    const user = await db.users.findById(userId);\n    const secret = decrypt(user.mfaSecret);\n    \n    if (!authenticator.verify({ token, secret })) {\n      return false;\n    }\n    \n    await db.users.update(userId, { mfaEnabled: true });\n    return true;\n  }\n  \n  async verify(userId: string, token: string): Promise<boolean> {\n    const user = await db.users.findById(userId);\n    if (!user.mfaEnabled) return true;  // MFA not required\n    \n    const secret = decrypt(user.mfaSecret);\n    return authenticator.verify({ token, secret });\n  }\n}\n```\n\n## Authorization Patterns\n\n### Role-Based Access Control (RBAC)\n\n```typescript\n// Role definitions\nconst ROLES = {\n  user: {\n    permissions: ['read:own', 'write:own'],\n  },\n  editor: {\n    permissions: ['read:own', 'write:own', 'read:all', 'write:all'],\n  },\n  admin: {\n    permissions: ['read:own', 'write:own', 'read:all', 'write:all', 'admin'],\n  },\n};\n\n// Permission check middleware\nfunction requirePermission(permission: string) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const userRole = req.user?.role || 'anonymous';\n    const roleConfig = ROLES[userRole];\n    \n    if (!roleConfig?.permissions.includes(permission)) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n    \n    next();\n  };\n}\n\n// Usage\napp.get('/api/documents', requirePermission('read:all'), listDocuments);\napp.delete('/api/users/:id', requirePermission('admin'), deleteUser);\n```\n\n### Attribute-Based Access Control (ABAC)\n\n```typescript\n// Policy definition\ninterface Policy {\n  resource: string;\n  action: string;\n  condition: (user: User, resource: any) => boolean;\n}\n\nconst policies: Policy[] = [\n  {\n    resource: 'document',\n    action: 'read',\n    condition: (user, doc) => \n      doc.isPublic || \n      doc.ownerId === user.id || \n      doc.sharedWith.includes(user.id),\n  },\n  {\n    resource: 'document',\n    action: 'write',\n    condition: (user, doc) => \n      doc.ownerId === user.id || \n      (doc.editors?.includes(user.id)),\n  },\n  {\n    resource: 'document',\n    action: 'delete',\n    condition: (user, doc) => \n      doc.ownerId === user.id || \n      user.role === 'admin',\n  },\n];\n\n// Policy enforcement\nfunction checkAccess(user: User, action: string, resource: string, object: any): boolean {\n  const policy = policies.find(p => \n    p.resource === resource && p.action === action\n  );\n  \n  if (!policy) return false;  // Deny by default\n  \n  return policy.condition(user, object);\n}\n\n// Usage\napp.get('/api/documents/:id', authenticate, async (req, res) => {\n  const doc = await Document.findById(req.params.id);\n  \n  if (!checkAccess(req.user, 'read', 'document', doc)) {\n    return res.status(403).json({ error: 'Forbidden' });\n  }\n  \n  res.json(doc);\n});\n```\n\n## Data Protection\n\n### Encryption at Rest\n\n```typescript\nimport crypto from 'crypto';\n\nconst ALGORITHM = 'aes-256-gcm';\nconst KEY = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex');\n\nfunction encrypt(plaintext: string): string {\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(ALGORITHM, KEY, iv);\n  \n  let encrypted = cipher.update(plaintext, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  const authTag = cipher.getAuthTag();\n  \n  // Format: iv:authTag:ciphertext\n  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;\n}\n\nfunction decrypt(encrypted: string): string {\n  const [ivHex, authTagHex, ciphertext] = encrypted.split(':');\n  \n  const iv = Buffer.from(ivHex, 'hex');\n  const authTag = Buffer.from(authTagHex, 'hex');\n  \n  const decipher = crypto.createDecipheriv(ALGORITHM, KEY, iv);\n  decipher.setAuthTag(authTag);\n  \n  let decrypted = decipher.update(ciphertext, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  \n  return decrypted;\n}\n\n// Field-level encryption\nclass EncryptedField {\n  static encrypt(value: string): string {\n    return encrypt(value);\n  }\n  \n  static decrypt(value: string): string {\n    return decrypt(value);\n  }\n}\n```\n\n### Data Masking\n\n```typescript\nfunction maskEmail(email: string): string {\n  const [local, domain] = email.split('@');\n  if (local.length <= 2) return `**@${domain}`;\n  return `${local[0]}***${local[local.length - 1]}@${domain}`;\n}\n\nfunction maskPhone(phone: string): string {\n  const digits = phone.replace(/\\D/g, '');\n  return `***-***-${digits.slice(-4)}`;\n}\n\nfunction maskCreditCard(cc: string): string {\n  const digits = cc.replace(/\\D/g, '');\n  return `****-****-****-${digits.slice(-4)}`;\n}\n\nfunction maskSSN(ssn: string): string {\n  return `***-**-${ssn.slice(-4)}`;\n}\n\n// Usage in logging\nlogger.info('User updated', {\n  email: maskEmail(user.email),\n  phone: maskPhone(user.phone),\n});\n```\n\n## Security Headers\n\n```typescript\nimport helmet from 'helmet';\n\n// Comprehensive security headers\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\", \"'strict-dynamic'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],  // Consider using nonces\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\n      connectSrc: [\"'self'\", \"https://api.example.com\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"],\n      baseUri: [\"'self'\"],\n      formAction: [\"'self'\"],\n      frameAncestors: [\"'none'\"],\n      upgradeInsecureRequests: [],\n    },\n  },\n  crossOriginEmbedderPolicy: true,\n  crossOriginOpenerPolicy: true,\n  crossOriginResourcePolicy: { policy: 'same-origin' },\n  dnsPrefetchControl: { allow: false },\n  frameguard: { action: 'deny' },\n  hsts: { maxAge: 31536000, includeSubDomains: true, preload: true },\n  ieNoOpen: true,\n  noSniff: true,\n  originAgentCluster: true,\n  permittedCrossDomainPolicies: { permittedPolicies: 'none' },\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n  xssFilter: true,\n}));\n```\n\n## Rate Limiting\n\n```typescript\nimport rateLimit from 'express-rate-limit';\nimport RedisStore from 'rate-limit-redis';\n\n// General API rate limit\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,  // 15 minutes\n  max: 100,\n  message: { error: 'Too many requests' },\n  standardHeaders: true,\n  legacyHeaders: false,\n  store: new RedisStore({ client: redisClient }),\n});\n\n// Strict rate limit for auth endpoints\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  message: { error: 'Too many login attempts' },\n  skipSuccessfulRequests: true,  // Only count failures\n  store: new RedisStore({ client: redisClient }),\n});\n\n// Per-user rate limit\nconst userLimiter = rateLimit({\n  windowMs: 60 * 1000,  // 1 minute\n  max: 30,\n  keyGenerator: (req) => req.user?.id || req.ip,\n  store: new RedisStore({ client: redisClient }),\n});\n\napp.use('/api', apiLimiter);\napp.use('/auth', authLimiter);\napp.use('/api', authenticate, userLimiter);\n```\n\n## Logging and Monitoring\n\n```typescript\n// Security event logger\nclass SecurityLogger {\n  private logger: Logger;\n  \n  constructor() {\n    this.logger = createLogger({\n      level: 'info',\n      format: format.combine(\n        format.timestamp(),\n        format.json()\n      ),\n      transports: [\n        new transports.File({ filename: 'security.log' }),\n        // Send critical events to SIEM\n        new SIEMTransport({ level: 'warn' }),\n      ],\n    });\n  }\n  \n  authSuccess(userId: string, ip: string, userAgent: string) {\n    this.logger.info('AUTH_SUCCESS', {\n      event: 'auth_success',\n      userId,\n      ip,\n      userAgent,\n    });\n  }\n  \n  authFailure(email: string, ip: string, reason: string) {\n    this.logger.warn('AUTH_FAILURE', {\n      event: 'auth_failure',\n      email: maskEmail(email),\n      ip,\n      reason,\n    });\n  }\n  \n  accessDenied(userId: string, resource: string, action: string) {\n    this.logger.warn('ACCESS_DENIED', {\n      event: 'access_denied',\n      userId,\n      resource,\n      action,\n    });\n  }\n  \n  suspiciousActivity(details: object) {\n    this.logger.error('SUSPICIOUS_ACTIVITY', {\n      event: 'suspicious_activity',\n      ...details,\n    });\n  }\n}\n```\n"
    },
    {
      "name": "secure-code-review.md",
      "path": "references/secure-code-review.md",
      "content": "# Secure Code Review\n\nSecurity-focused code review checklist and patterns.\n\n## Security Review Mindset\n\nWhen reviewing code for security:\n1. **Think adversarially** — How could this be abused?\n2. **Follow the data** — Where does input come from? Where does it go?\n3. **Check trust boundaries** — What crosses from untrusted to trusted?\n4. **Verify assumptions** — What does the code assume that might be wrong?\n\n## Input Validation\n\n### Checklist\n\n```markdown\n- [ ] All user input validated server-side\n- [ ] Validation uses allow-lists, not deny-lists\n- [ ] Input length limits enforced\n- [ ] Input type/format validated\n- [ ] Validation errors don't leak information\n- [ ] File uploads validated (type, size, name)\n```\n\n### Review Patterns\n\n```typescript\n// RED FLAG: No validation\napp.post('/api/users', (req, res) => {\n  db.users.insert(req.body);  // Accepts anything!\n});\n\n// RED FLAG: Client-side only validation\n// If validation only happens in JavaScript, it can be bypassed\n\n// RED FLAG: Deny-list approach\nif (!input.includes('<script>')) {  // Easy to bypass\n  // process input\n}\n\n// GREEN: Allow-list validation\nconst schema = z.object({\n  email: z.string().email().max(254),\n  name: z.string().min(1).max(100).regex(/^[a-zA-Z\\s]+$/),\n  age: z.number().int().min(0).max(150),\n});\n\nconst validated = schema.parse(req.body);\n```\n\n## Output Encoding\n\n### Checklist\n\n```markdown\n- [ ] HTML output encoded for context\n- [ ] JavaScript strings properly escaped\n- [ ] URL parameters encoded\n- [ ] JSON responses properly serialized\n- [ ] SQL queries use parameters\n- [ ] Shell commands don't use string interpolation\n```\n\n### Context-Aware Encoding\n\n```typescript\n// HTML Body Context\nconst safe = escapeHtml(userInput);\n// <div>${safe}</div>\n\n// HTML Attribute Context\nconst safe = escapeHtmlAttr(userInput);\n// <input value=\"${safe}\">\n\n// JavaScript Context\nconst safe = JSON.stringify(userInput);\n// <script>const data = ${safe};</script>\n\n// URL Parameter Context\nconst safe = encodeURIComponent(userInput);\n// <a href=\"/search?q=${safe}\">\n\n// CSS Context\nconst safe = escapeCss(userInput);\n// <style>.class { color: ${safe}; }</style>\n```\n\n### XSS Prevention\n\n```typescript\n// RED FLAG: innerHTML with user data\nelement.innerHTML = userInput;\n\n// RED FLAG: document.write\ndocument.write(userInput);\n\n// RED FLAG: eval() with user data\neval(userInput);\n\n// RED FLAG: React dangerouslySetInnerHTML\n<div dangerouslySetInnerHTML={{ __html: userInput }} />\n\n// GREEN: textContent (safe)\nelement.textContent = userInput;\n\n// GREEN: Parameterized DOM manipulation\nconst el = document.createElement('div');\nel.textContent = userInput;\nparent.appendChild(el);\n\n// GREEN: React auto-escaping\n<div>{userInput}</div>\n```\n\n## Authentication\n\n### Checklist\n\n```markdown\n- [ ] Passwords hashed with bcrypt/Argon2 (not MD5/SHA1)\n- [ ] Password requirements enforced\n- [ ] Brute force protection (rate limiting, lockout)\n- [ ] Session tokens cryptographically random\n- [ ] Sessions invalidated on logout\n- [ ] Session regenerated after login\n- [ ] Secure cookie flags set (HttpOnly, Secure, SameSite)\n- [ ] Password reset tokens single-use and time-limited\n- [ ] MFA option available for sensitive accounts\n```\n\n### Review Patterns\n\n```typescript\n// RED FLAG: Weak hashing\ncrypto.createHash('md5').update(password).digest('hex');\ncrypto.createHash('sha1').update(password).digest('hex');\n\n// RED FLAG: Missing salt\nbcrypt.hashSync(password, 1);  // Cost factor too low\n\n// RED FLAG: Predictable tokens\nconst token = Date.now().toString();\nconst token = Math.random().toString();\n\n// RED FLAG: Insecure comparison (timing attack)\nif (token === storedToken) { }\n\n// GREEN: Proper password hashing\nawait bcrypt.hash(password, 12);\n\n// GREEN: Secure random tokens\ncrypto.randomBytes(32).toString('hex');\n\n// GREEN: Timing-safe comparison\ncrypto.timingSafeEqual(Buffer.from(a), Buffer.from(b));\n```\n\n## Authorization\n\n### Checklist\n\n```markdown\n- [ ] Every endpoint has authorization check\n- [ ] Authorization checked server-side\n- [ ] Direct object references validated against user\n- [ ] Role changes logged and audited\n- [ ] Principle of least privilege applied\n- [ ] Admin functions separately protected\n- [ ] Horizontal access control (user A can't access user B's data)\n- [ ] Vertical access control (regular user can't access admin functions)\n```\n\n### Review Patterns\n\n```typescript\n// RED FLAG: Missing authorization\napp.get('/api/documents/:id', async (req, res) => {\n  const doc = await Document.findById(req.params.id);\n  res.json(doc);  // Anyone can access any document!\n});\n\n// RED FLAG: Client-side only authorization\n// Hiding UI elements but not checking server-side\n\n// RED FLAG: Trusting user input for authorization\napp.post('/api/admin', (req, res) => {\n  if (req.body.isAdmin) {  // User controls this!\n    // admin action\n  }\n});\n\n// GREEN: Proper authorization\napp.get('/api/documents/:id', authenticate, async (req, res) => {\n  const doc = await Document.findOne({\n    _id: req.params.id,\n    $or: [\n      { ownerId: req.user.id },\n      { sharedWith: req.user.id }\n    ]\n  });\n  \n  if (!doc) {\n    return res.status(404).json({ error: 'Not found' });\n  }\n  \n  res.json(doc);\n});\n```\n\n## Data Protection\n\n### Checklist\n\n```markdown\n- [ ] Sensitive data identified and classified\n- [ ] Encryption at rest for sensitive data\n- [ ] TLS for all communications\n- [ ] Secrets not in source code\n- [ ] Secrets not logged\n- [ ] PII minimized (collect only what's needed)\n- [ ] Data retention policies implemented\n- [ ] Secure deletion when required\n```\n\n### Review Patterns\n\n```typescript\n// RED FLAG: Hardcoded secrets\nconst API_KEY = 'sk_live_abc123';\nconst password = 'admin123';\n\n// RED FLAG: Secrets in logs\nconsole.log('Request:', { headers: req.headers });  // May contain auth tokens\nlogger.info('User login', { password });  // Logging password!\n\n// RED FLAG: Unencrypted sensitive data\nawait db.users.insert({ ssn: '123-45-6789' });\n\n// RED FLAG: HTTP for sensitive data\nfetch('http://api.example.com/login', { body: credentials });\n\n// GREEN: Environment variables for secrets\nconst API_KEY = process.env.API_KEY;\n\n// GREEN: Encrypted sensitive data\nconst encrypted = encrypt(ssn, process.env.ENCRYPTION_KEY);\nawait db.users.insert({ ssn: encrypted });\n\n// GREEN: Masked logging\nlogger.info('User login', { email: maskEmail(email) });\n```\n\n## Error Handling\n\n### Checklist\n\n```markdown\n- [ ] Errors don't expose stack traces to users\n- [ ] Errors don't expose system information\n- [ ] Errors don't expose SQL queries\n- [ ] Generic error messages for users\n- [ ] Detailed errors logged securely\n- [ ] Failed operations don't leave partial state\n- [ ] Fail secure (deny by default)\n```\n\n### Review Patterns\n\n```typescript\n// RED FLAG: Exposing internal errors\napp.use((err, req, res, next) => {\n  res.status(500).json({\n    error: err.message,\n    stack: err.stack,\n    query: err.sql\n  });\n});\n\n// RED FLAG: Different errors reveal information\nif (!user) return res.status(404).json({ error: 'User not found' });\nif (!passwordMatch) return res.status(401).json({ error: 'Wrong password' });\n// Reveals which emails exist!\n\n// GREEN: Generic errors to users\napp.use((err, req, res, next) => {\n  logger.error('Unhandled error', { err, requestId: req.id });\n  res.status(500).json({ error: 'An error occurred', requestId: req.id });\n});\n\n// GREEN: Consistent auth errors\nif (!user || !passwordMatch) {\n  return res.status(401).json({ error: 'Invalid credentials' });\n}\n```\n\n## Cryptography\n\n### Checklist\n\n```markdown\n- [ ] Using current, strong algorithms\n- [ ] Not inventing custom cryptography\n- [ ] Keys generated securely\n- [ ] Keys stored securely\n- [ ] IVs/nonces are random and unique\n- [ ] Proper key derivation for passwords\n```\n\n### Algorithm Guidance\n\n| Purpose | Recommended | Avoid |\n|---------|-------------|-------|\n| Password hashing | Argon2, bcrypt, scrypt | MD5, SHA1, SHA256 (without KDF) |\n| Symmetric encryption | AES-256-GCM | DES, 3DES, AES-ECB |\n| Asymmetric encryption | RSA-2048+, ECDSA P-256+ | RSA-1024 |\n| Hashing (non-password) | SHA-256, SHA-3 | MD5, SHA1 |\n| Random numbers | crypto.randomBytes | Math.random |\n\n### Review Patterns\n\n```typescript\n// RED FLAG: Custom crypto\nfunction encrypt(data, key) {\n  return data.split('').map((c, i) => \n    String.fromCharCode(c.charCodeAt(0) ^ key.charCodeAt(i % key.length))\n  ).join('');\n}\n\n// RED FLAG: ECB mode\ncrypto.createCipheriv('aes-256-ecb', key, '');\n\n// RED FLAG: Static IV\nconst iv = Buffer.from('0000000000000000');\n\n// RED FLAG: Math.random for security\nconst token = Math.random().toString(36);\n\n// GREEN: Standard library with proper usage\nconst iv = crypto.randomBytes(16);\nconst cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\n```\n\n## File Handling\n\n### Checklist\n\n```markdown\n- [ ] File type validated (not just extension)\n- [ ] File size limits enforced\n- [ ] Filename sanitized\n- [ ] Files stored outside web root\n- [ ] Uploaded files cannot be executed\n- [ ] Path traversal prevented\n```\n\n### Review Patterns\n\n```typescript\n// RED FLAG: Path traversal\nconst file = `/uploads/${req.params.filename}`;\nres.sendFile(file);\n// Attack: /files/../../../etc/passwd\n\n// RED FLAG: Trusting file extension\nif (file.name.endsWith('.jpg')) {\n  // Could be malicious.jpg.php\n}\n\n// RED FLAG: Executable uploads\n// Storing uploads in /public where they can be accessed and executed\n\n// GREEN: Safe file handling\nconst filename = path.basename(req.params.filename);  // Remove path\nconst safeName = filename.replace(/[^a-zA-Z0-9.-]/g, '');  // Sanitize\nconst filepath = path.join(UPLOAD_DIR, safeName);\n\n// Verify it's still in upload directory\nif (!filepath.startsWith(UPLOAD_DIR)) {\n  return res.status(400).json({ error: 'Invalid path' });\n}\n\n// Validate file type by magic bytes, not extension\nconst fileType = await fileTypeFromBuffer(buffer);\nif (!ALLOWED_TYPES.includes(fileType?.mime)) {\n  return res.status(400).json({ error: 'Invalid file type' });\n}\n```\n\n## Dependencies\n\n### Checklist\n\n```markdown\n- [ ] Dependencies from trusted sources\n- [ ] No known vulnerabilities (npm audit)\n- [ ] Dependencies pinned to specific versions\n- [ ] Lock file committed\n- [ ] Unused dependencies removed\n- [ ] Regular dependency updates scheduled\n```\n\n### Review Patterns\n\n```json\n// RED FLAG: Unpinned dependencies\n{\n  \"dependencies\": {\n    \"lodash\": \"*\",\n    \"express\": \"latest\"\n  }\n}\n\n// RED FLAG: Missing lock file\n// package-lock.json or yarn.lock not in repo\n\n// GREEN: Pinned dependencies\n{\n  \"dependencies\": {\n    \"lodash\": \"4.17.21\",\n    \"express\": \"^4.18.2\"\n  }\n}\n```\n\n## Security Headers Review\n\n```typescript\n// Check for security headers\napp.use(helmet());  // Sets many security headers\n\n// Or manually:\napp.use((req, res, next) => {\n  // Prevent clickjacking\n  res.setHeader('X-Frame-Options', 'DENY');\n  \n  // Prevent MIME sniffing\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  \n  // XSS protection\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  \n  // Content Security Policy\n  res.setHeader('Content-Security-Policy', \n    \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'\");\n  \n  // HTTPS only\n  res.setHeader('Strict-Transport-Security', \n    'max-age=31536000; includeSubDomains');\n  \n  next();\n});\n```\n"
    },
    {
      "name": "vulnerability-patterns.md",
      "path": "references/vulnerability-patterns.md",
      "content": "# Vulnerability Patterns\n\nCommon vulnerability patterns with detection and fixes.\n\n## Injection Vulnerabilities\n\n### SQL Injection\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\n`SELECT * FROM users WHERE id = ${id}`\n`SELECT * FROM users WHERE id = '${id}'`\n\"SELECT * FROM users WHERE id = '\" + id + \"'\"\ndb.query(`DELETE FROM items WHERE id = ${req.params.id}`)\n```\n\n**Fix**\n```typescript\n// Parameterized queries\ndb.query('SELECT * FROM users WHERE id = $1', [id]);\n\n// ORM with proper escaping\nUser.findOne({ where: { id } });\n\n// Query builder\ndb('users').where('id', id).first();\n```\n\n### NoSQL Injection\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\ndb.users.find({ username: req.body.username });\n// Attacker sends: { username: { $gt: '' } }\n\nUser.findOne({ $where: `this.username === '${username}'` });\n```\n\n**Fix**\n```typescript\n// Type coercion\ndb.users.find({ username: String(req.body.username) });\n\n// Schema validation\nconst username = z.string().parse(req.body.username);\n\n// Avoid $where entirely\nUser.findOne({ username: { $eq: String(username) } });\n```\n\n### Command Injection\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\nexec(`ls ${directory}`);\nexec('ping ' + hostname);\nspawn('sh', ['-c', `echo ${message}`]);\nchild_process.execSync(userInput);\n```\n\n**Fix**\n```typescript\n// execFile with argument array (no shell)\nexecFile('ls', [directory]);\n\n// Validate against allow-list\nconst ALLOWED = ['dir1', 'dir2'];\nif (!ALLOWED.includes(directory)) throw new Error('Invalid directory');\nexecFile('ls', [directory]);\n\n// Escape if shell required (avoid if possible)\nconst safeArg = shellEscape([userInput]);\n```\n\n### LDAP Injection\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\nldap.search(`(uid=${username})`);\nldap.search(`(&(uid=${user})(password=${pass}))`);\n```\n\n**Fix**\n```typescript\n// Escape special characters\nfunction escapeLdap(str: string): string {\n  return str.replace(/[\\\\*()]/g, '\\\\$&');\n}\n\nldap.search(`(uid=${escapeLdap(username)})`);\n```\n\n### XPath Injection\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\nxpath.select(`//user[@name='${name}']`);\n```\n\n**Fix**\n```typescript\n// Parameterized XPath (library dependent)\nxpath.select('//user[@name=$name]', { name });\n\n// Or validate/escape input\nconst safeName = name.replace(/['\"]/g, '');\n```\n\n## Cross-Site Scripting (XSS)\n\n### Reflected XSS\n\n**Detection Patterns**\n```typescript\n// RED FLAGS - Server-side\nres.send(`<h1>Search: ${req.query.q}</h1>`);\nres.send(`<script>var x = \"${userInput}\";</script>`);\n\n// RED FLAGS - Client-side\ndocument.getElementById('output').innerHTML = userInput;\n$('#output').html(userInput);\nelement.outerHTML = userInput;\n```\n\n**Fix**\n```typescript\n// Server-side: HTML encoding\nimport { escape } from 'html-escaper';\nres.send(`<h1>Search: ${escape(req.query.q)}</h1>`);\n\n// Client-side: textContent instead of innerHTML\ndocument.getElementById('output').textContent = userInput;\n\n// React: automatic escaping (don't use dangerouslySetInnerHTML)\n<div>{userInput}</div>\n```\n\n### Stored XSS\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\n// User input stored, then rendered without escaping\nconst comment = await Comment.findById(id);\nres.send(`<div class=\"comment\">${comment.text}</div>`);\n```\n\n**Fix**\n```typescript\n// Sanitize on input AND output\n// Input: validate and sanitize\nconst sanitized = DOMPurify.sanitize(text, { ALLOWED_TAGS: ['b', 'i'] });\nawait Comment.create({ text: sanitized });\n\n// Output: escape when rendering\nres.send(`<div class=\"comment\">${escape(comment.text)}</div>`);\n```\n\n### DOM-Based XSS\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\ndocument.write(location.hash);\neval(location.search);\nelement.innerHTML = window.name;\n$.parseHTML(document.referrer);\n```\n\n**Fix**\n```typescript\n// Use safe DOM methods\ndocument.body.appendChild(document.createTextNode(userInput));\n\n// Validate URL parameters\nconst url = new URL(location.href);\nconst value = url.searchParams.get('q');\nif (!/^[a-zA-Z0-9]+$/.test(value)) throw new Error('Invalid');\n```\n\n## Cross-Site Request Forgery (CSRF)\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\n// State-changing operation without CSRF protection\napp.post('/transfer', (req, res) => {\n  transferMoney(req.body.to, req.body.amount);\n});\n\n// Cookie-based auth without SameSite\nres.cookie('session', token);  // Missing SameSite\n```\n\n**Fix**\n```typescript\n// CSRF tokens\napp.use(csrf());\napp.post('/transfer', (req, res) => {\n  // csrf middleware validates token\n  transferMoney(req.body.to, req.body.amount);\n});\n\n// SameSite cookies\nres.cookie('session', token, {\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict'\n});\n\n// Custom headers for APIs (not sent by forms)\n// Require X-Requested-With header\n```\n\n## Authentication Vulnerabilities\n\n### Broken Authentication\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\n// Weak password hashing\ncrypto.createHash('md5').update(password);\ncrypto.createHash('sha256').update(password);  // No salt, no iterations\n\n// Predictable tokens\nconst resetToken = Date.now().toString();\nconst resetToken = user.id + '-' + Date.now();\n\n// Session in URL\nres.redirect(`/dashboard?session=${sessionId}`);\n\n// No rate limiting on login\napp.post('/login', authenticate);\n```\n\n**Fix**\n```typescript\n// Strong password hashing\nconst hash = await bcrypt.hash(password, 12);\n// Or: argon2.hash(password)\n\n// Cryptographically random tokens\nconst resetToken = crypto.randomBytes(32).toString('hex');\n\n// Rate limiting\nconst loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  skipSuccessfulRequests: true\n});\napp.post('/login', loginLimiter, authenticate);\n```\n\n### Session Management\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\n// Session not regenerated after auth\nreq.session.userId = user.id;\n\n// Session not invalidated on logout\napp.post('/logout', (req, res) => {\n  req.session.userId = null;  // Session still valid!\n});\n\n// Insecure session storage\napp.use(session({\n  secret: 'keyboard cat',  // Weak secret\n  cookie: { secure: false }  // HTTP allowed\n}));\n```\n\n**Fix**\n```typescript\n// Regenerate session after auth\napp.post('/login', (req, res) => {\n  // ... authenticate user\n  req.session.regenerate((err) => {\n    req.session.userId = user.id;\n    res.redirect('/dashboard');\n  });\n});\n\n// Properly destroy session on logout\napp.post('/logout', (req, res) => {\n  req.session.destroy((err) => {\n    res.clearCookie('connect.sid');\n    res.redirect('/');\n  });\n});\n\n// Secure session configuration\napp.use(session({\n  secret: process.env.SESSION_SECRET,  // Strong, from env\n  cookie: {\n    secure: true,\n    httpOnly: true,\n    sameSite: 'strict',\n    maxAge: 3600000\n  },\n  resave: false,\n  saveUninitialized: false\n}));\n```\n\n## Authorization Vulnerabilities\n\n### Insecure Direct Object Reference (IDOR)\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\napp.get('/api/users/:id', (req, res) => {\n  const user = await User.findById(req.params.id);\n  res.json(user);  // No ownership check!\n});\n\napp.get('/files/:filename', (req, res) => {\n  res.sendFile(`/files/${req.params.filename}`);  // No access check!\n});\n```\n\n**Fix**\n```typescript\n// Always verify ownership/permission\napp.get('/api/users/:id', authenticate, async (req, res) => {\n  // Only allow users to access their own data\n  if (req.params.id !== req.user.id && !req.user.isAdmin) {\n    return res.status(403).json({ error: 'Forbidden' });\n  }\n  const user = await User.findById(req.params.id);\n  res.json(user);\n});\n\n// Or scope queries\napp.get('/api/documents/:id', authenticate, async (req, res) => {\n  const doc = await Document.findOne({\n    _id: req.params.id,\n    ownerId: req.user.id  // Automatically scoped\n  });\n  if (!doc) return res.status(404).json({ error: 'Not found' });\n  res.json(doc);\n});\n```\n\n### Privilege Escalation\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\n// User can set their own role\napp.post('/api/users', (req, res) => {\n  const user = await User.create(req.body);  // body.role = 'admin'?\n});\n\n// Hidden admin endpoints\napp.post('/admin/delete-all', (req, res) => {\n  // No auth check!\n});\n\n// Role check only on frontend\nif (user.isAdmin) { showAdminButton(); }  // Can be bypassed\n```\n\n**Fix**\n```typescript\n// Explicitly set allowed fields\napp.post('/api/users', (req, res) => {\n  const { email, name, password } = req.body;\n  const user = await User.create({\n    email,\n    name,\n    password,\n    role: 'user'  // Always set server-side\n  });\n});\n\n// Protect admin routes\napp.use('/admin', authenticate, requireRole('admin'));\n\n// Double-check on backend\napp.post('/admin/delete-all', authenticate, requireRole('admin'), (req, res) => {\n  // ...\n});\n```\n\n## Sensitive Data Exposure\n\n### Information Disclosure\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\n// Verbose errors\nres.status(500).json({ error: err.stack });\n\n// Debug info in production\napp.use(errorHandler({ dumpExceptions: true, showStack: true }));\n\n// Sensitive data in responses\nres.json(user);  // Includes password hash!\n\n// Sensitive data in logs\nconsole.log('Login:', { email, password });\n```\n\n**Fix**\n```typescript\n// Generic errors for users\nres.status(500).json({ error: 'An error occurred', id: requestId });\n\n// Filter sensitive fields\nconst { password, ...safeUser } = user;\nres.json(safeUser);\n\n// Or use DTOs/serializers\nres.json(new UserResponse(user));  // Only includes safe fields\n\n// Mask sensitive data in logs\nconsole.log('Login:', { email: maskEmail(email) });\n```\n\n### Insecure Storage\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\n// Hardcoded secrets\nconst API_KEY = 'sk_live_12345';\n\n// Secrets in config files committed to git\n// config.json: { \"apiKey\": \"secret\" }\n\n// Unencrypted sensitive data\ndb.users.insert({ ssn: '123-45-6789' });\n```\n\n**Fix**\n```typescript\n// Environment variables\nconst API_KEY = process.env.API_KEY;\n\n// Secret managers\nconst secret = await secretManager.get('api-key');\n\n// Encryption for sensitive data\nconst encrypted = encrypt(ssn, process.env.ENCRYPTION_KEY);\ndb.users.insert({ ssn: encrypted });\n```\n\n## Server-Side Request Forgery (SSRF)\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\n// Fetch user-provided URLs\napp.get('/fetch', async (req, res) => {\n  const response = await fetch(req.query.url);\n  res.send(await response.text());\n});\n\n// Image/file fetching from URLs\nconst image = await downloadImage(req.body.imageUrl);\n```\n\n**Fix**\n```typescript\n// URL validation\nconst ALLOWED_HOSTS = ['api.trusted.com'];\nconst BLOCKED_RANGES = ['127.0.0.1', '10.0.0.0/8', '192.168.0.0/16'];\n\nasync function safeFetch(urlString: string) {\n  const url = new URL(urlString);\n  \n  // Check protocol\n  if (!['http:', 'https:'].includes(url.protocol)) {\n    throw new Error('Invalid protocol');\n  }\n  \n  // Check against allow-list\n  if (!ALLOWED_HOSTS.includes(url.hostname)) {\n    throw new Error('Host not allowed');\n  }\n  \n  // Resolve DNS and check for private IPs\n  const ip = await dns.resolve(url.hostname);\n  if (isPrivateIP(ip)) {\n    throw new Error('Private IP not allowed');\n  }\n  \n  return fetch(url.toString(), { redirect: 'error' });\n}\n```\n\n## Deserialization Vulnerabilities\n\n**Detection Patterns**\n```typescript\n// RED FLAGS\n// eval() for parsing\nconst data = eval('(' + jsonString + ')');\n\n// Unsafe YAML\nyaml.load(userInput);\n\n// pickle/marshal equivalent\ndeserialize(userInput);\n\n// Object.assign with prototype\nObject.assign(new User(), req.body);\n```\n\n**Fix**\n```typescript\n// Safe JSON parsing\nconst data = JSON.parse(jsonString);\n\n// Safe YAML\nyaml.load(userInput, { schema: yaml.SAFE_SCHEMA });\n\n// Explicit property assignment\nconst user = new User();\nuser.name = String(req.body.name);\nuser.email = String(req.body.email);\n\n// Or with validation\nconst validated = userSchema.parse(req.body);\nconst user = new User(validated);\n```\n"
    }
  ],
  "tags": [
    "security",
    "validation",
    "audit",
    "owasp",
    "core-workflow"
  ],
  "dependsOn": [
    "implement"
  ]
}