{
  "id": "code-review",
  "name": "code-review",
  "version": "1.0.0",
  "description": "Comprehensive PR review combining structural verification, semantic validation, and PR-specific concerns. Use before merging to assess code quality, correctness, and merge readiness. Produces actionable feedback formatted for PR comments with clear blocking vs. non-blocking distinctions.",
  "phase": "REVIEW",
  "category": "core",
  "content": "# Code Review\n\nComprehensive review for pull request merge readiness. Orchestrates verification and validation, adds PR-specific analysis, and produces actionable feedback.\n\n## When to Use\n\n- **Before merging a PR** ‚Äî \"Is this ready to merge?\"\n- **During review** ‚Äî \"What feedback should I give?\"\n- **Self-review** ‚Äî \"What did I miss before requesting review?\"\n- When you say: \"review this PR\", \"is this mergeable?\", \"what's wrong with this code?\"\n\n## Reference Requirements\n\n**MUST read before applying this skill:**\n\n| Reference | Why Required |\n|-----------|--------------|\n| `maintainability-checklist.md` | Quality criteria for review |\n| `feedback-formatting.md` | How to structure review comments |\n\n**Read if applicable:**\n\n| Reference | When Needed |\n|-----------|-------------|\n| `diff-analysis.md` | When reviewing PR diffs |\n| `commit-quality.md` | When assessing commit hygiene |\n| `test-expectations.md` | When verifying test coverage |\n\n**Verification:** Ensure CODE-REVIEW.md is produced with all 4 passes completed.\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| `CODE-REVIEW.md` | Project root | Always |\n\n## Core Concept\n\nCode review answers: **\"Should this be merged?\"**\n\nIt combines:\n1. **Verification** ‚Äî Is this structurally sound? (code-verification, thorough)\n2. **Validation** ‚Äî Does this solve the right problem? (code-validation)\n3. **PR hygiene** ‚Äî Is this a good PR? (commits, scope, documentation)\n4. **Maintainability** ‚Äî Will future developers thank or curse us?\n\n## Review Passes\n\nCode review runs four sequential passes:\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                    CODE REVIEW                          ‚îÇ\n‚îÇ                                                         ‚îÇ\n‚îÇ  Pass 1: Verification (structural)                      ‚îÇ\n‚îÇ     ‚îî‚îÄ‚Üí Invoke code-verification (thorough mode)        ‚îÇ\n‚îÇ         ‚Ä¢ Complexity, security, error handling          ‚îÇ\n‚îÇ         ‚Ä¢ Memory, concurrency, resources                ‚îÇ\n‚îÇ                                                         ‚îÇ\n‚îÇ  Pass 2: Validation (semantic)                          ‚îÇ\n‚îÇ     ‚îî‚îÄ‚Üí Invoke code-validation                          ‚îÇ\n‚îÇ         ‚Ä¢ Requirements, edge cases, failure modes       ‚îÇ\n‚îÇ         ‚Ä¢ Operations, integration, scalability          ‚îÇ\n‚îÇ                                                         ‚îÇ\n‚îÇ  Pass 3: PR Hygiene                                     ‚îÇ\n‚îÇ     ‚îî‚îÄ‚Üí PR-specific concerns                            ‚îÇ\n‚îÇ         ‚Ä¢ Diff analysis, commit quality                 ‚îÇ\n‚îÇ         ‚Ä¢ Scope appropriateness, documentation          ‚îÇ\n‚îÇ                                                         ‚îÇ\n‚îÇ  Pass 4: Maintainability                                ‚îÇ\n‚îÇ     ‚îî‚îÄ‚Üí Long-term code health                           ‚îÇ\n‚îÇ         ‚Ä¢ Naming, structure, clarity                    ‚îÇ\n‚îÇ         ‚Ä¢ Patterns, conventions, testability            ‚îÇ\n‚îÇ                                                         ‚îÇ\n‚îÇ  Synthesis: Merge Verdict                               ‚îÇ\n‚îÇ     ‚îî‚îÄ‚Üí APPROVE / REQUEST_CHANGES / COMMENT             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Pass 1: Verification\n\n**Invoke `code-verification` in thorough mode.**\n\nThis catches structural issues:\n- Complexity anti-patterns (O(n¬≤), etc.)\n- Security vulnerabilities (injection, auth bypass, etc.)\n- Error handling gaps\n- Memory leaks\n- Concurrency issues\n- Resource management problems\n\n**If verification fails:** Stop and report. No point reviewing semantics if structure is broken.\n\n‚Üí See `code-verification` skill for details\n\n## Pass 2: Validation\n\n**Invoke `code-validation`.**\n\nThis checks semantic correctness:\n- Requirements alignment\n- Edge case coverage\n- Failure mode handling\n- Operational readiness\n- Integration correctness\n- Scalability assessment\n\n**If validation fails:** Report blockers. Recommendations can proceed to later passes.\n\n‚Üí See `code-validation` skill for details\n\n## Pass 3: PR Hygiene\n\n**Analyze PR-specific concerns.**\n\n### 3.1 Diff Analysis\n\n**What changed, and is it appropriate?**\n\n| Check | What to Look For |\n|-------|------------------|\n| Scope | Does the diff match the PR description? |\n| Unrelated changes | Formatting, refactoring mixed with feature? |\n| Size | Is this reviewable? (>500 lines is a smell) |\n| Risk distribution | Are high-risk changes isolated? |\n\n**Red flags:**\n- PR titled \"Feature X\" but includes unrelated refactoring\n- Massive PR that should be split\n- Changes to critical paths buried in large diff\n\n‚Üí See `references/diff-analysis.md`\n\n### 3.2 Commit Quality\n\n**Are commits well-structured?**\n\n| Check | Good | Bad |\n|-------|------|-----|\n| Message format | \"Add user export endpoint\" | \"fixes\" |\n| Atomic commits | One logical change per commit | \"WIP\", \"more changes\" |\n| History | Clean, reviewable | Merge commits, reverts, fixups |\n| Commit scope | Matches message | Message says X, commit does Y |\n\n**Commit message format:**\n```\n<type>: <short summary>\n\n<body explaining what and why>\n\n<footer with references>\n```\n\nTypes: feat, fix, refactor, docs, test, chore\n\n‚Üí See `references/commit-quality.md`\n\n### 3.3 Documentation Updates\n\n**Is documentation in sync with code?**\n\n| Change Type | Documentation Needed |\n|-------------|---------------------|\n| New endpoint | API docs, README if public |\n| Config change | Config reference, deployment notes |\n| New feature | User-facing docs if applicable |\n| Breaking change | Migration guide, changelog |\n| New dependency | README, setup instructions |\n\n### 3.4 Test Coverage\n\n**Are changes tested?**\n\n| Check | Expectation |\n|-------|-------------|\n| New code | Has corresponding tests |\n| Bug fix | Has regression test |\n| Edge cases | Critical paths tested |\n| Coverage | No significant decrease |\n\n**Not everything needs tests**, but changes without tests need justification.\n\n‚Üí See `references/test-expectations.md`\n\n## Pass 4: Maintainability\n\n**Will future developers understand and extend this?**\n\n### 4.1 Naming\n\n| Element | Good Naming | Bad Naming |\n|---------|-------------|------------|\n| Functions | Verb + noun: `calculateTotal()` | `doIt()`, `process()`, `handle()` |\n| Variables | Descriptive: `userCount` | `x`, `temp`, `data` |\n| Booleans | Question form: `isActive`, `hasPermission` | `flag`, `status` |\n| Classes | Noun: `OrderProcessor` | `Manager`, `Helper`, `Utils` |\n\n**Ask:** Could someone understand this without context?\n\n### 4.2 Structure\n\n| Concern | What to Check |\n|---------|---------------|\n| Single responsibility | Does each function/class do one thing? |\n| Appropriate abstraction | Not too abstract, not too concrete |\n| Consistent patterns | Matches rest of codebase |\n| Reasonable file size | <500 lines per file |\n| Logical organization | Related code together |\n\n### 4.3 Code Clarity\n\n| Smell | Symptom | Fix |\n|-------|---------|-----|\n| Magic numbers | `if (status === 3)` | Named constants |\n| Deep nesting | 4+ levels of indentation | Early returns, extraction |\n| Long functions | >50 lines | Extract methods |\n| Complex conditionals | `if (a && b \\|\\| c && !d)` | Named predicates |\n| Comments explaining \"what\" | `// increment i` | Code should be self-documenting |\n\n**Good comments explain \"why\", not \"what\".**\n\n### 4.4 Consistency\n\n**Does this match codebase conventions?**\n\n- Formatting (should be automated)\n- Naming conventions\n- Error handling patterns\n- Logging patterns\n- File organization\n- Import ordering\n\n**Consistency > personal preference.** Match existing patterns unless changing them project-wide.\n\n‚Üí See `references/maintainability-checklist.md`\n\n## Synthesis: Merge Verdict\n\nAfter all passes, synthesize a verdict:\n\n### APPROVE\n\nAll of the following are true:\n- Verification passed (no structural issues)\n- Validation passed (no blockers)\n- PR hygiene acceptable\n- Maintainability acceptable\n- Minor issues documented as non-blocking comments\n\n### REQUEST_CHANGES\n\nAny of the following are true:\n- Verification failed (structural issues)\n- Validation has blockers\n- Critical PR hygiene issues (wrong target branch, breaking change without migration)\n- Severe maintainability issues\n\n### COMMENT\n\n- Validation passed but has recommendations\n- PR hygiene suggestions\n- Maintainability improvements suggested\n- Questions needing answers before approval\n\n## Feedback Formatting\n\n### Severity Levels\n\n| Level | Meaning | Action |\n|-------|---------|--------|\n| üö´ **Blocker** | Must fix before merge | REQUEST_CHANGES |\n| ‚ö†Ô∏è **Warning** | Should fix, but not blocking | COMMENT |\n| üí° **Suggestion** | Nice to have, optional | COMMENT |\n| ‚ùì **Question** | Need clarification | COMMENT |\n| ‚úÖ **Praise** | This is good, call it out | APPROVE |\n\n### Comment Structure\n\n```markdown\n**[SEVERITY] Category: Brief summary**\n\n[Explanation of the issue]\n\n[Specific location if applicable]\n\n[Suggested fix if applicable]\n```\n\n**Example:**\n```markdown\nüö´ **Security: SQL injection vulnerability**\n\nUser input is interpolated directly into the query string.\n\n`src/db/users.js:47`\n\nUse parameterized queries instead:\n```sql\nconst result = await db.query('SELECT * FROM users WHERE id = $1', [userId]);\n```\n```\n\n### Grouping Feedback\n\nGroup by file, then by severity:\n\n```markdown\n## src/services/order-service.js\n\nüö´ **Blocker:** Missing error handling for payment API timeout (line 142)\n\n‚ö†Ô∏è **Warning:** This function is 80 lines‚Äîconsider extracting payment logic (lines 120-200)\n\nüí° **Suggestion:** `processOrder` could be renamed to `submitOrderForPayment` for clarity\n\n## src/controllers/order-controller.js\n\n‚úÖ **Good:** Nice input validation pattern, matches our conventions\n```\n\n‚Üí See `references/feedback-formatting.md`\n\n## Output Format\n\n### Structured Output\n\n```json\n{\n  \"verdict\": \"REQUEST_CHANGES\",\n  \"summary\": \"Security issue blocks merge. Good feature implementation otherwise.\",\n  \"passes\": {\n    \"verification\": {\n      \"status\": \"fail\",\n      \"blockers\": 1,\n      \"warnings\": 0\n    },\n    \"validation\": {\n      \"status\": \"pass\",\n      \"blockers\": 0,\n      \"recommendations\": 2\n    },\n    \"pr_hygiene\": {\n      \"status\": \"pass\",\n      \"issues\": [\"Large PR‚Äîconsider splitting in future\"]\n    },\n    \"maintainability\": {\n      \"status\": \"warn\",\n      \"suggestions\": 3\n    }\n  },\n  \"blockers\": [\n    {\n      \"pass\": \"verification\",\n      \"category\": \"security\",\n      \"location\": \"src/db/users.js:47\",\n      \"issue\": \"SQL injection via string interpolation\",\n      \"suggestion\": \"Use parameterized query\"\n    }\n  ],\n  \"comments\": [\n    {\n      \"severity\": \"warning\",\n      \"location\": \"src/services/order-service.js:120-200\",\n      \"issue\": \"Function too long (80 lines)\",\n      \"suggestion\": \"Extract payment processing logic\"\n    }\n  ]\n}\n```\n\n### Conversational Output\n\n```markdown\n## Code Review: Add Order Export Feature\n\n### Verdict: REQUEST_CHANGES\n\nGood feature implementation, but there's a security issue that needs to be fixed before merge.\n\n---\n\n### üö´ Blockers (1)\n\n**Security: SQL injection in user lookup**\n`src/db/users.js:47`\n\nUser input is interpolated directly into the query. Use parameterized queries:\n```javascript\nconst result = await db.query('SELECT * FROM users WHERE id = $1', [userId]);\n```\n\n---\n\n### ‚ö†Ô∏è Warnings (2)\n\n**Long function in order-service.js**\n`src/services/order-service.js:120-200`\n\n`processOrder` is 80 lines. Consider extracting the payment processing logic into a separate function.\n\n**Missing test for edge case**\nThe export should handle empty order lists‚Äîadd a test case.\n\n---\n\n### üí° Suggestions (2)\n\n- Rename `processOrder` to `submitOrderForPayment` for clarity\n- Consider adding JSDoc for the new `exportOrders` function\n\n---\n\n### ‚úÖ What's Good\n\n- Clean separation between controller and service\n- Good input validation pattern\n- Matches existing codebase conventions\n\n---\n\nFix the SQL injection issue, and this is good to merge. The other items are non-blocking.\n```\n\n## Review Principles\n\n**Be constructive, not critical.** The goal is better code, not proving you're smart.\n\n**Distinguish blocking from non-blocking.** Don't block a PR for style preferences.\n\n**Explain the \"why\".** \"This is bad\" isn't helpful. \"This could cause X because Y\" is.\n\n**Offer solutions.** Don't just point out problems‚Äîsuggest fixes.\n\n**Acknowledge good work.** Positive feedback reinforces good patterns.\n\n**Right-size the review.** A typo fix doesn't need the same scrutiny as a payment system.\n\n**Consider the author.** Junior dev? More teaching. Senior dev? More trust.\n\n## Relationship to Other Skills\n\n| Skill | Relationship |\n|-------|--------------|\n| `code-verification` | Invoked as Pass 1 (thorough mode) |\n| `code-validation` | Invoked as Pass 2 |\n| `implement` | Review is the gate after implementation |\n| `test-generation` | Review may identify missing tests |\n| `spec` | Review checks against spec if available |\n| `frontend-design` | (Frontend systems) Review verifies code matches DESIGN.md |\n\n## References\n\n- `references/diff-analysis.md`: How to analyze what changed\n- `references/commit-quality.md`: Commit message and history standards\n- `references/test-expectations.md`: What tests to expect for different changes\n- `references/maintainability-checklist.md`: Code quality checklist\n- `references/feedback-formatting.md`: How to write effective review comments",
  "references": [
    {
      "name": "commit-quality.md",
      "path": "references/commit-quality.md",
      "content": "# Commit Quality\n\nStandards for commit messages and history.\n\n## Why This Matters\n\nCommits are documentation. They explain not just what changed but why. Good commit history makes debugging, reverting, and understanding code evolution possible. Bad history is noise that obscures the codebase's story.\n\n## Commit Message Format\n\n### Standard Format\n\n```\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n```\n\n### Components\n\n**Type** (required):\n| Type | When to Use |\n|------|-------------|\n| `feat` | New feature |\n| `fix` | Bug fix |\n| `refactor` | Code change that neither fixes nor adds |\n| `docs` | Documentation only |\n| `test` | Adding or fixing tests |\n| `chore` | Maintenance (deps, config, tooling) |\n| `perf` | Performance improvement |\n| `style` | Formatting, whitespace (no logic change) |\n\n**Scope** (optional): Component or area affected\n- `feat(auth): Add password reset`\n- `fix(orders): Handle empty cart`\n- `refactor(api): Extract validation middleware`\n\n**Subject** (required):\n- Imperative mood: \"Add feature\" not \"Added feature\"\n- No period at end\n- ‚â§50 characters\n- Capitalize first letter\n\n**Body** (optional but encouraged):\n- Explain what and why, not how\n- Wrap at 72 characters\n- Separate from subject with blank line\n\n**Footer** (optional):\n- Reference issues: `Fixes #123`, `Closes #456`\n- Note breaking changes: `BREAKING CHANGE: API endpoint renamed`\n- Co-authors: `Co-authored-by: Name <email>`\n\n### Examples\n\n**Good:**\n```\nfeat(orders): Add CSV export endpoint\n\nUsers can now export their order history as CSV. The export\nincludes order date, items, totals, and status.\n\n- Adds GET /api/orders/export endpoint\n- Supports date range filtering via query params\n- Limited to 10,000 orders per export\n\nCloses #234\n```\n\n**Good (simple):**\n```\nfix(auth): Handle expired token gracefully\n\nPreviously threw 500, now returns 401 with clear message.\n\nFixes #567\n```\n\n**Bad:**\n```\nfixed stuff\n```\n\n**Bad:**\n```\nWIP\n```\n\n**Bad:**\n```\nRefactoring and also fixed the bug and added some tests and updated deps\n```\n\n## Commit Atomicity\n\n### One Logical Change Per Commit\n\nEach commit should be:\n- **Complete:** Doesn't leave code in broken state\n- **Atomic:** Single logical change\n- **Reversible:** Can be reverted without breaking other changes\n\n**Good sequence:**\n```\n1. refactor(api): Extract validation to middleware\n2. feat(api): Add order export endpoint\n3. test(api): Add tests for order export\n4. docs(api): Document export endpoint\n```\n\n**Bad sequence:**\n```\n1. WIP export feature\n2. more work\n3. fix tests\n4. oops forgot this\n5. final cleanup\n```\n\n### When to Split Commits\n\nSplit when:\n- You're changing unrelated things\n- Your message needs \"and\" (feat: Add X and fix Y)\n- You could revert part but not all\n- Different parts could be reviewed separately\n\nDon't split when:\n- Changes are truly atomic (feature + its tests)\n- Splitting would leave intermediate broken states\n\n## History Hygiene\n\n### Before Opening PR\n\nClean up your history:\n\n| Issue | Fix |\n|-------|-----|\n| WIP commits | Interactive rebase, squash |\n| \"oops\" commits | Fixup into relevant commit |\n| Merge commits from main | Rebase instead |\n| Commits that break tests | Squash or reorder |\n\n**Interactive rebase workflow:**\n```bash\n# Rebase last N commits\ngit rebase -i HEAD~N\n\n# In editor:\npick abc123 feat: Add export endpoint\nfixup def456 oops forgot error handling\npick ghi789 test: Add export tests\nsquash jkl012 more tests\n```\n\n### Merge Strategy\n\n| Strategy | When to Use |\n|----------|-------------|\n| Squash merge | Small PRs, messy history |\n| Rebase merge | Clean history, want to preserve commits |\n| Merge commit | Want explicit merge record |\n\n**Team should agree on strategy** ‚Äî consistency matters more than choice.\n\n## Commit Quality Checklist\n\n### Per Commit\n\n```markdown\n- [ ] Message follows format (type: subject)\n- [ ] Subject is imperative mood\n- [ ] Subject ‚â§50 characters\n- [ ] Body explains what and why (if not obvious)\n- [ ] References issues if applicable\n- [ ] Commit is atomic (one logical change)\n- [ ] Tests pass at this commit\n```\n\n### PR History\n\n```markdown\n- [ ] No WIP or fixup commits\n- [ ] No \"oops\" commits\n- [ ] Logical progression of changes\n- [ ] No merge commits from main (rebased)\n- [ ] Each commit could be reverted independently\n```\n\n## Common Antipatterns\n\n### The Megacommit\n\n**Symptom:** Single commit with 500+ lines touching many files.\n\n**Problem:** Can't revert partially, hard to review, hard to understand.\n\n**Fix:** Split into logical commits, even retroactively via rebase.\n\n### The Stream of Consciousness\n\n**Symptom:**\n```\n1. start feature\n2. more work\n3. WIP\n4. almost done\n5. done\n6. fix tests\n7. really done\n```\n\n**Problem:** History tells no useful story.\n\n**Fix:** Squash into meaningful commits before PR.\n\n### The Merge Spaghetti\n\n**Symptom:** Lots of \"Merge branch 'main' into feature\" commits.\n\n**Problem:** Pollutes history, makes bisect difficult.\n\n**Fix:** Rebase onto main instead of merging.\n\n### The Lying Message\n\n**Symptom:** Message says \"fix: X\" but commit also adds feature Y.\n\n**Problem:** History is misleading, reverts are risky.\n\n**Fix:** Split into separate commits.\n\n## Review Guidance\n\n### What to Check\n\n| Aspect | Look For |\n|--------|----------|\n| Message format | Follows team conventions |\n| Atomicity | Each commit is one logical change |\n| Completeness | No broken intermediate states |\n| Accuracy | Messages match actual changes |\n| Cleanliness | No WIP, fixup, merge commits |\n\n### When to Request Changes\n\n- Commits leave tests broken\n- Messages are meaningless (\"asdf\", \"WIP\")\n- One commit mixes unrelated changes\n- History is hard to follow\n\n### When to Let It Go\n\n- Minor formatting issues in messages\n- Slightly large but logical commits\n- Team hasn't agreed on standards (establish standards first)\n\n## Output Format\n\nWhen reporting commit quality:\n\n```markdown\n## Commit Quality\n\n**Commits:** 4\n\n### Assessment\n\n‚úÖ Good:\n- Clear, descriptive messages\n- Logical progression of changes\n- Tests pass at each commit\n\n‚ö†Ô∏è Issues:\n- Commit 3 (\"fix tests\") should be squashed into commit 2\n- Commit 4 message doesn't follow format (missing type)\n\n### Commits\n\n1. `feat(orders): Add export endpoint` ‚úÖ\n   - Clear message, atomic change\n\n2. `feat(orders): Add date filtering to export` ‚úÖ\n   - Good incremental addition\n\n3. `fix tests` ‚ö†Ô∏è\n   - Should be squashed into commit 2\n   - Message doesn't follow format\n\n4. `update readme` ‚ö†Ô∏è\n   - Should be `docs(orders): Document export endpoint`\n\n### Recommendation\n\nMinor cleanup needed before merge:\n1. Squash commit 3 into commit 2\n2. Reword commit 4 to follow format\n```\n"
    },
    {
      "name": "diff-analysis.md",
      "path": "references/diff-analysis.md",
      "content": "# Diff Analysis\n\nHow to analyze what changed in a PR and whether the changes are appropriate.\n\n## Why This Matters\n\nThe diff is the artifact under review. Understanding what changed‚Äîand what didn't change but should have‚Äîis fundamental to good review. Large or unfocused diffs hide bugs and make review ineffective.\n\n## Diff Analysis Framework\n\n### 1. Scope Alignment\n\n**Does the diff match the PR description?**\n\n| Situation | Action |\n|-----------|--------|\n| Diff matches description | Proceed with review |\n| Diff is subset of description | Note incomplete work |\n| Diff exceeds description | Question unrelated changes |\n| Diff contradicts description | Request clarification |\n\n**Red flags:**\n- PR titled \"Fix login bug\" includes refactoring of unrelated code\n- PR titled \"Add feature X\" also includes \"while I was there\" changes\n- Description says one thing, code does another\n\n### 2. Change Classification\n\nClassify each change in the diff:\n\n| Type | Examples | Review Focus |\n|------|----------|--------------|\n| **Feature** | New endpoints, components, logic | Correctness, completeness |\n| **Bugfix** | Error handling, edge cases | Root cause addressed, regression test |\n| **Refactor** | Restructuring without behavior change | Behavior preserved, tests pass |\n| **Chore** | Dependencies, config, tooling | Security, compatibility |\n| **Docs** | README, comments, API docs | Accuracy, completeness |\n| **Test** | New tests, test fixes | Coverage, reliability |\n\n**Mixed PRs are smells.** A PR should ideally be one type. \"Feature + Refactor\" should usually be two PRs.\n\n### 3. Size Assessment\n\n| Lines Changed | Assessment | Action |\n|---------------|------------|--------|\n| < 100 | Small | Normal review |\n| 100-300 | Medium | Careful review |\n| 300-500 | Large | Consider splitting |\n| 500+ | Too large | Request split |\n\n**Exceptions to size limits:**\n- Generated code (migrations, schemas)\n- Bulk renames/moves (but verify they're mechanical)\n- New files with tests (test code inflates counts)\n- Deletion-heavy changes (removing code is usually safe)\n\n**Not exceptions:**\n- \"It's all related\" ‚Äî Large related changes should still be incremental\n- \"It was easier to do together\" ‚Äî Easier to write ‚â† easier to review\n\n### 4. Risk Distribution\n\n**Where are the high-risk changes?**\n\n| Risk Level | Examples |\n|------------|----------|\n| **Critical** | Auth, payments, data mutations, security |\n| **High** | Core business logic, integrations, migrations |\n| **Medium** | Feature code, UI components |\n| **Low** | Tests, docs, config, logging |\n\n**Good PRs:** High-risk changes are isolated, small, and obvious.\n**Bad PRs:** High-risk changes are buried in large diffs or mixed with low-risk noise.\n\n### 5. File-by-File Analysis\n\nFor each file changed:\n\n```markdown\n### [filename]\n\n**Type:** Feature / Bugfix / Refactor / Chore / Docs / Test\n**Risk:** Critical / High / Medium / Low\n**Changes:**\n- [Summary of what changed]\n**Questions:**\n- [Anything unclear or concerning]\n```\n\n### 6. What's Missing?\n\nSometimes the most important review finding is what's NOT in the diff:\n\n| Expected | Why It Might Be Missing |\n|----------|------------------------|\n| Tests | Forgot, deferred, \"tested manually\" |\n| Migration | Schema change without migration |\n| Documentation | New feature without docs |\n| Config changes | Feature flag, environment variable |\n| Error handling | Happy path only |\n| Logging | New operation without observability |\n\n## Diff Patterns\n\n### Pattern: Shotgun Surgery\n\n**Symptom:** Many files changed, each with small modifications.\n\n**Possible causes:**\n- Legitimate cross-cutting change (rename, new parameter)\n- Poor abstraction (change requires touching many places)\n- Breaking encapsulation\n\n**Review action:** Verify changes are mechanical and consistent. If not mechanical, question the design.\n\n### Pattern: God Commit\n\n**Symptom:** One commit with hundreds of lines across many files.\n\n**Possible causes:**\n- Developer forgot to commit incrementally\n- Genuine atomic change (rare)\n- Squashed messy history\n\n**Review action:** Request breakdown or detailed explanation of how pieces relate.\n\n### Pattern: Test-to-Code Ratio\n\n**Healthy ratio:** 0.5x to 2x test lines per code line.\n\n| Ratio | Interpretation |\n|-------|----------------|\n| 0x | No tests ‚Äî flag unless trivial change |\n| 0.1x-0.5x | Light testing ‚Äî acceptable for simple changes |\n| 0.5x-2x | Good coverage |\n| 2x+ | Thorough ‚Äî great for critical code |\n| 10x+ | Excessive? ‚Äî verify tests are meaningful |\n\n### Pattern: Refactor + Feature\n\n**Symptom:** PR includes both behavior changes and structural changes.\n\n**Problem:** Can't tell if bugs are from feature or refactor.\n\n**Solution:** Split into:\n1. PR 1: Refactor (all tests pass, no behavior change)\n2. PR 2: Feature (builds on clean refactored code)\n\n## Diff Review Checklist\n\n```markdown\n## Diff Analysis\n\n**PR:** [Title]\n**Size:** [X] lines changed across [Y] files\n\n### Scope\n- [ ] Changes match PR description\n- [ ] No unrelated changes\n- [ ] Scope is appropriate (not too big)\n\n### Classification\n- [ ] Clear change type (feature/bugfix/refactor/etc.)\n- [ ] Not mixing multiple change types\n\n### Risk\n- [ ] High-risk changes identified\n- [ ] High-risk changes are isolated and reviewable\n- [ ] No buried critical changes\n\n### Completeness\n- [ ] Expected tests present\n- [ ] Documentation updated if needed\n- [ ] Migration included if needed\n- [ ] No obvious missing pieces\n\n### Files Summary\n| File | Type | Risk | Notes |\n|------|------|------|-------|\n| ... | ... | ... | ... |\n```\n\n## Output Format\n\nWhen reporting diff analysis:\n\n```markdown\n## Diff Analysis\n\n**Size:** 247 lines across 8 files ‚Äî Medium, acceptable\n\n**Scope:** ‚úÖ Matches description \"Add order export feature\"\n\n**Classification:** Feature + Test (appropriate)\n\n**Risk Distribution:**\n- Critical: None\n- High: `src/services/order-service.js` (business logic)\n- Medium: `src/controllers/order-controller.js`\n- Low: `tests/*`, `README.md`\n\n**Missing:**\n- ‚ö†Ô∏è No migration for new `export_format` column\n- üí° Consider adding JSDoc for new public function\n\n**Concerns:**\n- None identified\n```\n"
    },
    {
      "name": "feedback-formatting.md",
      "path": "references/feedback-formatting.md",
      "content": "# Feedback Formatting\n\nHow to write effective code review comments.\n\n## Why This Matters\n\nThe same technical feedback can build people up or tear them down. Good feedback is specific, actionable, and kind. Bad feedback is vague, personal, and discouraging. The goal is better code AND better engineers.\n\n## Feedback Principles\n\n### 1. Be Specific\n\n**Bad:** \"This is confusing.\"\n**Good:** \"The function name `process` doesn't indicate what's being processed. Consider `processPayment` or `validateOrder`.\"\n\n**Bad:** \"This could be better.\"\n**Good:** \"This has O(n¬≤) complexity due to the nested find(). Build a Map for O(1) lookups.\"\n\n### 2. Explain the Why\n\n**Bad:** \"Don't use var.\"\n**Good:** \"Use `const` instead of `var` here‚Äîthe value never changes, and `const` signals that intent to readers.\"\n\n**Bad:** \"Add error handling.\"\n**Good:** \"If the API call fails, this will throw an unhandled error. Add try/catch to return a meaningful error to users.\"\n\n### 3. Suggest Solutions\n\n**Bad:** \"This won't scale.\"\n**Good:** \"This loads all orders into memory, which won't work once we have 10K+ orders. Consider pagination or streaming.\"\n\n### 4. Distinguish Blocking from Non-Blocking\n\n**Blocking (must fix):**\n- Security vulnerabilities\n- Bugs that will break production\n- Missing critical requirements\n- Breaking changes without migration\n\n**Non-blocking (should fix but won't block):**\n- Code style issues\n- Performance optimizations for non-critical paths\n- Naming improvements\n- Missing optional features\n\n**Non-blocking (nice to have):**\n- Alternative approaches\n- Future improvements\n- Style preferences\n\n### 5. Acknowledge Good Work\n\nDon't just point out problems. Call out what's done well:\n- \"Nice test coverage!\"\n- \"Good error handling here.\"\n- \"This abstraction makes the code much cleaner.\"\n\n## Severity Markers\n\nUse consistent markers so authors know what's required:\n\n| Marker | Meaning | Author Action |\n|--------|---------|---------------|\n| üö´ **Blocker** | Must fix to merge | Fix before approval |\n| ‚ö†Ô∏è **Warning** | Should fix, significant issue | Fix or explain why not |\n| üí° **Suggestion** | Optional improvement | Consider for this PR or future |\n| ‚ùì **Question** | Need clarification | Respond before approval |\n| üîß **Nit** | Trivial issue, nitpick | Fix if easy, ignore if not |\n| ‚úÖ **Praise** | This is good | Keep doing this |\n\n## Comment Templates\n\n### Security Issue\n\n```markdown\nüö´ **Security: [vulnerability type]**\n\n[Description of the vulnerability and why it's dangerous]\n\n`[file:line]`\n\n[How to fix it with code example if helpful]\n\n[Link to reference if applicable]\n```\n\n**Example:**\n```markdown\nüö´ **Security: SQL Injection**\n\nUser input is concatenated directly into the query string, allowing attackers to execute arbitrary SQL.\n\n`src/db/users.js:47`\n\nUse parameterized queries:\n```js\nconst result = await db.query('SELECT * FROM users WHERE id = $1', [userId]);\n```\n\nSee: https://owasp.org/www-community/attacks/SQL_Injection\n```\n\n### Bug or Logic Error\n\n```markdown\n‚ö†Ô∏è **Bug: [brief description]**\n\n[What's wrong and what will happen]\n\n`[file:line]`\n\n[Suggested fix]\n```\n\n**Example:**\n```markdown\n‚ö†Ô∏è **Bug: Off-by-one in pagination**\n\nThe last page will be missing one item because `slice(start, end)` excludes `end`.\n\n`src/utils/paginate.js:23`\n\nChange to `slice(start, end + 1)` or use `start + pageSize` instead of `end`.\n```\n\n### Improvement Suggestion\n\n```markdown\nüí° **Suggestion: [brief description]**\n\n[What could be better and why]\n\n[Optional: alternative approach]\n```\n\n**Example:**\n```markdown\nüí° **Suggestion: Extract to named constant**\n\nThe retry count `3` appears twice and its meaning isn't clear.\n\nConsider:\n```js\nconst MAX_PAYMENT_RETRIES = 3;\n```\n```\n\n### Clarifying Question\n\n```markdown\n‚ùì **Question: [what you're asking]**\n\n[Context for why you're asking]\n```\n\n**Example:**\n```markdown\n‚ùì **Question: Should this also handle the `refunded` status?**\n\nI see handling for `completed` and `failed`, but customers can also have refunded orders. Is that intentional or should we add it?\n```\n\n### Praise\n\n```markdown\n‚úÖ **Nice: [what's good]**\n\n[Why it's good, optional]\n```\n\n**Example:**\n```markdown\n‚úÖ **Nice error handling**\n\nGood separation of user-facing error messages from logged details. This pattern makes debugging easier without exposing internals.\n```\n\n## Comment Tone\n\n### Use \"We\" Language\n\n**Instead of:** \"You should...\"\n**Use:** \"We could...\" or \"Consider...\"\n\n**Instead of:** \"You forgot to...\"\n**Use:** \"This needs...\" or \"Missing...\"\n\n**Instead of:** \"Why did you...\"\n**Use:** \"What's the reason for...\" or \"I'm curious about...\"\n\n### Ask, Don't Demand\n\n**Instead of:** \"Change this to X.\"\n**Use:** \"Would X work better here because...?\"\n\n**Instead of:** \"This is wrong.\"\n**Use:** \"I think there might be an issue here‚Äî[explanation]\"\n\n### Assume Good Intent\n\n**Instead of:** \"Did you even test this?\"\n**Use:** \"This might cause an issue when [scenario]‚Äîcan we add a test?\"\n\n**Instead of:** \"This is poorly designed.\"\n**Use:** \"I have some concerns about this approach‚Äî[specific concerns]\"\n\n## Comment Placement\n\n### Inline Comments\n\nUse for:\n- Line-specific issues\n- Quick fixes\n- Code suggestions\n\n### Summary Comment\n\nUse for:\n- Overall assessment\n- Architectural concerns\n- Cross-cutting issues\n- Praise for overall approach\n\n**Structure:**\n```markdown\n## Summary\n\n[Overall assessment]\n\n### Blockers\n- [List of must-fix items]\n\n### Suggestions\n- [List of optional improvements]\n\n### Questions\n- [List of clarifications needed]\n\n### What's Good\n- [Positive feedback]\n```\n\n## Handling Disagreement\n\n### When Author Pushes Back\n\n1. **Listen first.** They may have context you don't.\n2. **Ask questions.** \"Help me understand why...\"\n3. **Explain impact.** \"My concern is that this could cause...\"\n4. **Propose compromise.** \"Would it work to...\"\n5. **Escalate if needed.** Bring in a third opinion.\n\n### When You're Wrong\n\n**Just say so:**\n\"Good point, I missed that. Approved!\"\n\nDon't double down or hedge. Being wrong sometimes means you're learning.\n\n## Review Etiquette\n\n| Do | Don't |\n|----|-------|\n| Review promptly (same day ideal) | Let PRs languish for days |\n| Batch feedback (one review pass) | Drip comments over hours |\n| Respond to responses | Ignore author's replies |\n| Approve once concerns addressed | Require new review for nits |\n| Thank the author | Take good work for granted |\n\n## Output Format\n\nWhen synthesizing review feedback:\n\n```markdown\n## Code Review Summary\n\n### Verdict: REQUEST_CHANGES\n\nOverall good implementation. One security issue needs to be fixed.\n\n---\n\n### üö´ Blockers (1)\n\n1. **Security: SQL injection** in `src/db/users.js:47`\n   - User input concatenated into query\n   - Fix: Use parameterized query\n\n---\n\n### ‚ö†Ô∏è Warnings (2)\n\n1. **Bug: Pagination off-by-one** in `src/utils/paginate.js:23`\n   - Last page missing one item\n\n2. **Missing test for error case** in order export\n   - Add test for API failure scenario\n\n---\n\n### üí° Suggestions (3)\n\n1. Extract magic number `3` to `MAX_RETRIES` constant\n2. Consider renaming `processData` to `transformOrderData`\n3. `handleError` could log request ID for debugging\n\n---\n\n### ‚úÖ What's Good\n\n- Clean separation of concerns\n- Comprehensive happy path tests\n- Good error messages for users\n\n---\n\n**Next steps:** Fix the SQL injection issue, and let's discuss the pagination bug.\n```\n"
    },
    {
      "name": "maintainability-checklist.md",
      "path": "references/maintainability-checklist.md",
      "content": "# Maintainability Checklist\n\nHow to assess long-term code health.\n\n## Why This Matters\n\nCode is read more than written. Code that works today but can't be understood tomorrow is a liability. Maintainability is about respecting future developers‚Äîincluding future you.\n\n## Maintainability Dimensions\n\n### 1. Naming\n\n**Variables and Parameters**\n\n| Good | Bad | Why |\n|------|-----|-----|\n| `userCount` | `n`, `count` | Unclear what's being counted |\n| `isActive` | `flag`, `status` | Boolean should be yes/no question |\n| `maxRetries` | `max`, `m` | Max of what? |\n| `orderTotal` | `total` | Total of what? |\n| `filteredUsers` | `result` | What's in the result? |\n\n**Functions and Methods**\n\n| Good | Bad | Why |\n|------|-----|-----|\n| `calculateShippingCost` | `calc`, `process` | What does it calculate/process? |\n| `validateEmail` | `check` | Check what? Return what? |\n| `fetchUserOrders` | `getData` | What data? |\n| `isExpired` | `checkExpiry` | Boolean functions should be predicates |\n| `sendWelcomeEmail` | `handleUser` | Handle how? |\n\n**Classes and Types**\n\n| Good | Bad | Why |\n|------|-----|-----|\n| `OrderRepository` | `OrderManager` | Manager doesn't say what it does |\n| `EmailValidator` | `Helper` | Helper is meaningless |\n| `PaymentProcessor` | `PaymentUtils` | Utils is a junk drawer |\n| `UserSession` | `UserData` | Data is vague |\n\n**Anti-patterns:**\n- `Manager`, `Helper`, `Utils`, `Handler` ‚Äî usually means unclear responsibility\n- Single letters except in tiny scopes (loop indices)\n- Abbreviations that aren't universally known\n- Names that lie (`userList` that's actually a Map)\n\n### 2. Function Design\n\n**Length**\n\n| Lines | Assessment |\n|-------|------------|\n| 1-10 | Great |\n| 10-30 | Fine |\n| 30-50 | Consider splitting |\n| 50+ | Should split |\n\n**Complexity**\n\n| Issue | Symptom | Fix |\n|-------|---------|-----|\n| Too many parameters | >3-4 params | Introduce parameter object |\n| Deep nesting | >3 levels | Early returns, extract methods |\n| Long conditionals | `if (a && b \\|\\| c && !d)` | Extract to named predicate |\n| Multiple responsibilities | Does A, B, and C | Split into focused functions |\n\n**Function Design Principles:**\n\n- **Do one thing.** If you need \"and\" to describe it, split it.\n- **Same level of abstraction.** Don't mix high-level and low-level.\n- **Few side effects.** Prefer returning values to mutating state.\n- **Fail fast.** Handle error cases at the top, happy path below.\n\n**Example: Before**\n```javascript\nfunction processOrder(order, user, config) {\n  if (order) {\n    if (order.items && order.items.length > 0) {\n      let total = 0;\n      for (let i = 0; i < order.items.length; i++) {\n        if (order.items[i].price) {\n          total += order.items[i].price * order.items[i].quantity;\n        }\n      }\n      if (user.discount) {\n        total = total * (1 - user.discount);\n      }\n      if (total > config.freeShippingThreshold) {\n        // shipping is free\n      } else {\n        total += config.shippingCost;\n      }\n      return total;\n    }\n  }\n  return 0;\n}\n```\n\n**Example: After**\n```javascript\nfunction calculateOrderTotal(order, user, config) {\n  if (!order?.items?.length) return 0;\n  \n  const subtotal = calculateSubtotal(order.items);\n  const discounted = applyDiscount(subtotal, user.discount);\n  const shipping = calculateShipping(discounted, config);\n  \n  return discounted + shipping;\n}\n\nfunction calculateSubtotal(items) {\n  return items.reduce((sum, item) => \n    sum + (item.price ?? 0) * (item.quantity ?? 0), 0);\n}\n\nfunction applyDiscount(amount, discount) {\n  return discount ? amount * (1 - discount) : amount;\n}\n\nfunction calculateShipping(subtotal, config) {\n  return subtotal > config.freeShippingThreshold ? 0 : config.shippingCost;\n}\n```\n\n### 3. Code Structure\n\n**File Organization**\n\n| Guideline | Rationale |\n|-----------|-----------|\n| One concept per file | Easy to find things |\n| Related code together | Changes are localized |\n| Public API at top | Readers see interface first |\n| Implementation details below | Can skip if not needed |\n| <500 lines per file | Larger files are harder to navigate |\n\n**Module Organization**\n\n| Pattern | When to Use |\n|---------|-------------|\n| By feature | When features are independent |\n| By layer | When cross-cutting concerns dominate |\n| By domain | When domain boundaries are clear |\n\n**Dependency Direction**\n\nGood:\n```\nController ‚Üí Service ‚Üí Repository ‚Üí Database\n```\n\nBad:\n```\nController ‚Üê ‚Üí Service ‚Üê ‚Üí Repository (circular)\n```\n\n### 4. Comments\n\n**Good Comments (Why)**\n\n```javascript\n// We retry 3 times because the payment API has intermittent failures\n// that resolve within seconds. See incident report #456.\nconst MAX_RETRIES = 3;\n\n// Using linear search because n < 20 and the added complexity\n// of maintaining a sorted structure isn't worth it.\nconst item = items.find(i => i.id === targetId);\n```\n\n**Bad Comments (What)**\n\n```javascript\n// Increment counter\ncounter++;\n\n// Loop through users\nfor (const user of users) {\n\n// Check if null\nif (value === null) {\n```\n\n**Comment Rules:**\n\n- Comment **why**, not **what**\n- Comment surprises, workarounds, business rules\n- Don't comment obvious code‚Äîimprove the code instead\n- Keep comments updated (stale comments are worse than none)\n\n### 5. Consistency\n\n**Within File:**\n- Same naming conventions throughout\n- Same patterns (arrow vs function, etc.)\n- Same error handling approach\n\n**Within Codebase:**\n- Match existing patterns\n- Match existing naming\n- Match existing structure\n\n**Consistency > Personal Preference.**\n\nIf the codebase uses `callback` but you prefer `cb`, use `callback`. Consistency aids comprehension.\n\n### 6. Testability\n\nCode that's hard to test is often poorly designed.\n\n| Testing Difficulty | Design Issue |\n|-------------------|--------------|\n| Can't test in isolation | Too many dependencies |\n| Need complex setup | Too much coupling |\n| Tests are brittle | Testing implementation, not behavior |\n| Can't mock dependency | Hardcoded dependencies |\n| Random/time-dependent | Impure functions |\n\n**Design for testability:**\n- Inject dependencies\n- Separate pure logic from I/O\n- Small, focused functions\n- Avoid global state\n\n## Maintainability Review Checklist\n\n```markdown\n### Naming\n- [ ] Variables describe what they hold\n- [ ] Functions describe what they do\n- [ ] No meaningless names (temp, data, result, manager)\n- [ ] Consistent naming conventions\n\n### Structure\n- [ ] Functions are focused (one job)\n- [ ] Functions are short (<50 lines)\n- [ ] Nesting is shallow (<4 levels)\n- [ ] Files are focused (<500 lines)\n- [ ] Related code is grouped\n\n### Clarity\n- [ ] Code is self-documenting\n- [ ] Comments explain why, not what\n- [ ] No dead/commented code\n- [ ] No magic numbers\n\n### Consistency\n- [ ] Matches codebase conventions\n- [ ] Patterns are applied uniformly\n- [ ] Similar code looks similar\n\n### Testability\n- [ ] Dependencies are injectable\n- [ ] Pure logic is separated\n- [ ] No global state mutation\n```\n\n## Output Format\n\nWhen reporting maintainability:\n\n```markdown\n## Maintainability Assessment\n\n### Naming\n\n‚úÖ Good:\n- Function names are clear and descriptive\n- Variable names describe their contents\n\n‚ö†Ô∏è Issues:\n- `data` in `processData()` line 45 ‚Äî what kind of data?\n- `result` used throughout ‚Äî be specific\n\n### Structure\n\n‚úÖ Good:\n- Functions are reasonably sized\n- Clear separation between controller and service\n\n‚ö†Ô∏è Issues:\n- `processOrder()` is 75 lines ‚Äî consider splitting\n- 5 levels of nesting in `validateItems()` ‚Äî use early returns\n\n### Clarity\n\n‚úÖ Good:\n- Business rules have explanatory comments\n\n‚ö†Ô∏è Issues:\n- Magic number `3` on line 67 ‚Äî extract to named constant\n- Commented-out code on lines 120-135 ‚Äî remove\n\n### Consistency\n\n‚úÖ Good:\n- Follows existing codebase patterns\n- Naming conventions match\n\n### Verdict\n\nMinor maintainability issues. Non-blocking, but recommend:\n1. Rename generic variables\n2. Extract magic numbers\n3. Remove dead code\n```\n"
    },
    {
      "name": "test-expectations.md",
      "path": "references/test-expectations.md",
      "content": "# Test Expectations\n\nWhat tests to expect for different types of changes.\n\n## Why This Matters\n\nTests are proof that code works. During review, missing tests are as important as buggy code‚Äîmaybe more, because bugs will be discovered eventually, but missing tests are missing forever.\n\n## Test Expectations by Change Type\n\n### Feature Code\n\n**Expectation:** Tests for new functionality.\n\n| Feature Type | Expected Tests |\n|--------------|----------------|\n| New endpoint | Request/response for happy path + errors |\n| New UI component | Render test, interaction tests |\n| New service method | Unit test for logic, mock dependencies |\n| New utility function | Unit tests including edge cases |\n\n**Minimum bar:** Happy path works.\n**Good bar:** Happy path + error cases + edge cases.\n\n### Bug Fixes\n\n**Expectation:** Regression test proving the bug is fixed.\n\n```markdown\n1. Test that would have caught the bug (fails before fix)\n2. After fix, test passes\n3. Bug can never silently regress\n```\n\n**If no test:** The bug WILL come back. It's not fixed, it's hiding.\n\n### Refactoring\n\n**Expectation:** Existing tests still pass. No new tests required.\n\n**If tests break:** Refactoring changed behavior (not a refactor).\n**If tests don't exist:** Add them before refactoring, so you know behavior is preserved.\n\n### Configuration Changes\n\n**Expectation:** Depends on what changed.\n\n| Change | Testing Expectation |\n|--------|---------------------|\n| Environment variable | Verify default behavior, document |\n| Dependency update | Full test suite passes |\n| Build config | Build still works, artifacts correct |\n| Feature flag | Test both flag states |\n\n### Data Model Changes\n\n**Expectation:** Tests for new model behavior.\n\n| Change | Testing Expectation |\n|--------|---------------------|\n| New field | Validation tests if validated |\n| New relation | Tests for relationship behavior |\n| New constraint | Tests that constraint is enforced |\n| Migration | Migration runs both directions |\n\n## Test Coverage Levels\n\n### Critical Code (Must Test)\n\n- Authentication/authorization\n- Payment processing\n- Data mutations (create, update, delete)\n- Security-sensitive operations\n- Core business logic\n- Public API contracts\n\n### Important Code (Should Test)\n\n- Most feature code\n- Validation logic\n- Error handling paths\n- Integration points\n- State management\n\n### Lower Priority (Nice to Test)\n\n- Pure UI (visual testing harder to maintain)\n- Configuration wiring\n- Logging/metrics (verify in integration)\n- Simple CRUD without business logic\n\n### Don't Test\n\n- Framework code (test your code, not React)\n- Third-party libraries\n- Generated code (test the generator)\n- Trivial getters/setters\n\n## Test Quality Criteria\n\n### Good Tests\n\n| Quality | Description |\n|---------|-------------|\n| **Isolated** | Doesn't depend on other tests or external state |\n| **Repeatable** | Same result every time |\n| **Fast** | Runs in milliseconds (unit) or seconds (integration) |\n| **Clear** | Test name explains what's being tested |\n| **Focused** | Tests one thing, fails for one reason |\n| **Maintainable** | Easy to update when requirements change |\n\n### Test Smells\n\n| Smell | Symptom | Problem |\n|-------|---------|---------|\n| **Brittle** | Breaks on unrelated changes | Tests implementation, not behavior |\n| **Slow** | Takes seconds per test | Too much setup, not isolated |\n| **Flaky** | Sometimes passes, sometimes fails | Race conditions, external deps |\n| **Obscure** | Hard to tell what it tests | Bad naming, too complex |\n| **Redundant** | Tests same thing multiple ways | Maintenance burden |\n| **Gap-covering** | Tests only to increase coverage | Not testing useful scenarios |\n\n## Test Review Checklist\n\n### Are Tests Present?\n\n```markdown\nFor each production code change:\n- [ ] Corresponding test exists\n- [ ] Test would fail without the change\n- [ ] Test covers the primary use case\n```\n\n### Are Tests Sufficient?\n\n```markdown\n- [ ] Happy path tested\n- [ ] Error cases tested\n- [ ] Edge cases tested (null, empty, boundary)\n- [ ] Integration points mocked/stubbed appropriately\n```\n\n### Are Tests Good?\n\n```markdown\n- [ ] Test names describe the scenario\n- [ ] Tests are focused (one assertion per test or logical group)\n- [ ] Tests don't depend on each other\n- [ ] Tests don't depend on external state\n- [ ] No obvious flakiness risks (time, network, random)\n```\n\n## Missing Test Scenarios\n\nCommon scenarios that should have tests but often don't:\n\n### API Endpoints\n\n- [ ] Valid request returns expected response\n- [ ] Invalid request returns appropriate error\n- [ ] Missing auth returns 401\n- [ ] Forbidden action returns 403\n- [ ] Not found returns 404\n- [ ] Malformed request returns 400\n- [ ] Server error is handled gracefully\n\n### Data Validation\n\n- [ ] Valid data passes\n- [ ] Missing required field fails\n- [ ] Wrong type fails\n- [ ] Out-of-range value fails\n- [ ] Empty string vs null handling\n- [ ] Unicode/special characters handled\n\n### State Transitions\n\n- [ ] Valid transition succeeds\n- [ ] Invalid transition fails with message\n- [ ] Concurrent transitions handled\n- [ ] Transition from each state tested\n\n### Collections/Lists\n\n- [ ] Empty list\n- [ ] Single item\n- [ ] Multiple items\n- [ ] Maximum size\n- [ ] Pagination boundaries\n- [ ] Filtering returns correct subset\n- [ ] Sorting works correctly\n\n## When No Tests Are Acceptable\n\nTesting isn't always required. Acceptable exceptions:\n\n| Situation | Rationale |\n|-----------|-----------|\n| Spike/prototype | Code will be rewritten |\n| Trivial change | Risk is very low (typo fix) |\n| Generated code | Test the generator instead |\n| Dead code removal | Removing tests is fine |\n| Config-only change | Manual verification sufficient |\n\n**But document the justification.** \"No tests because X\" is better than silent omission.\n\n## Output Format\n\nWhen reporting test expectations:\n\n```markdown\n## Test Coverage\n\n### Changes Without Tests\n\n| File | Change | Expected Test |\n|------|--------|---------------|\n| `order-service.js` | New `exportOrders` function | Unit test for export logic |\n| `order-controller.js` | New endpoint | API test for request/response |\n\n### Test Gaps\n\n‚ö†Ô∏è **Missing edge cases:**\n- No test for empty order list\n- No test for date range with no orders\n- No test for export format validation\n\n### Existing Tests\n\n‚úÖ Happy path tested:\n- Export with valid orders\n- Date filtering works\n\n‚úÖ Error cases tested:\n- Authentication required\n\n### Recommendation\n\nAdd tests for edge cases before merge:\n1. Empty order list should return empty CSV (not error)\n2. Invalid date range should return 400\n```\n"
    }
  ],
  "tags": [
    "quality",
    "review",
    "core-workflow"
  ],
  "dependsOn": [
    "code-verification"
  ]
}