{
  "id": "history-collector",
  "name": "history-collector",
  "version": "1.0.0",
  "description": "Collects execution history for async context. Gathers recent loop executions, outcomes, and learnings to inform queue planning.",
  "phase": "GATHER",
  "category": "operations",
  "content": "# History Collector\n\nGathers execution history to provide temporal context for async operation.\n\n## When to Use\n\n- During async-loop GATHER phase\n- To understand recent activity and momentum\n- To identify incomplete work needing continuation\n\n## What It Collects\n\n### Execution History\n\n| Data | Source | Purpose |\n|------|--------|---------|\n| Recent executions | Run archives | What was done recently |\n| Outcomes | Execution results | Success/failure patterns |\n| Duration data | Timestamps | Actual vs estimated time |\n| Gate history | Gate records | Approval patterns |\n\n### Analysis Points\n\n- Last 10 completed executions\n- Any incomplete executions\n- Failed executions needing retry\n- Gate approval wait times\n\n## Workflow\n\n### Step 1: Query Execution History\n\n```typescript\nconst history = await runArchivalService.queryRuns({\n  limit: 20,\n  sortBy: 'completedAt',\n  order: 'desc'\n});\n```\n\n### Step 2: Categorize Executions\n\n```json\n{\n  \"executions\": {\n    \"completed\": [...],\n    \"incomplete\": [...],\n    \"failed\": [...]\n  }\n}\n```\n\n### Step 3: Extract Insights\n\n```typescript\nconst insights = {\n  recentLoops: extractLoopTypes(history.completed),\n  averageDuration: calculateAvgDuration(history.completed),\n  successRate: calculateSuccessRate(history),\n  commonGateDelays: findGatePatterns(history)\n};\n```\n\n### Step 4: Identify Action Items\n\n- Incomplete executions to resume\n- Failed executions to retry\n- Patterns to inform queue\n\n## Output\n\nUpdates `memory/async-context.json`:\n\n```json\n{\n  \"history\": {\n    \"collected_at\": \"ISO-timestamp\",\n    \"recent_executions\": [\n      {\n        \"id\": \"exec-123\",\n        \"loop\": \"engineering-loop\",\n        \"completed_at\": \"ISO-timestamp\",\n        \"duration_minutes\": 180,\n        \"outcome\": \"success\"\n      }\n    ],\n    \"incomplete\": [],\n    \"needs_retry\": [],\n    \"insights\": {\n      \"most_common_loop\": \"engineering-loop\",\n      \"average_duration_minutes\": 120,\n      \"success_rate\": 0.92,\n      \"avg_gate_wait_minutes\": 15\n    },\n    \"momentum\": {\n      \"streak\": 5,\n      \"last_active\": \"ISO-timestamp\",\n      \"days_since_activity\": 0\n    }\n  }\n}\n```\n\n## Required Deliverables\n\n| Deliverable | Location | Condition |\n|-------------|----------|-----------|\n| Updated async context | `memory/async-context.json` | Always |\n\n## Momentum Tracking\n\n### Streak Calculation\n\n```typescript\nconst streak = countConsecutiveSuccesses(history.completed);\n```\n\n### Activity Recency\n\n```typescript\nconst daysSinceActivity = daysBetween(\n  history.completed[0]?.completedAt,\n  now\n);\n```\n\n## References\n\n- [history-analysis.md](references/history-analysis.md) — How to analyze execution history",
  "references": [
    {
      "name": "history-analysis.md",
      "path": "references/history-analysis.md",
      "content": "# History Analysis\n\nHow to analyze execution history for async context.\n\n## Execution Categories\n\n### Completed\n\nSuccessfully finished executions:\n- All phases completed\n- All gates approved\n- Deliverables produced\n\n### Incomplete\n\nStarted but not finished:\n- Paused executions\n- Abandoned mid-phase\n- Waiting on gate approval\n\n### Failed\n\nTerminated with errors:\n- Gate rejections (not auto-recoverable)\n- System errors\n- User aborts\n\n## Key Metrics\n\n### Success Rate\n\n```\nsuccess_rate = completed_count / (completed_count + failed_count)\n```\n\nExcludes incomplete (still in progress).\n\n### Average Duration\n\n```\navg_duration = sum(completed.duration) / completed.count\n```\n\nPer loop type for accuracy.\n\n### Gate Wait Time\n\n```\navg_gate_wait = sum(gate_approval_time - gate_triggered_time) / gate_count\n```\n\nIdentifies if gates are bottleneck.\n\n## Momentum Indicators\n\n### Streak\n\nConsecutive successful completions:\n- Positive momentum: streak > 3\n- Neutral: streak 1-2\n- Recovering: streak after failure\n\n### Recency\n\nDays since last activity:\n- Active: 0-1 days\n- Recent: 2-7 days\n- Dormant: 7+ days\n\n### Velocity\n\nExecutions per week:\n- High velocity: 5+ per week\n- Normal: 2-4 per week\n- Low: <2 per week\n\n## Patterns to Surface\n\n### Loop Sequences\n\nCommon loop chains:\n- engineering → bugfix → distribution\n- learning → engineering\n- bugfix → engineering\n\n### Time-of-Day\n\nWhen work typically happens:\n- Morning (6am-12pm)\n- Afternoon (12pm-6pm)\n- Evening (6pm-12am)\n\n### Day-of-Week\n\nWhich days are productive:\n- Weekday patterns\n- Weekend patterns\n\n## Action Items from History\n\n### Resume Candidates\n\nIncomplete executions that can be resumed:\n- State preserved\n- No blocking errors\n- Within reasonable timeframe\n\n### Retry Candidates\n\nFailed executions that might succeed:\n- Transient failures\n- External dependencies now available\n- Fixed underlying issues\n\n### Archive Candidates\n\nOld incomplete executions to clean up:\n- >7 days old\n- Superseded by newer work\n- Context no longer relevant\n"
    }
  ],
  "tags": [
    "async",
    "history",
    "executions",
    "context"
  ],
  "dependsOn": [
    "state-loader"
  ]
}