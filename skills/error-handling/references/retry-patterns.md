# Retry Patterns Reference

## Exponential Backoff with Jitter

The standard retry algorithm for distributed systems. Simple exponential backoff causes
"thundering herd" when many clients retry in lockstep. Jitter breaks synchronization.

### Formula

```
delay = min(maxDelay, baseDelay * 2^attempt) * random(0.5, 1.5)
```

- `baseDelay`: Starting delay (typically 100-500ms)
- `attempt`: Zero-indexed retry count (0, 1, 2, ...)
- `maxDelay`: Cap to prevent unbounded waits (typically 30-60s)
- `random(0.5, 1.5)`: Jitter factor, randomizes +/- 50%

### Example Delay Sequence (baseDelay=200ms, maxDelay=30s)

| Attempt | Base delay | With jitter (range) |
|---------|-----------|---------------------|
| 0 | 200ms | 100-300ms |
| 1 | 400ms | 200-600ms |
| 2 | 800ms | 400-1200ms |
| 3 | 1600ms | 800-2400ms |
| 4 | 3200ms | 1600-4800ms |
| 5 | 6400ms | 3200-9600ms |

### Implementation

```javascript
async function retryWithBackoff(fn, options = {}) {
  const {
    maxRetries = 3, baseDelay = 200,
    maxDelay = 30000, retryableCheck = () => true,
  } = options;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries || !retryableCheck(error)) throw error;
      const delay = Math.min(maxDelay, baseDelay * Math.pow(2, attempt));
      await sleep(delay * (0.5 + Math.random()));
    }
  }
}
```

## Idempotency Requirements

**Any retried operation MUST be idempotent.** A retry might arrive after the original
succeeded (network timeout on response, not on request).

| Operation | Strategy | Implementation |
|-----------|----------|----------------|
| Create resource | Idempotency key | Client sends unique key; server deduplicates |
| Update resource | Version/ETag | Conditional update with `If-Match` header |
| Delete resource | Naturally idempotent | Deleting already-deleted returns success |
| Payment/transfer | Idempotency key | Store key->result mapping; return cached result |
| Queue publish | Message dedup ID | Consumer deduplicates by message ID |

### Idempotency Key Pattern

```
Client generates: idempotencyKey = uuid()

POST /orders  |  Idempotency-Key: abc-123

Server: check if abc-123 exists in store
  -> Yes: return stored response (do NOT re-execute)
  -> No:  execute, store response keyed by abc-123 (expires 24-48h)
```

**Critical:** The key must be generated by the caller. The caller retries with the SAME key.

## Retry Budget Management

Unbounded retries amplify failures. Use budgets to limit total retry load.

### Per-Request Budget

```
Total timeout: 10s  |  Max retries: 3  |  Per-attempt timeout: 2s
Budget remaining = totalTimeout - elapsed
```

Stop retrying when budget is exhausted, even if max retries not reached.

### System-Wide Retry Budget

Limit retries to 20% of total requests across the service. If retry rate exceeds
budget, fail fast. This prevents retry storms from amplifying outages.

### Circuit Breaker Integration

Retries feed into the circuit breaker. When retries consistently fail, the circuit
opens and stops all calls for a cooldown period.

## When NOT to Retry

### Non-Transient Errors (never retry)

| HTTP Status | Meaning | Why no retry |
|-------------|---------|--------------|
| 400 | Bad Request | Payload won't fix itself |
| 401 | Unauthorized | Token is invalid |
| 403 | Forbidden | Permission won't change |
| 404 | Not Found | Resource doesn't exist |
| 409 | Conflict | Requires resolution, not retry |
| 422 | Unprocessable | Validation failure |

### Retryable Errors (retry with backoff)

| HTTP Status | Meaning | Retry guidance |
|-------------|---------|----------------|
| 408 | Request Timeout | Retry immediately |
| 429 | Too Many Requests | Respect `Retry-After` header |
| 502 | Bad Gateway | Retry, upstream may recover |
| 503 | Service Unavailable | Retry, service restarting |
| 504 | Gateway Timeout | Retry with longer timeout |

### Other Non-Retryable Conditions

- **Mutation already applied**: POST succeeded but response timed out; retry creates duplicates
- **Business logic rejection**: "Insufficient funds" won't change on retry
- **Authentication failures**: Re-authenticate; don't retry the same bad token

## Retry Observability

Log every retry for debugging and tuning:

```json
{
  "level": "warn",
  "message": "Retrying failed operation",
  "operation": "fetchUserProfile",
  "attempt": 2,
  "maxAttempts": 3,
  "delayMs": 847,
  "error": { "code": "ETIMEDOUT" },
  "correlationId": "req-a1b2c3d4"
}
```

Track retry rate as a metric. A rising retry rate is an early warning signal.
