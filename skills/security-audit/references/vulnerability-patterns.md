# Vulnerability Patterns

Common vulnerability patterns with detection and fixes.

## Injection Vulnerabilities

### SQL Injection

**Detection Patterns**
```typescript
// RED FLAGS
`SELECT * FROM users WHERE id = ${id}`
`SELECT * FROM users WHERE id = '${id}'`
"SELECT * FROM users WHERE id = '" + id + "'"
db.query(`DELETE FROM items WHERE id = ${req.params.id}`)
```

**Fix**
```typescript
// Parameterized queries
db.query('SELECT * FROM users WHERE id = $1', [id]);

// ORM with proper escaping
User.findOne({ where: { id } });

// Query builder
db('users').where('id', id).first();
```

### NoSQL Injection

**Detection Patterns**
```typescript
// RED FLAGS
db.users.find({ username: req.body.username });
// Attacker sends: { username: { $gt: '' } }

User.findOne({ $where: `this.username === '${username}'` });
```

**Fix**
```typescript
// Type coercion
db.users.find({ username: String(req.body.username) });

// Schema validation
const username = z.string().parse(req.body.username);

// Avoid $where entirely
User.findOne({ username: { $eq: String(username) } });
```

### Command Injection

**Detection Patterns**
```typescript
// RED FLAGS
exec(`ls ${directory}`);
exec('ping ' + hostname);
spawn('sh', ['-c', `echo ${message}`]);
child_process.execSync(userInput);
```

**Fix**
```typescript
// execFile with argument array (no shell)
execFile('ls', [directory]);

// Validate against allow-list
const ALLOWED = ['dir1', 'dir2'];
if (!ALLOWED.includes(directory)) throw new Error('Invalid directory');
execFile('ls', [directory]);

// Escape if shell required (avoid if possible)
const safeArg = shellEscape([userInput]);
```

### LDAP Injection

**Detection Patterns**
```typescript
// RED FLAGS
ldap.search(`(uid=${username})`);
ldap.search(`(&(uid=${user})(password=${pass}))`);
```

**Fix**
```typescript
// Escape special characters
function escapeLdap(str: string): string {
  return str.replace(/[\\*()]/g, '\\$&');
}

ldap.search(`(uid=${escapeLdap(username)})`);
```

### XPath Injection

**Detection Patterns**
```typescript
// RED FLAGS
xpath.select(`//user[@name='${name}']`);
```

**Fix**
```typescript
// Parameterized XPath (library dependent)
xpath.select('//user[@name=$name]', { name });

// Or validate/escape input
const safeName = name.replace(/['"]/g, '');
```

## Cross-Site Scripting (XSS)

### Reflected XSS

**Detection Patterns**
```typescript
// RED FLAGS - Server-side
res.send(`<h1>Search: ${req.query.q}</h1>`);
res.send(`<script>var x = "${userInput}";</script>`);

// RED FLAGS - Client-side
document.getElementById('output').innerHTML = userInput;
$('#output').html(userInput);
element.outerHTML = userInput;
```

**Fix**
```typescript
// Server-side: HTML encoding
import { escape } from 'html-escaper';
res.send(`<h1>Search: ${escape(req.query.q)}</h1>`);

// Client-side: textContent instead of innerHTML
document.getElementById('output').textContent = userInput;

// React: automatic escaping (don't use dangerouslySetInnerHTML)
<div>{userInput}</div>
```

### Stored XSS

**Detection Patterns**
```typescript
// RED FLAGS
// User input stored, then rendered without escaping
const comment = await Comment.findById(id);
res.send(`<div class="comment">${comment.text}</div>`);
```

**Fix**
```typescript
// Sanitize on input AND output
// Input: validate and sanitize
const sanitized = DOMPurify.sanitize(text, { ALLOWED_TAGS: ['b', 'i'] });
await Comment.create({ text: sanitized });

// Output: escape when rendering
res.send(`<div class="comment">${escape(comment.text)}</div>`);
```

### DOM-Based XSS

**Detection Patterns**
```typescript
// RED FLAGS
document.write(location.hash);
eval(location.search);
element.innerHTML = window.name;
$.parseHTML(document.referrer);
```

**Fix**
```typescript
// Use safe DOM methods
document.body.appendChild(document.createTextNode(userInput));

// Validate URL parameters
const url = new URL(location.href);
const value = url.searchParams.get('q');
if (!/^[a-zA-Z0-9]+$/.test(value)) throw new Error('Invalid');
```

## Cross-Site Request Forgery (CSRF)

**Detection Patterns**
```typescript
// RED FLAGS
// State-changing operation without CSRF protection
app.post('/transfer', (req, res) => {
  transferMoney(req.body.to, req.body.amount);
});

// Cookie-based auth without SameSite
res.cookie('session', token);  // Missing SameSite
```

**Fix**
```typescript
// CSRF tokens
app.use(csrf());
app.post('/transfer', (req, res) => {
  // csrf middleware validates token
  transferMoney(req.body.to, req.body.amount);
});

// SameSite cookies
res.cookie('session', token, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict'
});

// Custom headers for APIs (not sent by forms)
// Require X-Requested-With header
```

## Authentication Vulnerabilities

### Broken Authentication

**Detection Patterns**
```typescript
// RED FLAGS
// Weak password hashing
crypto.createHash('md5').update(password);
crypto.createHash('sha256').update(password);  // No salt, no iterations

// Predictable tokens
const resetToken = Date.now().toString();
const resetToken = user.id + '-' + Date.now();

// Session in URL
res.redirect(`/dashboard?session=${sessionId}`);

// No rate limiting on login
app.post('/login', authenticate);
```

**Fix**
```typescript
// Strong password hashing
const hash = await bcrypt.hash(password, 12);
// Or: argon2.hash(password)

// Cryptographically random tokens
const resetToken = crypto.randomBytes(32).toString('hex');

// Rate limiting
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  skipSuccessfulRequests: true
});
app.post('/login', loginLimiter, authenticate);
```

### Session Management

**Detection Patterns**
```typescript
// RED FLAGS
// Session not regenerated after auth
req.session.userId = user.id;

// Session not invalidated on logout
app.post('/logout', (req, res) => {
  req.session.userId = null;  // Session still valid!
});

// Insecure session storage
app.use(session({
  secret: 'keyboard cat',  // Weak secret
  cookie: { secure: false }  // HTTP allowed
}));
```

**Fix**
```typescript
// Regenerate session after auth
app.post('/login', (req, res) => {
  // ... authenticate user
  req.session.regenerate((err) => {
    req.session.userId = user.id;
    res.redirect('/dashboard');
  });
});

// Properly destroy session on logout
app.post('/logout', (req, res) => {
  req.session.destroy((err) => {
    res.clearCookie('connect.sid');
    res.redirect('/');
  });
});

// Secure session configuration
app.use(session({
  secret: process.env.SESSION_SECRET,  // Strong, from env
  cookie: {
    secure: true,
    httpOnly: true,
    sameSite: 'strict',
    maxAge: 3600000
  },
  resave: false,
  saveUninitialized: false
}));
```

## Authorization Vulnerabilities

### Insecure Direct Object Reference (IDOR)

**Detection Patterns**
```typescript
// RED FLAGS
app.get('/api/users/:id', (req, res) => {
  const user = await User.findById(req.params.id);
  res.json(user);  // No ownership check!
});

app.get('/files/:filename', (req, res) => {
  res.sendFile(`/files/${req.params.filename}`);  // No access check!
});
```

**Fix**
```typescript
// Always verify ownership/permission
app.get('/api/users/:id', authenticate, async (req, res) => {
  // Only allow users to access their own data
  if (req.params.id !== req.user.id && !req.user.isAdmin) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  const user = await User.findById(req.params.id);
  res.json(user);
});

// Or scope queries
app.get('/api/documents/:id', authenticate, async (req, res) => {
  const doc = await Document.findOne({
    _id: req.params.id,
    ownerId: req.user.id  // Automatically scoped
  });
  if (!doc) return res.status(404).json({ error: 'Not found' });
  res.json(doc);
});
```

### Privilege Escalation

**Detection Patterns**
```typescript
// RED FLAGS
// User can set their own role
app.post('/api/users', (req, res) => {
  const user = await User.create(req.body);  // body.role = 'admin'?
});

// Hidden admin endpoints
app.post('/admin/delete-all', (req, res) => {
  // No auth check!
});

// Role check only on frontend
if (user.isAdmin) { showAdminButton(); }  // Can be bypassed
```

**Fix**
```typescript
// Explicitly set allowed fields
app.post('/api/users', (req, res) => {
  const { email, name, password } = req.body;
  const user = await User.create({
    email,
    name,
    password,
    role: 'user'  // Always set server-side
  });
});

// Protect admin routes
app.use('/admin', authenticate, requireRole('admin'));

// Double-check on backend
app.post('/admin/delete-all', authenticate, requireRole('admin'), (req, res) => {
  // ...
});
```

## Sensitive Data Exposure

### Information Disclosure

**Detection Patterns**
```typescript
// RED FLAGS
// Verbose errors
res.status(500).json({ error: err.stack });

// Debug info in production
app.use(errorHandler({ dumpExceptions: true, showStack: true }));

// Sensitive data in responses
res.json(user);  // Includes password hash!

// Sensitive data in logs
console.log('Login:', { email, password });
```

**Fix**
```typescript
// Generic errors for users
res.status(500).json({ error: 'An error occurred', id: requestId });

// Filter sensitive fields
const { password, ...safeUser } = user;
res.json(safeUser);

// Or use DTOs/serializers
res.json(new UserResponse(user));  // Only includes safe fields

// Mask sensitive data in logs
console.log('Login:', { email: maskEmail(email) });
```

### Insecure Storage

**Detection Patterns**
```typescript
// RED FLAGS
// Hardcoded secrets
const API_KEY = 'sk_live_12345';

// Secrets in config files committed to git
// config.json: { "apiKey": "secret" }

// Unencrypted sensitive data
db.users.insert({ ssn: '123-45-6789' });
```

**Fix**
```typescript
// Environment variables
const API_KEY = process.env.API_KEY;

// Secret managers
const secret = await secretManager.get('api-key');

// Encryption for sensitive data
const encrypted = encrypt(ssn, process.env.ENCRYPTION_KEY);
db.users.insert({ ssn: encrypted });
```

## Server-Side Request Forgery (SSRF)

**Detection Patterns**
```typescript
// RED FLAGS
// Fetch user-provided URLs
app.get('/fetch', async (req, res) => {
  const response = await fetch(req.query.url);
  res.send(await response.text());
});

// Image/file fetching from URLs
const image = await downloadImage(req.body.imageUrl);
```

**Fix**
```typescript
// URL validation
const ALLOWED_HOSTS = ['api.trusted.com'];
const BLOCKED_RANGES = ['127.0.0.1', '10.0.0.0/8', '192.168.0.0/16'];

async function safeFetch(urlString: string) {
  const url = new URL(urlString);
  
  // Check protocol
  if (!['http:', 'https:'].includes(url.protocol)) {
    throw new Error('Invalid protocol');
  }
  
  // Check against allow-list
  if (!ALLOWED_HOSTS.includes(url.hostname)) {
    throw new Error('Host not allowed');
  }
  
  // Resolve DNS and check for private IPs
  const ip = await dns.resolve(url.hostname);
  if (isPrivateIP(ip)) {
    throw new Error('Private IP not allowed');
  }
  
  return fetch(url.toString(), { redirect: 'error' });
}
```

## Deserialization Vulnerabilities

**Detection Patterns**
```typescript
// RED FLAGS
// eval() for parsing
const data = eval('(' + jsonString + ')');

// Unsafe YAML
yaml.load(userInput);

// pickle/marshal equivalent
deserialize(userInput);

// Object.assign with prototype
Object.assign(new User(), req.body);
```

**Fix**
```typescript
// Safe JSON parsing
const data = JSON.parse(jsonString);

// Safe YAML
yaml.load(userInput, { schema: yaml.SAFE_SCHEMA });

// Explicit property assignment
const user = new User();
user.name = String(req.body.name);
user.email = String(req.body.email);

// Or with validation
const validated = userSchema.parse(req.body);
const user = new User(validated);
```
