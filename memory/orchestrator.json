{
  "id": "orchestrator",
  "level": "orchestrator",
  "summary": "Self-improving meta-system using Organization → System → Module hierarchy (simplified from 4-tier to 3-tier). 32 modules across 7 layers planned via ROADMAP.md. All loops share context loading protocol and completion archival. 54+ MCP tools, 11 loop definitions. Learning System v2 with rubric scoring. Leverage Protocol with Critical Rules for optimal loop sequencing. Version alignment from single source of truth. v0.9.0 with self-improvement architecture complete: Analytics (OBSERVE) + Learning (ACT) modules provide closed-loop feedback.",
  "decisions": [
    {
      "id": "ADR-001",
      "title": "Three-tier context hierarchy",
      "context": "Loops needed a consistent way to understand scope and share context",
      "decision": "Adopted Organization → System → Module hierarchy with Dream State documents at each tier",
      "consequences": "All loops now speak the same language, can query past runs, and auto-update progress",
      "date": "2025-01-29T00:00:00Z"
    },
    {
      "id": "ADR-002",
      "title": "Learning System v2 - Rubric-based skill improvement",
      "context": "Skills needed a feedback mechanism to improve based on execution experience",
      "decision": "Added rubric scoring (completeness, quality, friction, relevance) to complete_skill calls, with threshold-based proposal generation",
      "consequences": "System can now generate upgrade proposals when patterns emerge (e.g., section improvised 2+ times → propose adding it)",
      "date": "2026-01-30T00:00:00Z"
    },
    {
      "id": "ADR-003",
      "title": "Leverage Protocol - Next highest leverage move",
      "context": "Needed a way to sequence loops optimally toward dream state achievement",
      "decision": "Added value equation (DSA 40% + Unlock 25% + Likelihood 15%) / (Time 10% + Effort 10%) evaluated at loop boundaries",
      "consequences": "Claude now proposes the next highest leverage loop at every completion, enabling seamless loop chaining",
      "date": "2026-01-30T00:00:00Z"
    },
    {
      "id": "ADR-004",
      "title": "Version Alignment - Single source of truth",
      "context": "Version numbers were getting out of sync between package.json, server, releases, and dashboard",
      "decision": "Created src/version.ts that reads from package.json at runtime. All consumers use this utility. Distribution-loop bumps version during INIT phase.",
      "consequences": "Version stays aligned automatically. Bumping package.json propagates everywhere on next distribution.",
      "date": "2026-01-30T00:00:00Z"
    },
    {
      "id": "ADR-005",
      "title": "Critical Rules - Explicit enforcement over implicit understanding",
      "context": "Leverage protocol was being skipped (no distribution after code, saying 'done' instead of proposing next loop)",
      "decision": "Added Critical Rules section to protocols with explicit numbered rules, ❌/✅ examples, decision trees, and anti-patterns list",
      "consequences": "Behavior immediately corrected. Pattern generalizes to all protocols that need enforced behavior.",
      "date": "2026-01-31T00:00:00Z"
    },
    {
      "id": "ADR-006",
      "title": "Hierarchy Simplification - Remove domain tier",
      "context": "Four-tier hierarchy (Org→Domain→System→Module) added unnecessary complexity. 'Domain' concept was confusing and rarely used.",
      "decision": "Simplified to three tiers: Organization → System → Module. Systems ladder directly to Org dream state. Modules ladder to System dream state.",
      "consequences": "Clearer mental model. ROADMAP.md tracks modules within a system. Dream states are now just Org-level and System-level.",
      "date": "2026-01-31T00:00:00Z"
    },
    {
      "id": "ADR-007",
      "title": "Seven-Layer Roadmap Architecture",
      "context": "Needed a consistent way to organize modules within a system by their purpose and dependencies",
      "decision": "Adopted 7-layer structure: L0 Foundation, L1 Visualization, L2 Autonomy, L3 Intelligence, L4 Interface, L5 Domain Loops, L6 Meta, L7 Sovereignty",
      "consequences": "Modules have clear placement. Dependencies flow upward. Layer 7 (Sovereignty/local-first) sits at the top as the architectural decision that affects all external integrations.",
      "date": "2026-01-31T00:00:00Z"
    }
  ],
  "patterns": [
    {
      "id": "PAT-001",
      "name": "unified-loop-architecture",
      "context": "When building loops that need to share context and learn from each other",
      "solution": "Use the Organization → System → Module hierarchy with Dream State documents at each tier. All loops load context on init and archive runs on completion.",
      "example": "engineering-loop v5.0.0 loads ~/.claude/DREAM-STATE.md, {repo}/.claude/DREAM-STATE.md, and recent runs via query_runs on initialization",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-002",
      "name": "completion-archival-protocol",
      "context": "When a loop reaches COMPLETE phase",
      "solution": "Archive full state + summary to ~/.claude/runs/{year-month}/{system}-{loop}-{timestamp}.json, update Dream State at appropriate tier, prune active state file",
      "example": "learning-loop completes → archive_run() → update DREAM-STATE.md → delete learning-state.json",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-003",
      "name": "deep-context-protocol",
      "context": "Before any non-trivial task or decision",
      "solution": "Ask 5-10+ clarifying questions across all dimensions (problem, constraints, success criteria, risks, stakeholders). Keep asking until user signals 'that's everything'. Summarize understanding before proceeding.",
      "example": "User asks for auth system → probe: auth methods, compliance needs, user volume, session handling, MFA requirements, API keys needed, etc.",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-004",
      "name": "terrain-check",
      "context": "After every substantive response during execution",
      "solution": "Assess uphill (uncertain, assuming, multiple paths) vs downhill (clear, verified, just executing). If uphill, surface questions. If downhill, proceed without friction. Watch for terrain transitions.",
      "example": "Implemented auth middleware → [uphill: assumed JWT] → 'Quick check: I went with JWT. Should I stick with that, or do you prefer sessions?'",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-005",
      "name": "docs-alignment-protocol",
      "context": "After every loop reaches COMPLETE phase",
      "solution": "Run docs-alignment skill to scan MECE categories, update Dream States with progress, validate cross-references, regenerate indexes, and prune stale documentation.",
      "example": "engineering-loop completes → docs-alignment scans all tiers → updates DREAM-STATE.md with new module progress → fixes broken links in ARCHITECTURE.md → regenerates INDEX.md",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-006",
      "name": "leverage-protocol",
      "context": "At every loop completion boundary",
      "solution": "Evaluate available loops against value equation: (DSA×0.40 + Unlock×0.25 + Likelihood×0.15) / (Time×0.10 + Effort×0.10). Always propose a specific loop. If needed capability doesn't exist, propose meta-loop to create it first.",
      "example": "engineering-loop completes → evaluate: engineering-loop@auth (8.2), bugfix-loop@tests (5.1), learning-loop@review (4.8) → recommend auth-service as highest leverage",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2026-01-30T00:00:00Z",
      "lastUsed": "2026-01-30T00:00:00Z"
    },
    {
      "id": "PAT-007",
      "name": "learning-feedback-loop",
      "context": "When skills are executed during loops",
      "solution": "Call complete_skill() with rubric scores. At COMPLETE phase, call complete_run_tracking() to persist signals and generate proposals. Review proposals via list_upgrade_proposals, approve via approve_upgrade_proposal.",
      "example": "complete_skill(rubric={completeness:4, quality:5, friction:3, relevance:4}) → [COMPLETE] → complete_run_tracking() → 'New proposals: 1' → list_upgrade_proposals → approve",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2026-01-30T00:00:00Z",
      "lastUsed": "2026-01-30T00:00:00Z"
    },
    {
      "id": "PAT-008",
      "name": "version-alignment-architecture",
      "context": "When version numbers need to stay aligned across server, releases, and UI",
      "solution": "Single source of truth in package.json. Create src/version.ts utility that reads at runtime. GitHub Actions reads package.json for releases. UI parses from release body.",
      "example": "package.json:0.7.0 → version.ts reads it → /health returns 0.7.0 → release body has 'Version: 0.7.0' → /distribute page shows 0.7.0",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2026-01-30T00:00:00Z",
      "lastUsed": "2026-01-30T00:00:00Z"
    },
    {
      "id": "PAT-009",
      "name": "explicit-rules-enforcement",
      "context": "When a protocol or skill has implicit behavior that gets skipped",
      "solution": "Add a 'Critical Rules' section with explicit numbered rules, ❌/✅ examples, decision trees, and anti-patterns. Implicit understanding fails; explicit rules succeed.",
      "example": "Leverage protocol was being skipped → added Rule 1 (distribution after code), Rule 2 (never say done), Rule 3 (look beyond queue) with anti-patterns → behavior corrected",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": "2026-01-31T00:00:00Z"
    },
    {
      "id": "PAT-010",
      "name": "self-improvement-architecture",
      "context": "When building a system that needs to observe its own behavior and improve autonomously",
      "solution": "Two-module design: OBSERVE layer (Analytics) reads from all services without modification, surfaces insights via aggregation. ACT layer (Learning) consumes Analytics signals, generates prioritized proposals, applies improvements with human-in-the-loop approval. Separation ensures read operations don't cause side effects.",
      "example": "Execute loops → AnalyticsService.getSkillHealth() identifies low-scoring skills → ImprovementOrchestrator.processAnalyticsSignals() generates proposals → Human approves → LearningService.applyProposal() upgrades skill → Next execution benefits",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": "2026-01-31T00:00:00Z"
    },
    {
      "id": "PAT-011",
      "name": "roadmapping-process",
      "context": "When creating a system roadmap from a user's coded brainstorm list",
      "solution": "1) Receive user's coded list, 2) Explore codebase to understand existing modules, 3) Ask clarifying questions batched by category (acronyms, scope, differentiation, dependencies, updates vs new), 4) Identify dependencies between modules, 5) Separate updates from new modules, 6) Organize into 7 layers based on purpose and dependencies, 7) Create both ROADMAP.md and terminal visualization",
      "example": "User pastes coded list → explore src/services, loops/, skills/ → ask about 'ADIR', 'autonomous', 'tech trees vs skill trees' → identify 2-layer-orchestration unlocks autonomous → place in Layer 0 Foundation → create ROADMAP.md",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": "2026-01-31T00:00:00Z"
    },
    {
      "id": "PAT-012",
      "name": "ADIR-reasoning-cycle",
      "context": "When running strategic loops that need to improve their own reasoning, not just conclusions",
      "solution": "Four phases: Abductive (hypotheses from observations), Deductive (testable predictions), Inductive (updated beliefs from results), Reflexive (frame audit producing Context Delta). The Reflexive phase outputs keep/discard/add/reweight/next_tests/guardrails to improve the instruction set.",
      "example": "Abductive: 'Users might want voice' → Deductive: 'If true, usage should spike on mobile' → Inductive: '80% mobile usage confirms' → Reflexive: {keep: 'mobile-first', add: 'voice input', next_tests: ['dictation UX']}",
      "uses": 0,
      "confidence": "medium",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": null
    },
    {
      "id": "PAT-013",
      "name": "finite-infinite-game-framing",
      "context": "When aligning work at different hierarchy levels to motivate coherent action",
      "solution": "Frame module→system and system→org as finite games with clear win conditions, checkpoints, and 'done' states. Frame org (mission) as infinite game with cosmic purpose and continuous play. Finite games ladder up to enable infinite play.",
      "example": "Module: 'Ship roadmapping module' (finite, clear deliverable) → System: 'Complete orchestrator for launch' (finite, checkpoint) → Org: 'Augment human capability indefinitely' (infinite, mission)",
      "uses": 0,
      "confidence": "medium",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": null
    },
    {
      "id": "PAT-014",
      "name": "loop-sequencing-chess-lines",
      "context": "When planning beyond the immediate next loop to optimize multi-move strategy",
      "solution": "Detect patterns of loop co-occurrence (like NLP n-grams). Use that intuition to look multiple moves ahead in the 'line'. Goes beyond single-move leverage protocol to multi-move planning inspired by chess.",
      "example": "Notice: engineering-loop often followed by bugfix-loop then distribution-loop. When starting engineering-loop, plan the full line: engineering→bugfix→distribution, not just engineering.",
      "uses": 0,
      "confidence": "low",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": null
    }
  ],
  "calibration": {
    "estimates": [],
    "adjustments": {
      "global": { "multiplier": 1.0, "samples": 0 }
    }
  },
  "createdAt": "2026-01-25T00:00:00Z",
  "updatedAt": "2026-01-31T00:00:00Z"
}
