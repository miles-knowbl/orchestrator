{
  "id": "orchestrator",
  "level": "orchestrator",
  "summary": "Self-improving meta-system using Organization → System → Module hierarchy (simplified from 4-tier to 3-tier). 32 modules across 7 layers planned via ROADMAP.md. All loops share context loading protocol and completion archival. 54+ MCP tools, 11 loop definitions. Learning System v2 with rubric scoring. Leverage Protocol with Critical Rules for optimal loop sequencing. Version alignment from single source of truth. v0.9.0 with self-improvement architecture complete: Analytics (OBSERVE) + Learning (ACT) modules provide closed-loop feedback. Meta-Change Protocol (PAT-017) for safe modification of guidance infrastructure.",
  "decisions": [
    {
      "id": "ADR-001",
      "title": "Three-tier context hierarchy",
      "context": "Loops needed a consistent way to understand scope and share context",
      "decision": "Adopted Organization → System → Module hierarchy with Dream State documents at each tier",
      "consequences": "All loops now speak the same language, can query past runs, and auto-update progress",
      "date": "2025-01-29T00:00:00Z"
    },
    {
      "id": "ADR-002",
      "title": "Learning System v2 - Rubric-based skill improvement",
      "context": "Skills needed a feedback mechanism to improve based on execution experience",
      "decision": "Added rubric scoring (completeness, quality, friction, relevance) to complete_skill calls, with threshold-based proposal generation",
      "consequences": "System can now generate upgrade proposals when patterns emerge (e.g., section improvised 2+ times → propose adding it)",
      "date": "2026-01-30T00:00:00Z"
    },
    {
      "id": "ADR-003",
      "title": "Leverage Protocol - Next highest leverage move",
      "context": "Needed a way to sequence loops optimally toward dream state achievement",
      "decision": "Added value equation (DSA 40% + Unlock 25% + Likelihood 15%) / (Time 10% + Effort 10%) evaluated at loop boundaries",
      "consequences": "Claude now proposes the next highest leverage loop at every completion, enabling seamless loop chaining",
      "date": "2026-01-30T00:00:00Z"
    },
    {
      "id": "ADR-004",
      "title": "Version Alignment - Single source of truth",
      "context": "Version numbers were getting out of sync between package.json, server, releases, and dashboard",
      "decision": "Created src/version.ts that reads from package.json at runtime. All consumers use this utility. Distribution-loop bumps version during INIT phase.",
      "consequences": "Version stays aligned automatically. Bumping package.json propagates everywhere on next distribution.",
      "date": "2026-01-30T00:00:00Z"
    },
    {
      "id": "ADR-005",
      "title": "Critical Rules - Explicit enforcement over implicit understanding",
      "context": "Leverage protocol was being skipped (no distribution after code, saying 'done' instead of proposing next loop)",
      "decision": "Added Critical Rules section to protocols with explicit numbered rules, ❌/✅ examples, decision trees, and anti-patterns list",
      "consequences": "Behavior immediately corrected. Pattern generalizes to all protocols that need enforced behavior.",
      "date": "2026-01-31T00:00:00Z"
    },
    {
      "id": "ADR-006",
      "title": "Hierarchy Simplification - Remove domain tier",
      "context": "Four-tier hierarchy (Org→Domain→System→Module) added unnecessary complexity. 'Domain' concept was confusing and rarely used.",
      "decision": "Simplified to three tiers: Organization → System → Module. Systems ladder directly to Org dream state. Modules ladder to System dream state.",
      "consequences": "Clearer mental model. ROADMAP.md tracks modules within a system. Dream states are now just Org-level and System-level.",
      "date": "2026-01-31T00:00:00Z"
    },
    {
      "id": "ADR-007",
      "title": "Seven-Layer Roadmap Architecture",
      "context": "Needed a consistent way to organize modules within a system by their purpose and dependencies",
      "decision": "Adopted 7-layer structure: L0 Foundation, L1 Visualization, L2 Autonomy, L3 Intelligence, L4 Interface, L5 Domain Loops, L6 Meta, L7 Sovereignty",
      "consequences": "Modules have clear placement. Dependencies flow upward. Layer 7 (Sovereignty/local-first) sits at the top as the architectural decision that affects all external integrations.",
      "date": "2026-01-31T00:00:00Z"
    },
    {
      "id": "ADR-008",
      "title": "Slack Autonomy Mode - Thread-per-execution",
      "context": "Slack channel needed consistent notification behavior. Two options: (A) Full parity with terminal (every gate request), or (B) Autonomous mode (only start/complete notifications). Terminal interaction can be synchronous; Slack is inherently async.",
      "decision": "Adopted thread-per-execution model: Each loop execution opens a new Slack thread on start. All subsequent messages for that execution go to the same thread. This keeps context grouped and allows reviewing execution history. Slack assumes autonomous mode - loops run autonomously with notifications at start and completion, reducing noise while maintaining visibility.",
      "consequences": "Clean Slack channel with one thread per execution. Engineers can review threads for context without blocking on every gate. Reduces notification fatigue. SlackAdapter tracks executionId→threadTs mapping. ProactiveMessagingService has notifyLoopStart() in addition to notifyLoopComplete().",
      "date": "2026-02-01T00:00:00Z"
    },
    {
      "id": "ADR-009",
      "title": "Meta-Change Protocol - Atomic changes to guidance infrastructure",
      "context": "Attempted to change roadmap architecture (JSON source of truth + generated markdown). Documentation was written but implementation never completed. API errors interrupted work. No checkpoint existed, so state was lost. This is the self-referential trap: changing the system that guides us while using it for guidance.",
      "decision": "Adopted Meta-Change Protocol (PAT-017) for all modifications to guidance infrastructure. Required phases: CHECKPOINT (backup state), BOOTSTRAP (create TRANSITION.md), IMPLEMENT (atomic changes), VERIFY (coherence check), CLEANUP (remove checkpoint). Any failure triggers ROLLBACK.",
      "consequences": "Meta-changes are now recoverable. TRANSITION.md survives session boundaries and API errors. Atomic implementation prevents partial states. Verification ensures new state works before old is discarded. Pattern applies to: ROADMAP.md, DREAM-STATE.md, memory/*.json, loop commands, skill schemas.",
      "date": "2026-02-04T00:00:00Z",
      "learnedFrom": "Structured Document Architecture change failed"
    }
  ],
  "patterns": [
    {
      "id": "PAT-001",
      "name": "unified-loop-architecture",
      "category": "architectural",
      "context": "When building loops that need to share context and learn from each other",
      "solution": "Use the Organization → System → Module hierarchy with Dream State documents at each tier. All loops load context on init and archive runs on completion.",
      "example": "engineering-loop v5.0.0 loads ~/.claude/DREAM-STATE.md, {repo}/.claude/DREAM-STATE.md, and recent runs via query_runs on initialization",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-002",
      "name": "completion-archival-protocol",
      "category": "phase-bound",
      "context": "When a loop reaches COMPLETE phase",
      "solution": "Archive full state + summary to ~/.claude/runs/{year-month}/{system}-{loop}-{timestamp}.json, update Dream State at appropriate tier, prune active state file",
      "example": "learning-loop completes → archive_run() → update DREAM-STATE.md → delete learning-state.json",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-003",
      "name": "deep-context-protocol",
      "category": "ambient",
      "ooda": "Orient",
      "reflex": "What context am I missing?",
      "context": "Continuously, as a reflex — especially before non-trivial tasks or decisions",
      "solution": "Ask clarifying questions across all dimensions (problem, constraints, success criteria, risks, stakeholders). Keep asking until context is sufficient. Summarize understanding before proceeding.",
      "example": "User asks for auth system → probe: auth methods, compliance needs, user volume, session handling, MFA requirements, API keys needed, etc.",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-004",
      "name": "terrain-check",
      "category": "ambient",
      "ooda": "Observe",
      "reflex": "Where am I in the landscape?",
      "context": "Continuously — after every substantive response, and when assessing project/module landscape",
      "solution": "Assess uphill (uncertain, assuming, multiple paths) vs downhill (clear, verified, just executing). If uphill, surface questions. If downhill, proceed without friction. Watch for terrain transitions. When scoping work, map the landscape: existing modules, dependencies, layers, what's complete vs remaining.",
      "example": "Implemented auth middleware → [uphill: assumed JWT] → 'Quick check: I went with JWT. Should I stick with that, or do you prefer sessions?' | Scoping new feature → explore codebase → identify dependencies → place in correct layer",
      "fusedFrom": ["terrain-check", "roadmapping-process"],
      "uses": 1,
      "confidence": "high",
      "createdAt": "2025-01-29T00:00:00Z",
      "updatedAt": "2026-02-03T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-005",
      "name": "docs-alignment-protocol",
      "category": "phase-bound",
      "context": "After every loop reaches COMPLETE phase",
      "solution": "Run docs-alignment skill to scan MECE categories, update Dream States with progress, validate cross-references, regenerate indexes, and prune stale documentation.",
      "example": "engineering-loop completes → docs-alignment scans all tiers → updates DREAM-STATE.md with new module progress → fixes broken links in ARCHITECTURE.md → regenerates INDEX.md",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-006",
      "name": "leverage-protocol",
      "category": "ambient",
      "ooda": "Decide",
      "reflex": "What's the highest-leverage move?",
      "context": "At every loop completion boundary, and when planning multi-move strategy",
      "solution": "Evaluate available loops against value equation: (DSA×0.40 + Unlock×0.25 + Likelihood×0.15) / (Time×0.10 + Effort×0.10). Always propose a specific loop. If needed capability doesn't exist, propose meta-loop to create it first. Think multiple moves ahead: detect loop co-occurrence patterns (engineering→bugfix→distribution) and plan the full line, not just the next move.",
      "example": "engineering-loop completes → evaluate full line: engineering@auth (8.2) → bugfix@tests → distribution → recommend auth-service with downstream sequence visible",
      "fusedFrom": ["leverage-protocol", "loop-sequencing-chess-lines"],
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2026-01-30T00:00:00Z",
      "updatedAt": "2026-02-03T00:00:00Z",
      "lastUsed": "2026-01-30T00:00:00Z"
    },
    {
      "id": "PAT-007",
      "name": "learning-feedback-loop",
      "category": "ambient",
      "ooda": "Act",
      "reflex": "Calibrate — improve what needs improving",
      "context": "Continuously — after substantive actions, notice what worked and what didn't. When patterns emerge, act on them.",
      "solution": "Continuously calibrate based on feedback. After substantive actions, notice what worked and what didn't. When patterns emerge (section improvised 2+ times, estimate consistently off), improve skills, adjust estimates, update beliefs. The 'Act' is the calibration itself — versioning skills, updating models, applying learnings.",
      "example": "Notice: auth section improvised twice → propose adding to skill | Estimate was 2x off → adjust calibration multiplier | Pattern detected → formalize into memory",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2026-01-30T00:00:00Z",
      "updatedAt": "2026-02-03T00:00:00Z",
      "lastUsed": "2026-01-30T00:00:00Z"
    },
    {
      "id": "PAT-008",
      "name": "version-alignment-architecture",
      "category": "architectural",
      "context": "When version numbers need to stay aligned across server, releases, and UI",
      "solution": "Single source of truth in package.json. Create src/version.ts utility that reads at runtime. GitHub Actions reads package.json for releases. UI parses from release body.",
      "example": "package.json:0.7.0 → version.ts reads it → /health returns 0.7.0 → release body has 'Version: 0.7.0' → /distribute page shows 0.7.0",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2026-01-30T00:00:00Z",
      "lastUsed": "2026-01-30T00:00:00Z"
    },
    {
      "id": "PAT-009",
      "name": "explicit-rules-enforcement",
      "category": "relocated",
      "relocatedTo": "behavior-guarantees module (deferred)",
      "context": "When a protocol or skill has implicit behavior that gets skipped",
      "solution": "Add a 'Critical Rules' section with explicit numbered rules, ❌/✅ examples, decision trees, and anti-patterns. Implicit understanding fails; explicit rules succeed.",
      "example": "Leverage protocol was being skipped → added Rule 1 (distribution after code), Rule 2 (never say done), Rule 3 (look beyond queue) with anti-patterns → behavior corrected",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": "2026-01-31T00:00:00Z"
    },
    {
      "id": "PAT-010",
      "name": "self-improvement-architecture",
      "category": "architectural",
      "context": "When building a system that needs to observe its own behavior and improve autonomously",
      "solution": "Two-module design: OBSERVE layer (Analytics) reads from all services without modification, surfaces insights via aggregation. ACT layer (Learning) consumes Analytics signals, generates prioritized proposals, applies improvements with human-in-the-loop approval. Separation ensures read operations don't cause side effects.",
      "example": "Execute loops → AnalyticsService.getSkillHealth() identifies low-scoring skills → ImprovementOrchestrator.processAnalyticsSignals() generates proposals → Human approves → LearningService.applyProposal() upgrades skill → Next execution benefits",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": "2026-01-31T00:00:00Z"
    },
    {
      "id": "PAT-011",
      "name": "roadmapping-process",
      "category": "fused",
      "fusedInto": "PAT-004 (terrain-check)",
      "context": "When creating a system roadmap from a user's coded brainstorm list",
      "solution": "1) Receive user's coded list, 2) Explore codebase to understand existing modules, 3) Ask clarifying questions batched by category (acronyms, scope, differentiation, dependencies, updates vs new), 4) Identify dependencies between modules, 5) Separate updates from new modules, 6) Organize into 7 layers based on purpose and dependencies, 7) Create both ROADMAP.md and terminal visualization",
      "example": "User pastes coded list → explore src/services, loops/, skills/ → ask about 'ADIR', 'autonomous', 'tech trees vs skill trees' → identify 2-layer-orchestration unlocks autonomous → place in Layer 0 Foundation → create ROADMAP.md",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": "2026-01-31T00:00:00Z"
    },
    {
      "id": "PAT-012",
      "name": "ADIR-reasoning-cycle",
      "category": "relocated",
      "relocatedTo": "dream-loop integration (when dreaming module is un-deferred)",
      "context": "When reasoning needs to improve itself, not just reach conclusions. Synergizes with Deep Context Protocol, Leverage Protocol, MECE Opportunity Mapping, and Terrain Check.",
      "solution": "Four phases that form a meta-cognitive loop: (A) Abductive - generate hypotheses from observations, (D) Deductive - derive testable predictions, (I) Inductive - update beliefs from results, (R) Reflexive - audit the frame itself and produce Context Delta. The Reflexive phase outputs {keep, discard, add, reweight, next_tests, guardrails} to improve the instruction set, not just conclusions.",
      "synergies": {
        "deep-context-protocol": "ADIR's Abductive phase IS context gathering. Ask questions to generate hypotheses. The Reflexive phase identifies which context questions should be added or removed from future gathering.",
        "leverage-protocol": "ADIR's Inductive phase updates belief weights used in leverage scoring. Reflexive phase can reweight the value equation factors (DSA, Unlock, Likelihood, Time, Effort) based on observed accuracy.",
        "mece-opportunity-mapping": "ADIR's Deductive phase generates testable predictions that can be organized MECE. Reflexive phase identifies gaps in the opportunity space that need new categories.",
        "terrain-check": "ADIR's Reflexive phase produces explicit uphill/downhill markers. 'keep' = downhill (verified), 'discard' = was uphill and proved wrong, 'add' = new uphill territory identified."
      },
      "contextDelta": {
        "keep": "stable truths that survived testing",
        "discard": "assumptions invalidated by evidence",
        "add": "newly discovered constraints or opportunities",
        "reweight": "belief updates with confidence levels",
        "next_tests": "1-3 highest-leverage experiments to run",
        "guardrails": "failure modes to avoid going forward"
      },
      "example": "Abductive: 'Users might want voice' → Deductive: 'If true, mobile usage > 70%' → Inductive: '80% confirms, update belief' → Reflexive: {keep: 'mobile-first', discard: 'desktop-only viable', add: 'voice input priority', reweight: {voice: 0.8, typing: 0.5}, next_tests: ['dictation accuracy', 'noise handling'], guardrails: ['dont ship voice without offline mode']}",
      "antiPatterns": [
        "Running only A-D-I without R (conclusions but no meta-learning)",
        "Skipping straight to R without A-D-I (opinions without evidence)",
        "Treating R as optional (missing the improvement opportunity)",
        "Keeping Context Delta in your head instead of externalizing it"
      ],
      "uses": 0,
      "confidence": "high",
      "createdAt": "2026-01-31T00:00:00Z",
      "updatedAt": "2026-02-01T00:00:00Z",
      "lastUsed": null
    },
    {
      "id": "PAT-013",
      "name": "finite-infinite-game-framing",
      "category": "architectural",
      "context": "When aligning work at different hierarchy levels to motivate coherent action",
      "solution": "Frame module→system and system→org as finite games with clear win conditions, checkpoints, and 'done' states. Frame org (mission) as infinite game with cosmic purpose and continuous play. Finite games ladder up to enable infinite play.",
      "example": "Module: 'Ship roadmapping module' (finite, clear deliverable) → System: 'Complete orchestrator for launch' (finite, checkpoint) → Org: 'Augment human capability indefinitely' (infinite, mission)",
      "uses": 0,
      "confidence": "medium",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": null
    },
    {
      "id": "PAT-014",
      "name": "loop-sequencing-chess-lines",
      "category": "fused",
      "fusedInto": "PAT-006 (leverage-protocol)",
      "context": "When planning beyond the immediate next loop to optimize multi-move strategy",
      "solution": "Detect patterns of loop co-occurrence (like NLP n-grams). Use that intuition to look multiple moves ahead in the 'line'. Goes beyond single-move leverage protocol to multi-move planning inspired by chess.",
      "example": "Notice: engineering-loop often followed by bugfix-loop then distribution-loop. When starting engineering-loop, plan the full line: engineering→bugfix→distribution, not just engineering.",
      "uses": 0,
      "confidence": "low",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": null
    },
    {
      "id": "PAT-015",
      "name": "completion-format-protocol",
      "category": "phase-bound",
      "context": "When any loop iteration completes and needs to present results and next steps",
      "solution": "Use standard completion format: (1) Completion banner with loop + primitive, (2) Key deliverables summary, (3) Next highest leverage move with FULL reasoning (Dream State, Downstream Unlock, Likelihood), (4) Alternatives Considered with scores, (5) Available moves (UNBLOCKED ONLY) grouped by category/layer, (6) Deferred items go to last layer (not separate section), (7) Clear call-to-action. Hide completed and blocked items from menu.",
      "example": "/engineering-loop → spaced-repetition: COMPLETE → [deliverables box] → NEXT: proposing-decks (V: 6.05) with reasoning → Alternatives Considered: ooda-clocks (5.60) → Available Moves (unblocked): Layer 1: ooda-clocks, Layer 5: proposing-decks → 'Say go to start'",
      "reference": "commands/_shared/completion-format.md",
      "uses": 2,
      "confidence": "high",
      "createdAt": "2026-02-01T00:00:00Z",
      "lastUsed": "2026-02-01T00:00:00Z"
    },
    {
      "id": "PAT-016",
      "name": "thread-per-execution",
      "category": "phase-bound",
      "context": "When sending Slack notifications for loop executions to maintain context",
      "solution": "Each loop execution opens a new Slack thread via loop_start notification. The first message (without thread_ts) creates the thread; its timestamp becomes the thread_ts for all subsequent messages. SlackAdapter tracks executionId→threadTs mapping. FormattedMessage includes metadata.executionId for automatic thread routing.",
      "example": "notifyLoopStart(loopId, executionId, target) → first message creates thread → gate_waiting for same executionId → automatically routes to same thread → loop_complete closes the thread context",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2026-02-01T00:00:00Z",
      "lastUsed": "2026-02-01T00:00:00Z",
      "implementedVia": "ADR-008 (Slack Autonomy Mode)"
    },
    {
      "id": "PAT-017",
      "name": "meta-change-protocol",
      "category": "architectural",
      "context": "When modifying guidance infrastructure (roadmap, dream-state, memory, loops) that the system depends on for its own operation",
      "problem": "Self-referential trap: Changing the system that guides us while using that system for guidance creates instability. Mid-change, guidance becomes invalid. If interrupted (API error, context loss), we lose track of both the change and the original state.",
      "solution": "Atomic meta-changes with explicit checkpointing: (1) CHECKPOINT: Save current state to explicit backup before any modification, (2) BOOTSTRAP: Create minimal standalone guidance document that survives the transition, (3) IMPLEMENT: Make changes atomically (all-or-nothing), (4) VERIFY: Validate new state is coherent and usable, (5) CLEANUP: Remove checkpoint only after verification succeeds. If any step fails, ROLLBACK to checkpoint.",
      "phases": {
        "checkpoint": "git stash or explicit backup file before starting",
        "bootstrap": "Create TRANSITION.md with: current goal, expected end state, rollback instructions",
        "implement": "Make all changes in single session, commit atomically",
        "verify": "Load new system, run coherence check, test critical paths",
        "cleanup": "Remove TRANSITION.md and checkpoint after success"
      },
      "antiPatterns": [
        "Starting meta-change without checkpoint (no rollback path)",
        "Partial implementation across multiple sessions (drift between sessions)",
        "Modifying guidance docs without bootstrap (lost if interrupted)",
        "Declaring success before verification (broken state persists)",
        "Documenting change but not implementing (design-implementation gap)"
      ],
      "example": "Structured Document Architecture change failed because: no checkpoint (uncommitted docs), no bootstrap (no TRANSITION.md), partial implementation (docs done, code not started), API error interrupted → lost state",
      "triggerConditions": [
        "Changing ROADMAP.md structure or location",
        "Changing DREAM-STATE.md structure or location",
        "Changing memory/*.json schema",
        "Changing loop command definitions",
        "Changing skill schema or guarantees"
      ],
      "uses": 0,
      "confidence": "high",
      "createdAt": "2026-02-04T00:00:00Z",
      "lastUsed": null,
      "learnedFrom": "Structured Document Architecture change failed 2026-02-04"
    }
  ],
  "calibration": {
    "estimates": [],
    "adjustments": {
      "global": { "multiplier": 1.0, "samples": 0 }
    }
  },
  "createdAt": "2026-01-25T00:00:00Z",
  "updatedAt": "2026-02-04T17:00:00Z"
}
