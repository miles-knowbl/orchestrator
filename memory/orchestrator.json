{
  "id": "orchestrator",
  "level": "orchestrator",
  "summary": "Self-improving meta-system using Organization → System → Module hierarchy. All loops share context loading protocol and completion archival. 54+ MCP tools, 10 loop definitions.",
  "decisions": [
    {
      "id": "ADR-001",
      "title": "Three-tier context hierarchy",
      "context": "Loops needed a consistent way to understand scope and share context",
      "decision": "Adopted Organization → System → Module hierarchy with Dream State documents at each tier",
      "consequences": "All loops now speak the same language, can query past runs, and auto-update progress",
      "date": "2025-01-29T00:00:00Z"
    },
    {
      "id": "ADR-002",
      "title": "Learning System v2 - Rubric-based skill improvement",
      "context": "Skills needed a feedback mechanism to improve based on execution experience",
      "decision": "Added rubric scoring (completeness, quality, friction, relevance) to complete_skill calls, with threshold-based proposal generation",
      "consequences": "System can now generate upgrade proposals when patterns emerge (e.g., section improvised 2+ times → propose adding it)",
      "date": "2026-01-30T00:00:00Z"
    },
    {
      "id": "ADR-003",
      "title": "Leverage Protocol - Next highest leverage move",
      "context": "Needed a way to sequence loops optimally toward dream state achievement",
      "decision": "Added value equation (DSA 40% + Unlock 25% + Likelihood 15%) / (Time 10% + Effort 10%) evaluated at loop boundaries",
      "consequences": "Claude now proposes the next highest leverage loop at every completion, enabling seamless loop chaining",
      "date": "2026-01-30T00:00:00Z"
    }
  ],
  "patterns": [
    {
      "id": "PAT-001",
      "name": "unified-loop-architecture",
      "context": "When building loops that need to share context and learn from each other",
      "solution": "Use the Organization → System → Module hierarchy with Dream State documents at each tier. All loops load context on init and archive runs on completion.",
      "example": "engineering-loop v5.0.0 loads ~/.claude/DREAM-STATE.md, {repo}/.claude/DREAM-STATE.md, and recent runs via query_runs on initialization",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-002",
      "name": "completion-archival-protocol",
      "context": "When a loop reaches COMPLETE phase",
      "solution": "Archive full state + summary to ~/.claude/runs/{year-month}/{system}-{loop}-{timestamp}.json, update Dream State at appropriate tier, prune active state file",
      "example": "learning-loop completes → archive_run() → update DREAM-STATE.md → delete learning-state.json",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-003",
      "name": "deep-context-protocol",
      "context": "Before any non-trivial task or decision",
      "solution": "Ask 5-10+ clarifying questions across all dimensions (problem, constraints, success criteria, risks, stakeholders). Keep asking until user signals 'that's everything'. Summarize understanding before proceeding.",
      "example": "User asks for auth system → probe: auth methods, compliance needs, user volume, session handling, MFA requirements, API keys needed, etc.",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-004",
      "name": "terrain-check",
      "context": "After every substantive response during execution",
      "solution": "Assess uphill (uncertain, assuming, multiple paths) vs downhill (clear, verified, just executing). If uphill, surface questions. If downhill, proceed without friction. Watch for terrain transitions.",
      "example": "Implemented auth middleware → [uphill: assumed JWT] → 'Quick check: I went with JWT. Should I stick with that, or do you prefer sessions?'",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-005",
      "name": "docs-alignment-protocol",
      "context": "After every loop reaches COMPLETE phase",
      "solution": "Run docs-alignment skill to scan MECE categories, update Dream States with progress, validate cross-references, regenerate indexes, and prune stale documentation.",
      "example": "engineering-loop completes → docs-alignment scans all tiers → updates DREAM-STATE.md with new module progress → fixes broken links in ARCHITECTURE.md → regenerates INDEX.md",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-006",
      "name": "leverage-protocol",
      "context": "At every loop completion boundary",
      "solution": "Evaluate available loops against value equation: (DSA×0.40 + Unlock×0.25 + Likelihood×0.15) / (Time×0.10 + Effort×0.10). Always propose a specific loop. If needed capability doesn't exist, propose meta-loop to create it first.",
      "example": "engineering-loop completes → evaluate: engineering-loop@auth (8.2), bugfix-loop@tests (5.1), learning-loop@review (4.8) → recommend auth-service as highest leverage",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2026-01-30T00:00:00Z",
      "lastUsed": "2026-01-30T00:00:00Z"
    },
    {
      "id": "PAT-007",
      "name": "learning-feedback-loop",
      "context": "When skills are executed during loops",
      "solution": "Call complete_skill() with rubric scores. At COMPLETE phase, call complete_run_tracking() to persist signals and generate proposals. Review proposals via list_upgrade_proposals, approve via approve_upgrade_proposal.",
      "example": "complete_skill(rubric={completeness:4, quality:5, friction:3, relevance:4}) → [COMPLETE] → complete_run_tracking() → 'New proposals: 1' → list_upgrade_proposals → approve",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2026-01-30T00:00:00Z",
      "lastUsed": "2026-01-30T00:00:00Z"
    }
  ],
  "calibration": {
    "estimates": [],
    "adjustments": {
      "global": { "multiplier": 1.0, "samples": 0 }
    }
  },
  "createdAt": "2026-01-25T00:00:00Z",
  "updatedAt": "2026-01-25T00:00:00Z"
}
