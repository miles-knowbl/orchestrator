{
  "id": "orchestrator",
  "level": "orchestrator",
  "summary": "Self-improving meta-system using Organization → System → Module hierarchy. All loops share context loading protocol and completion archival. 54+ MCP tools, 10 loop definitions. Learning System v2 with rubric scoring. Leverage Protocol with Critical Rules for optimal loop sequencing. Version alignment from single source of truth. v0.8.0 with dashboard at 100%.",
  "decisions": [
    {
      "id": "ADR-001",
      "title": "Three-tier context hierarchy",
      "context": "Loops needed a consistent way to understand scope and share context",
      "decision": "Adopted Organization → System → Module hierarchy with Dream State documents at each tier",
      "consequences": "All loops now speak the same language, can query past runs, and auto-update progress",
      "date": "2025-01-29T00:00:00Z"
    },
    {
      "id": "ADR-002",
      "title": "Learning System v2 - Rubric-based skill improvement",
      "context": "Skills needed a feedback mechanism to improve based on execution experience",
      "decision": "Added rubric scoring (completeness, quality, friction, relevance) to complete_skill calls, with threshold-based proposal generation",
      "consequences": "System can now generate upgrade proposals when patterns emerge (e.g., section improvised 2+ times → propose adding it)",
      "date": "2026-01-30T00:00:00Z"
    },
    {
      "id": "ADR-003",
      "title": "Leverage Protocol - Next highest leverage move",
      "context": "Needed a way to sequence loops optimally toward dream state achievement",
      "decision": "Added value equation (DSA 40% + Unlock 25% + Likelihood 15%) / (Time 10% + Effort 10%) evaluated at loop boundaries",
      "consequences": "Claude now proposes the next highest leverage loop at every completion, enabling seamless loop chaining",
      "date": "2026-01-30T00:00:00Z"
    },
    {
      "id": "ADR-004",
      "title": "Version Alignment - Single source of truth",
      "context": "Version numbers were getting out of sync between package.json, server, releases, and dashboard",
      "decision": "Created src/version.ts that reads from package.json at runtime. All consumers use this utility. Distribution-loop bumps version during INIT phase.",
      "consequences": "Version stays aligned automatically. Bumping package.json propagates everywhere on next distribution.",
      "date": "2026-01-30T00:00:00Z"
    },
    {
      "id": "ADR-005",
      "title": "Critical Rules - Explicit enforcement over implicit understanding",
      "context": "Leverage protocol was being skipped (no distribution after code, saying 'done' instead of proposing next loop)",
      "decision": "Added Critical Rules section to protocols with explicit numbered rules, ❌/✅ examples, decision trees, and anti-patterns list",
      "consequences": "Behavior immediately corrected. Pattern generalizes to all protocols that need enforced behavior.",
      "date": "2026-01-31T00:00:00Z"
    }
  ],
  "patterns": [
    {
      "id": "PAT-001",
      "name": "unified-loop-architecture",
      "context": "When building loops that need to share context and learn from each other",
      "solution": "Use the Organization → System → Module hierarchy with Dream State documents at each tier. All loops load context on init and archive runs on completion.",
      "example": "engineering-loop v5.0.0 loads ~/.claude/DREAM-STATE.md, {repo}/.claude/DREAM-STATE.md, and recent runs via query_runs on initialization",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-002",
      "name": "completion-archival-protocol",
      "context": "When a loop reaches COMPLETE phase",
      "solution": "Archive full state + summary to ~/.claude/runs/{year-month}/{system}-{loop}-{timestamp}.json, update Dream State at appropriate tier, prune active state file",
      "example": "learning-loop completes → archive_run() → update DREAM-STATE.md → delete learning-state.json",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-003",
      "name": "deep-context-protocol",
      "context": "Before any non-trivial task or decision",
      "solution": "Ask 5-10+ clarifying questions across all dimensions (problem, constraints, success criteria, risks, stakeholders). Keep asking until user signals 'that's everything'. Summarize understanding before proceeding.",
      "example": "User asks for auth system → probe: auth methods, compliance needs, user volume, session handling, MFA requirements, API keys needed, etc.",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-004",
      "name": "terrain-check",
      "context": "After every substantive response during execution",
      "solution": "Assess uphill (uncertain, assuming, multiple paths) vs downhill (clear, verified, just executing). If uphill, surface questions. If downhill, proceed without friction. Watch for terrain transitions.",
      "example": "Implemented auth middleware → [uphill: assumed JWT] → 'Quick check: I went with JWT. Should I stick with that, or do you prefer sessions?'",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-005",
      "name": "docs-alignment-protocol",
      "context": "After every loop reaches COMPLETE phase",
      "solution": "Run docs-alignment skill to scan MECE categories, update Dream States with progress, validate cross-references, regenerate indexes, and prune stale documentation.",
      "example": "engineering-loop completes → docs-alignment scans all tiers → updates DREAM-STATE.md with new module progress → fixes broken links in ARCHITECTURE.md → regenerates INDEX.md",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2025-01-29T00:00:00Z",
      "lastUsed": "2025-01-29T00:00:00Z"
    },
    {
      "id": "PAT-006",
      "name": "leverage-protocol",
      "context": "At every loop completion boundary",
      "solution": "Evaluate available loops against value equation: (DSA×0.40 + Unlock×0.25 + Likelihood×0.15) / (Time×0.10 + Effort×0.10). Always propose a specific loop. If needed capability doesn't exist, propose meta-loop to create it first.",
      "example": "engineering-loop completes → evaluate: engineering-loop@auth (8.2), bugfix-loop@tests (5.1), learning-loop@review (4.8) → recommend auth-service as highest leverage",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2026-01-30T00:00:00Z",
      "lastUsed": "2026-01-30T00:00:00Z"
    },
    {
      "id": "PAT-007",
      "name": "learning-feedback-loop",
      "context": "When skills are executed during loops",
      "solution": "Call complete_skill() with rubric scores. At COMPLETE phase, call complete_run_tracking() to persist signals and generate proposals. Review proposals via list_upgrade_proposals, approve via approve_upgrade_proposal.",
      "example": "complete_skill(rubric={completeness:4, quality:5, friction:3, relevance:4}) → [COMPLETE] → complete_run_tracking() → 'New proposals: 1' → list_upgrade_proposals → approve",
      "uses": 1,
      "confidence": "medium",
      "createdAt": "2026-01-30T00:00:00Z",
      "lastUsed": "2026-01-30T00:00:00Z"
    },
    {
      "id": "PAT-008",
      "name": "version-alignment-architecture",
      "context": "When version numbers need to stay aligned across server, releases, and UI",
      "solution": "Single source of truth in package.json. Create src/version.ts utility that reads at runtime. GitHub Actions reads package.json for releases. UI parses from release body.",
      "example": "package.json:0.7.0 → version.ts reads it → /health returns 0.7.0 → release body has 'Version: 0.7.0' → /distribute page shows 0.7.0",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2026-01-30T00:00:00Z",
      "lastUsed": "2026-01-30T00:00:00Z"
    },
    {
      "id": "PAT-009",
      "name": "explicit-rules-enforcement",
      "context": "When a protocol or skill has implicit behavior that gets skipped",
      "solution": "Add a 'Critical Rules' section with explicit numbered rules, ❌/✅ examples, decision trees, and anti-patterns. Implicit understanding fails; explicit rules succeed.",
      "example": "Leverage protocol was being skipped → added Rule 1 (distribution after code), Rule 2 (never say done), Rule 3 (look beyond queue) with anti-patterns → behavior corrected",
      "uses": 1,
      "confidence": "high",
      "createdAt": "2026-01-31T00:00:00Z",
      "lastUsed": "2026-01-31T00:00:00Z"
    }
  ],
  "calibration": {
    "estimates": [],
    "adjustments": {
      "global": { "multiplier": 1.0, "samples": 0 }
    }
  },
  "createdAt": "2026-01-25T00:00:00Z",
  "updatedAt": "2026-01-31T00:00:00Z"
}
